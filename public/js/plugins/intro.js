/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Plugins_1 = __webpack_require__(1);
	var Helpers_1 = __webpack_require__(2);
	__webpack_require__(3);
	var Intro = (function (_super) {
	    __extends(Intro, _super);
	    /**
	     * Constructor
	     *
	     * @param app
	     * @param canvas
	     */
	    function Intro(app, canvas) {
	        _super.call(this);
	        if (canvas.constructor === String) {
	            canvas = document.querySelector(canvas);
	        }
	        this.canvas = canvas;
	        this.app = app;
	        this.modules = this.app.bootstrap(this, Helpers_1.requireAll(__webpack_require__(5)));
	    }
	    /**
	     * Start The Interaction
	     * @param item
	     */
	    Intro.prototype.start = function (composition) {
	        var _this = this;
	        var payload = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            payload[_i - 1] = arguments[_i];
	        }
	        try {
	            this.compositions
	                .start(composition, payload)
	                .then(function () { return _this.animate(); })
	                .catch(console.log);
	        }
	        catch (error) {
	            console.log(error);
	        }
	    };
	    /**
	     * Animation Loop
	     */
	    Intro.prototype.animate = function () {
	        var _this = this;
	        var clock = new THREE.Clock(), loop = function (time) {
	            var delta = clock.getDelta();
	            requestAnimationFrame(loop);
	            /**
	             * Update Modules
	             */
	            _this.modules.forEach(function (module) { return module.update(time, delta); });
	        };
	        /**
	         * Start Loop
	         */
	        loop(0);
	    };
	    return Intro;
	}(Plugins_1.Plugins));
	exports.Intro = Intro;
	/**
	 * Auto install itself
	 */
	window['dreamsark'].install({
	    Intro: Intro
	});
	//# sourceMappingURL=Intro.js.map

/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";
	var Plugins = (function () {
	    function Plugins() {
	        this.exposes = {};
	    }
	    Plugins.prototype.install = function () {
	    };
	    return Plugins;
	}());
	exports.Plugins = Plugins;
	//# sourceMappingURL=Plugins.js.map

/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * For Loop
	 */
	exports.forEach = function (array, callback, scope) {
	    for (var i = 0; i < array.length; i++)
	        callback.call(scope, i, array[i]);
	};
	/**
	 * Pop array by key name
	 *
	 * @param data
	 * @param key
	 * @returns any[]
	 */
	exports.popByKey = function (data, key, defaults) {
	    if (!data.hasOwnProperty(key))
	        return defaults;
	    var value = data[key];
	    delete data[key];
	    return value;
	};
	/**
	 * Extend Object
	 *
	 * @param defaults
	 * @param object
	 * @returns {any}
	 */
	exports.extend = function (defaults) {
	    var object = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        object[_i - 1] = arguments[_i];
	    }
	    for (var a in object) {
	        for (var i in object[a]) {
	            if (object[a].hasOwnProperty(i)) {
	                defaults[i] = object[a][i];
	            }
	        }
	    }
	    return defaults;
	};
	/**
	 * Convert String to CamelCase
	 *
	 * @param str
	 * @returns {string}
	 */
	exports.toCamelCase = function (str) {
	    return str.replace(/^([A-Z])|[\s-_](\w)/g, function (match, p1, p2, offset) {
	        if (p2)
	            return p2.toUpperCase();
	        return p1.toLowerCase();
	    });
	};
	exports.captalize = function (str) {
	    return str.charAt(0).toUpperCase() + str.slice(1);
	};
	/**
	 * Firefox have an issue to submit form if its not appended to the body
	 * @param form
	 */
	exports.submitForm = function (form) {
	    document.body.appendChild(form);
	    form.submit();
	};
	/**
	 * Require a whole Folder
	 *
	 * @param requireContext
	 * @returns {U[]}
	 */
	exports.requireAll = function (requireContext) {
	    return requireContext.keys().map(requireContext);
	};
	//# sourceMappingURL=Helpers.js.map

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["THREE"] = __webpack_require__(4);
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.THREE = global.THREE || {})));
	}(this, (function (exports) { 'use strict';

		// Polyfills

		if ( Number.EPSILON === undefined ) {

			Number.EPSILON = Math.pow( 2, - 52 );

		}

		//

		if ( Math.sign === undefined ) {

			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

			Math.sign = function ( x ) {

				return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

			};

		}

		if ( Function.prototype.name === undefined ) {

			// Missing in IE9-11.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

			Object.defineProperty( Function.prototype, 'name', {

				get: function () {

					return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

				}

			} );

		}

		if ( Object.assign === undefined ) {

			// Missing in IE.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

			( function () {

				Object.assign = function ( target ) {

					'use strict';

					if ( target === undefined || target === null ) {

						throw new TypeError( 'Cannot convert undefined or null to object' );

					}

					var output = Object( target );

					for ( var index = 1; index < arguments.length; index ++ ) {

						var source = arguments[ index ];

						if ( source !== undefined && source !== null ) {

							for ( var nextKey in source ) {

								if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

									output[ nextKey ] = source[ nextKey ];

								}

							}

						}

					}

					return output;

				};

			} )();

		}

		/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */

		function EventDispatcher() {}

		Object.assign( EventDispatcher.prototype, {

			addEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) this._listeners = {};

				var listeners = this._listeners;

				if ( listeners[ type ] === undefined ) {

					listeners[ type ] = [];

				}

				if ( listeners[ type ].indexOf( listener ) === - 1 ) {

					listeners[ type ].push( listener );

				}

			},

			hasEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) return false;

				var listeners = this._listeners;

				if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

					return true;

				}

				return false;

			},

			removeEventListener: function ( type, listener ) {

				if ( this._listeners === undefined ) return;

				var listeners = this._listeners;
				var listenerArray = listeners[ type ];

				if ( listenerArray !== undefined ) {

					var index = listenerArray.indexOf( listener );

					if ( index !== - 1 ) {

						listenerArray.splice( index, 1 );

					}

				}

			},

			dispatchEvent: function ( event ) {

				if ( this._listeners === undefined ) return;

				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];

				if ( listenerArray !== undefined ) {

					event.target = this;

					var array = [], i = 0;
					var length = listenerArray.length;

					for ( i = 0; i < length; i ++ ) {

						array[ i ] = listenerArray[ i ];

					}

					for ( i = 0; i < length; i ++ ) {

						array[ i ].call( this, event );

					}

				}

			}

		} );

		var REVISION = '82';
		var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
		var CullFaceNone = 0;
		var CullFaceBack = 1;
		var CullFaceFront = 2;
		var CullFaceFrontBack = 3;
		var FrontFaceDirectionCW = 0;
		var FrontFaceDirectionCCW = 1;
		var BasicShadowMap = 0;
		var PCFShadowMap = 1;
		var PCFSoftShadowMap = 2;
		var FrontSide = 0;
		var BackSide = 1;
		var DoubleSide = 2;
		var FlatShading = 1;
		var SmoothShading = 2;
		var NoColors = 0;
		var FaceColors = 1;
		var VertexColors = 2;
		var NoBlending = 0;
		var NormalBlending = 1;
		var AdditiveBlending = 2;
		var SubtractiveBlending = 3;
		var MultiplyBlending = 4;
		var CustomBlending = 5;
		var BlendingMode = {
			NoBlending: NoBlending,
			NormalBlending: NormalBlending,
			AdditiveBlending: AdditiveBlending,
			SubtractiveBlending: SubtractiveBlending,
			MultiplyBlending: MultiplyBlending,
			CustomBlending: CustomBlending
		};
		var AddEquation = 100;
		var SubtractEquation = 101;
		var ReverseSubtractEquation = 102;
		var MinEquation = 103;
		var MaxEquation = 104;
		var ZeroFactor = 200;
		var OneFactor = 201;
		var SrcColorFactor = 202;
		var OneMinusSrcColorFactor = 203;
		var SrcAlphaFactor = 204;
		var OneMinusSrcAlphaFactor = 205;
		var DstAlphaFactor = 206;
		var OneMinusDstAlphaFactor = 207;
		var DstColorFactor = 208;
		var OneMinusDstColorFactor = 209;
		var SrcAlphaSaturateFactor = 210;
		var NeverDepth = 0;
		var AlwaysDepth = 1;
		var LessDepth = 2;
		var LessEqualDepth = 3;
		var EqualDepth = 4;
		var GreaterEqualDepth = 5;
		var GreaterDepth = 6;
		var NotEqualDepth = 7;
		var MultiplyOperation = 0;
		var MixOperation = 1;
		var AddOperation = 2;
		var NoToneMapping = 0;
		var LinearToneMapping = 1;
		var ReinhardToneMapping = 2;
		var Uncharted2ToneMapping = 3;
		var CineonToneMapping = 4;
		var UVMapping = 300;
		var CubeReflectionMapping = 301;
		var CubeRefractionMapping = 302;
		var EquirectangularReflectionMapping = 303;
		var EquirectangularRefractionMapping = 304;
		var SphericalReflectionMapping = 305;
		var CubeUVReflectionMapping = 306;
		var CubeUVRefractionMapping = 307;
		var TextureMapping = {
			UVMapping: UVMapping,
			CubeReflectionMapping: CubeReflectionMapping,
			CubeRefractionMapping: CubeRefractionMapping,
			EquirectangularReflectionMapping: EquirectangularReflectionMapping,
			EquirectangularRefractionMapping: EquirectangularRefractionMapping,
			SphericalReflectionMapping: SphericalReflectionMapping,
			CubeUVReflectionMapping: CubeUVReflectionMapping,
			CubeUVRefractionMapping: CubeUVRefractionMapping
		};
		var RepeatWrapping = 1000;
		var ClampToEdgeWrapping = 1001;
		var MirroredRepeatWrapping = 1002;
		var TextureWrapping = {
			RepeatWrapping: RepeatWrapping,
			ClampToEdgeWrapping: ClampToEdgeWrapping,
			MirroredRepeatWrapping: MirroredRepeatWrapping
		};
		var NearestFilter = 1003;
		var NearestMipMapNearestFilter = 1004;
		var NearestMipMapLinearFilter = 1005;
		var LinearFilter = 1006;
		var LinearMipMapNearestFilter = 1007;
		var LinearMipMapLinearFilter = 1008;
		var TextureFilter = {
			NearestFilter: NearestFilter,
			NearestMipMapNearestFilter: NearestMipMapNearestFilter,
			NearestMipMapLinearFilter: NearestMipMapLinearFilter,
			LinearFilter: LinearFilter,
			LinearMipMapNearestFilter: LinearMipMapNearestFilter,
			LinearMipMapLinearFilter: LinearMipMapLinearFilter
		};
		var UnsignedByteType = 1009;
		var ByteType = 1010;
		var ShortType = 1011;
		var UnsignedShortType = 1012;
		var IntType = 1013;
		var UnsignedIntType = 1014;
		var FloatType = 1015;
		var HalfFloatType = 1016;
		var UnsignedShort4444Type = 1017;
		var UnsignedShort5551Type = 1018;
		var UnsignedShort565Type = 1019;
		var UnsignedInt248Type = 1020;
		var AlphaFormat = 1021;
		var RGBFormat = 1022;
		var RGBAFormat = 1023;
		var LuminanceFormat = 1024;
		var LuminanceAlphaFormat = 1025;
		var RGBEFormat = RGBAFormat;
		var DepthFormat = 1026;
		var DepthStencilFormat = 1027;
		var RGB_S3TC_DXT1_Format = 2001;
		var RGBA_S3TC_DXT1_Format = 2002;
		var RGBA_S3TC_DXT3_Format = 2003;
		var RGBA_S3TC_DXT5_Format = 2004;
		var RGB_PVRTC_4BPPV1_Format = 2100;
		var RGB_PVRTC_2BPPV1_Format = 2101;
		var RGBA_PVRTC_4BPPV1_Format = 2102;
		var RGBA_PVRTC_2BPPV1_Format = 2103;
		var RGB_ETC1_Format = 2151;
		var LoopOnce = 2200;
		var LoopRepeat = 2201;
		var LoopPingPong = 2202;
		var InterpolateDiscrete = 2300;
		var InterpolateLinear = 2301;
		var InterpolateSmooth = 2302;
		var ZeroCurvatureEnding = 2400;
		var ZeroSlopeEnding = 2401;
		var WrapAroundEnding = 2402;
		var TrianglesDrawMode = 0;
		var TriangleStripDrawMode = 1;
		var TriangleFanDrawMode = 2;
		var LinearEncoding = 3000;
		var sRGBEncoding = 3001;
		var GammaEncoding = 3007;
		var RGBEEncoding = 3002;
		var LogLuvEncoding = 3003;
		var RGBM7Encoding = 3004;
		var RGBM16Encoding = 3005;
		var RGBDEncoding = 3006;
		var BasicDepthPacking = 3200;
		var RGBADepthPacking = 3201;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		var _Math = {

			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,

			generateUUID: function () {

				// http://www.broofa.com/Tools/Math.uuid.htm

				var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
				var uuid = new Array( 36 );
				var rnd = 0, r;

				return function generateUUID() {

					for ( var i = 0; i < 36; i ++ ) {

						if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

							uuid[ i ] = '-';

						} else if ( i === 14 ) {

							uuid[ i ] = '4';

						} else {

							if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
							r = rnd & 0xf;
							rnd = rnd >> 4;
							uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

						}

					}

					return uuid.join( '' );

				};

			}(),

			clamp: function ( value, min, max ) {

				return Math.max( min, Math.min( max, value ) );

			},

			// compute euclidian modulo of m % n
			// https://en.wikipedia.org/wiki/Modulo_operation

			euclideanModulo: function ( n, m ) {

				return ( ( n % m ) + m ) % m;

			},

			// Linear mapping from range <a1, a2> to range <b1, b2>

			mapLinear: function ( x, a1, a2, b1, b2 ) {

				return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

			},

			// https://en.wikipedia.org/wiki/Linear_interpolation

			lerp: function ( x, y, t ) {

				return ( 1 - t ) * x + t * y;

			},

			// http://en.wikipedia.org/wiki/Smoothstep

			smoothstep: function ( x, min, max ) {

				if ( x <= min ) return 0;
				if ( x >= max ) return 1;

				x = ( x - min ) / ( max - min );

				return x * x * ( 3 - 2 * x );

			},

			smootherstep: function ( x, min, max ) {

				if ( x <= min ) return 0;
				if ( x >= max ) return 1;

				x = ( x - min ) / ( max - min );

				return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

			},

			random16: function () {

				console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
				return Math.random();

			},

			// Random integer from <low, high> interval

			randInt: function ( low, high ) {

				return low + Math.floor( Math.random() * ( high - low + 1 ) );

			},

			// Random float from <low, high> interval

			randFloat: function ( low, high ) {

				return low + Math.random() * ( high - low );

			},

			// Random float from <-range/2, range/2> interval

			randFloatSpread: function ( range ) {

				return range * ( 0.5 - Math.random() );

			},

			degToRad: function ( degrees ) {

				return degrees * _Math.DEG2RAD;

			},

			radToDeg: function ( radians ) {

				return radians * _Math.RAD2DEG;

			},

			isPowerOfTwo: function ( value ) {

				return ( value & ( value - 1 ) ) === 0 && value !== 0;

			},

			nearestPowerOfTwo: function ( value ) {

				return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

			},

			nextPowerOfTwo: function ( value ) {

				value --;
				value |= value >> 1;
				value |= value >> 2;
				value |= value >> 4;
				value |= value >> 8;
				value |= value >> 16;
				value ++;

				return value;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		function Vector2( x, y ) {

			this.x = x || 0;
			this.y = y || 0;

		}

		Vector2.prototype = {

			constructor: Vector2,

			isVector2: true,

			get width() {

				return this.x;

			},

			set width( value ) {

				this.x = value;

			},

			get height() {

				return this.y;

			},

			set height( value ) {

				this.y = value;

			},

			//

			set: function ( x, y ) {

				this.x = x;
				this.y = y;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}
				
				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;

				return this;

			},

			multiply: function ( v ) {

				this.x *= v.x;
				this.y *= v.y;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;

				} else {

					this.x = 0;
					this.y = 0;

				}

				return this;

			},

			divide: function ( v ) {

				this.x /= v.x;
				this.y /= v.y;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector2();
						max = new Vector2();

					}

					min.set( minVal, minVal );
					max.set( maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y );

			},

			lengthManhattan: function() {

				return Math.abs( this.x ) + Math.abs( this.y );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			angle: function () {

				// computes the angle in radians with respect to the positive x-axis

				var angle = Math.atan2( this.y, this.x );

				if ( angle < 0 ) angle += 2 * Math.PI;

				return angle;

			},

			distanceTo: function ( v ) {

				return Math.sqrt( this.distanceToSquared( v ) );

			},

			distanceToSquared: function ( v ) {

				var dx = this.x - v.x, dy = this.y - v.y;
				return dx * dx + dy * dy;

			},

			distanceToManhattan: function ( v ) {

				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;

				return array;

			},

			fromAttribute: function ( attribute, index, offset ) {

				if ( offset === undefined ) offset = 0;

				index = index * attribute.itemSize + offset;

				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];

				return this;

			},

			rotateAround: function ( center, angle ) {

				var c = Math.cos( angle ), s = Math.sin( angle );

				var x = this.x - center.x;
				var y = this.y - center.y;

				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */

		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			Object.defineProperty( this, 'id', { value: TextureIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.sourceFile = '';

			this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
			this.mipmaps = [];

			this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

			this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
			this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

			this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

			this.format = format !== undefined ? format : RGBAFormat;
			this.type = type !== undefined ? type : UnsignedByteType;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding !== undefined ? encoding :  LinearEncoding;

			this.version = 0;
			this.onUpdate = null;

		}

		Texture.DEFAULT_IMAGE = undefined;
		Texture.DEFAULT_MAPPING = UVMapping;

		Texture.prototype = {

			constructor: Texture,

			isTexture: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.image = source.image;
				this.mipmaps = source.mipmaps.slice( 0 );

				this.mapping = source.mapping;

				this.wrapS = source.wrapS;
				this.wrapT = source.wrapT;

				this.magFilter = source.magFilter;
				this.minFilter = source.minFilter;

				this.anisotropy = source.anisotropy;

				this.format = source.format;
				this.type = source.type;

				this.offset.copy( source.offset );
				this.repeat.copy( source.repeat );

				this.generateMipmaps = source.generateMipmaps;
				this.premultiplyAlpha = source.premultiplyAlpha;
				this.flipY = source.flipY;
				this.unpackAlignment = source.unpackAlignment;
				this.encoding = source.encoding;

				return this;

			},

			toJSON: function ( meta ) {

				if ( meta.textures[ this.uuid ] !== undefined ) {

					return meta.textures[ this.uuid ];

				}

				function getDataURL( image ) {

					var canvas;

					if ( image.toDataURL !== undefined ) {

						canvas = image;

					} else {

						canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
						canvas.width = image.width;
						canvas.height = image.height;

						canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

					}

					if ( canvas.width > 2048 || canvas.height > 2048 ) {

						return canvas.toDataURL( 'image/jpeg', 0.6 );

					} else {

						return canvas.toDataURL( 'image/png' );

					}

				}

				var output = {
					metadata: {
						version: 4.4,
						type: 'Texture',
						generator: 'Texture.toJSON'
					},

					uuid: this.uuid,
					name: this.name,

					mapping: this.mapping,

					repeat: [ this.repeat.x, this.repeat.y ],
					offset: [ this.offset.x, this.offset.y ],
					wrap: [ this.wrapS, this.wrapT ],

					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,

					flipY: this.flipY
				};

				if ( this.image !== undefined ) {

					// TODO: Move to THREE.Image

					var image = this.image;

					if ( image.uuid === undefined ) {

						image.uuid = _Math.generateUUID(); // UGH

					}

					if ( meta.images[ image.uuid ] === undefined ) {

						meta.images[ image.uuid ] = {
							uuid: image.uuid,
							url: getDataURL( image )
						};

					}

					output.image = image.uuid;

				}

				meta.textures[ this.uuid ] = output;

				return output;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			},

			transformUv: function ( uv ) {

				if ( this.mapping !== UVMapping )  return;

				uv.multiply( this.repeat );
				uv.add( this.offset );

				if ( uv.x < 0 || uv.x > 1 ) {

					switch ( this.wrapS ) {

						case RepeatWrapping:

							uv.x = uv.x - Math.floor( uv.x );
							break;

						case ClampToEdgeWrapping:

							uv.x = uv.x < 0 ? 0 : 1;
							break;

						case MirroredRepeatWrapping:

							if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

								uv.x = Math.ceil( uv.x ) - uv.x;

							} else {

								uv.x = uv.x - Math.floor( uv.x );

							}
							break;

					}

				}

				if ( uv.y < 0 || uv.y > 1 ) {

					switch ( this.wrapT ) {

						case RepeatWrapping:

							uv.y = uv.y - Math.floor( uv.y );
							break;

						case ClampToEdgeWrapping:

							uv.y = uv.y < 0 ? 0 : 1;
							break;

						case MirroredRepeatWrapping:

							if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

								uv.y = Math.ceil( uv.y ) - uv.y;

							} else {

								uv.y = uv.y - Math.floor( uv.y );

							}
							break;

					}

				}

				if ( this.flipY ) {

					uv.y = 1 - uv.y;

				}

			}

		};

		Object.assign( Texture.prototype, EventDispatcher.prototype );

		var count = 0;
		function TextureIdCount() { return count++; }

		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Vector4( x, y, z, w ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;

		}

		Vector4.prototype = {

			constructor: Vector4,

			isVector4: true,

			set: function ( x, y, z, w ) {

				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setZ: function ( z ) {

				this.z = z;

				return this;

			},

			setW: function ( w ) {

				this.w = w;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					case 3: this.w = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}
				
				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					case 3: return this.w;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y, this.z, this.w );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = ( v.w !== undefined ) ? v.w : 1;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
					this.w *= scalar;

				} else {

					this.x = 0;
					this.y = 0;
					this.z = 0;
					this.w = 0;

				}

				return this;

			},

			applyMatrix4: function ( m ) {

				var x = this.x, y = this.y, z = this.z, w = this.w;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
				this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			setAxisAngleFromQuaternion: function ( q ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

				// q is assumed to be normalized

				this.w = 2 * Math.acos( q.w );

				var s = Math.sqrt( 1 - q.w * q.w );

				if ( s < 0.0001 ) {

					 this.x = 1;
					 this.y = 0;
					 this.z = 0;

				} else {

					 this.x = q.x / s;
					 this.y = q.y / s;
					 this.z = q.z / s;

				}

				return this;

			},

			setAxisAngleFromRotationMatrix: function ( m ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var angle, x, y, z,		// variables for result
					epsilon = 0.01,		// margin to allow for rounding errors
					epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

					te = m.elements,

					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

				if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
				     ( Math.abs( m13 - m31 ) < epsilon ) &&
				     ( Math.abs( m23 - m32 ) < epsilon ) ) {

					// singularity found
					// first check for identity matrix which must have +1 for all terms
					// in leading diagonal and zero in other terms

					if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
					     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
					     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
					     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

						// this singularity is identity matrix so angle = 0

						this.set( 1, 0, 0, 0 );

						return this; // zero angle, arbitrary axis

					}

					// otherwise this singularity is angle = 180

					angle = Math.PI;

					var xx = ( m11 + 1 ) / 2;
					var yy = ( m22 + 1 ) / 2;
					var zz = ( m33 + 1 ) / 2;
					var xy = ( m12 + m21 ) / 4;
					var xz = ( m13 + m31 ) / 4;
					var yz = ( m23 + m32 ) / 4;

					if ( ( xx > yy ) && ( xx > zz ) ) {

						// m11 is the largest diagonal term

						if ( xx < epsilon ) {

							x = 0;
							y = 0.707106781;
							z = 0.707106781;

						} else {

							x = Math.sqrt( xx );
							y = xy / x;
							z = xz / x;

						}

					} else if ( yy > zz ) {

						// m22 is the largest diagonal term

						if ( yy < epsilon ) {

							x = 0.707106781;
							y = 0;
							z = 0.707106781;

						} else {

							y = Math.sqrt( yy );
							x = xy / y;
							z = yz / y;

						}

					} else {

						// m33 is the largest diagonal term so base result on this

						if ( zz < epsilon ) {

							x = 0.707106781;
							y = 0.707106781;
							z = 0;

						} else {

							z = Math.sqrt( zz );
							x = xz / z;
							y = yz / z;

						}

					}

					this.set( x, y, z, angle );

					return this; // return 180 deg rotation

				}

				// as we have reached here there are no singularities so we can handle normally

				var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				                   ( m13 - m31 ) * ( m13 - m31 ) +
				                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

				if ( Math.abs( s ) < 0.001 ) s = 1;

				// prevent divide by zero, should not happen if matrix is orthogonal and should be
				// caught by singularity test above, but I've left it in just in case

				this.x = ( m32 - m23 ) / s;
				this.y = ( m13 - m31 ) / s;
				this.z = ( m21 - m12 ) / s;
				this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

				return this;

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
				this.w = Math.min( this.w, v.w );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
				this.w = Math.max( this.w, v.w );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
				this.w = Math.max( min.w, Math.min( max.w, this.w ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector4();
						max = new Vector4();

					}

					min.set( minVal, minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
				this.w = Math.floor( this.w );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
				this.w = Math.ceil( this.w );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
				this.w = Math.round( this.w );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
				this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
				this.w = - this.w;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

			},

			lengthManhattan: function () {

				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
				this.w += ( v.w - this.w ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
				this.w = array[ offset + 3 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
				array[ offset + 3 ] = this.w;

				return array;

			},

			fromAttribute: function ( attribute, index, offset ) {

				if ( offset === undefined ) offset = 0;

				index = index * attribute.itemSize + offset;

				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];
				this.z = attribute.array[ index + 2 ];
				this.w = attribute.array[ index + 3 ];

				return this;

			}

		};

		/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 */

		/*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/
		function WebGLRenderTarget( width, height, options ) {

			this.uuid = _Math.generateUUID();

			this.width = width;
			this.height = height;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			options = options || {};

			if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

			this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

		}

		Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

			isWebGLRenderTarget: true,

			setSize: function ( width, height ) {

				if ( this.width !== width || this.height !== height ) {

					this.width = width;
					this.height = height;

					this.dispose();

				}

				this.viewport.set( 0, 0, width, height );
				this.scissor.set( 0, 0, width, height );

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.width = source.width;
				this.height = source.height;

				this.viewport.copy( source.viewport );

				this.texture = source.texture.clone();

				this.depthBuffer = source.depthBuffer;
				this.stencilBuffer = source.stencilBuffer;
				this.depthTexture = source.depthTexture;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com
		 */

		function WebGLRenderTargetCube( width, height, options ) {

			WebGLRenderTarget.call( this, width, height, options );

			this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
			this.activeMipMapLevel = 0;

		}

		WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
		WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

		WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */

		function Quaternion( x, y, z, w ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;

		}

		Quaternion.prototype = {

			constructor: Quaternion,

			get x () {

				return this._x;

			},

			set x ( value ) {

				this._x = value;
				this.onChangeCallback();

			},

			get y () {

				return this._y;

			},

			set y ( value ) {

				this._y = value;
				this.onChangeCallback();

			},

			get z () {

				return this._z;

			},

			set z ( value ) {

				this._z = value;
				this.onChangeCallback();

			},

			get w () {

				return this._w;

			},

			set w ( value ) {

				this._w = value;
				this.onChangeCallback();

			},

			set: function ( x, y, z, w ) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;

				this.onChangeCallback();

				return this;

			},

			clone: function () {

				return new this.constructor( this._x, this._y, this._z, this._w );

			},

			copy: function ( quaternion ) {

				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;

				this.onChangeCallback();

				return this;

			},

			setFromEuler: function ( euler, update ) {

				if ( (euler && euler.isEuler) === false ) {

					throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				// http://www.mathworks.com/matlabcentral/fileexchange/
				// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
				//	content/SpinCalc.m

				var c1 = Math.cos( euler._x / 2 );
				var c2 = Math.cos( euler._y / 2 );
				var c3 = Math.cos( euler._z / 2 );
				var s1 = Math.sin( euler._x / 2 );
				var s2 = Math.sin( euler._y / 2 );
				var s3 = Math.sin( euler._z / 2 );

				var order = euler.order;

				if ( order === 'XYZ' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'YXZ' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				} else if ( order === 'ZXY' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'ZYX' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				} else if ( order === 'YZX' ) {

					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;

				} else if ( order === 'XZY' ) {

					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;

				}

				if ( update !== false ) this.onChangeCallback();

				return this;

			},

			setFromAxisAngle: function ( axis, angle ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

				// assumes axis is normalized

				var halfAngle = angle / 2, s = Math.sin( halfAngle );

				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos( halfAngle );

				this.onChangeCallback();

				return this;

			},

			setFromRotationMatrix: function ( m ) {

				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var te = m.elements,

					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

					trace = m11 + m22 + m33,
					s;

				if ( trace > 0 ) {

					s = 0.5 / Math.sqrt( trace + 1.0 );

					this._w = 0.25 / s;
					this._x = ( m32 - m23 ) * s;
					this._y = ( m13 - m31 ) * s;
					this._z = ( m21 - m12 ) * s;

				} else if ( m11 > m22 && m11 > m33 ) {

					s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

					this._w = ( m32 - m23 ) / s;
					this._x = 0.25 * s;
					this._y = ( m12 + m21 ) / s;
					this._z = ( m13 + m31 ) / s;

				} else if ( m22 > m33 ) {

					s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

					this._w = ( m13 - m31 ) / s;
					this._x = ( m12 + m21 ) / s;
					this._y = 0.25 * s;
					this._z = ( m23 + m32 ) / s;

				} else {

					s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

					this._w = ( m21 - m12 ) / s;
					this._x = ( m13 + m31 ) / s;
					this._y = ( m23 + m32 ) / s;
					this._z = 0.25 * s;

				}

				this.onChangeCallback();

				return this;

			},

			setFromUnitVectors: function () {

				// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

				// assumes direction vectors vFrom and vTo are normalized

				var v1, r;

				var EPS = 0.000001;

				return function setFromUnitVectors( vFrom, vTo ) {

					if ( v1 === undefined ) v1 = new Vector3();

					r = vFrom.dot( vTo ) + 1;

					if ( r < EPS ) {

						r = 0;

						if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

							v1.set( - vFrom.y, vFrom.x, 0 );

						} else {

							v1.set( 0, - vFrom.z, vFrom.y );

						}

					} else {

						v1.crossVectors( vFrom, vTo );

					}

					this._x = v1.x;
					this._y = v1.y;
					this._z = v1.z;
					this._w = r;

					return this.normalize();

				};

			}(),

			inverse: function () {

				return this.conjugate().normalize();

			},

			conjugate: function () {

				this._x *= - 1;
				this._y *= - 1;
				this._z *= - 1;

				this.onChangeCallback();

				return this;

			},

			dot: function ( v ) {

				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

			},

			lengthSq: function () {

				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

			},

			length: function () {

				return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

			},

			normalize: function () {

				var l = this.length();

				if ( l === 0 ) {

					this._x = 0;
					this._y = 0;
					this._z = 0;
					this._w = 1;

				} else {

					l = 1 / l;

					this._x = this._x * l;
					this._y = this._y * l;
					this._z = this._z * l;
					this._w = this._w * l;

				}

				this.onChangeCallback();

				return this;

			},

			multiply: function ( q, p ) {

				if ( p !== undefined ) {

					console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
					return this.multiplyQuaternions( q, p );

				}

				return this.multiplyQuaternions( this, q );

			},

			premultiply: function ( q ) {

				return this.multiplyQuaternions( q, this );

			},

			multiplyQuaternions: function ( a, b ) {

				// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

				var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
				var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

				this.onChangeCallback();

				return this;

			},

			slerp: function ( qb, t ) {

				if ( t === 0 ) return this;
				if ( t === 1 ) return this.copy( qb );

				var x = this._x, y = this._y, z = this._z, w = this._w;

				// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

				if ( cosHalfTheta < 0 ) {

					this._w = - qb._w;
					this._x = - qb._x;
					this._y = - qb._y;
					this._z = - qb._z;

					cosHalfTheta = - cosHalfTheta;

				} else {

					this.copy( qb );

				}

				if ( cosHalfTheta >= 1.0 ) {

					this._w = w;
					this._x = x;
					this._y = y;
					this._z = z;

					return this;

				}

				var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

				if ( Math.abs( sinHalfTheta ) < 0.001 ) {

					this._w = 0.5 * ( w + this._w );
					this._x = 0.5 * ( x + this._x );
					this._y = 0.5 * ( y + this._y );
					this._z = 0.5 * ( z + this._z );

					return this;

				}

				var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
				var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

				this._w = ( w * ratioA + this._w * ratioB );
				this._x = ( x * ratioA + this._x * ratioB );
				this._y = ( y * ratioA + this._y * ratioB );
				this._z = ( z * ratioA + this._z * ratioB );

				this.onChangeCallback();

				return this;

			},

			equals: function ( quaternion ) {

				return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this._x = array[ offset ];
				this._y = array[ offset + 1 ];
				this._z = array[ offset + 2 ];
				this._w = array[ offset + 3 ];

				this.onChangeCallback();

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._w;

				return array;

			},

			onChange: function ( callback ) {

				this.onChangeCallback = callback;

				return this;

			},

			onChangeCallback: function () {}

		};

		Object.assign( Quaternion, {

			slerp: function( qa, qb, qm, t ) {

				return qm.copy( qa ).slerp( qb, t );

			},

			slerpFlat: function(
					dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

				// fuzz-free, array-based Quaternion SLERP operation

				var x0 = src0[ srcOffset0 + 0 ],
					y0 = src0[ srcOffset0 + 1 ],
					z0 = src0[ srcOffset0 + 2 ],
					w0 = src0[ srcOffset0 + 3 ],

					x1 = src1[ srcOffset1 + 0 ],
					y1 = src1[ srcOffset1 + 1 ],
					z1 = src1[ srcOffset1 + 2 ],
					w1 = src1[ srcOffset1 + 3 ];

				if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

					var s = 1 - t,

						cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

						dir = ( cos >= 0 ? 1 : - 1 ),
						sqrSin = 1 - cos * cos;

					// Skip the Slerp for tiny steps to avoid numeric problems:
					if ( sqrSin > Number.EPSILON ) {

						var sin = Math.sqrt( sqrSin ),
							len = Math.atan2( sin, cos * dir );

						s = Math.sin( s * len ) / sin;
						t = Math.sin( t * len ) / sin;

					}

					var tDir = t * dir;

					x0 = x0 * s + x1 * tDir;
					y0 = y0 * s + y1 * tDir;
					z0 = z0 * s + z1 * tDir;
					w0 = w0 * s + w1 * tDir;

					// Normalize in case we just did a lerp:
					if ( s === 1 - t ) {

						var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

						x0 *= f;
						y0 *= f;
						z0 *= f;
						w0 *= f;

					}

				}

				dst[ dstOffset ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author *kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Vector3( x, y, z ) {

			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;

		}

		Vector3.prototype = {

			constructor: Vector3,

			isVector3: true,

			set: function ( x, y, z ) {

				this.x = x;
				this.y = y;
				this.z = z;

				return this;

			},

			setScalar: function ( scalar ) {

				this.x = scalar;
				this.y = scalar;
				this.z = scalar;

				return this;

			},

			setX: function ( x ) {

				this.x = x;

				return this;

			},

			setY: function ( y ) {

				this.y = y;

				return this;

			},

			setZ: function ( z ) {

				this.z = z;

				return this;

			},

			setComponent: function ( index, value ) {

				switch ( index ) {

					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					default: throw new Error( 'index is out of range: ' + index );

				}
				
				return this;

			},

			getComponent: function ( index ) {

				switch ( index ) {

					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					default: throw new Error( 'index is out of range: ' + index );

				}

			},

			clone: function () {

				return new this.constructor( this.x, this.y, this.z );

			},

			copy: function ( v ) {

				this.x = v.x;
				this.y = v.y;
				this.z = v.z;

				return this;

			},

			add: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );

				}

				this.x += v.x;
				this.y += v.y;
				this.z += v.z;

				return this;

			},

			addScalar: function ( s ) {

				this.x += s;
				this.y += s;
				this.z += s;

				return this;

			},

			addVectors: function ( a, b ) {

				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;

				return this;

			},

			addScaledVector: function ( v, s ) {

				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;

				return this;

			},

			sub: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );

				}

				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;

				return this;

			},

			subScalar: function ( s ) {

				this.x -= s;
				this.y -= s;
				this.z -= s;

				return this;

			},

			subVectors: function ( a, b ) {

				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;

				return this;

			},

			multiply: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
					return this.multiplyVectors( v, w );

				}

				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;

				return this;

			},

			multiplyScalar: function ( scalar ) {

				if ( isFinite( scalar ) ) {

					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;

				} else {

					this.x = 0;
					this.y = 0;
					this.z = 0;

				}

				return this;

			},

			multiplyVectors: function ( a, b ) {

				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;

				return this;

			},

			applyEuler: function () {

				var quaternion;

				return function applyEuler( euler ) {

					if ( (euler && euler.isEuler) === false ) {

						console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

					}

					if ( quaternion === undefined ) quaternion = new Quaternion();

					return this.applyQuaternion( quaternion.setFromEuler( euler ) );

				};

			}(),

			applyAxisAngle: function () {

				var quaternion;

				return function applyAxisAngle( axis, angle ) {

					if ( quaternion === undefined ) quaternion = new Quaternion();

					return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

				};

			}(),

			applyMatrix3: function ( m ) {

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
				this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

				return this;

			},

			applyMatrix4: function ( m ) {

				// input: THREE.Matrix4 affine matrix

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

				return this;

			},

			applyProjection: function ( m ) {

				// input: THREE.Matrix4 projection matrix

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
				var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

				this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
				this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
				this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

				return this;

			},

			applyQuaternion: function ( q ) {

				var x = this.x, y = this.y, z = this.z;
				var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

				// calculate quat * vector

				var ix =  qw * x + qy * z - qz * y;
				var iy =  qw * y + qz * x - qx * z;
				var iz =  qw * z + qx * y - qy * x;
				var iw = - qx * x - qy * y - qz * z;

				// calculate result * inverse quat

				this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
				this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
				this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

				return this;

			},

			project: function () {

				var matrix;

				return function project( camera ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
					return this.applyProjection( matrix );

				};

			}(),

			unproject: function () {

				var matrix;

				return function unproject( camera ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
					return this.applyProjection( matrix );

				};

			}(),

			transformDirection: function ( m ) {

				// input: THREE.Matrix4 affine matrix
				// vector interpreted as a direction

				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;

				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

				return this.normalize();

			},

			divide: function ( v ) {

				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;

				return this;

			},

			divideScalar: function ( scalar ) {

				return this.multiplyScalar( 1 / scalar );

			},

			min: function ( v ) {

				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );

				return this;

			},

			max: function ( v ) {

				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );

				return this;

			},

			clamp: function ( min, max ) {

				// This function assumes min < max, if this assumption isn't true it will not operate correctly

				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );

				return this;

			},

			clampScalar: function () {

				var min, max;

				return function clampScalar( minVal, maxVal ) {

					if ( min === undefined ) {

						min = new Vector3();
						max = new Vector3();

					}

					min.set( minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal );

					return this.clamp( min, max );

				};

			}(),

			clampLength: function ( min, max ) {

				var length = this.length();

				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

			},

			floor: function () {

				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );

				return this;

			},

			ceil: function () {

				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );

				return this;

			},

			round: function () {

				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );

				return this;

			},

			roundToZero: function () {

				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

				return this;

			},

			negate: function () {

				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;

				return this;

			},

			dot: function ( v ) {

				return this.x * v.x + this.y * v.y + this.z * v.z;

			},

			lengthSq: function () {

				return this.x * this.x + this.y * this.y + this.z * this.z;

			},

			length: function () {

				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

			},

			lengthManhattan: function () {

				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

			},

			normalize: function () {

				return this.divideScalar( this.length() );

			},

			setLength: function ( length ) {

				return this.multiplyScalar( length / this.length() );

			},

			lerp: function ( v, alpha ) {

				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;

				return this;

			},

			lerpVectors: function ( v1, v2, alpha ) {

				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

			},

			cross: function ( v, w ) {

				if ( w !== undefined ) {

					console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
					return this.crossVectors( v, w );

				}

				var x = this.x, y = this.y, z = this.z;

				this.x = y * v.z - z * v.y;
				this.y = z * v.x - x * v.z;
				this.z = x * v.y - y * v.x;

				return this;

			},

			crossVectors: function ( a, b ) {

				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;

				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;

				return this;

			},

			projectOnVector: function ( vector ) {

				var scalar = vector.dot( this ) / vector.lengthSq();

				return this.copy( vector ).multiplyScalar( scalar );

			},

			projectOnPlane: function () {

				var v1;

				return function projectOnPlane( planeNormal ) {

					if ( v1 === undefined ) v1 = new Vector3();

					v1.copy( this ).projectOnVector( planeNormal );

					return this.sub( v1 );

				};

			}(),

			reflect: function () {

				// reflect incident vector off plane orthogonal to normal
				// normal is assumed to have unit length

				var v1;

				return function reflect( normal ) {

					if ( v1 === undefined ) v1 = new Vector3();

					return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

				};

			}(),

			angleTo: function ( v ) {

				var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

				// clamp, to handle numerical problems

				return Math.acos( _Math.clamp( theta, - 1, 1 ) );

			},

			distanceTo: function ( v ) {

				return Math.sqrt( this.distanceToSquared( v ) );

			},

			distanceToSquared: function ( v ) {

				var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

				return dx * dx + dy * dy + dz * dz;

			},

			distanceToManhattan: function ( v ) {

				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

			},

			setFromSpherical: function( s ) {

				var sinPhiRadius = Math.sin( s.phi ) * s.radius;

				this.x = sinPhiRadius * Math.sin( s.theta );
				this.y = Math.cos( s.phi ) * s.radius;
				this.z = sinPhiRadius * Math.cos( s.theta );

				return this;

			},

			setFromMatrixPosition: function ( m ) {

				return this.setFromMatrixColumn( m, 3 );

			},

			setFromMatrixScale: function ( m ) {

				var sx = this.setFromMatrixColumn( m, 0 ).length();
				var sy = this.setFromMatrixColumn( m, 1 ).length();
				var sz = this.setFromMatrixColumn( m, 2 ).length();

				this.x = sx;
				this.y = sy;
				this.z = sz;

				return this;

			},

			setFromMatrixColumn: function ( m, index ) {

				if ( typeof m === 'number' ) {

					console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
					var temp = m;
					m = index;
					index = temp;

				}

				return this.fromArray( m.elements, index * 4 );

			},

			equals: function ( v ) {

				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;

				return array;

			},

			fromAttribute: function ( attribute, index, offset ) {

				if ( offset === undefined ) offset = 0;

				index = index * attribute.itemSize + offset;

				this.x = attribute.array[ index ];
				this.y = attribute.array[ index + 1 ];
				this.z = attribute.array[ index + 2 ];

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Matrix4() {

			this.elements = new Float32Array( [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			] );

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		Matrix4.prototype = {

			constructor: Matrix4,

			isMatrix4: true,

			set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

				var te = this.elements;

				te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
				te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
				te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
				te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

				return this;

			},

			identity: function () {

				this.set(

					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1

				);

				return this;

			},

			clone: function () {

				return new Matrix4().fromArray( this.elements );

			},

			copy: function ( m ) {

				this.elements.set( m.elements );

				return this;

			},

			copyPosition: function ( m ) {

				var te = this.elements;
				var me = m.elements;

				te[ 12 ] = me[ 12 ];
				te[ 13 ] = me[ 13 ];
				te[ 14 ] = me[ 14 ];

				return this;

			},

			extractBasis: function ( xAxis, yAxis, zAxis ) {

				xAxis.setFromMatrixColumn( this, 0 );
				yAxis.setFromMatrixColumn( this, 1 );
				zAxis.setFromMatrixColumn( this, 2 );

				return this;

			},

			makeBasis: function ( xAxis, yAxis, zAxis ) {

				this.set(
					xAxis.x, yAxis.x, zAxis.x, 0,
					xAxis.y, yAxis.y, zAxis.y, 0,
					xAxis.z, yAxis.z, zAxis.z, 0,
					0,       0,       0,       1
				);

				return this;

			},

			extractRotation: function () {

				var v1;

				return function extractRotation( m ) {

					if ( v1 === undefined ) v1 = new Vector3();

					var te = this.elements;
					var me = m.elements;

					var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
					var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
					var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

					te[ 0 ] = me[ 0 ] * scaleX;
					te[ 1 ] = me[ 1 ] * scaleX;
					te[ 2 ] = me[ 2 ] * scaleX;

					te[ 4 ] = me[ 4 ] * scaleY;
					te[ 5 ] = me[ 5 ] * scaleY;
					te[ 6 ] = me[ 6 ] * scaleY;

					te[ 8 ] = me[ 8 ] * scaleZ;
					te[ 9 ] = me[ 9 ] * scaleZ;
					te[ 10 ] = me[ 10 ] * scaleZ;

					return this;

				};

			}(),

			makeRotationFromEuler: function ( euler ) {

				if ( (euler && euler.isEuler) === false ) {

					console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

				}

				var te = this.elements;

				var x = euler.x, y = euler.y, z = euler.z;
				var a = Math.cos( x ), b = Math.sin( x );
				var c = Math.cos( y ), d = Math.sin( y );
				var e = Math.cos( z ), f = Math.sin( z );

				if ( euler.order === 'XYZ' ) {

					var ae = a * e, af = a * f, be = b * e, bf = b * f;

					te[ 0 ] = c * e;
					te[ 4 ] = - c * f;
					te[ 8 ] = d;

					te[ 1 ] = af + be * d;
					te[ 5 ] = ae - bf * d;
					te[ 9 ] = - b * c;

					te[ 2 ] = bf - ae * d;
					te[ 6 ] = be + af * d;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'YXZ' ) {

					var ce = c * e, cf = c * f, de = d * e, df = d * f;

					te[ 0 ] = ce + df * b;
					te[ 4 ] = de * b - cf;
					te[ 8 ] = a * d;

					te[ 1 ] = a * f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b;

					te[ 2 ] = cf * b - de;
					te[ 6 ] = df + ce * b;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'ZXY' ) {

					var ce = c * e, cf = c * f, de = d * e, df = d * f;

					te[ 0 ] = ce - df * b;
					te[ 4 ] = - a * f;
					te[ 8 ] = de + cf * b;

					te[ 1 ] = cf + de * b;
					te[ 5 ] = a * e;
					te[ 9 ] = df - ce * b;

					te[ 2 ] = - a * d;
					te[ 6 ] = b;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'ZYX' ) {

					var ae = a * e, af = a * f, be = b * e, bf = b * f;

					te[ 0 ] = c * e;
					te[ 4 ] = be * d - af;
					te[ 8 ] = ae * d + bf;

					te[ 1 ] = c * f;
					te[ 5 ] = bf * d + ae;
					te[ 9 ] = af * d - be;

					te[ 2 ] = - d;
					te[ 6 ] = b * c;
					te[ 10 ] = a * c;

				} else if ( euler.order === 'YZX' ) {

					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

					te[ 0 ] = c * e;
					te[ 4 ] = bd - ac * f;
					te[ 8 ] = bc * f + ad;

					te[ 1 ] = f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b * e;

					te[ 2 ] = - d * e;
					te[ 6 ] = ad * f + bc;
					te[ 10 ] = ac - bd * f;

				} else if ( euler.order === 'XZY' ) {

					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

					te[ 0 ] = c * e;
					te[ 4 ] = - f;
					te[ 8 ] = d * e;

					te[ 1 ] = ac * f + bd;
					te[ 5 ] = a * e;
					te[ 9 ] = ad * f - bc;

					te[ 2 ] = bc * f - ad;
					te[ 6 ] = b * e;
					te[ 10 ] = bd * f + ac;

				}

				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;

				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			},

			makeRotationFromQuaternion: function ( q ) {

				var te = this.elements;

				var x = q.x, y = q.y, z = q.z, w = q.w;
				var x2 = x + x, y2 = y + y, z2 = z + z;
				var xx = x * x2, xy = x * y2, xz = x * z2;
				var yy = y * y2, yz = y * z2, zz = z * z2;
				var wx = w * x2, wy = w * y2, wz = w * z2;

				te[ 0 ] = 1 - ( yy + zz );
				te[ 4 ] = xy - wz;
				te[ 8 ] = xz + wy;

				te[ 1 ] = xy + wz;
				te[ 5 ] = 1 - ( xx + zz );
				te[ 9 ] = yz - wx;

				te[ 2 ] = xz - wy;
				te[ 6 ] = yz + wx;
				te[ 10 ] = 1 - ( xx + yy );

				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;

				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			},

			lookAt: function () {

				var x, y, z;

				return function lookAt( eye, target, up ) {

					if ( x === undefined ) {

						x = new Vector3();
						y = new Vector3();
						z = new Vector3();

					}

					var te = this.elements;

					z.subVectors( eye, target ).normalize();

					if ( z.lengthSq() === 0 ) {

						z.z = 1;

					}

					x.crossVectors( up, z ).normalize();

					if ( x.lengthSq() === 0 ) {

						z.z += 0.0001;
						x.crossVectors( up, z ).normalize();

					}

					y.crossVectors( z, x );


					te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
					te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
					te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

					return this;

				};

			}(),

			multiply: function ( m, n ) {

				if ( n !== undefined ) {

					console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
					return this.multiplyMatrices( m, n );

				}

				return this.multiplyMatrices( this, m );

			},

			premultiply: function ( m ) {

				return this.multiplyMatrices( m, this );

			},

			multiplyMatrices: function ( a, b ) {

				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;

				var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
				var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
				var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
				var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

				var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
				var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
				var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
				var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

				te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

				return this;

			},

			multiplyToArray: function ( a, b, r ) {

				var te = this.elements;

				this.multiplyMatrices( a, b );

				r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
				r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
				r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
				r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

				return this;

			},

			multiplyScalar: function ( s ) {

				var te = this.elements;

				te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
				te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
				te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
				te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

				return this;

			},

			applyToVector3Array: function () {

				var v1;

				return function applyToVector3Array( array, offset, length ) {

					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = array.length;

					for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

						v1.fromArray( array, j );
						v1.applyMatrix4( this );
						v1.toArray( array, j );

					}

					return array;

				};

			}(),

			applyToBuffer: function () {

				var v1;

				return function applyToBuffer( buffer, offset, length ) {

					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = buffer.length / buffer.itemSize;

					for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

						v1.x = buffer.getX( j );
						v1.y = buffer.getY( j );
						v1.z = buffer.getZ( j );

						v1.applyMatrix4( this );

						buffer.setXYZ( j, v1.x, v1.y, v1.z );

					}

					return buffer;

				};

			}(),

			determinant: function () {

				var te = this.elements;

				var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
				var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
				var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
				var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

				//TODO: make this more efficient
				//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

				return (
					n41 * (
						+ n14 * n23 * n32
						 - n13 * n24 * n32
						 - n14 * n22 * n33
						 + n12 * n24 * n33
						 + n13 * n22 * n34
						 - n12 * n23 * n34
					) +
					n42 * (
						+ n11 * n23 * n34
						 - n11 * n24 * n33
						 + n14 * n21 * n33
						 - n13 * n21 * n34
						 + n13 * n24 * n31
						 - n14 * n23 * n31
					) +
					n43 * (
						+ n11 * n24 * n32
						 - n11 * n22 * n34
						 - n14 * n21 * n32
						 + n12 * n21 * n34
						 + n14 * n22 * n31
						 - n12 * n24 * n31
					) +
					n44 * (
						- n13 * n22 * n31
						 - n11 * n23 * n32
						 + n11 * n22 * n33
						 + n13 * n21 * n32
						 - n12 * n21 * n33
						 + n12 * n23 * n31
					)

				);

			},

			transpose: function () {

				var te = this.elements;
				var tmp;

				tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
				tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
				tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

				tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
				tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
				tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

				return this;

			},

			flattenToArrayOffset: function ( array, offset ) {

				console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
						"- just use .toArray instead." );

				return this.toArray( array, offset );

			},

			getPosition: function () {

				var v1;

				return function getPosition() {

					if ( v1 === undefined ) v1 = new Vector3();
					console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

					return v1.setFromMatrixColumn( this, 3 );

				};

			}(),

			setPosition: function ( v ) {

				var te = this.elements;

				te[ 12 ] = v.x;
				te[ 13 ] = v.y;
				te[ 14 ] = v.z;

				return this;

			},

			getInverse: function ( m, throwOnDegenerate ) {

				// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
				var te = this.elements,
					me = m.elements,

					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
					n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
					n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
					n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

				if ( det === 0 ) {

					var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

					if ( throwOnDegenerate === true ) {

						throw new Error( msg );

					} else {

						console.warn( msg );

					}

					return this.identity();

				}

				var detInv = 1 / det;

				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
				te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
				te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

				te[ 4 ] = t12 * detInv;
				te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
				te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
				te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

				te[ 8 ] = t13 * detInv;
				te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
				te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
				te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

				te[ 12 ] = t14 * detInv;
				te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
				te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
				te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

				return this;

			},

			scale: function ( v ) {

				var te = this.elements;
				var x = v.x, y = v.y, z = v.z;

				te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
				te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
				te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
				te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

				return this;

			},

			getMaxScaleOnAxis: function () {

				var te = this.elements;

				var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
				var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
				var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

				return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

			},

			makeTranslation: function ( x, y, z ) {

				this.set(

					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1

				);

				return this;

			},

			makeRotationX: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					1, 0,  0, 0,
					0, c, - s, 0,
					0, s,  c, 0,
					0, 0,  0, 1

				);

				return this;

			},

			makeRotationY: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					 c, 0, s, 0,
					 0, 1, 0, 0,
					- s, 0, c, 0,
					 0, 0, 0, 1

				);

				return this;

			},

			makeRotationZ: function ( theta ) {

				var c = Math.cos( theta ), s = Math.sin( theta );

				this.set(

					c, - s, 0, 0,
					s,  c, 0, 0,
					0,  0, 1, 0,
					0,  0, 0, 1

				);

				return this;

			},

			makeRotationAxis: function ( axis, angle ) {

				// Based on http://www.gamedev.net/reference/articles/article1199.asp

				var c = Math.cos( angle );
				var s = Math.sin( angle );
				var t = 1 - c;
				var x = axis.x, y = axis.y, z = axis.z;
				var tx = t * x, ty = t * y;

				this.set(

					tx * x + c, tx * y - s * z, tx * z + s * y, 0,
					tx * y + s * z, ty * y + c, ty * z - s * x, 0,
					tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
					0, 0, 0, 1

				);

				 return this;

			},

			makeScale: function ( x, y, z ) {

				this.set(

					x, 0, 0, 0,
					0, y, 0, 0,
					0, 0, z, 0,
					0, 0, 0, 1

				);

				return this;

			},

			compose: function ( position, quaternion, scale ) {

				this.makeRotationFromQuaternion( quaternion );
				this.scale( scale );
				this.setPosition( position );

				return this;

			},

			decompose: function () {

				var vector, matrix;

				return function decompose( position, quaternion, scale ) {

					if ( vector === undefined ) {

						vector = new Vector3();
						matrix = new Matrix4();

					}

					var te = this.elements;

					var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
					var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
					var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

					// if determine is negative, we need to invert one scale
					var det = this.determinant();
					if ( det < 0 ) {

						sx = - sx;

					}

					position.x = te[ 12 ];
					position.y = te[ 13 ];
					position.z = te[ 14 ];

					// scale the rotation part

					matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

					var invSX = 1 / sx;
					var invSY = 1 / sy;
					var invSZ = 1 / sz;

					matrix.elements[ 0 ] *= invSX;
					matrix.elements[ 1 ] *= invSX;
					matrix.elements[ 2 ] *= invSX;

					matrix.elements[ 4 ] *= invSY;
					matrix.elements[ 5 ] *= invSY;
					matrix.elements[ 6 ] *= invSY;

					matrix.elements[ 8 ] *= invSZ;
					matrix.elements[ 9 ] *= invSZ;
					matrix.elements[ 10 ] *= invSZ;

					quaternion.setFromRotationMatrix( matrix );

					scale.x = sx;
					scale.y = sy;
					scale.z = sz;

					return this;

				};

			}(),

			makeFrustum: function ( left, right, bottom, top, near, far ) {

				var te = this.elements;
				var x = 2 * near / ( right - left );
				var y = 2 * near / ( top - bottom );

				var a = ( right + left ) / ( right - left );
				var b = ( top + bottom ) / ( top - bottom );
				var c = - ( far + near ) / ( far - near );
				var d = - 2 * far * near / ( far - near );

				te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
				te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

				return this;

			},

			makePerspective: function ( fov, aspect, near, far ) {

				var ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );
				var ymin = - ymax;
				var xmin = ymin * aspect;
				var xmax = ymax * aspect;

				return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

			},

			makeOrthographic: function ( left, right, top, bottom, near, far ) {

				var te = this.elements;
				var w = 1.0 / ( right - left );
				var h = 1.0 / ( top - bottom );
				var p = 1.0 / ( far - near );

				var x = ( right + left ) * w;
				var y = ( top + bottom ) * h;
				var z = ( far + near ) * p;

				te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
				te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

				return this;

			},

			equals: function ( matrix ) {

				var te = this.elements;
				var me = matrix.elements;

				for ( var i = 0; i < 16; i ++ ) {

					if ( te[ i ] !== me[ i ] ) return false;

				}

				return true;

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				for( var i = 0; i < 16; i ++ ) {

					this.elements[ i ] = array[ i + offset ];

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				var te = this.elements;

				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
				array[ offset + 3 ] = te[ 3 ];

				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];

				array[ offset + 8 ]  = te[ 8 ];
				array[ offset + 9 ]  = te[ 9 ];
				array[ offset + 10 ] = te[ 10 ];
				array[ offset + 11 ] = te[ 11 ];

				array[ offset + 12 ] = te[ 12 ];
				array[ offset + 13 ] = te[ 13 ];
				array[ offset + 14 ] = te[ 14 ];
				array[ offset + 15 ] = te[ 15 ];

				return array;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.flipY = false;

		}

		CubeTexture.prototype = Object.create( Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;

		CubeTexture.prototype.isCubeTexture = true;

		Object.defineProperty( CubeTexture.prototype, 'images', {

			get: function () {

				return this.image;

			},

			set: function ( value ) {

				this.image = value;

			}

		} );

		/**
		 * @author tschw
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [renderer] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'renderer' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (renderer factorizations):
		 *
		 * .upload( gl, seq, values, renderer )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (renderer factorizations):
		 *
		 * .setValue( gl, name, value )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .set( gl, obj, prop )
		 *
		 * 		sets uniform from object and property with same name than uniform
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */

		var emptyTexture = new Texture();
		var emptyCubeTexture = new CubeTexture();

		// --- Base for inner nodes (including the root) ---

		function UniformContainer() {

			this.seq = [];
			this.map = {};

		}

		// --- Utilities ---

		// Array Caches (provide typed arrays for temporary by size)

		var arrayCacheF32 = [];
		var arrayCacheI32 = [];

		// Flattening for arrays of vectors and matrices

		function flatten( array, nBlocks, blockSize ) {

			var firstElem = array[ 0 ];

			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983

			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];

			if ( r === undefined ) {

				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;

			}

			if ( nBlocks !== 0 ) {

				firstElem.toArray( r, 0 );

				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

					offset += blockSize;
					array[ i ].toArray( r, offset );

				}

			}

			return r;

		}

		// Texture unit allocation

		function allocTexUnits( renderer, n ) {

			var r = arrayCacheI32[ n ];

			if ( r === undefined ) {

				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;

			}

			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();

			return r;

		}

		// --- Setters ---

		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.

		// Single scalar

		function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
		function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

		// Single float vector (from flat array or THREE.VectorN)

		function setValue2fv( gl, v ) {

			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );

		}

		function setValue3fv( gl, v ) {

			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );

		}

		function setValue4fv( gl, v ) {

			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

		}

		// Single matrix (from flat array or MatrixN)

		function setValue2fm( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, v.elements || v );

		}

		function setValue3fm( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, v.elements || v );

		}

		function setValue4fm( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, v.elements || v );

		}

		// Single texture (2D / Cube)

		function setValueT1( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTexture2D( v || emptyTexture, unit );

		}

		function setValueT6( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTextureCube( v || emptyCubeTexture, unit );

		}

		// Integer / Boolean vectors or arrays thereof (always flat arrays)

		function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
		function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
		function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

		// Helper to pick the right setter for the singular case

		function getSingularSetter( type ) {

			switch ( type ) {

				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4

				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4

				case 0x8b5e: return setValueT1; // SAMPLER_2D
				case 0x8b60: return setValueT6; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		}

		// Array of scalars

		function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
		function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

		// Array of vectors (flat or from THREE classes)

		function setValueV2a( gl, v ) {

			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

		}

		function setValueV3a( gl, v ) {

			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

		}

		function setValueV4a( gl, v ) {

			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

		}

		// Array of matrices (flat or from THREE clases)

		function setValueM2a( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

		}

		function setValueM3a( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

		}

		function setValueM4a( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

		}

		// Array of textures (2D / Cube)

		function setValueT1a( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

			}

		}

		function setValueT6a( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

			}

		}

		// Helper to pick the right setter for a pure (bottom-level) array

		function getPureArraySetter( type ) {

			switch ( type ) {

				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4

				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4

				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		}

		// --- Uniform Classes ---

		function SingleUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

		function PureArrayUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		}

		function StructuredUniform( id ) {

			this.id = id;

			UniformContainer.call( this ); // mix-in

		}

		StructuredUniform.prototype.setValue = function( gl, value ) {

			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.

			var seq = this.seq;

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ];
				u.setValue( gl, value[ u.id ] );

			}

		};

		// --- Top-level ---

		// Parser - builds up the property tree from the path strings

		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.

		function addUniform( container, uniformObject ) {

			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;

		}

		function parseUniform( activeInfo, addr, container ) {

			var path = activeInfo.name,
				pathLength = path.length;

			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;

			for (; ;) {

				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,

					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];

				if ( idIsIndex ) id = id | 0; // convert to integer

				if ( subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength ) {
					// bare name or "pure" bottom-level array "[0]" suffix

					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );

					break;

				} else {
					// step into inner node / create it in case it doesn't exist

					var map = container.map,
						next = map[ id ];

					if ( next === undefined ) {

						next = new StructuredUniform( id );
						addUniform( container, next );

					}

					container = next;

				}

			}

		}

		// Root Container

		function WebGLUniforms( gl, program, renderer ) {

			UniformContainer.call( this );

			this.renderer = renderer;

			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( var i = 0; i !== n; ++ i ) {

				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );

				parseUniform( info, addr, this );

			}

		}

		WebGLUniforms.prototype.setValue = function( gl, name, value ) {

			var u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, value, this.renderer );

		};

		WebGLUniforms.prototype.set = function( gl, object, name ) {

			var u = this.map[ name ];

			if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

		};

		WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

			var v = object[ name ];

			if ( v !== undefined ) this.setValue( gl, name, v );

		};


		// Static interface

		WebGLUniforms.upload = function( gl, seq, values, renderer ) {

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ],
					v = values[ u.id ];

				if ( v.needsUpdate !== false ) {
					// note: always updating when .needsUpdate is undefined

					u.setValue( gl, v.value, renderer );

				}

			}

		};

		WebGLUniforms.seqWithValue = function( seq, values ) {

			var r = [];

			for ( var i = 0, n = seq.length; i !== n; ++ i ) {

				var u = seq[ i ];
				if ( u.id in values ) r.push( u );

			}

			return r;

		};

		/**
		 * Uniform Utilities
		 */

		var UniformsUtils = {

			merge: function ( uniforms ) {

				var merged = {};

				for ( var u = 0; u < uniforms.length; u ++ ) {

					var tmp = this.clone( uniforms[ u ] );

					for ( var p in tmp ) {

						merged[ p ] = tmp[ p ];

					}

				}

				return merged;

			},

			clone: function ( uniforms_src ) {

				var uniforms_dst = {};

				for ( var u in uniforms_src ) {

					uniforms_dst[ u ] = {};

					for ( var p in uniforms_src[ u ] ) {

						var parameter_src = uniforms_src[ u ][ p ];

						if ( parameter_src && ( parameter_src.isColor ||
							parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
							parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
							parameter_src.isTexture ) ) {

							uniforms_dst[ u ][ p ] = parameter_src.clone();

						} else if ( Array.isArray( parameter_src ) ) {

							uniforms_dst[ u ][ p ] = parameter_src.slice();

						} else {

							uniforms_dst[ u ][ p ] = parameter_src;

						}

					}

				}

				return uniforms_dst;

			}

		};

		var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

		var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

		var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

		var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

		var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

		var begin_vertex = "\nvec3 transformed = vec3( position );\n";

		var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

		var bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

		var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

		var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

		var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

		var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

		var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

		var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

		var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

		var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

		var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

		var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

		var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

		var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

		var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

		var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

		var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

		var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

		var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

		var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

		var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

		var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

		var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

		var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

		var fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

		var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

		var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

		var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

		var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

		var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

		var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

		var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

		var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

		var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

		var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

		var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

		var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

		var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

		var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

		var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

		var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

		var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

		var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

		var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";

		var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

		var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

		var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

		var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

		var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

		var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

		var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

		var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

		var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

		var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

		var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

		var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

		var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

		var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

		var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

		var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

		var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

		var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

		var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

		var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

		var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

		var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

		var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

		var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

		var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

		var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

		var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

		var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

		var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

		var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

		var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

		var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

		var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

		var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

		var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

		var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

		var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

		var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

		var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

		var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

		var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";

		var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";

		var normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

		var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

		var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

		var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

		var ShaderChunk = {
			alphamap_fragment: alphamap_fragment,
			alphamap_pars_fragment: alphamap_pars_fragment,
			alphatest_fragment: alphatest_fragment,
			aomap_fragment: aomap_fragment,
			aomap_pars_fragment: aomap_pars_fragment,
			begin_vertex: begin_vertex,
			beginnormal_vertex: beginnormal_vertex,
			bsdfs: bsdfs,
			bumpmap_pars_fragment: bumpmap_pars_fragment,
			clipping_planes_fragment: clipping_planes_fragment,
			clipping_planes_pars_fragment: clipping_planes_pars_fragment,
			clipping_planes_pars_vertex: clipping_planes_pars_vertex,
			clipping_planes_vertex: clipping_planes_vertex,
			color_fragment: color_fragment,
			color_pars_fragment: color_pars_fragment,
			color_pars_vertex: color_pars_vertex,
			color_vertex: color_vertex,
			common: common,
			cube_uv_reflection_fragment: cube_uv_reflection_fragment,
			defaultnormal_vertex: defaultnormal_vertex,
			displacementmap_pars_vertex: displacementmap_pars_vertex,
			displacementmap_vertex: displacementmap_vertex,
			emissivemap_fragment: emissivemap_fragment,
			emissivemap_pars_fragment: emissivemap_pars_fragment,
			encodings_fragment: encodings_fragment,
			encodings_pars_fragment: encodings_pars_fragment,
			envmap_fragment: envmap_fragment,
			envmap_pars_fragment: envmap_pars_fragment,
			envmap_pars_vertex: envmap_pars_vertex,
			envmap_vertex: envmap_vertex,
			fog_fragment: fog_fragment,
			fog_pars_fragment: fog_pars_fragment,
			lightmap_fragment: lightmap_fragment,
			lightmap_pars_fragment: lightmap_pars_fragment,
			lights_lambert_vertex: lights_lambert_vertex,
			lights_pars: lights_pars,
			lights_phong_fragment: lights_phong_fragment,
			lights_phong_pars_fragment: lights_phong_pars_fragment,
			lights_physical_fragment: lights_physical_fragment,
			lights_physical_pars_fragment: lights_physical_pars_fragment,
			lights_template: lights_template,
			logdepthbuf_fragment: logdepthbuf_fragment,
			logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
			logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
			logdepthbuf_vertex: logdepthbuf_vertex,
			map_fragment: map_fragment,
			map_pars_fragment: map_pars_fragment,
			map_particle_fragment: map_particle_fragment,
			map_particle_pars_fragment: map_particle_pars_fragment,
			metalnessmap_fragment: metalnessmap_fragment,
			metalnessmap_pars_fragment: metalnessmap_pars_fragment,
			morphnormal_vertex: morphnormal_vertex,
			morphtarget_pars_vertex: morphtarget_pars_vertex,
			morphtarget_vertex: morphtarget_vertex,
			normal_flip: normal_flip,
			normal_fragment: normal_fragment,
			normalmap_pars_fragment: normalmap_pars_fragment,
			packing: packing,
			premultiplied_alpha_fragment: premultiplied_alpha_fragment,
			project_vertex: project_vertex,
			roughnessmap_fragment: roughnessmap_fragment,
			roughnessmap_pars_fragment: roughnessmap_pars_fragment,
			shadowmap_pars_fragment: shadowmap_pars_fragment,
			shadowmap_pars_vertex: shadowmap_pars_vertex,
			shadowmap_vertex: shadowmap_vertex,
			shadowmask_pars_fragment: shadowmask_pars_fragment,
			skinbase_vertex: skinbase_vertex,
			skinning_pars_vertex: skinning_pars_vertex,
			skinning_vertex: skinning_vertex,
			skinnormal_vertex: skinnormal_vertex,
			specularmap_fragment: specularmap_fragment,
			specularmap_pars_fragment: specularmap_pars_fragment,
			tonemapping_fragment: tonemapping_fragment,
			tonemapping_pars_fragment: tonemapping_pars_fragment,
			uv_pars_fragment: uv_pars_fragment,
			uv_pars_vertex: uv_pars_vertex,
			uv_vertex: uv_vertex,
			uv2_pars_fragment: uv2_pars_fragment,
			uv2_pars_vertex: uv2_pars_vertex,
			uv2_vertex: uv2_vertex,
			worldpos_vertex: worldpos_vertex,

			cube_frag: cube_frag,
			cube_vert: cube_vert,
			depth_frag: depth_frag,
			depth_vert: depth_vert,
			distanceRGBA_frag: distanceRGBA_frag,
			distanceRGBA_vert: distanceRGBA_vert,
			equirect_frag: equirect_frag,
			equirect_vert: equirect_vert,
			linedashed_frag: linedashed_frag,
			linedashed_vert: linedashed_vert,
			meshbasic_frag: meshbasic_frag,
			meshbasic_vert: meshbasic_vert,
			meshlambert_frag: meshlambert_frag,
			meshlambert_vert: meshlambert_vert,
			meshphong_frag: meshphong_frag,
			meshphong_vert: meshphong_vert,
			meshphysical_frag: meshphysical_frag,
			meshphysical_vert: meshphysical_vert,
			normal_frag: normal_frag,
			normal_vert: normal_vert,
			points_frag: points_frag,
			points_vert: points_vert,
			shadow_frag: shadow_frag,
			shadow_vert: shadow_vert
		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Color( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string
				return this.set( r );

			}

			return this.setRGB( r, g, b );

		}

		Color.prototype = {

			constructor: Color,

			isColor: true,

			r: 1, g: 1, b: 1,

			set: function ( value ) {

				if ( (value && value.isColor) ) {

					this.copy( value );

				} else if ( typeof value === 'number' ) {

					this.setHex( value );

				} else if ( typeof value === 'string' ) {

					this.setStyle( value );

				}

				return this;

			},

			setScalar: function ( scalar ) {

				this.r = scalar;
				this.g = scalar;
				this.b = scalar;

				return this;

			},

			setHex: function ( hex ) {

				hex = Math.floor( hex );

				this.r = ( hex >> 16 & 255 ) / 255;
				this.g = ( hex >> 8 & 255 ) / 255;
				this.b = ( hex & 255 ) / 255;

				return this;

			},

			setRGB: function ( r, g, b ) {

				this.r = r;
				this.g = g;
				this.b = b;

				return this;

			},

			setHSL: function () {

				function hue2rgb( p, q, t ) {

					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;

				}

				return function setHSL( h, s, l ) {

					// h,s,l ranges are in 0.0 - 1.0
					h = _Math.euclideanModulo( h, 1 );
					s = _Math.clamp( s, 0, 1 );
					l = _Math.clamp( l, 0, 1 );

					if ( s === 0 ) {

						this.r = this.g = this.b = l;

					} else {

						var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
						var q = ( 2 * l ) - p;

						this.r = hue2rgb( q, p, h + 1 / 3 );
						this.g = hue2rgb( q, p, h );
						this.b = hue2rgb( q, p, h - 1 / 3 );

					}

					return this;

				};

			}(),

			setStyle: function ( style ) {

				function handleAlpha( string ) {

					if ( string === undefined ) return;

					if ( parseFloat( string ) < 1 ) {

						console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

					}

				}


				var m;

				if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

					// rgb / hsl

					var color;
					var name = m[ 1 ];
					var components = m[ 2 ];

					switch ( name ) {

						case 'rgb':
						case 'rgba':

							if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// rgb(255,0,0) rgba(255,0,0,0.5)
								this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
								this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
								this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

								handleAlpha( color[ 5 ] );

								return this;

							}

							if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
								this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
								this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
								this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

								handleAlpha( color[ 5 ] );

								return this;

							}

							break;

						case 'hsl':
						case 'hsla':

							if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

								// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
								var h = parseFloat( color[ 1 ] ) / 360;
								var s = parseInt( color[ 2 ], 10 ) / 100;
								var l = parseInt( color[ 3 ], 10 ) / 100;

								handleAlpha( color[ 5 ] );

								return this.setHSL( h, s, l );

							}

							break;

					}

				} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

					// hex color

					var hex = m[ 1 ];
					var size = hex.length;

					if ( size === 3 ) {

						// #ff0
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

						return this;

					} else if ( size === 6 ) {

						// #ff0000
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

						return this;

					}

				}

				if ( style && style.length > 0 ) {

					// color keywords
					var hex = ColorKeywords[ style ];

					if ( hex !== undefined ) {

						// red
						this.setHex( hex );

					} else {

						// unknown color
						console.warn( 'THREE.Color: Unknown color ' + style );

					}

				}

				return this;

			},

			clone: function () {

				return new this.constructor( this.r, this.g, this.b );

			},

			copy: function ( color ) {

				this.r = color.r;
				this.g = color.g;
				this.b = color.b;

				return this;

			},

			copyGammaToLinear: function ( color, gammaFactor ) {

				if ( gammaFactor === undefined ) gammaFactor = 2.0;

				this.r = Math.pow( color.r, gammaFactor );
				this.g = Math.pow( color.g, gammaFactor );
				this.b = Math.pow( color.b, gammaFactor );

				return this;

			},

			copyLinearToGamma: function ( color, gammaFactor ) {

				if ( gammaFactor === undefined ) gammaFactor = 2.0;

				var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

				this.r = Math.pow( color.r, safeInverse );
				this.g = Math.pow( color.g, safeInverse );
				this.b = Math.pow( color.b, safeInverse );

				return this;

			},

			convertGammaToLinear: function () {

				var r = this.r, g = this.g, b = this.b;

				this.r = r * r;
				this.g = g * g;
				this.b = b * b;

				return this;

			},

			convertLinearToGamma: function () {

				this.r = Math.sqrt( this.r );
				this.g = Math.sqrt( this.g );
				this.b = Math.sqrt( this.b );

				return this;

			},

			getHex: function () {

				return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

			},

			getHexString: function () {

				return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

			},

			getHSL: function ( optionalTarget ) {

				// h,s,l ranges are in 0.0 - 1.0

				var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

				var r = this.r, g = this.g, b = this.b;

				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );

				var hue, saturation;
				var lightness = ( min + max ) / 2.0;

				if ( min === max ) {

					hue = 0;
					saturation = 0;

				} else {

					var delta = max - min;

					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

					switch ( max ) {

						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;

					}

					hue /= 6;

				}

				hsl.h = hue;
				hsl.s = saturation;
				hsl.l = lightness;

				return hsl;

			},

			getStyle: function () {

				return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

			},

			offsetHSL: function ( h, s, l ) {

				var hsl = this.getHSL();

				hsl.h += h; hsl.s += s; hsl.l += l;

				this.setHSL( hsl.h, hsl.s, hsl.l );

				return this;

			},

			add: function ( color ) {

				this.r += color.r;
				this.g += color.g;
				this.b += color.b;

				return this;

			},

			addColors: function ( color1, color2 ) {

				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;

				return this;

			},

			addScalar: function ( s ) {

				this.r += s;
				this.g += s;
				this.b += s;

				return this;

			},

			sub: function( color ) {

				this.r = Math.max( 0, this.r - color.r );
				this.g = Math.max( 0, this.g - color.g );
				this.b = Math.max( 0, this.b - color.b );

				return this;

			},

			multiply: function ( color ) {

				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;

				return this;

			},

			multiplyScalar: function ( s ) {

				this.r *= s;
				this.g *= s;
				this.b *= s;

				return this;

			},

			lerp: function ( color, alpha ) {

				this.r += ( color.r - this.r ) * alpha;
				this.g += ( color.g - this.g ) * alpha;
				this.b += ( color.b - this.b ) * alpha;

				return this;

			},

			equals: function ( c ) {

				return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				this.r = array[ offset ];
				this.g = array[ offset + 1 ];
				this.b = array[ offset + 2 ];

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this.r;
				array[ offset + 1 ] = this.g;
				array[ offset + 2 ] = this.b;

				return array;

			},

			toJSON: function () {

				return this.getHex();

			}

		};

		var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

		/**
		 * Uniforms library for shared webgl shaders
		 */

		var UniformsLib = {

			common: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },

				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

				specularMap: { value: null },
				alphaMap: { value: null },

				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				reflectivity: { value: 1.0 },
				refractionRatio: { value: 0.98 }

			},

			aomap: {

				aoMap: { value: null },
				aoMapIntensity: { value: 1 }

			},

			lightmap: {

				lightMap: { value: null },
				lightMapIntensity: { value: 1 }

			},

			emissivemap: {

				emissiveMap: { value: null }

			},

			bumpmap: {

				bumpMap: { value: null },
				bumpScale: { value: 1 }

			},

			normalmap: {

				normalMap: { value: null },
				normalScale: { value: new Vector2( 1, 1 ) }

			},

			displacementmap: {

				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 }

			},

			roughnessmap: {

				roughnessMap: { value: null }

			},

			metalnessmap: {

				metalnessMap: { value: null }

			},

			fog: {

				fogDensity: { value: 0.00025 },
				fogNear: { value: 1 },
				fogFar: { value: 2000 },
				fogColor: { value: new Color( 0xffffff ) }

			},

			lights: {

				ambientLightColor: { value: [] },

				directionalLights: { value: [], properties: {
					direction: {},
					color: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },

				spotLights: { value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },

				pointLights: { value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {},

					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },

				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },

				hemisphereLights: { value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				} }

			},

			points: {

				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				size: { value: 1.0 },
				scale: { value: 1.0 },
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */

		var ShaderLib = {

			basic: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.fog

				] ),

				vertexShader: ShaderChunk.meshbasic_vert,
				fragmentShader: ShaderChunk.meshbasic_frag

			},

			lambert: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.fog,
					UniformsLib.lights,

					{
						emissive : { value: new Color( 0x000000 ) }
					}

				] ),

				vertexShader: ShaderChunk.meshlambert_vert,
				fragmentShader: ShaderChunk.meshlambert_frag

			},

			phong: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.fog,
					UniformsLib.lights,

					{
						emissive : { value: new Color( 0x000000 ) },
						specular : { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}

				] ),

				vertexShader: ShaderChunk.meshphong_vert,
				fragmentShader: ShaderChunk.meshphong_frag

			},

			standard: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.roughnessmap,
					UniformsLib.metalnessmap,
					UniformsLib.fog,
					UniformsLib.lights,

					{
						emissive : { value: new Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0 },
						envMapIntensity : { value: 1 }, // temporary
					}

				] ),

				vertexShader: ShaderChunk.meshphysical_vert,
				fragmentShader: ShaderChunk.meshphysical_frag

			},

			points: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.points,
					UniformsLib.fog

				] ),

				vertexShader: ShaderChunk.points_vert,
				fragmentShader: ShaderChunk.points_frag

			},

			dashed: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.fog,

					{
						scale    : { value: 1 },
						dashSize : { value: 1 },
						totalSize: { value: 2 }
					}

				] ),

				vertexShader: ShaderChunk.linedashed_vert,
				fragmentShader: ShaderChunk.linedashed_frag

			},

			depth: {

				uniforms: UniformsUtils.merge( [

					UniformsLib.common,
					UniformsLib.displacementmap

				] ),

				vertexShader: ShaderChunk.depth_vert,
				fragmentShader: ShaderChunk.depth_frag

			},

			normal: {

				uniforms: {

					opacity : { value: 1.0 }

				},

				vertexShader: ShaderChunk.normal_vert,
				fragmentShader: ShaderChunk.normal_frag

			},

			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */

			cube: {

				uniforms: {
					tCube: { value: null },
					tFlip: { value: - 1 },
					opacity: { value: 1.0 }
				},

				vertexShader: ShaderChunk.cube_vert,
				fragmentShader: ShaderChunk.cube_frag

			},

			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */

			equirect: {

				uniforms: {
					tEquirect: { value: null },
					tFlip: { value: - 1 }
				},

				vertexShader: ShaderChunk.equirect_vert,
				fragmentShader: ShaderChunk.equirect_frag

			},

			distanceRGBA: {

				uniforms: {

					lightPos: { value: new Vector3() }

				},

				vertexShader: ShaderChunk.distanceRGBA_vert,
				fragmentShader: ShaderChunk.distanceRGBA_frag

			}

		};

		ShaderLib.physical = {

			uniforms: UniformsUtils.merge( [

				ShaderLib.standard.uniforms,

				{
					clearCoat: { value: 0 },
					clearCoatRoughness: { value: 0 }
				}

			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		};

		/**
		 * @author bhouston / http://clara.io
		 */

		function Box2( min, max ) {

			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

		}

		Box2.prototype = {

			constructor: Box2,

			set: function ( min, max ) {

				this.min.copy( min );
				this.max.copy( max );

				return this;

			},

			setFromPoints: function ( points ) {

				this.makeEmpty();

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					this.expandByPoint( points[ i ] );

				}

				return this;

			},

			setFromCenterAndSize: function () {

				var v1 = new Vector2();

				return function setFromCenterAndSize( center, size ) {

					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( box ) {

				this.min.copy( box.min );
				this.max.copy( box.max );

				return this;

			},

			makeEmpty: function () {

				this.min.x = this.min.y = + Infinity;
				this.max.x = this.max.y = - Infinity;

				return this;

			},

			isEmpty: function () {

				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

			},

			getSize: function ( optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

			},

			expandByPoint: function ( point ) {

				this.min.min( point );
				this.max.max( point );

				return this;

			},

			expandByVector: function ( vector ) {

				this.min.sub( vector );
				this.max.add( vector );

				return this;

			},

			expandByScalar: function ( scalar ) {

				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );

				return this;

			},

			containsPoint: function ( point ) {

				if ( point.x < this.min.x || point.x > this.max.x ||
				     point.y < this.min.y || point.y > this.max.y ) {

					return false;

				}

				return true;

			},

			containsBox: function ( box ) {

				if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
				     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

					return true;

				}

				return false;

			},

			getParameter: function ( point, optionalTarget ) {

				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.

				var result = optionalTarget || new Vector2();

				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y )
				);

			},

			intersectsBox: function ( box ) {

				// using 6 splitting planes to rule out intersections.

				if ( box.max.x < this.min.x || box.min.x > this.max.x ||
				     box.max.y < this.min.y || box.min.y > this.max.y ) {

					return false;

				}

				return true;

			},

			clampPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector2();
				return result.copy( point ).clamp( this.min, this.max );

			},

			distanceToPoint: function () {

				var v1 = new Vector2();

				return function distanceToPoint( point ) {

					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();

				};

			}(),

			intersect: function ( box ) {

				this.min.max( box.min );
				this.max.min( box.max );

				return this;

			},

			union: function ( box ) {

				this.min.min( box.min );
				this.max.max( box.max );

				return this;

			},

			translate: function ( offset ) {

				this.min.add( offset );
				this.max.add( offset );

				return this;

			},

			equals: function ( box ) {

				return box.min.equals( this.min ) && box.max.equals( this.max );

			}

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function LensFlarePlugin( renderer, flares ) {

			var gl = renderer.context;
			var state = renderer.state;

			var vertexBuffer, elementBuffer;
			var shader, program, attributes, uniforms;

			var tempTexture, occlusionTexture;

			function init() {

				var vertices = new Float32Array( [
					- 1, - 1,  0, 0,
					 1, - 1,  1, 0,
					 1,  1,  1, 1,
					- 1,  1,  0, 1
				] );

				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );

				// buffers

				vertexBuffer     = gl.createBuffer();
				elementBuffer    = gl.createBuffer();

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

				// textures

				tempTexture      = gl.createTexture();
				occlusionTexture = gl.createTexture();

				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

				shader = {

					vertexShader: [

						"uniform lowp int renderType;",

						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",

						"uniform sampler2D occlusionMap;",

						"attribute vec2 position;",
						"attribute vec2 uv;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							"vUV = uv;",

							"vec2 pos = position;",

							"if ( renderType == 2 ) {",

								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",

								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

							"}",

							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

						"}"

					].join( "\n" ),

					fragmentShader: [

						"uniform lowp int renderType;",

						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",

						"varying vec2 vUV;",
						"varying float vVisibility;",

						"void main() {",

							// pink square

							"if ( renderType == 0 ) {",

								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

							// restore

							"} else if ( renderType == 1 ) {",

								"gl_FragColor = texture2D( map, vUV );",

							// flare

							"} else {",

								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",

							"}",

						"}"

					].join( "\n" )

				};

				program = createProgram( shader );

				attributes = {
					vertex: gl.getAttribLocation ( program, "position" ),
					uv:     gl.getAttribLocation ( program, "uv" )
				};

				uniforms = {
					renderType:     gl.getUniformLocation( program, "renderType" ),
					map:            gl.getUniformLocation( program, "map" ),
					occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
					opacity:        gl.getUniformLocation( program, "opacity" ),
					color:          gl.getUniformLocation( program, "color" ),
					scale:          gl.getUniformLocation( program, "scale" ),
					rotation:       gl.getUniformLocation( program, "rotation" ),
					screenPosition: gl.getUniformLocation( program, "screenPosition" )
				};

			}

			/*
			 * Render lens flares
			 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
			 *         reads these back and calculates occlusion.
			 */

			this.render = function ( scene, camera, viewport ) {

				if ( flares.length === 0 ) return;

				var tempPosition = new Vector3();

				var invAspect = viewport.w / viewport.z,
					halfViewportWidth = viewport.z * 0.5,
					halfViewportHeight = viewport.w * 0.5;

				var size = 16 / viewport.w,
					scale = new Vector2( size * invAspect, size );

				var screenPosition = new Vector3( 1, 1, 0 ),
					screenPositionPixels = new Vector2( 1, 1 );

				var validArea = new Box2();

				validArea.min.set( viewport.x, viewport.y );
				validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

				if ( program === undefined ) {

					init();

				}

				gl.useProgram( program );

				state.initAttributes();
				state.enableAttribute( attributes.vertex );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();

				// loop through all lens flares to update their occlusion and positions
				// setup gl and common used attribs/uniforms

				gl.uniform1i( uniforms.occlusionMap, 0 );
				gl.uniform1i( uniforms.map, 1 );

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

				state.disable( gl.CULL_FACE );
				state.setDepthWrite( false );

				for ( var i = 0, l = flares.length; i < l; i ++ ) {

					size = 16 / viewport.w;
					scale.set( size * invAspect, size );

					// calc object screen position

					var flare = flares[ i ];

					tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

					tempPosition.applyMatrix4( camera.matrixWorldInverse );
					tempPosition.applyProjection( camera.projectionMatrix );

					// setup arrays for gl programs

					screenPosition.copy( tempPosition );

					// horizontal and vertical coordinate of the lower left corner of the pixels to copy

					screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
					screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

					// screen cull

					if ( validArea.containsPoint( screenPositionPixels ) === true ) {

						// save current RGB to temp texture

						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, null );
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


						// render pink quad

						gl.uniform1i( uniforms.renderType, 0 );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

						state.disable( gl.BLEND );
						state.enable( gl.DEPTH_TEST );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


						// copy result to occlusionMap

						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


						// restore graphics

						gl.uniform1i( uniforms.renderType, 1 );
						state.disable( gl.DEPTH_TEST );

						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


						// update object positions

						flare.positionScreen.copy( screenPosition );

						if ( flare.customUpdateCallback ) {

							flare.customUpdateCallback( flare );

						} else {

							flare.updateLensFlares();

						}

						// render flares

						gl.uniform1i( uniforms.renderType, 2 );
						state.enable( gl.BLEND );

						for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

							var sprite = flare.lensFlares[ j ];

							if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

								screenPosition.x = sprite.x;
								screenPosition.y = sprite.y;
								screenPosition.z = sprite.z;

								size = sprite.size * sprite.scale / viewport.w;

								scale.x = size * invAspect;
								scale.y = size;

								gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
								gl.uniform2f( uniforms.scale, scale.x, scale.y );
								gl.uniform1f( uniforms.rotation, sprite.rotation );

								gl.uniform1f( uniforms.opacity, sprite.opacity );
								gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

								state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
								renderer.setTexture2D( sprite.texture, 1 );

								gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

							}

						}

					}

				}

				// restore gl

				state.enable( gl.CULL_FACE );
				state.enable( gl.DEPTH_TEST );
				state.setDepthWrite( true );

				renderer.resetGLState();

			};

			function createProgram( shader ) {

				var program = gl.createProgram();

				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );

				var prefix = "precision " + renderer.getPrecision() + " float;\n";

				gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
				gl.shaderSource( vertexShader, prefix + shader.vertexShader );

				gl.compileShader( fragmentShader );
				gl.compileShader( vertexShader );

				gl.attachShader( program, fragmentShader );
				gl.attachShader( program, vertexShader );

				gl.linkProgram( program );

				return program;

			}

		}

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function SpritePlugin( renderer, sprites ) {

			var gl = renderer.context;
			var state = renderer.state;

			var vertexBuffer, elementBuffer;
			var program, attributes, uniforms;

			var texture;

			// decompose matrixWorld

			var spritePosition = new Vector3();
			var spriteRotation = new Quaternion();
			var spriteScale = new Vector3();

			function init() {

				var vertices = new Float32Array( [
					- 0.5, - 0.5,  0, 0,
					  0.5, - 0.5,  1, 0,
					  0.5,   0.5,  1, 1,
					- 0.5,   0.5,  0, 1
				] );

				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );

				vertexBuffer  = gl.createBuffer();
				elementBuffer = gl.createBuffer();

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

				program = createProgram();

				attributes = {
					position:			gl.getAttribLocation ( program, 'position' ),
					uv:					gl.getAttribLocation ( program, 'uv' )
				};

				uniforms = {
					uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
					uvScale:			gl.getUniformLocation( program, 'uvScale' ),

					rotation:			gl.getUniformLocation( program, 'rotation' ),
					scale:				gl.getUniformLocation( program, 'scale' ),

					color:				gl.getUniformLocation( program, 'color' ),
					map:				gl.getUniformLocation( program, 'map' ),
					opacity:			gl.getUniformLocation( program, 'opacity' ),

					modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
					projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

					fogType:			gl.getUniformLocation( program, 'fogType' ),
					fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
					fogNear:			gl.getUniformLocation( program, 'fogNear' ),
					fogFar:				gl.getUniformLocation( program, 'fogFar' ),
					fogColor:			gl.getUniformLocation( program, 'fogColor' ),

					alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
				};

				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = 8;
				canvas.height = 8;

				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 0, 8, 8 );

				texture = new Texture( canvas );
				texture.needsUpdate = true;

			}

			this.render = function ( scene, camera ) {

				if ( sprites.length === 0 ) return;

				// setup gl

				if ( program === undefined ) {

					init();

				}

				gl.useProgram( program );

				state.initAttributes();
				state.enableAttribute( attributes.position );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();

				state.disable( gl.CULL_FACE );
				state.enable( gl.BLEND );

				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

				gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

				state.activeTexture( gl.TEXTURE0 );
				gl.uniform1i( uniforms.map, 0 );

				var oldFogType = 0;
				var sceneFogType = 0;
				var fog = scene.fog;

				if ( fog ) {

					gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

					if ( (fog && fog.isFog) ) {

						gl.uniform1f( uniforms.fogNear, fog.near );
						gl.uniform1f( uniforms.fogFar, fog.far );

						gl.uniform1i( uniforms.fogType, 1 );
						oldFogType = 1;
						sceneFogType = 1;

					} else if ( (fog && fog.isFogExp2) ) {

						gl.uniform1f( uniforms.fogDensity, fog.density );

						gl.uniform1i( uniforms.fogType, 2 );
						oldFogType = 2;
						sceneFogType = 2;

					}

				} else {

					gl.uniform1i( uniforms.fogType, 0 );
					oldFogType = 0;
					sceneFogType = 0;

				}


				// update positions and sort

				for ( var i = 0, l = sprites.length; i < l; i ++ ) {

					var sprite = sprites[ i ];

					sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
					sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

				}

				sprites.sort( painterSortStable );

				// render all sprites

				var scale = [];

				for ( var i = 0, l = sprites.length; i < l; i ++ ) {

					var sprite = sprites[ i ];
					var material = sprite.material;

					if ( material.visible === false ) continue;

					gl.uniform1f( uniforms.alphaTest, material.alphaTest );
					gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

					sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

					scale[ 0 ] = spriteScale.x;
					scale[ 1 ] = spriteScale.y;

					var fogType = 0;

					if ( scene.fog && material.fog ) {

						fogType = sceneFogType;

					}

					if ( oldFogType !== fogType ) {

						gl.uniform1i( uniforms.fogType, fogType );
						oldFogType = fogType;

					}

					if ( material.map !== null ) {

						gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
						gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

					} else {

						gl.uniform2f( uniforms.uvOffset, 0, 0 );
						gl.uniform2f( uniforms.uvScale, 1, 1 );

					}

					gl.uniform1f( uniforms.opacity, material.opacity );
					gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

					gl.uniform1f( uniforms.rotation, material.rotation );
					gl.uniform2fv( uniforms.scale, scale );

					state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
					state.setDepthTest( material.depthTest );
					state.setDepthWrite( material.depthWrite );

					if ( material.map ) {

						renderer.setTexture2D( material.map, 0 );

					} else {

						renderer.setTexture2D( texture, 0 );

					}

					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

				}

				// restore gl

				state.enable( gl.CULL_FACE );

				renderer.resetGLState();

			};

			function createProgram() {

				var program = gl.createProgram();

				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

				gl.shaderSource( vertexShader, [

					'precision ' + renderer.getPrecision() + ' float;',

					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform float rotation;',
					'uniform vec2 scale;',
					'uniform vec2 uvOffset;',
					'uniform vec2 uvScale;',

					'attribute vec2 position;',
					'attribute vec2 uv;',

					'varying vec2 vUV;',

					'void main() {',

						'vUV = uvOffset + uv * uvScale;',

						'vec2 alignedPosition = position * scale;',

						'vec2 rotatedPosition;',
						'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
						'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

						'vec4 finalPosition;',

						'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
						'finalPosition.xy += rotatedPosition;',
						'finalPosition = projectionMatrix * finalPosition;',

						'gl_Position = finalPosition;',

					'}'

				].join( '\n' ) );

				gl.shaderSource( fragmentShader, [

					'precision ' + renderer.getPrecision() + ' float;',

					'uniform vec3 color;',
					'uniform sampler2D map;',
					'uniform float opacity;',

					'uniform int fogType;',
					'uniform vec3 fogColor;',
					'uniform float fogDensity;',
					'uniform float fogNear;',
					'uniform float fogFar;',
					'uniform float alphaTest;',

					'varying vec2 vUV;',

					'void main() {',

						'vec4 texture = texture2D( map, vUV );',

						'if ( texture.a < alphaTest ) discard;',

						'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

						'if ( fogType > 0 ) {',

							'float depth = gl_FragCoord.z / gl_FragCoord.w;',
							'float fogFactor = 0.0;',

							'if ( fogType == 1 ) {',

								'fogFactor = smoothstep( fogNear, fogFar, depth );',

							'} else {',

								'const float LOG2 = 1.442695;',
								'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
								'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

							'}',

							'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

						'}',

					'}'

				].join( '\n' ) );

				gl.compileShader( vertexShader );
				gl.compileShader( fragmentShader );

				gl.attachShader( program, vertexShader );
				gl.attachShader( program, fragmentShader );

				gl.linkProgram( program );

				return program;

			}

			function painterSortStable( a, b ) {

				if ( a.renderOrder !== b.renderOrder ) {

					return a.renderOrder - b.renderOrder;

				} else if ( a.z !== b.z ) {

					return b.z - a.z;

				} else {

					return b.id - a.id;

				}

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Material() {

			Object.defineProperty( this, 'id', { value: MaterialIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Material';

			this.fog = true;
			this.lights = true;

			this.blending = NormalBlending;
			this.side = FrontSide;
			this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
			this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

			this.opacity = 1;
			this.transparent = false;

			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;

			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;

			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;

			this.colorWrite = true;

			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;

			this.alphaTest = 0;
			this.premultipliedAlpha = false;

			this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

			this.visible = true;

			this._needsUpdate = true;

		}

		Material.prototype = {

			constructor: Material,

			isMaterial: true,

			get needsUpdate() {

				return this._needsUpdate;

			},

			set needsUpdate( value ) {

				if ( value === true ) this.update();
				this._needsUpdate = value;

			},

			setValues: function ( values ) {

				if ( values === undefined ) return;

				for ( var key in values ) {

					var newValue = values[ key ];

					if ( newValue === undefined ) {

						console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
						continue;

					}

					var currentValue = this[ key ];

					if ( currentValue === undefined ) {

						console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
						continue;

					}

					if ( (currentValue && currentValue.isColor) ) {

						currentValue.set( newValue );

					} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {

						currentValue.copy( newValue );

					} else if ( key === 'overdraw' ) {

						// ensure overdraw is backwards-compatible with legacy boolean type
						this[ key ] = Number( newValue );

					} else {

						this[ key ] = newValue;

					}

				}

			},

			toJSON: function ( meta ) {

				var isRoot = meta === undefined;

				if ( isRoot ) {

					meta = {
						textures: {},
						images: {}
					};

				}

				var data = {
					metadata: {
						version: 4.4,
						type: 'Material',
						generator: 'Material.toJSON'
					}
				};

				// standard Material serialization
				data.uuid = this.uuid;
				data.type = this.type;

				if ( this.name !== '' ) data.name = this.name;

				if ( (this.color && this.color.isColor) ) data.color = this.color.getHex();

				if ( this.roughness !== undefined ) data.roughness = this.roughness;
				if ( this.metalness !== undefined ) data.metalness = this.metalness;

				if ( (this.emissive && this.emissive.isColor) ) data.emissive = this.emissive.getHex();
				if ( (this.specular && this.specular.isColor) ) data.specular = this.specular.getHex();
				if ( this.shininess !== undefined ) data.shininess = this.shininess;

				if ( (this.map && this.map.isTexture) ) data.map = this.map.toJSON( meta ).uuid;
				if ( (this.alphaMap && this.alphaMap.isTexture) ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
				if ( (this.lightMap && this.lightMap.isTexture) ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
				if ( (this.bumpMap && this.bumpMap.isTexture) ) {

					data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
					data.bumpScale = this.bumpScale;

				}
				if ( (this.normalMap && this.normalMap.isTexture) ) {

					data.normalMap = this.normalMap.toJSON( meta ).uuid;
					data.normalScale = this.normalScale.toArray();

				}
				if ( (this.displacementMap && this.displacementMap.isTexture) ) {

					data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
					data.displacementScale = this.displacementScale;
					data.displacementBias = this.displacementBias;

				}
				if ( (this.roughnessMap && this.roughnessMap.isTexture) ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
				if ( (this.metalnessMap && this.metalnessMap.isTexture) ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

				if ( (this.emissiveMap && this.emissiveMap.isTexture) ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
				if ( (this.specularMap && this.specularMap.isTexture) ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

				if ( (this.envMap && this.envMap.isTexture) ) {

					data.envMap = this.envMap.toJSON( meta ).uuid;
					data.reflectivity = this.reflectivity; // Scale behind envMap

				}

				if ( this.size !== undefined ) data.size = this.size;
				if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

				if ( this.blending !== NormalBlending ) data.blending = this.blending;
				if ( this.shading !== SmoothShading ) data.shading = this.shading;
				if ( this.side !== FrontSide ) data.side = this.side;
				if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

				if ( this.opacity < 1 ) data.opacity = this.opacity;
				if ( this.transparent === true ) data.transparent = this.transparent;

				data.depthFunc = this.depthFunc;
				data.depthTest = this.depthTest;
				data.depthWrite = this.depthWrite;

				if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
				if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
				if ( this.wireframe === true ) data.wireframe = this.wireframe;
				if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
				if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
				if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

				data.skinning = this.skinning;
				data.morphTargets = this.morphTargets;

				// TODO: Copied from Object3D.toJSON

				function extractFromCache( cache ) {

					var values = [];

					for ( var key in cache ) {

						var data = cache[ key ];
						delete data.metadata;
						values.push( data );

					}

					return values;

				}

				if ( isRoot ) {

					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );

					if ( textures.length > 0 ) data.textures = textures;
					if ( images.length > 0 ) data.images = images;

				}

				return data;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.name = source.name;

				this.fog = source.fog;
				this.lights = source.lights;

				this.blending = source.blending;
				this.side = source.side;
				this.shading = source.shading;
				this.vertexColors = source.vertexColors;

				this.opacity = source.opacity;
				this.transparent = source.transparent;

				this.blendSrc = source.blendSrc;
				this.blendDst = source.blendDst;
				this.blendEquation = source.blendEquation;
				this.blendSrcAlpha = source.blendSrcAlpha;
				this.blendDstAlpha = source.blendDstAlpha;
				this.blendEquationAlpha = source.blendEquationAlpha;

				this.depthFunc = source.depthFunc;
				this.depthTest = source.depthTest;
				this.depthWrite = source.depthWrite;

				this.colorWrite = source.colorWrite;

				this.precision = source.precision;

				this.polygonOffset = source.polygonOffset;
				this.polygonOffsetFactor = source.polygonOffsetFactor;
				this.polygonOffsetUnits = source.polygonOffsetUnits;

				this.alphaTest = source.alphaTest;

				this.premultipliedAlpha = source.premultipliedAlpha;

				this.overdraw = source.overdraw;

				this.visible = source.visible;
				this.clipShadows = source.clipShadows;
				this.clipIntersection = source.clipIntersection;

				var srcPlanes = source.clippingPlanes,
					dstPlanes = null;

				if ( srcPlanes !== null ) {

					var n = srcPlanes.length;
					dstPlanes = new Array( n );

					for ( var i = 0; i !== n; ++ i )
						dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

				this.clippingPlanes = dstPlanes;

				return this;

			},

			update: function () {

				this.dispatchEvent( { type: 'update' } );

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		};

		Object.assign( Material.prototype, EventDispatcher.prototype );

		var count$1 = 0;
		function MaterialIdCount() { return count$1++; }

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function ShaderMaterial( parameters ) {

			Material.call( this );

			this.type = 'ShaderMaterial';

			this.defines = {};
			this.uniforms = {};

			this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
			this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

			this.linewidth = 1;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes

			this.skinning = false; // set to use skinning attribute streams
			this.morphTargets = false; // set to use morph targets
			this.morphNormals = false; // set to use morph normals

			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};

			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};

			this.index0AttributeName = undefined;

			if ( parameters !== undefined ) {

				if ( parameters.attributes !== undefined ) {

					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

				}

				this.setValues( parameters );

			}

		}

		ShaderMaterial.prototype = Object.create( Material.prototype );
		ShaderMaterial.prototype.constructor = ShaderMaterial;

		ShaderMaterial.prototype.isShaderMaterial = true;

		ShaderMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;

			this.uniforms = UniformsUtils.clone( source.uniforms );

			this.defines = source.defines;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.lights = source.lights;
			this.clipping = source.clipping;

			this.skinning = source.skinning;

			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.extensions = source.extensions;

			return this;

		};

		ShaderMaterial.prototype.toJSON = function ( meta ) {

			var data = Material.prototype.toJSON.call( this, meta );

			data.uniforms = this.uniforms;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;

			return data;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */

		function MeshDepthMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;
			this.lights = false;

			this.setValues( parameters );

		}

		MeshDepthMaterial.prototype = Object.create( Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

		MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

		MeshDepthMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.depthPacking = source.depthPacking;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function Box3( min, max ) {

			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

		}

		Box3.prototype = {

			constructor: Box3,

			isBox3: true,

			set: function ( min, max ) {

				this.min.copy( min );
				this.max.copy( max );

				return this;

			},

			setFromArray: function ( array ) {

				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;

				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var x = array[ i ];
					var y = array[ i + 1 ];
					var z = array[ i + 2 ];

					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;

					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;

				}

				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );

			},

			setFromPoints: function ( points ) {

				this.makeEmpty();

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					this.expandByPoint( points[ i ] );

				}

				return this;

			},

			setFromCenterAndSize: function () {

				var v1 = new Vector3();

				return function setFromCenterAndSize( center, size ) {

					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );

					return this;

				};

			}(),

			setFromObject: function () {

				// Computes the world-axis-aligned bounding box of an object (including its children),
				// accounting for both the object's, and children's, world transforms

				var v1 = new Vector3();

				return function setFromObject( object ) {

					var scope = this;

					object.updateMatrixWorld( true );

					this.makeEmpty();

					object.traverse( function ( node ) {

						var geometry = node.geometry;

						if ( geometry !== undefined ) {

							if ( (geometry && geometry.isGeometry) ) {

								var vertices = geometry.vertices;

								for ( var i = 0, il = vertices.length; i < il; i ++ ) {

									v1.copy( vertices[ i ] );
									v1.applyMatrix4( node.matrixWorld );

									scope.expandByPoint( v1 );

								}

							} else if ( (geometry && geometry.isBufferGeometry) ) {

								var attribute = geometry.attributes.position;

								if ( attribute !== undefined ) {

									var array, offset, stride;

									if ( (attribute && attribute.isInterleavedBufferAttribute) ) {

										array = attribute.data.array;
										offset = attribute.offset;
										stride = attribute.data.stride;

									} else {

										array = attribute.array;
										offset = 0;
										stride = 3;

									}

									for ( var i = offset, il = array.length; i < il; i += stride ) {

										v1.fromArray( array, i );
										v1.applyMatrix4( node.matrixWorld );

										scope.expandByPoint( v1 );

									}

								}

							}

						}

					} );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( box ) {

				this.min.copy( box.min );
				this.max.copy( box.max );

				return this;

			},

			makeEmpty: function () {

				this.min.x = this.min.y = this.min.z = + Infinity;
				this.max.x = this.max.y = this.max.z = - Infinity;

				return this;

			},

			isEmpty: function () {

				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

			},

			getSize: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

			},

			expandByPoint: function ( point ) {

				this.min.min( point );
				this.max.max( point );

				return this;

			},

			expandByVector: function ( vector ) {

				this.min.sub( vector );
				this.max.add( vector );

				return this;

			},

			expandByScalar: function ( scalar ) {

				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );

				return this;

			},

			containsPoint: function ( point ) {

				if ( point.x < this.min.x || point.x > this.max.x ||
						 point.y < this.min.y || point.y > this.max.y ||
						 point.z < this.min.z || point.z > this.max.z ) {

					return false;

				}

				return true;

			},

			containsBox: function ( box ) {

				if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
					 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
					 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

					return true;

				}

				return false;

			},

			getParameter: function ( point, optionalTarget ) {

				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.

				var result = optionalTarget || new Vector3();

				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y ),
					( point.z - this.min.z ) / ( this.max.z - this.min.z )
				);

			},

			intersectsBox: function ( box ) {

				// using 6 splitting planes to rule out intersections.

				if ( box.max.x < this.min.x || box.min.x > this.max.x ||
						 box.max.y < this.min.y || box.min.y > this.max.y ||
						 box.max.z < this.min.z || box.min.z > this.max.z ) {

					return false;

				}

				return true;

			},

			intersectsSphere: ( function () {

				var closestPoint;

				return function intersectsSphere( sphere ) {

					if ( closestPoint === undefined ) closestPoint = new Vector3();

					// Find the point on the AABB closest to the sphere center.
					this.clampPoint( sphere.center, closestPoint );

					// If that point is inside the sphere, the AABB and sphere intersect.
					return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

				};

			} )(),

			intersectsPlane: function ( plane ) {

				// We compute the minimum and maximum dot product values. If those values
				// are on the same side (back or front) of the plane, then there is no intersection.

				var min, max;

				if ( plane.normal.x > 0 ) {

					min = plane.normal.x * this.min.x;
					max = plane.normal.x * this.max.x;

				} else {

					min = plane.normal.x * this.max.x;
					max = plane.normal.x * this.min.x;

				}

				if ( plane.normal.y > 0 ) {

					min += plane.normal.y * this.min.y;
					max += plane.normal.y * this.max.y;

				} else {

					min += plane.normal.y * this.max.y;
					max += plane.normal.y * this.min.y;

				}

				if ( plane.normal.z > 0 ) {

					min += plane.normal.z * this.min.z;
					max += plane.normal.z * this.max.z;

				} else {

					min += plane.normal.z * this.max.z;
					max += plane.normal.z * this.min.z;

				}

				return ( min <= plane.constant && max >= plane.constant );

			},

			clampPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.copy( point ).clamp( this.min, this.max );

			},

			distanceToPoint: function () {

				var v1 = new Vector3();

				return function distanceToPoint( point ) {

					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();

				};

			}(),

			getBoundingSphere: function () {

				var v1 = new Vector3();

				return function getBoundingSphere( optionalTarget ) {

					var result = optionalTarget || new Sphere();

					this.getCenter( result.center );

					result.radius = this.getSize( v1 ).length() * 0.5;

					return result;

				};

			}(),

			intersect: function ( box ) {

				this.min.max( box.min );
				this.max.min( box.max );

				// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
				if( this.isEmpty() ) this.makeEmpty();

				return this;

			},

			union: function ( box ) {

				this.min.min( box.min );
				this.max.max( box.max );

				return this;

			},

			applyMatrix4: function () {

				var points = [
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3()
				];

				return function applyMatrix4( matrix ) {

					// transform of empty box is an empty box.
					if( this.isEmpty() ) return this;

					// NOTE: I am using a binary pattern to specify all 2^3 combinations below
					points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
					points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
					points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
					points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
					points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
					points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
					points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
					points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

					this.setFromPoints( points );

					return this;

				};

			}(),

			translate: function ( offset ) {

				this.min.add( offset );
				this.max.add( offset );

				return this;

			},

			equals: function ( box ) {

				return box.min.equals( this.min ) && box.max.equals( this.max );

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Sphere( center, radius ) {

			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : 0;

		}

		Sphere.prototype = {

			constructor: Sphere,

			set: function ( center, radius ) {

				this.center.copy( center );
				this.radius = radius;

				return this;

			},

			setFromPoints: function () {

				var box = new Box3();

				return function setFromPoints( points, optionalCenter ) {

					var center = this.center;

					if ( optionalCenter !== undefined ) {

						center.copy( optionalCenter );

					} else {

						box.setFromPoints( points ).getCenter( center );

					}

					var maxRadiusSq = 0;

					for ( var i = 0, il = points.length; i < il; i ++ ) {

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

					}

					this.radius = Math.sqrt( maxRadiusSq );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( sphere ) {

				this.center.copy( sphere.center );
				this.radius = sphere.radius;

				return this;

			},

			empty: function () {

				return ( this.radius <= 0 );

			},

			containsPoint: function ( point ) {

				return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

			},

			distanceToPoint: function ( point ) {

				return ( point.distanceTo( this.center ) - this.radius );

			},

			intersectsSphere: function ( sphere ) {

				var radiusSum = this.radius + sphere.radius;

				return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

			},

			intersectsBox: function ( box ) {

				return box.intersectsSphere( this );

			},

			intersectsPlane: function ( plane ) {

				// We use the following equation to compute the signed distance from
				// the center of the sphere to the plane.
				//
				// distance = q * n - d
				//
				// If this distance is greater than the radius of the sphere,
				// then there is no intersection.

				return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

			},

			clampPoint: function ( point, optionalTarget ) {

				var deltaLengthSq = this.center.distanceToSquared( point );

				var result = optionalTarget || new Vector3();

				result.copy( point );

				if ( deltaLengthSq > ( this.radius * this.radius ) ) {

					result.sub( this.center ).normalize();
					result.multiplyScalar( this.radius ).add( this.center );

				}

				return result;

			},

			getBoundingBox: function ( optionalTarget ) {

				var box = optionalTarget || new Box3();

				box.set( this.center, this.center );
				box.expandByScalar( this.radius );

				return box;

			},

			applyMatrix4: function ( matrix ) {

				this.center.applyMatrix4( matrix );
				this.radius = this.radius * matrix.getMaxScaleOnAxis();

				return this;

			},

			translate: function ( offset ) {

				this.center.add( offset );

				return this;

			},

			equals: function ( sphere ) {

				return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */

		function Matrix3() {

			this.elements = new Float32Array( [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			] );

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		Matrix3.prototype = {

			constructor: Matrix3,

			isMatrix3: true,

			set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

				var te = this.elements;

				te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
				te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
				te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

				return this;

			},

			identity: function () {

				this.set(

					1, 0, 0,
					0, 1, 0,
					0, 0, 1

				);

				return this;

			},

			clone: function () {

				return new this.constructor().fromArray( this.elements );

			},

			copy: function ( m ) {

				var me = m.elements;

				this.set(

					me[ 0 ], me[ 3 ], me[ 6 ],
					me[ 1 ], me[ 4 ], me[ 7 ],
					me[ 2 ], me[ 5 ], me[ 8 ]

				);

				return this;

			},

			setFromMatrix4: function( m ) {

				var me = m.elements;

				this.set(

					me[ 0 ], me[ 4 ], me[  8 ],
					me[ 1 ], me[ 5 ], me[  9 ],
					me[ 2 ], me[ 6 ], me[ 10 ]

				);

				return this;

			},

			applyToVector3Array: function () {

				var v1;

				return function applyToVector3Array( array, offset, length ) {

					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = array.length;

					for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

						v1.fromArray( array, j );
						v1.applyMatrix3( this );
						v1.toArray( array, j );

					}

					return array;

				};

			}(),

			applyToBuffer: function () {

				var v1;

				return function applyToBuffer( buffer, offset, length ) {

					if ( v1 === undefined ) v1 = new Vector3();
					if ( offset === undefined ) offset = 0;
					if ( length === undefined ) length = buffer.length / buffer.itemSize;

					for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

						v1.x = buffer.getX( j );
						v1.y = buffer.getY( j );
						v1.z = buffer.getZ( j );

						v1.applyMatrix3( this );

						buffer.setXYZ( j, v1.x, v1.y, v1.z );

					}

					return buffer;

				};

			}(),

			multiplyScalar: function ( s ) {

				var te = this.elements;

				te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
				te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
				te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

				return this;

			},

			determinant: function () {

				var te = this.elements;

				var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
					d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
					g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

			},

			getInverse: function ( matrix, throwOnDegenerate ) {

				if ( (matrix && matrix.isMatrix4) ) {

					console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

				}

				var me = matrix.elements,
					te = this.elements,

					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
					n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
					n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,

					det = n11 * t11 + n21 * t12 + n31 * t13;

				if ( det === 0 ) {

					var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

					if ( throwOnDegenerate === true ) {

						throw new Error( msg );

					} else {

						console.warn( msg );

					}

					return this.identity();
				}

				var detInv = 1 / det;

				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
				te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

				te[ 3 ] = t12 * detInv;
				te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
				te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

				te[ 6 ] = t13 * detInv;
				te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
				te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

				return this;

			},

			transpose: function () {

				var tmp, m = this.elements;

				tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
				tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
				tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

				return this;

			},

			flattenToArrayOffset: function ( array, offset ) {

				console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
						"- just use .toArray instead." );

				return this.toArray( array, offset );

			},

			getNormalMatrix: function ( matrix4 ) {

				return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

			},

			transposeIntoArray: function ( r ) {

				var m = this.elements;

				r[ 0 ] = m[ 0 ];
				r[ 1 ] = m[ 3 ];
				r[ 2 ] = m[ 6 ];
				r[ 3 ] = m[ 1 ];
				r[ 4 ] = m[ 4 ];
				r[ 5 ] = m[ 7 ];
				r[ 6 ] = m[ 2 ];
				r[ 7 ] = m[ 5 ];
				r[ 8 ] = m[ 8 ];

				return this;

			},

			fromArray: function ( array, offset ) {

				if ( offset === undefined ) offset = 0;

				for( var i = 0; i < 9; i ++ ) {

					this.elements[ i ] = array[ i + offset ];

				}

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				var te = this.elements;

				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];

				array[ offset + 3 ] = te[ 3 ];
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];

				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
				array[ offset + 8 ]  = te[ 8 ];

				return array;

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 */

		function Plane( normal, constant ) {

			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;

		}

		Plane.prototype = {

			constructor: Plane,

			set: function ( normal, constant ) {

				this.normal.copy( normal );
				this.constant = constant;

				return this;

			},

			setComponents: function ( x, y, z, w ) {

				this.normal.set( x, y, z );
				this.constant = w;

				return this;

			},

			setFromNormalAndCoplanarPoint: function ( normal, point ) {

				this.normal.copy( normal );
				this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

				return this;

			},

			setFromCoplanarPoints: function () {

				var v1 = new Vector3();
				var v2 = new Vector3();

				return function setFromCoplanarPoints( a, b, c ) {

					var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

					// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

					this.setFromNormalAndCoplanarPoint( normal, a );

					return this;

				};

			}(),

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( plane ) {

				this.normal.copy( plane.normal );
				this.constant = plane.constant;

				return this;

			},

			normalize: function () {

				// Note: will lead to a divide by zero if the plane is invalid.

				var inverseNormalLength = 1.0 / this.normal.length();
				this.normal.multiplyScalar( inverseNormalLength );
				this.constant *= inverseNormalLength;

				return this;

			},

			negate: function () {

				this.constant *= - 1;
				this.normal.negate();

				return this;

			},

			distanceToPoint: function ( point ) {

				return this.normal.dot( point ) + this.constant;

			},

			distanceToSphere: function ( sphere ) {

				return this.distanceToPoint( sphere.center ) - sphere.radius;

			},

			projectPoint: function ( point, optionalTarget ) {

				return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

			},

			orthoPoint: function ( point, optionalTarget ) {

				var perpendicularMagnitude = this.distanceToPoint( point );

				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

			},

			intersectLine: function () {

				var v1 = new Vector3();

				return function intersectLine( line, optionalTarget ) {

					var result = optionalTarget || new Vector3();

					var direction = line.delta( v1 );

					var denominator = this.normal.dot( direction );

					if ( denominator === 0 ) {

						// line is coplanar, return origin
						if ( this.distanceToPoint( line.start ) === 0 ) {

							return result.copy( line.start );

						}

						// Unsure if this is the correct method to handle this case.
						return undefined;

					}

					var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

					if ( t < 0 || t > 1 ) {

						return undefined;

					}

					return result.copy( direction ).multiplyScalar( t ).add( line.start );

				};

			}(),

			intersectsLine: function ( line ) {

				// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

				var startSign = this.distanceToPoint( line.start );
				var endSign = this.distanceToPoint( line.end );

				return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

			},

			intersectsBox: function ( box ) {

				return box.intersectsPlane( this );

			},

			intersectsSphere: function ( sphere ) {

				return sphere.intersectsPlane( this );

			},

			coplanarPoint: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( - this.constant );

			},

			applyMatrix4: function () {

				var v1 = new Vector3();
				var m1 = new Matrix3();

				return function applyMatrix4( matrix, optionalNormalMatrix ) {

					var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

					// transform normal based on theory here:
					// http://www.songho.ca/opengl/gl_normaltransform.html
					var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
					var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

					// recalculate constant (like in setFromNormalAndCoplanarPoint)
					this.constant = - referencePoint.dot( normal );

					return this;

				};

			}(),

			translate: function ( offset ) {

				this.constant = this.constant - offset.dot( this.normal );

				return this;

			},

			equals: function ( plane ) {

				return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */

		function Frustum( p0, p1, p2, p3, p4, p5 ) {

			this.planes = [

				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()

			];

		}

		Frustum.prototype = {

			constructor: Frustum,

			set: function ( p0, p1, p2, p3, p4, p5 ) {

				var planes = this.planes;

				planes[ 0 ].copy( p0 );
				planes[ 1 ].copy( p1 );
				planes[ 2 ].copy( p2 );
				planes[ 3 ].copy( p3 );
				planes[ 4 ].copy( p4 );
				planes[ 5 ].copy( p5 );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( frustum ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					planes[ i ].copy( frustum.planes[ i ] );

				}

				return this;

			},

			setFromMatrix: function ( m ) {

				var planes = this.planes;
				var me = m.elements;
				var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
				var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
				var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
				var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

				planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
				planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
				planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
				planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

				return this;

			},

			intersectsObject: function () {

				var sphere = new Sphere();

				return function intersectsObject( object ) {

					var geometry = object.geometry;

					if ( geometry.boundingSphere === null )
						geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere )
						.applyMatrix4( object.matrixWorld );

					return this.intersectsSphere( sphere );

				};

			}(),

			intersectsSprite: function () {

				var sphere = new Sphere();

				return function intersectsSprite( sprite ) {

					sphere.center.set( 0, 0, 0 );
					sphere.radius = 0.7071067811865476;
					sphere.applyMatrix4( sprite.matrixWorld );

					return this.intersectsSphere( sphere );

				};

			}(),

			intersectsSphere: function ( sphere ) {

				var planes = this.planes;
				var center = sphere.center;
				var negRadius = - sphere.radius;

				for ( var i = 0; i < 6; i ++ ) {

					var distance = planes[ i ].distanceToPoint( center );

					if ( distance < negRadius ) {

						return false;

					}

				}

				return true;

			},

			intersectsBox: function () {

				var p1 = new Vector3(),
					p2 = new Vector3();

				return function intersectsBox( box ) {

					var planes = this.planes;

					for ( var i = 0; i < 6 ; i ++ ) {

						var plane = planes[ i ];

						p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
						p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
						p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
						p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
						p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
						p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

						var d1 = plane.distanceToPoint( p1 );
						var d2 = plane.distanceToPoint( p2 );

						// if both outside plane, no intersection

						if ( d1 < 0 && d2 < 0 ) {

							return false;

						}

					}

					return true;

				};

			}(),


			containsPoint: function ( point ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					if ( planes[ i ].distanceToPoint( point ) < 0 ) {

						return false;

					}

				}

				return true;

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

			var _gl = _renderer.context,
			_state = _renderer.state,
			_frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_lightShadows = _lights.shadows,

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_renderList = [],

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

			var cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			var cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

			var cube2DViewPorts = [
				new Vector4(), new Vector4(), new Vector4(),
				new Vector4(), new Vector4(), new Vector4()
			];

			// init

			var depthMaterialTemplate = new MeshDepthMaterial();
			depthMaterialTemplate.depthPacking = RGBADepthPacking;
			depthMaterialTemplate.clipping = true;

			var distanceShader = ShaderLib[ "distanceRGBA" ];
			var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );

			for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

				var useMorphing = ( i & _MorphingFlag ) !== 0;
				var useSkinning = ( i & _SkinningFlag ) !== 0;

				var depthMaterial = depthMaterialTemplate.clone();
				depthMaterial.morphTargets = useMorphing;
				depthMaterial.skinning = useSkinning;

				_depthMaterials[ i ] = depthMaterial;

				var distanceMaterial = new ShaderMaterial( {
					defines: {
						'USE_SHADOWMAP': ''
					},
					uniforms: distanceUniforms,
					vertexShader: distanceShader.vertexShader,
					fragmentShader: distanceShader.fragmentShader,
					morphTargets: useMorphing,
					skinning: useSkinning,
					clipping: true
				} );

				_distanceMaterials[ i ] = distanceMaterial;

			}

			//

			var scope = this;

			this.enabled = false;

			this.autoUpdate = true;
			this.needsUpdate = false;

			this.type = PCFShadowMap;

			this.renderReverseSided = true;
			this.renderSingleSided = true;

			this.render = function ( scene, camera ) {

				if ( scope.enabled === false ) return;
				if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

				if ( _lightShadows.length === 0 ) return;

				// Set GL state for depth map.
				_state.clearColor( 1, 1, 1, 1 );
				_state.disable( _gl.BLEND );
				_state.setDepthTest( true );
				_state.setScissorTest( false );

				// render depth map

				var faceCount, isPointLight;

				for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

					var light = _lightShadows[ i ];
					var shadow = light.shadow;

					if ( shadow === undefined ) {

						console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
						continue;

					}

					var shadowCamera = shadow.camera;

					_shadowMapSize.copy( shadow.mapSize );
					_shadowMapSize.min( _maxShadowMapSize );

					if ( (light && light.isPointLight) ) {

						faceCount = 6;
						isPointLight = true;

						var vpWidth = _shadowMapSize.x;
						var vpHeight = _shadowMapSize.y;

						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction

						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

						_shadowMapSize.x *= 4.0;
						_shadowMapSize.y *= 2.0;

					} else {

						faceCount = 1;
						isPointLight = false;

					}

					if ( shadow.map === null ) {

						var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

						shadowCamera.updateProjectionMatrix();

					}

					if ( (shadow && shadow.isSpotLightShadow) ) {

						shadow.update( light );

					}

					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;

					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );

					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();

					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not

					for ( var face = 0; face < faceCount; face ++ ) {

						if ( isPointLight ) {

							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );

							var vpDimensions = cube2DViewPorts[ face ];
							_state.viewport( vpDimensions );

						} else {

							_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
							shadowCamera.lookAt( _lookTarget );

						}

						shadowCamera.updateMatrixWorld();
						shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

						// compute shadow matrix

						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);

						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

						// update camera matrices and frustum

						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );

						// set object matrices & frustum culling

						_renderList.length = 0;

						projectObject( scene, camera, shadowCamera );

						// render shadow map
						// render regular objects

						for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

							var object = _renderList[ j ];
							var geometry = _objects.update( object );
							var material = object.material;

							if ( (material && material.isMultiMaterial) ) {

								var groups = geometry.groups;
								var materials = material.materials;

								for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

									var group = groups[ k ];
									var groupMaterial = materials[ group.materialIndex ];

									if ( groupMaterial.visible === true ) {

										var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
										_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

									}

								}

							} else {

								var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

							}

						}

					}

				}

				// Restore GL state.
				var clearColor = _renderer.getClearColor(),
				clearAlpha = _renderer.getClearAlpha();
				_renderer.setClearColor( clearColor, clearAlpha );

				scope.needsUpdate = false;

			};

			function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

				var geometry = object.geometry;

				var result = null;

				var materialVariants = _depthMaterials;
				var customMaterial = object.customDepthMaterial;

				if ( isPointLight ) {

					materialVariants = _distanceMaterials;
					customMaterial = object.customDistanceMaterial;

				}

				if ( ! customMaterial ) {

					var useMorphing = false;

					if ( material.morphTargets ) {

						if ( (geometry && geometry.isBufferGeometry) ) {

							useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

						} else if ( (geometry && geometry.isGeometry) ) {

							useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

						}

					}

					var useSkinning = object.isSkinnedMesh && material.skinning;

					var variantIndex = 0;

					if ( useMorphing ) variantIndex |= _MorphingFlag;
					if ( useSkinning ) variantIndex |= _SkinningFlag;

					result = materialVariants[ variantIndex ];

				} else {

					result = customMaterial;

				}

				if ( _renderer.localClippingEnabled &&
					 material.clipShadows === true &&
						material.clippingPlanes.length !== 0 ) {

					// in this case we need a unique material instance reflecting the
					// appropriate state

					var keyA = result.uuid, keyB = material.uuid;

					var materialsForVariant = _materialCache[ keyA ];

					if ( materialsForVariant === undefined ) {

						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;

					}

					var cachedMaterial = materialsForVariant[ keyB ];

					if ( cachedMaterial === undefined ) {

						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;

					}

					result = cachedMaterial;

				}

				result.visible = material.visible;
				result.wireframe = material.wireframe;

				var side = material.side;

				if ( scope.renderSingleSided && side == DoubleSide ) {

					side = FrontSide;

				}

				if ( scope.renderReverseSided ) {

					if ( side === FrontSide ) side = BackSide;
					else if ( side === BackSide ) side = FrontSide;

				}

				result.side = side;

				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;

				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;

				if ( isPointLight && result.uniforms.lightPos !== undefined ) {

					result.uniforms.lightPos.value.copy( lightPositionWorld );

				}

				return result;

			}

			function projectObject( object, camera, shadowCamera ) {

				if ( object.visible === false ) return;

				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

				if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

					if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

						var material = object.material;

						if ( material.visible === true ) {

							object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
							_renderList.push( object );

						}

					}

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera, shadowCamera );

				}

			}

		}

		/**
		 * @author bhouston / http://clara.io
		 */

		function Ray( origin, direction ) {

			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3();

		}

		Ray.prototype = {

			constructor: Ray,

			set: function ( origin, direction ) {

				this.origin.copy( origin );
				this.direction.copy( direction );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( ray ) {

				this.origin.copy( ray.origin );
				this.direction.copy( ray.direction );

				return this;

			},

			at: function ( t, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

			},

			lookAt: function ( v ) {

				this.direction.copy( v ).sub( this.origin ).normalize();

				return this;

			},

			recast: function () {

				var v1 = new Vector3();

				return function recast( t ) {

					this.origin.copy( this.at( t, v1 ) );

					return this;

				};

			}(),

			closestPointToPoint: function ( point, optionalTarget ) {

				var result = optionalTarget || new Vector3();
				result.subVectors( point, this.origin );
				var directionDistance = result.dot( this.direction );

				if ( directionDistance < 0 ) {

					return result.copy( this.origin );

				}

				return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			},

			distanceToPoint: function ( point ) {

				return Math.sqrt( this.distanceSqToPoint( point ) );

			},

			distanceSqToPoint: function () {

				var v1 = new Vector3();

				return function distanceSqToPoint( point ) {

					var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

					// point behind the ray

					if ( directionDistance < 0 ) {

						return this.origin.distanceToSquared( point );

					}

					v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

					return v1.distanceToSquared( point );

				};

			}(),

			distanceSqToSegment: function () {

				var segCenter = new Vector3();
				var segDir = new Vector3();
				var diff = new Vector3();

				return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
					// It returns the min distance between the ray and the segment
					// defined by v0 and v1
					// It can also set two optional targets :
					// - The closest point on the ray
					// - The closest point on the segment

					segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
					segDir.copy( v1 ).sub( v0 ).normalize();
					diff.copy( this.origin ).sub( segCenter );

					var segExtent = v0.distanceTo( v1 ) * 0.5;
					var a01 = - this.direction.dot( segDir );
					var b0 = diff.dot( this.direction );
					var b1 = - diff.dot( segDir );
					var c = diff.lengthSq();
					var det = Math.abs( 1 - a01 * a01 );
					var s0, s1, sqrDist, extDet;

					if ( det > 0 ) {

						// The ray and segment are not parallel.

						s0 = a01 * b1 - b0;
						s1 = a01 * b0 - b1;
						extDet = segExtent * det;

						if ( s0 >= 0 ) {

							if ( s1 >= - extDet ) {

								if ( s1 <= extDet ) {

									// region 0
									// Minimum at interior points of ray and segment.

									var invDet = 1 / det;
									s0 *= invDet;
									s1 *= invDet;
									sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

								} else {

									// region 1

									s1 = segExtent;
									s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
									sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

								}

							} else {

								// region 5

								s1 = - segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							if ( s1 <= - extDet ) {

								// region 4

								s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							} else if ( s1 <= extDet ) {

								// region 3

								s0 = 0;
								s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = s1 * ( s1 + 2 * b1 ) + c;

							} else {

								// region 2

								s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						}

					} else {

						// Ray and segment are parallel.

						s1 = ( a01 > 0 ) ? - segExtent : segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

					if ( optionalPointOnRay ) {

						optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

					}

					if ( optionalPointOnSegment ) {

						optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

					}

					return sqrDist;

				};

			}(),

			intersectSphere: function () {

				var v1 = new Vector3();

				return function intersectSphere( sphere, optionalTarget ) {

					v1.subVectors( sphere.center, this.origin );
					var tca = v1.dot( this.direction );
					var d2 = v1.dot( v1 ) - tca * tca;
					var radius2 = sphere.radius * sphere.radius;

					if ( d2 > radius2 ) return null;

					var thc = Math.sqrt( radius2 - d2 );

					// t0 = first intersect point - entrance on front of sphere
					var t0 = tca - thc;

					// t1 = second intersect point - exit point on back of sphere
					var t1 = tca + thc;

					// test to see if both t0 and t1 are behind the ray - if so, return null
					if ( t0 < 0 && t1 < 0 ) return null;

					// test to see if t0 is behind the ray:
					// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
					// in order to always return an intersect point that is in front of the ray.
					if ( t0 < 0 ) return this.at( t1, optionalTarget );

					// else t0 is in front of the ray, so return the first collision point scaled by t0
					return this.at( t0, optionalTarget );

				};

			}(),

			intersectsSphere: function ( sphere ) {

				return this.distanceToPoint( sphere.center ) <= sphere.radius;

			},

			distanceToPlane: function ( plane ) {

				var denominator = plane.normal.dot( this.direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( plane.distanceToPoint( this.origin ) === 0 ) {

						return 0;

					}

					// Null is preferable to undefined since undefined means.... it is undefined

					return null;

				}

				var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

				// Return if the ray never intersects the plane

				return t >= 0 ? t :  null;

			},

			intersectPlane: function ( plane, optionalTarget ) {

				var t = this.distanceToPlane( plane );

				if ( t === null ) {

					return null;

				}

				return this.at( t, optionalTarget );

			},



			intersectsPlane: function ( plane ) {

				// check if the ray lies on the plane first

				var distToPoint = plane.distanceToPoint( this.origin );

				if ( distToPoint === 0 ) {

					return true;

				}

				var denominator = plane.normal.dot( this.direction );

				if ( denominator * distToPoint < 0 ) {

					return true;

				}

				// ray origin is behind the plane (and is pointing behind it)

				return false;

			},

			intersectBox: function ( box, optionalTarget ) {

				var tmin, tmax, tymin, tymax, tzmin, tzmax;

				var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;

				var origin = this.origin;

				if ( invdirx >= 0 ) {

					tmin = ( box.min.x - origin.x ) * invdirx;
					tmax = ( box.max.x - origin.x ) * invdirx;

				} else {

					tmin = ( box.max.x - origin.x ) * invdirx;
					tmax = ( box.min.x - origin.x ) * invdirx;

				}

				if ( invdiry >= 0 ) {

					tymin = ( box.min.y - origin.y ) * invdiry;
					tymax = ( box.max.y - origin.y ) * invdiry;

				} else {

					tymin = ( box.max.y - origin.y ) * invdiry;
					tymax = ( box.min.y - origin.y ) * invdiry;

				}

				if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

				// These lines also handle the case where tmin or tmax is NaN
				// (result of 0 * Infinity). x !== x returns true if x is NaN

				if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

				if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

				if ( invdirz >= 0 ) {

					tzmin = ( box.min.z - origin.z ) * invdirz;
					tzmax = ( box.max.z - origin.z ) * invdirz;

				} else {

					tzmin = ( box.max.z - origin.z ) * invdirz;
					tzmax = ( box.min.z - origin.z ) * invdirz;

				}

				if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

				if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

				if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

				//return point closest to the ray (positive side)

				if ( tmax < 0 ) return null;

				return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

			},

			intersectsBox: ( function () {

				var v = new Vector3();

				return function intersectsBox( box ) {

					return this.intersectBox( box, v ) !== null;

				};

			} )(),

			intersectTriangle: function () {

				// Compute the offset origin, edges, and normal.
				var diff = new Vector3();
				var edge1 = new Vector3();
				var edge2 = new Vector3();
				var normal = new Vector3();

				return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

					edge1.subVectors( b, a );
					edge2.subVectors( c, a );
					normal.crossVectors( edge1, edge2 );

					// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
					// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
					//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
					//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
					//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
					var DdN = this.direction.dot( normal );
					var sign;

					if ( DdN > 0 ) {

						if ( backfaceCulling ) return null;
						sign = 1;

					} else if ( DdN < 0 ) {

						sign = - 1;
						DdN = - DdN;

					} else {

						return null;

					}

					diff.subVectors( this.origin, a );
					var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

					// b1 < 0, no intersection
					if ( DdQxE2 < 0 ) {

						return null;

					}

					var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

					// b2 < 0, no intersection
					if ( DdE1xQ < 0 ) {

						return null;

					}

					// b1+b2 > 1, no intersection
					if ( DdQxE2 + DdE1xQ > DdN ) {

						return null;

					}

					// Line intersects triangle, check if ray does.
					var QdN = - sign * diff.dot( normal );

					// t < 0, no intersection
					if ( QdN < 0 ) {

						return null;

					}

					// Ray intersects triangle.
					return this.at( QdN / DdN, optionalTarget );

				};

			}(),

			applyMatrix4: function ( matrix4 ) {

				this.direction.add( this.origin ).applyMatrix4( matrix4 );
				this.origin.applyMatrix4( matrix4 );
				this.direction.sub( this.origin );
				this.direction.normalize();

				return this;

			},

			equals: function ( ray ) {

				return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */

		function Euler( x, y, z, order ) {

			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;

		}

		Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

		Euler.DefaultOrder = 'XYZ';

		Euler.prototype = {

			constructor: Euler,

			isEuler: true,

			get x () {

				return this._x;

			},

			set x ( value ) {

				this._x = value;
				this.onChangeCallback();

			},

			get y () {

				return this._y;

			},

			set y ( value ) {

				this._y = value;
				this.onChangeCallback();

			},

			get z () {

				return this._z;

			},

			set z ( value ) {

				this._z = value;
				this.onChangeCallback();

			},

			get order () {

				return this._order;

			},

			set order ( value ) {

				this._order = value;
				this.onChangeCallback();

			},

			set: function ( x, y, z, order ) {

				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;

				this.onChangeCallback();

				return this;

			},

			clone: function () {

				return new this.constructor( this._x, this._y, this._z, this._order );

			},

			copy: function ( euler ) {

				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;

				this.onChangeCallback();

				return this;

			},

			setFromRotationMatrix: function ( m, order, update ) {

				var clamp = _Math.clamp;

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				var te = m.elements;
				var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
				var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
				var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

				order = order || this._order;

				if ( order === 'XYZ' ) {

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.99999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

				} else if ( order === 'YXZ' ) {

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.99999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

				} else if ( order === 'ZXY' ) {

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.99999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

				} else if ( order === 'ZYX' ) {

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.99999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

				} else if ( order === 'YZX' ) {

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.99999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

				} else if ( order === 'XZY' ) {

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.99999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

				} else {

					console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

				}

				this._order = order;

				if ( update !== false ) this.onChangeCallback();

				return this;

			},

			setFromQuaternion: function () {

				var matrix;

				return function setFromQuaternion( q, order, update ) {

					if ( matrix === undefined ) matrix = new Matrix4();

					matrix.makeRotationFromQuaternion( q );

					return this.setFromRotationMatrix( matrix, order, update );

				};

			}(),

			setFromVector3: function ( v, order ) {

				return this.set( v.x, v.y, v.z, order || this._order );

			},

			reorder: function () {

				// WARNING: this discards revolution information -bhouston

				var q = new Quaternion();

				return function reorder( newOrder ) {

					q.setFromEuler( this );

					return this.setFromQuaternion( q, newOrder );

				};

			}(),

			equals: function ( euler ) {

				return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

			},

			fromArray: function ( array ) {

				this._x = array[ 0 ];
				this._y = array[ 1 ];
				this._z = array[ 2 ];
				if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

				this.onChangeCallback();

				return this;

			},

			toArray: function ( array, offset ) {

				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;

				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._order;

				return array;

			},

			toVector3: function ( optionalResult ) {

				if ( optionalResult ) {

					return optionalResult.set( this._x, this._y, this._z );

				} else {

					return new Vector3( this._x, this._y, this._z );

				}

			},

			onChange: function ( callback ) {

				this.onChangeCallback = callback;

				return this;

			},

			onChangeCallback: function () {}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Layers() {

			this.mask = 1;

		}

		Layers.prototype = {

			constructor: Layers,

			set: function ( channel ) {

				this.mask = 1 << channel;

			},

			enable: function ( channel ) {

				this.mask |= 1 << channel;

			},

			toggle: function ( channel ) {

				this.mask ^= 1 << channel;

			},

			disable: function ( channel ) {

				this.mask &= ~ ( 1 << channel );

			},

			test: function ( layers ) {

				return ( this.mask & layers.mask ) !== 0;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */

		function Object3D() {

			Object.defineProperty( this, 'id', { value: Object3DIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Object3D';

			this.parent = null;
			this.children = [];

			this.up = Object3D.DefaultUp.clone();

			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3( 1, 1, 1 );

			function onRotationChange() {

				quaternion.setFromEuler( rotation, false );

			}

			function onQuaternionChange() {

				rotation.setFromQuaternion( quaternion, undefined, false );

			}

			rotation.onChange( onRotationChange );
			quaternion.onChange( onQuaternionChange );

			Object.defineProperties( this, {
				position: {
					enumerable: true,
					value: position
				},
				rotation: {
					enumerable: true,
					value: rotation
				},
				quaternion: {
					enumerable: true,
					value: quaternion
				},
				scale: {
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );

			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();

			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;

			this.layers = new Layers();
			this.visible = true;

			this.castShadow = false;
			this.receiveShadow = false;

			this.frustumCulled = true;
			this.renderOrder = 0;

			this.userData = {};

			this.onBeforeRender = function(){}; 
			this.onAfterRender = function(){};

		}

		Object3D.DefaultUp = new Vector3( 0, 1, 0 );
		Object3D.DefaultMatrixAutoUpdate = true;

		Object.assign( Object3D.prototype, EventDispatcher.prototype, {

			isObject3D: true,

			applyMatrix: function ( matrix ) {

				this.matrix.multiplyMatrices( matrix, this.matrix );

				this.matrix.decompose( this.position, this.quaternion, this.scale );

			},

			setRotationFromAxisAngle: function ( axis, angle ) {

				// assumes axis is normalized

				this.quaternion.setFromAxisAngle( axis, angle );

			},

			setRotationFromEuler: function ( euler ) {

				this.quaternion.setFromEuler( euler, true );

			},

			setRotationFromMatrix: function ( m ) {

				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

				this.quaternion.setFromRotationMatrix( m );

			},

			setRotationFromQuaternion: function ( q ) {

				// assumes q is normalized

				this.quaternion.copy( q );

			},

			rotateOnAxis: function () {

				// rotate object on axis in object space
				// axis is assumed to be normalized

				var q1 = new Quaternion();

				return function rotateOnAxis( axis, angle ) {

					q1.setFromAxisAngle( axis, angle );

					this.quaternion.multiply( q1 );

					return this;

				};

			}(),

			rotateX: function () {

				var v1 = new Vector3( 1, 0, 0 );

				return function rotateX( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			rotateY: function () {

				var v1 = new Vector3( 0, 1, 0 );

				return function rotateY( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			rotateZ: function () {

				var v1 = new Vector3( 0, 0, 1 );

				return function rotateZ( angle ) {

					return this.rotateOnAxis( v1, angle );

				};

			}(),

			translateOnAxis: function () {

				// translate object by distance along axis in object space
				// axis is assumed to be normalized

				var v1 = new Vector3();

				return function translateOnAxis( axis, distance ) {

					v1.copy( axis ).applyQuaternion( this.quaternion );

					this.position.add( v1.multiplyScalar( distance ) );

					return this;

				};

			}(),

			translateX: function () {

				var v1 = new Vector3( 1, 0, 0 );

				return function translateX( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			translateY: function () {

				var v1 = new Vector3( 0, 1, 0 );

				return function translateY( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			translateZ: function () {

				var v1 = new Vector3( 0, 0, 1 );

				return function translateZ( distance ) {

					return this.translateOnAxis( v1, distance );

				};

			}(),

			localToWorld: function ( vector ) {

				return vector.applyMatrix4( this.matrixWorld );

			},

			worldToLocal: function () {

				var m1 = new Matrix4();

				return function worldToLocal( vector ) {

					return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

				};

			}(),

			lookAt: function () {

				// This routine does not support objects with rotated and/or translated parent(s)

				var m1 = new Matrix4();

				return function lookAt( vector ) {

					m1.lookAt( vector, this.position, this.up );

					this.quaternion.setFromRotationMatrix( m1 );

				};

			}(),

			add: function ( object ) {

				if ( arguments.length > 1 ) {

					for ( var i = 0; i < arguments.length; i ++ ) {

						this.add( arguments[ i ] );

					}

					return this;

				}

				if ( object === this ) {

					console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
					return this;

				}

				if ( (object && object.isObject3D) ) {

					if ( object.parent !== null ) {

						object.parent.remove( object );

					}

					object.parent = this;
					object.dispatchEvent( { type: 'added' } );

					this.children.push( object );

				} else {

					console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

				}

				return this;

			},

			remove: function ( object ) {

				if ( arguments.length > 1 ) {

					for ( var i = 0; i < arguments.length; i ++ ) {

						this.remove( arguments[ i ] );

					}

				}

				var index = this.children.indexOf( object );

				if ( index !== - 1 ) {

					object.parent = null;

					object.dispatchEvent( { type: 'removed' } );

					this.children.splice( index, 1 );

				}

			},

			getObjectById: function ( id ) {

				return this.getObjectByProperty( 'id', id );

			},

			getObjectByName: function ( name ) {

				return this.getObjectByProperty( 'name', name );

			},

			getObjectByProperty: function ( name, value ) {

				if ( this[ name ] === value ) return this;

				for ( var i = 0, l = this.children.length; i < l; i ++ ) {

					var child = this.children[ i ];
					var object = child.getObjectByProperty( name, value );

					if ( object !== undefined ) {

						return object;

					}

				}

				return undefined;

			},

			getWorldPosition: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.updateMatrixWorld( true );

				return result.setFromMatrixPosition( this.matrixWorld );

			},

			getWorldQuaternion: function () {

				var position = new Vector3();
				var scale = new Vector3();

				return function getWorldQuaternion( optionalTarget ) {

					var result = optionalTarget || new Quaternion();

					this.updateMatrixWorld( true );

					this.matrixWorld.decompose( position, result, scale );

					return result;

				};

			}(),

			getWorldRotation: function () {

				var quaternion = new Quaternion();

				return function getWorldRotation( optionalTarget ) {

					var result = optionalTarget || new Euler();

					this.getWorldQuaternion( quaternion );

					return result.setFromQuaternion( quaternion, this.rotation.order, false );

				};

			}(),

			getWorldScale: function () {

				var position = new Vector3();
				var quaternion = new Quaternion();

				return function getWorldScale( optionalTarget ) {

					var result = optionalTarget || new Vector3();

					this.updateMatrixWorld( true );

					this.matrixWorld.decompose( position, quaternion, result );

					return result;

				};

			}(),

			getWorldDirection: function () {

				var quaternion = new Quaternion();

				return function getWorldDirection( optionalTarget ) {

					var result = optionalTarget || new Vector3();

					this.getWorldQuaternion( quaternion );

					return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

				};

			}(),

			raycast: function () {},

			traverse: function ( callback ) {

				callback( this );

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].traverse( callback );

				}

			},

			traverseVisible: function ( callback ) {

				if ( this.visible === false ) return;

				callback( this );

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].traverseVisible( callback );

				}

			},

			traverseAncestors: function ( callback ) {

				var parent = this.parent;

				if ( parent !== null ) {

					callback( parent );

					parent.traverseAncestors( callback );

				}

			},

			updateMatrix: function () {

				this.matrix.compose( this.position, this.quaternion, this.scale );

				this.matrixWorldNeedsUpdate = true;

			},

			updateMatrixWorld: function ( force ) {

				if ( this.matrixAutoUpdate === true ) this.updateMatrix();

				if ( this.matrixWorldNeedsUpdate === true || force === true ) {

					if ( this.parent === null ) {

						this.matrixWorld.copy( this.matrix );

					} else {

						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

					}

					this.matrixWorldNeedsUpdate = false;

					force = true;

				}

				// update children

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( force );

				}

			},

			toJSON: function ( meta ) {

				// meta is '' when called from JSON.stringify
				var isRootObject = ( meta === undefined || meta === '' );

				var output = {};

				// meta is a hash used to collect geometries, materials.
				// not providing it implies that this is the root object
				// being serialized.
				if ( isRootObject ) {

					// initialize meta obj
					meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {}
					};

					output.metadata = {
						version: 4.4,
						type: 'Object',
						generator: 'Object3D.toJSON'
					};

				}

				// standard Object3D serialization

				var object = {};

				object.uuid = this.uuid;
				object.type = this.type;

				if ( this.name !== '' ) object.name = this.name;
				if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
				if ( this.castShadow === true ) object.castShadow = true;
				if ( this.receiveShadow === true ) object.receiveShadow = true;
				if ( this.visible === false ) object.visible = false;

				object.matrix = this.matrix.toArray();

				//

				if ( this.geometry !== undefined ) {

					if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

						meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

					}

					object.geometry = this.geometry.uuid;

				}

				if ( this.material !== undefined ) {

					if ( meta.materials[ this.material.uuid ] === undefined ) {

						meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

					}

					object.material = this.material.uuid;

				}

				//

				if ( this.children.length > 0 ) {

					object.children = [];

					for ( var i = 0; i < this.children.length; i ++ ) {

						object.children.push( this.children[ i ].toJSON( meta ).object );

					}

				}

				if ( isRootObject ) {

					var geometries = extractFromCache( meta.geometries );
					var materials = extractFromCache( meta.materials );
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );

					if ( geometries.length > 0 ) output.geometries = geometries;
					if ( materials.length > 0 ) output.materials = materials;
					if ( textures.length > 0 ) output.textures = textures;
					if ( images.length > 0 ) output.images = images;

				}

				output.object = object;

				return output;

				// extract data from the cache hash
				// remove metadata on each item
				// and return as array
				function extractFromCache( cache ) {

					var values = [];
					for ( var key in cache ) {

						var data = cache[ key ];
						delete data.metadata;
						values.push( data );

					}
					return values;

				}

			},

			clone: function ( recursive ) {

				return new this.constructor().copy( this, recursive );

			},

			copy: function ( source, recursive ) {

				if ( recursive === undefined ) recursive = true;

				this.name = source.name;

				this.up.copy( source.up );

				this.position.copy( source.position );
				this.quaternion.copy( source.quaternion );
				this.scale.copy( source.scale );

				this.matrix.copy( source.matrix );
				this.matrixWorld.copy( source.matrixWorld );

				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

				this.visible = source.visible;

				this.castShadow = source.castShadow;
				this.receiveShadow = source.receiveShadow;

				this.frustumCulled = source.frustumCulled;
				this.renderOrder = source.renderOrder;

				this.userData = JSON.parse( JSON.stringify( source.userData ) );

				if ( recursive === true ) {

					for ( var i = 0; i < source.children.length; i ++ ) {

						var child = source.children[ i ];
						this.add( child.clone() );

					}

				}

				return this;

			}

		} );

		var count$2 = 0;
		function Object3DIdCount() { return count$2++; }

		/**
		 * @author bhouston / http://clara.io
		 */

		function Line3( start, end ) {

			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();

		}

		Line3.prototype = {

			constructor: Line3,

			set: function ( start, end ) {

				this.start.copy( start );
				this.end.copy( end );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( line ) {

				this.start.copy( line.start );
				this.end.copy( line.end );

				return this;

			},

			getCenter: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

			},

			delta: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.subVectors( this.end, this.start );

			},

			distanceSq: function () {

				return this.start.distanceToSquared( this.end );

			},

			distance: function () {

				return this.start.distanceTo( this.end );

			},

			at: function ( t, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				return this.delta( result ).multiplyScalar( t ).add( this.start );

			},

			closestPointToPointParameter: function () {

				var startP = new Vector3();
				var startEnd = new Vector3();

				return function closestPointToPointParameter( point, clampToLine ) {

					startP.subVectors( point, this.start );
					startEnd.subVectors( this.end, this.start );

					var startEnd2 = startEnd.dot( startEnd );
					var startEnd_startP = startEnd.dot( startP );

					var t = startEnd_startP / startEnd2;

					if ( clampToLine ) {

						t = _Math.clamp( t, 0, 1 );

					}

					return t;

				};

			}(),

			closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

				var t = this.closestPointToPointParameter( point, clampToLine );

				var result = optionalTarget || new Vector3();

				return this.delta( result ).multiplyScalar( t ).add( this.start );

			},

			applyMatrix4: function ( matrix ) {

				this.start.applyMatrix4( matrix );
				this.end.applyMatrix4( matrix );

				return this;

			},

			equals: function ( line ) {

				return line.start.equals( this.start ) && line.end.equals( this.end );

			}

		};

		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Triangle( a, b, c ) {

			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();

		}

		Triangle.normal = function () {

			var v0 = new Vector3();

			return function normal( a, b, c, optionalTarget ) {

				var result = optionalTarget || new Vector3();

				result.subVectors( c, b );
				v0.subVectors( a, b );
				result.cross( v0 );

				var resultLengthSq = result.lengthSq();
				if ( resultLengthSq > 0 ) {

					return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

				}

				return result.set( 0, 0, 0 );

			};

		}();

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		Triangle.barycoordFromPoint = function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				var result = optionalTarget || new Vector3();

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return result.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return result.set( 1 - u - v, v, u );

			};

		}();

		Triangle.containsPoint = function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

				return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

			};

		}();

		Triangle.prototype = {

			constructor: Triangle,

			set: function ( a, b, c ) {

				this.a.copy( a );
				this.b.copy( b );
				this.c.copy( c );

				return this;

			},

			setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

				this.a.copy( points[ i0 ] );
				this.b.copy( points[ i1 ] );
				this.c.copy( points[ i2 ] );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( triangle ) {

				this.a.copy( triangle.a );
				this.b.copy( triangle.b );
				this.c.copy( triangle.c );

				return this;

			},

			area: function () {

				var v0 = new Vector3();
				var v1 = new Vector3();

				return function area() {

					v0.subVectors( this.c, this.b );
					v1.subVectors( this.a, this.b );

					return v0.cross( v1 ).length() * 0.5;

				};

			}(),

			midpoint: function ( optionalTarget ) {

				var result = optionalTarget || new Vector3();
				return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

			},

			normal: function ( optionalTarget ) {

				return Triangle.normal( this.a, this.b, this.c, optionalTarget );

			},

			plane: function ( optionalTarget ) {

				var result = optionalTarget || new Plane();

				return result.setFromCoplanarPoints( this.a, this.b, this.c );

			},

			barycoordFromPoint: function ( point, optionalTarget ) {

				return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

			},

			containsPoint: function ( point ) {

				return Triangle.containsPoint( point, this.a, this.b, this.c );

			},

			closestPointToPoint: function () {

				var plane, edgeList, projectedPoint, closestPoint;

				return function closestPointToPoint( point, optionalTarget ) {

					if ( plane === undefined ) {

						plane = new Plane();
						edgeList = [ new Line3(), new Line3(), new Line3() ];
						projectedPoint = new Vector3();
						closestPoint = new Vector3();

					}

					var result = optionalTarget || new Vector3();
					var minDistance = Infinity;

					// project the point onto the plane of the triangle

					plane.setFromCoplanarPoints( this.a, this.b, this.c );
					plane.projectPoint( point, projectedPoint );

					// check if the projection lies within the triangle

					if( this.containsPoint( projectedPoint ) === true ) {

						// if so, this is the closest point

						result.copy( projectedPoint );

					} else {

						// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

						edgeList[ 0 ].set( this.a, this.b );
						edgeList[ 1 ].set( this.b, this.c );
						edgeList[ 2 ].set( this.c, this.a );

						for( var i = 0; i < edgeList.length; i ++ ) {

							edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

							var distance = projectedPoint.distanceToSquared( closestPoint );

							if( distance < minDistance ) {

								minDistance = distance;

								result.copy( closestPoint );

							}

						}

					}

					return result;

				};

			}(),

			equals: function ( triangle ) {

				return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Face3( a, b, c, normal, color, materialIndex ) {

			this.a = a;
			this.b = b;
			this.c = c;

			this.normal = (normal && normal.isVector3) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];

			this.color = (color && color.isColor) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];

			this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

		}

		Face3.prototype = {

			constructor: Face3,

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( source ) {

				this.a = source.a;
				this.b = source.b;
				this.c = source.c;

				this.normal.copy( source.normal );
				this.color.copy( source.color );

				this.materialIndex = source.materialIndex;

				for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

					this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

				}

				for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

					this.vertexColors[ i ] = source.vertexColors[ i ].clone();

				}

				return this;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  shading: THREE.SmoothShading,
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */

		function MeshBasicMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;

			this.lights = false;

			this.setValues( parameters );

		}

		MeshBasicMaterial.prototype = Object.create( Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

		MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

		MeshBasicMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferAttribute( array, itemSize, normalized ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.uuid = _Math.generateUUID();

			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;

			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

		}

		BufferAttribute.prototype = {

			constructor: BufferAttribute,

			isBufferAttribute: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			setArray: function ( array ) {

				if ( Array.isArray( array ) ) {

					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

				}

				this.count = array !== undefined ? array.length / this.itemSize : 0;
				this.array = array;

			},

			setDynamic: function ( value ) {

				this.dynamic = value;

				return this;

			},

			copy: function ( source ) {

				this.array = new source.array.constructor( source.array );
				this.itemSize = source.itemSize;
				this.count = source.count;
				this.normalized = source.normalized;

				this.dynamic = source.dynamic;

				return this;

			},

			copyAt: function ( index1, attribute, index2 ) {

				index1 *= this.itemSize;
				index2 *= attribute.itemSize;

				for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

					this.array[ index1 + i ] = attribute.array[ index2 + i ];

				}

				return this;

			},

			copyArray: function ( array ) {

				this.array.set( array );

				return this;

			},

			copyColorsArray: function ( colors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = colors.length; i < l; i ++ ) {

					var color = colors[ i ];

					if ( color === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
						color = new Color();

					}

					array[ offset ++ ] = color.r;
					array[ offset ++ ] = color.g;
					array[ offset ++ ] = color.b;

				}

				return this;

			},

			copyIndicesArray: function ( indices ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					var index = indices[ i ];

					array[ offset ++ ] = index.a;
					array[ offset ++ ] = index.b;
					array[ offset ++ ] = index.c;

				}

				return this;

			},

			copyVector2sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
						vector = new Vector2();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;

				}

				return this;

			},

			copyVector3sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
						vector = new Vector3();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;

				}

				return this;

			},

			copyVector4sArray: function ( vectors ) {

				var array = this.array, offset = 0;

				for ( var i = 0, l = vectors.length; i < l; i ++ ) {

					var vector = vectors[ i ];

					if ( vector === undefined ) {

						console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
						vector = new Vector4();

					}

					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
					array[ offset ++ ] = vector.w;

				}

				return this;

			},

			set: function ( value, offset ) {

				if ( offset === undefined ) offset = 0;

				this.array.set( value, offset );

				return this;

			},

			getX: function ( index ) {

				return this.array[ index * this.itemSize ];

			},

			setX: function ( index, x ) {

				this.array[ index * this.itemSize ] = x;

				return this;

			},

			getY: function ( index ) {

				return this.array[ index * this.itemSize + 1 ];

			},

			setY: function ( index, y ) {

				this.array[ index * this.itemSize + 1 ] = y;

				return this;

			},

			getZ: function ( index ) {

				return this.array[ index * this.itemSize + 2 ];

			},

			setZ: function ( index, z ) {

				this.array[ index * this.itemSize + 2 ] = z;

				return this;

			},

			getW: function ( index ) {

				return this.array[ index * this.itemSize + 3 ];

			},

			setW: function ( index, w ) {

				this.array[ index * this.itemSize + 3 ] = w;

				return this;

			},

			setXY: function ( index, x, y ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;

				return this;

			},

			setXYZ: function ( index, x, y, z ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;

				return this;

			},

			setXYZW: function ( index, x, y, z, w ) {

				index *= this.itemSize;

				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
				this.array[ index + 3 ] = w;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			}

		};

		//

		function Int8Attribute( array, itemSize ) {

			return new BufferAttribute( new Int8Array( array ), itemSize );

		}

		function Uint8Attribute( array, itemSize ) {

			return new BufferAttribute( new Uint8Array( array ), itemSize );

		}

		function Uint8ClampedAttribute( array, itemSize ) {

			return new BufferAttribute( new Uint8ClampedArray( array ), itemSize );

		}

		function Int16Attribute( array, itemSize ) {

			return new BufferAttribute( new Int16Array( array ), itemSize );

		}

		function Uint16Attribute( array, itemSize ) {

			return new BufferAttribute( new Uint16Array( array ), itemSize );

		}

		function Int32Attribute( array, itemSize ) {

			return new BufferAttribute( new Int32Array( array ), itemSize );

		}

		function Uint32Attribute( array, itemSize ) {

			return new BufferAttribute( new Uint32Array( array ), itemSize );

		}

		function Float32Attribute( array, itemSize ) {

			return new BufferAttribute( new Float32Array( array ), itemSize );

		}

		function Float64Attribute( array, itemSize ) {

			return new BufferAttribute( new Float64Array( array ), itemSize );

		}

		// Deprecated

		function DynamicBufferAttribute( array, itemSize ) {

			console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
			return new BufferAttribute( array, itemSize ).setDynamic( true );

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */

		function Geometry() {

			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'Geometry';

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [ [] ];

			this.morphTargets = [];
			this.morphNormals = [];

			this.skinWeights = [];
			this.skinIndices = [];

			this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.elementsNeedUpdate = false;
			this.verticesNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.lineDistancesNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		Object.assign( Geometry.prototype, EventDispatcher.prototype, {

			isGeometry: true,

			applyMatrix: function ( matrix ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

					var vertex = this.vertices[ i ];
					vertex.applyMatrix4( matrix );

				}

				for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

					var face = this.faces[ i ];
					face.normal.applyMatrix3( normalMatrix ).normalize();

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

					}

				}

				if ( this.boundingBox !== null ) {

					this.computeBoundingBox();

				}

				if ( this.boundingSphere !== null ) {

					this.computeBoundingSphere();

				}

				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;

				return this;

			},

			rotateX: function () {

				// rotate geometry around world x-axis

				var m1;

				return function rotateX( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationX( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateY: function () {

				// rotate geometry around world y-axis

				var m1;

				return function rotateY( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationY( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateZ: function () {

				// rotate geometry around world z-axis

				var m1;

				return function rotateZ( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationZ( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			translate: function () {

				// translate geometry

				var m1;

				return function translate( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeTranslation( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			scale: function () {

				// scale geometry

				var m1;

				return function scale( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeScale( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			lookAt: function () {

				var obj;

				return function lookAt( vector ) {

					if ( obj === undefined ) obj = new Object3D();

					obj.lookAt( vector );

					obj.updateMatrix();

					this.applyMatrix( obj.matrix );

				};

			}(),

			fromBufferGeometry: function ( geometry ) {

				var scope = this;

				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;

				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

				if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

				var tempNormals = [];
				var tempUVs = [];
				var tempUVs2 = [];

				for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

					scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

					if ( normals !== undefined ) {

						tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

					}

					if ( colors !== undefined ) {

						scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

					}

					if ( uvs !== undefined ) {

						tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

					}

					if ( uvs2 !== undefined ) {

						tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

					}

				}

				function addFace( a, b, c, materialIndex ) {

					var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
					var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

					var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

					scope.faces.push( face );

					if ( uvs !== undefined ) {

						scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

					}

					if ( uvs2 !== undefined ) {

						scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

					}

				}

				if ( indices !== undefined ) {

					var groups = geometry.groups;

					if ( groups.length > 0 ) {

						for ( var i = 0; i < groups.length; i ++ ) {

							var group = groups[ i ];

							var start = group.start;
							var count = group.count;

							for ( var j = start, jl = start + count; j < jl; j += 3 ) {

								addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

							}

						}

					} else {

						for ( var i = 0; i < indices.length; i += 3 ) {

							addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

						}

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

				this.computeFaceNormals();

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				return this;

			},

			center: function () {

				this.computeBoundingBox();

				var offset = this.boundingBox.getCenter().negate();

				this.translate( offset.x, offset.y, offset.z );

				return offset;

			},

			normalize: function () {

				this.computeBoundingSphere();

				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;

				var s = radius === 0 ? 1 : 1.0 / radius;

				var matrix = new Matrix4();
				matrix.set(
					s, 0, 0, - s * center.x,
					0, s, 0, - s * center.y,
					0, 0, s, - s * center.z,
					0, 0, 0, 1
				);

				this.applyMatrix( matrix );

				return this;

			},

			computeFaceNormals: function () {

				var cb = new Vector3(), ab = new Vector3();

				for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

					var face = this.faces[ f ];

					var vA = this.vertices[ face.a ];
					var vB = this.vertices[ face.b ];
					var vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					cb.normalize();

					face.normal.copy( cb );

				}

			},

			computeVertexNormals: function ( areaWeighted ) {

				if ( areaWeighted === undefined ) areaWeighted = true;

				var v, vl, f, fl, face, vertices;

				vertices = new Array( this.vertices.length );

				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

					vertices[ v ] = new Vector3();

				}

				if ( areaWeighted ) {

					// vertex normals weighted by triangle areas
					// http://www.iquilezles.org/www/articles/normals/normals.htm

					var vA, vB, vC;
					var cb = new Vector3(), ab = new Vector3();

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];

						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );

						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );

					}

				} else {

					this.computeFaceNormals();

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );

					}

				}

				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

					vertices[ v ].normalize();

				}

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						vertexNormals[ 0 ].copy( vertices[ face.a ] );
						vertexNormals[ 1 ].copy( vertices[ face.b ] );
						vertexNormals[ 2 ].copy( vertices[ face.c ] );

					} else {

						vertexNormals[ 0 ] = vertices[ face.a ].clone();
						vertexNormals[ 1 ] = vertices[ face.b ].clone();
						vertexNormals[ 2 ] = vertices[ face.c ].clone();

					}

				}

				if ( this.faces.length > 0 ) {

					this.normalsNeedUpdate = true;

				}

			},

			computeFlatVertexNormals: function () {

				var f, fl, face;

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						vertexNormals[ 0 ].copy( face.normal );
						vertexNormals[ 1 ].copy( face.normal );
						vertexNormals[ 2 ].copy( face.normal );

					} else {

						vertexNormals[ 0 ] = face.normal.clone();
						vertexNormals[ 1 ] = face.normal.clone();
						vertexNormals[ 2 ] = face.normal.clone();

					}

				}

				if ( this.faces.length > 0 ) {

					this.normalsNeedUpdate = true;

				}

			},

			computeMorphNormals: function () {

				var i, il, f, fl, face;

				// save original normals
				// - create temp variables on first access
				//   otherwise just copy (for faster repeated calls)

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					if ( ! face.__originalFaceNormal ) {

						face.__originalFaceNormal = face.normal.clone();

					} else {

						face.__originalFaceNormal.copy( face.normal );

					}

					if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

					for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

						if ( ! face.__originalVertexNormals[ i ] ) {

							face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

						} else {

							face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

						}

					}

				}

				// use temp geometry to compute face and vertex normals for each morph

				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;

				for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

					// create on first access

					if ( ! this.morphNormals[ i ] ) {

						this.morphNormals[ i ] = {};
						this.morphNormals[ i ].faceNormals = [];
						this.morphNormals[ i ].vertexNormals = [];

						var dstNormalsFace = this.morphNormals[ i ].faceNormals;
						var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

						var faceNormal, vertexNormals;

						for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

							faceNormal = new Vector3();
							vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

							dstNormalsFace.push( faceNormal );
							dstNormalsVertex.push( vertexNormals );

						}

					}

					var morphNormals = this.morphNormals[ i ];

					// set vertices to morph target

					tmpGeo.vertices = this.morphTargets[ i ].vertices;

					// compute morph normals

					tmpGeo.computeFaceNormals();
					tmpGeo.computeVertexNormals();

					// store morph normals

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						face = this.faces[ f ];

						faceNormal = morphNormals.faceNormals[ f ];
						vertexNormals = morphNormals.vertexNormals[ f ];

						faceNormal.copy( face.normal );

						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );

					}

				}

				// restore original normals

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					face.normal = face.__originalFaceNormal;
					face.vertexNormals = face.__originalVertexNormals;

				}

			},

			computeTangents: function () {

				console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

			},

			computeLineDistances: function () {

				var d = 0;
				var vertices = this.vertices;

				for ( var i = 0, il = vertices.length; i < il; i ++ ) {

					if ( i > 0 ) {

						d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

					}

					this.lineDistances[ i ] = d;

				}

			},

			computeBoundingBox: function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				this.boundingBox.setFromPoints( this.vertices );

			},

			computeBoundingSphere: function () {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				this.boundingSphere.setFromPoints( this.vertices );

			},

			merge: function ( geometry, matrix, materialIndexOffset ) {

				if ( (geometry && geometry.isGeometry) === false ) {

					console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
					return;

				}

				var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

				if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

				if ( matrix !== undefined ) {

					normalMatrix = new Matrix3().getNormalMatrix( matrix );

				}

				// vertices

				for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

					var vertex = vertices2[ i ];

					var vertexCopy = vertex.clone();

					if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

					vertices1.push( vertexCopy );

				}

				// colors

				for ( var i = 0, il = colors2.length; i < il; i ++ ) {

					colors1.push( colors2[ i ].clone() );

				}

				// faces

				for ( i = 0, il = faces2.length; i < il; i ++ ) {

					var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

					faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
					faceCopy.normal.copy( face.normal );

					if ( normalMatrix !== undefined ) {

						faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

					}

					for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

						normal = faceVertexNormals[ j ].clone();

						if ( normalMatrix !== undefined ) {

							normal.applyMatrix3( normalMatrix ).normalize();

						}

						faceCopy.vertexNormals.push( normal );

					}

					faceCopy.color.copy( face.color );

					for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

						color = faceVertexColors[ j ];
						faceCopy.vertexColors.push( color.clone() );

					}

					faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

					faces1.push( faceCopy );

				}

				// uvs

				for ( i = 0, il = uvs2.length; i < il; i ++ ) {

					var uv = uvs2[ i ], uvCopy = [];

					if ( uv === undefined ) {

						continue;

					}

					for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

						uvCopy.push( uv[ j ].clone() );

					}

					uvs1.push( uvCopy );

				}

			},

			mergeMesh: function ( mesh ) {

				if ( (mesh && mesh.isMesh) === false ) {

					console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
					return;

				}

				mesh.matrixAutoUpdate && mesh.updateMatrix();

				this.merge( mesh.geometry, mesh.matrix );

			},

			/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */

			mergeVertices: function () {

				var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
				var unique = [], changes = [];

				var v, key;
				var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
				var precision = Math.pow( 10, precisionPoints );
				var i, il, face;
				var indices, j, jl;

				for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

					v = this.vertices[ i ];
					key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

					if ( verticesMap[ key ] === undefined ) {

						verticesMap[ key ] = i;
						unique.push( this.vertices[ i ] );
						changes[ i ] = unique.length - 1;

					} else {

						//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
						changes[ i ] = changes[ verticesMap[ key ] ];

					}

				}


				// if faces are completely degenerate after merging vertices, we
				// have to remove them from the geometry.
				var faceIndicesToRemove = [];

				for ( i = 0, il = this.faces.length; i < il; i ++ ) {

					face = this.faces[ i ];

					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];

					indices = [ face.a, face.b, face.c ];

					var dupIndex = - 1;

					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {

						if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

							dupIndex = n;
							faceIndicesToRemove.push( i );
							break;

						}

					}

				}

				for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

					var idx = faceIndicesToRemove[ i ];

					this.faces.splice( idx, 1 );

					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

						this.faceVertexUvs[ j ].splice( idx, 1 );

					}

				}

				// Use unique set of vertices

				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;

			},

			sortFacesByMaterialIndex: function () {

				var faces = this.faces;
				var length = faces.length;

				// tag faces

				for ( var i = 0; i < length; i ++ ) {

					faces[ i ]._id = i;

				}

				// sort faces

				function materialIndexSort( a, b ) {

					return a.materialIndex - b.materialIndex;

				}

				faces.sort( materialIndexSort );

				// sort uvs

				var uvs1 = this.faceVertexUvs[ 0 ];
				var uvs2 = this.faceVertexUvs[ 1 ];

				var newUvs1, newUvs2;

				if ( uvs1 && uvs1.length === length ) newUvs1 = [];
				if ( uvs2 && uvs2.length === length ) newUvs2 = [];

				for ( var i = 0; i < length; i ++ ) {

					var id = faces[ i ]._id;

					if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
					if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

				}

				if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
				if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.4,
						type: 'Geometry',
						generator: 'Geometry.toJSON'
					}
				};

				// standard Geometry serialization

				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;

				if ( this.parameters !== undefined ) {

					var parameters = this.parameters;

					for ( var key in parameters ) {

						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

					}

					return data;

				}

				var vertices = [];

				for ( var i = 0; i < this.vertices.length; i ++ ) {

					var vertex = this.vertices[ i ];
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};

				for ( var i = 0; i < this.faces.length; i ++ ) {

					var face = this.faces[ i ];

					var hasMaterial = true;
					var hasFaceUv = false; // deprecated
					var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
					var hasFaceNormal = face.normal.length() > 0;
					var hasFaceVertexNormal = face.vertexNormals.length > 0;
					var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
					var hasFaceVertexColor = face.vertexColors.length > 0;

					var faceType = 0;

					faceType = setBit( faceType, 0, 0 ); // isQuad
					faceType = setBit( faceType, 1, hasMaterial );
					faceType = setBit( faceType, 2, hasFaceUv );
					faceType = setBit( faceType, 3, hasFaceVertexUv );
					faceType = setBit( faceType, 4, hasFaceNormal );
					faceType = setBit( faceType, 5, hasFaceVertexNormal );
					faceType = setBit( faceType, 6, hasFaceColor );
					faceType = setBit( faceType, 7, hasFaceVertexColor );

					faces.push( faceType );
					faces.push( face.a, face.b, face.c );
					faces.push( face.materialIndex );

					if ( hasFaceVertexUv ) {

						var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

						faces.push(
							getUvIndex( faceVertexUvs[ 0 ] ),
							getUvIndex( faceVertexUvs[ 1 ] ),
							getUvIndex( faceVertexUvs[ 2 ] )
						);

					}

					if ( hasFaceNormal ) {

						faces.push( getNormalIndex( face.normal ) );

					}

					if ( hasFaceVertexNormal ) {

						var vertexNormals = face.vertexNormals;

						faces.push(
							getNormalIndex( vertexNormals[ 0 ] ),
							getNormalIndex( vertexNormals[ 1 ] ),
							getNormalIndex( vertexNormals[ 2 ] )
						);

					}

					if ( hasFaceColor ) {

						faces.push( getColorIndex( face.color ) );

					}

					if ( hasFaceVertexColor ) {

						var vertexColors = face.vertexColors;

						faces.push(
							getColorIndex( vertexColors[ 0 ] ),
							getColorIndex( vertexColors[ 1 ] ),
							getColorIndex( vertexColors[ 2 ] )
						);

					}

				}

				function setBit( value, position, enabled ) {

					return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

				}

				function getNormalIndex( normal ) {

					var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

					if ( normalsHash[ hash ] !== undefined ) {

						return normalsHash[ hash ];

					}

					normalsHash[ hash ] = normals.length / 3;
					normals.push( normal.x, normal.y, normal.z );

					return normalsHash[ hash ];

				}

				function getColorIndex( color ) {

					var hash = color.r.toString() + color.g.toString() + color.b.toString();

					if ( colorsHash[ hash ] !== undefined ) {

						return colorsHash[ hash ];

					}

					colorsHash[ hash ] = colors.length;
					colors.push( color.getHex() );

					return colorsHash[ hash ];

				}

				function getUvIndex( uv ) {

					var hash = uv.x.toString() + uv.y.toString();

					if ( uvsHash[ hash ] !== undefined ) {

						return uvsHash[ hash ];

					}

					uvsHash[ hash ] = uvs.length / 2;
					uvs.push( uv.x, uv.y );

					return uvsHash[ hash ];

				}

				data.data = {};

				data.data.vertices = vertices;
				data.data.normals = normals;
				if ( colors.length > 0 ) data.data.colors = colors;
				if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
				data.data.faces = faces;

				return data;

			},

			clone: function () {

				/*
				// Handle primitives

				var parameters = this.parameters;

				if ( parameters !== undefined ) {

					var values = [];

					for ( var key in parameters ) {

						values.push( parameters[ key ] );

					}

					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;

				}

				return new this.constructor().copy( this );
				*/

				return new Geometry().copy( this );

			},

			copy: function ( source ) {

				this.vertices = [];
				this.faces = [];
				this.faceVertexUvs = [ [] ];
				this.colors = [];

				var vertices = source.vertices;

				for ( var i = 0, il = vertices.length; i < il; i ++ ) {

					this.vertices.push( vertices[ i ].clone() );

				}

				var colors = source.colors;

				for ( var i = 0, il = colors.length; i < il; i ++ ) {

					this.colors.push( colors[ i ].clone() );

				}

				var faces = source.faces;

				for ( var i = 0, il = faces.length; i < il; i ++ ) {

					this.faces.push( faces[ i ].clone() );

				}

				for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

					var faceVertexUvs = source.faceVertexUvs[ i ];

					if ( this.faceVertexUvs[ i ] === undefined ) {

						this.faceVertexUvs[ i ] = [];

					}

					for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

						var uvs = faceVertexUvs[ j ], uvsCopy = [];

						for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

							var uv = uvs[ k ];

							uvsCopy.push( uv.clone() );

						}

						this.faceVertexUvs[ i ].push( uvsCopy );

					}

				}

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		var count$3 = 0;
		function GeometryIdCount() { return count$3++; }

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function DirectGeometry() {

			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'DirectGeometry';

			this.indices = [];
			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];

			this.groups = [];

			this.morphTargets = {};

			this.skinWeights = [];
			this.skinIndices = [];

			// this.lineDistances = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			// update flags

			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;

		}

		Object.assign( DirectGeometry.prototype, EventDispatcher.prototype, {

			computeBoundingBox: Geometry.prototype.computeBoundingBox,
			computeBoundingSphere: Geometry.prototype.computeBoundingSphere,

			computeFaceNormals: function () {

				console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

			},

			computeVertexNormals: function () {

				console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

			},

			computeGroups: function ( geometry ) {

				var group;
				var groups = [];
				var materialIndex;

				var faces = geometry.faces;

				for ( var i = 0; i < faces.length; i ++ ) {

					var face = faces[ i ];

					// materials

					if ( face.materialIndex !== materialIndex ) {

						materialIndex = face.materialIndex;

						if ( group !== undefined ) {

							group.count = ( i * 3 ) - group.start;
							groups.push( group );

						}

						group = {
							start: i * 3,
							materialIndex: materialIndex
						};

					}

				}

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				this.groups = groups;

			},

			fromGeometry: function ( geometry ) {

				var faces = geometry.faces;
				var vertices = geometry.vertices;
				var faceVertexUvs = geometry.faceVertexUvs;

				var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
				var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

				// morphs

				var morphTargets = geometry.morphTargets;
				var morphTargetsLength = morphTargets.length;

				var morphTargetsPosition;

				if ( morphTargetsLength > 0 ) {

					morphTargetsPosition = [];

					for ( var i = 0; i < morphTargetsLength; i ++ ) {

						morphTargetsPosition[ i ] = [];

					}

					this.morphTargets.position = morphTargetsPosition;

				}

				var morphNormals = geometry.morphNormals;
				var morphNormalsLength = morphNormals.length;

				var morphTargetsNormal;

				if ( morphNormalsLength > 0 ) {

					morphTargetsNormal = [];

					for ( var i = 0; i < morphNormalsLength; i ++ ) {

						morphTargetsNormal[ i ] = [];

					}

					this.morphTargets.normal = morphTargetsNormal;

				}

				// skins

				var skinIndices = geometry.skinIndices;
				var skinWeights = geometry.skinWeights;

				var hasSkinIndices = skinIndices.length === vertices.length;
				var hasSkinWeights = skinWeights.length === vertices.length;

				//

				for ( var i = 0; i < faces.length; i ++ ) {

					var face = faces[ i ];

					this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

					var vertexNormals = face.vertexNormals;

					if ( vertexNormals.length === 3 ) {

						this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

					} else {

						var normal = face.normal;

						this.normals.push( normal, normal, normal );

					}

					var vertexColors = face.vertexColors;

					if ( vertexColors.length === 3 ) {

						this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

					} else {

						var color = face.color;

						this.colors.push( color, color, color );

					}

					if ( hasFaceVertexUv === true ) {

						var vertexUvs = faceVertexUvs[ 0 ][ i ];

						if ( vertexUvs !== undefined ) {

							this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

						} else {

							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

							this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

						}

					}

					if ( hasFaceVertexUv2 === true ) {

						var vertexUvs = faceVertexUvs[ 1 ][ i ];

						if ( vertexUvs !== undefined ) {

							this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

						} else {

							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

							this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

						}

					}

					// morphs

					for ( var j = 0; j < morphTargetsLength; j ++ ) {

						var morphTarget = morphTargets[ j ].vertices;

						morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

					}

					for ( var j = 0; j < morphNormalsLength; j ++ ) {

						var morphNormal = morphNormals[ j ].vertexNormals[ i ];

						morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

					}

					// skins

					if ( hasSkinIndices ) {

						this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

					}

					if ( hasSkinWeights ) {

						this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

					}

				}

				this.computeGroups( geometry );

				this.verticesNeedUpdate = geometry.verticesNeedUpdate;
				this.normalsNeedUpdate = geometry.normalsNeedUpdate;
				this.colorsNeedUpdate = geometry.colorsNeedUpdate;
				this.uvsNeedUpdate = geometry.uvsNeedUpdate;
				this.groupsNeedUpdate = geometry.groupsNeedUpdate;

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferGeometry() {

			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

			this.uuid = _Math.generateUUID();

			this.name = '';
			this.type = 'BufferGeometry';

			this.index = null;
			this.attributes = {};

			this.morphAttributes = {};

			this.groups = [];

			this.boundingBox = null;
			this.boundingSphere = null;

			this.drawRange = { start: 0, count: Infinity };

		}

		Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

			isBufferGeometry: true,

			getIndex: function () {

				return this.index;

			},

			setIndex: function ( index ) {

				this.index = index;

			},

			addAttribute: function ( name, attribute ) {

				if ( (attribute && attribute.isBufferAttribute) === false && (attribute && attribute.isInterleavedBufferAttribute) === false ) {

					console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

					this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

					return;

				}

				if ( name === 'index' ) {

					console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
					this.setIndex( attribute );

					return;

				}

				this.attributes[ name ] = attribute;

				return this;

			},

			getAttribute: function ( name ) {

				return this.attributes[ name ];

			},

			removeAttribute: function ( name ) {

				delete this.attributes[ name ];

				return this;

			},

			addGroup: function ( start, count, materialIndex ) {

				this.groups.push( {

					start: start,
					count: count,
					materialIndex: materialIndex !== undefined ? materialIndex : 0

				} );

			},

			clearGroups: function () {

				this.groups = [];

			},

			setDrawRange: function ( start, count ) {

				this.drawRange.start = start;
				this.drawRange.count = count;

			},

			applyMatrix: function ( matrix ) {

				var position = this.attributes.position;

				if ( position !== undefined ) {

					matrix.applyToVector3Array( position.array );
					position.needsUpdate = true;

				}

				var normal = this.attributes.normal;

				if ( normal !== undefined ) {

					var normalMatrix = new Matrix3().getNormalMatrix( matrix );

					normalMatrix.applyToVector3Array( normal.array );
					normal.needsUpdate = true;

				}

				if ( this.boundingBox !== null ) {

					this.computeBoundingBox();

				}

				if ( this.boundingSphere !== null ) {

					this.computeBoundingSphere();

				}

				return this;

			},

			rotateX: function () {

				// rotate geometry around world x-axis

				var m1;

				return function rotateX( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationX( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateY: function () {

				// rotate geometry around world y-axis

				var m1;

				return function rotateY( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationY( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			rotateZ: function () {

				// rotate geometry around world z-axis

				var m1;

				return function rotateZ( angle ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeRotationZ( angle );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			translate: function () {

				// translate geometry

				var m1;

				return function translate( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeTranslation( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			scale: function () {

				// scale geometry

				var m1;

				return function scale( x, y, z ) {

					if ( m1 === undefined ) m1 = new Matrix4();

					m1.makeScale( x, y, z );

					this.applyMatrix( m1 );

					return this;

				};

			}(),

			lookAt: function () {

				var obj;

				return function lookAt( vector ) {

					if ( obj === undefined ) obj = new Object3D();

					obj.lookAt( vector );

					obj.updateMatrix();

					this.applyMatrix( obj.matrix );

				};

			}(),

			center: function () {

				this.computeBoundingBox();

				var offset = this.boundingBox.getCenter().negate();

				this.translate( offset.x, offset.y, offset.z );

				return offset;

			},

			setFromObject: function ( object ) {

				// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

				var geometry = object.geometry;

				if ( (object && object.isPoints) || (object && object.isLine) ) {

					var positions = new Float32Attribute( geometry.vertices.length * 3, 3 );
					var colors = new Float32Attribute( geometry.colors.length * 3, 3 );

					this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
					this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

					if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

						var lineDistances = new Float32Attribute( geometry.lineDistances.length, 1 );

						this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

					}

					if ( geometry.boundingSphere !== null ) {

						this.boundingSphere = geometry.boundingSphere.clone();

					}

					if ( geometry.boundingBox !== null ) {

						this.boundingBox = geometry.boundingBox.clone();

					}

				} else if ( (object && object.isMesh) ) {

					if ( (geometry && geometry.isGeometry) ) {

						this.fromGeometry( geometry );

					}

				}

				return this;

			},

			updateFromObject: function ( object ) {

				var geometry = object.geometry;

				if ( (object && object.isMesh) ) {

					var direct = geometry.__directGeometry;

					if ( geometry.elementsNeedUpdate === true ) {

						direct = undefined;
						geometry.elementsNeedUpdate = false;

					}

					if ( direct === undefined ) {

						return this.fromGeometry( geometry );

					}

					direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
					direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
					direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
					direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
					direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

					geometry.verticesNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.groupsNeedUpdate = false;

					geometry = direct;

				}

				var attribute;

				if ( geometry.verticesNeedUpdate === true ) {

					attribute = this.attributes.position;

					if ( attribute !== undefined ) {

						attribute.copyVector3sArray( geometry.vertices );
						attribute.needsUpdate = true;

					}

					geometry.verticesNeedUpdate = false;

				}

				if ( geometry.normalsNeedUpdate === true ) {

					attribute = this.attributes.normal;

					if ( attribute !== undefined ) {

						attribute.copyVector3sArray( geometry.normals );
						attribute.needsUpdate = true;

					}

					geometry.normalsNeedUpdate = false;

				}

				if ( geometry.colorsNeedUpdate === true ) {

					attribute = this.attributes.color;

					if ( attribute !== undefined ) {

						attribute.copyColorsArray( geometry.colors );
						attribute.needsUpdate = true;

					}

					geometry.colorsNeedUpdate = false;

				}

				if ( geometry.uvsNeedUpdate ) {

					attribute = this.attributes.uv;

					if ( attribute !== undefined ) {

						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;

					}

					geometry.uvsNeedUpdate = false;

				}

				if ( geometry.lineDistancesNeedUpdate ) {

					attribute = this.attributes.lineDistance;

					if ( attribute !== undefined ) {

						attribute.copyArray( geometry.lineDistances );
						attribute.needsUpdate = true;

					}

					geometry.lineDistancesNeedUpdate = false;

				}

				if ( geometry.groupsNeedUpdate ) {

					geometry.computeGroups( object.geometry );
					this.groups = geometry.groups;

					geometry.groupsNeedUpdate = false;

				}

				return this;

			},

			fromGeometry: function ( geometry ) {

				geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

				return this.fromDirectGeometry( geometry.__directGeometry );

			},

			fromDirectGeometry: function ( geometry ) {

				var positions = new Float32Array( geometry.vertices.length * 3 );
				this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

				if ( geometry.normals.length > 0 ) {

					var normals = new Float32Array( geometry.normals.length * 3 );
					this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

				}

				if ( geometry.colors.length > 0 ) {

					var colors = new Float32Array( geometry.colors.length * 3 );
					this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

				}

				if ( geometry.uvs.length > 0 ) {

					var uvs = new Float32Array( geometry.uvs.length * 2 );
					this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

				}

				if ( geometry.uvs2.length > 0 ) {

					var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
					this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

				}

				if ( geometry.indices.length > 0 ) {

					var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
					var indices = new TypeArray( geometry.indices.length * 3 );
					this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

				}

				// groups

				this.groups = geometry.groups;

				// morphs

				for ( var name in geometry.morphTargets ) {

					var array = [];
					var morphTargets = geometry.morphTargets[ name ];

					for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

						var morphTarget = morphTargets[ i ];

						var attribute = new Float32Attribute( morphTarget.length * 3, 3 );

						array.push( attribute.copyVector3sArray( morphTarget ) );

					}

					this.morphAttributes[ name ] = array;

				}

				// skinning

				if ( geometry.skinIndices.length > 0 ) {

					var skinIndices = new Float32Attribute( geometry.skinIndices.length * 4, 4 );
					this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

				}

				if ( geometry.skinWeights.length > 0 ) {

					var skinWeights = new Float32Attribute( geometry.skinWeights.length * 4, 4 );
					this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

				}

				//

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

				return this;

			},

			computeBoundingBox: function () {

				if ( this.boundingBox === null ) {

					this.boundingBox = new Box3();

				}

				var positions = this.attributes.position.array;

				if ( positions !== undefined ) {

					this.boundingBox.setFromArray( positions );

				} else {

					this.boundingBox.makeEmpty();

				}

				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

				}

			},

			computeBoundingSphere: function () {

				var box = new Box3();
				var vector = new Vector3();

				return function computeBoundingSphere() {

					if ( this.boundingSphere === null ) {

						this.boundingSphere = new Sphere();

					}

					var positions = this.attributes.position;

					if ( positions ) {

						var array = positions.array;
						var center = this.boundingSphere.center;

						box.setFromArray( array );
						box.getCenter( center );

						// hoping to find a boundingSphere with a radius smaller than the
						// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

						var maxRadiusSq = 0;

						for ( var i = 0, il = array.length; i < il; i += 3 ) {

							vector.fromArray( array, i );
							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

						}

						this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

						if ( isNaN( this.boundingSphere.radius ) ) {

							console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

						}

					}

				};

			}(),

			computeFaceNormals: function () {

				// backwards compatibility

			},

			computeVertexNormals: function () {

				var index = this.index;
				var attributes = this.attributes;
				var groups = this.groups;

				if ( attributes.position ) {

					var positions = attributes.position.array;

					if ( attributes.normal === undefined ) {

						this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

					} else {

						// reset existing normals to zero

						var array = attributes.normal.array;

						for ( var i = 0, il = array.length; i < il; i ++ ) {

							array[ i ] = 0;

						}

					}

					var normals = attributes.normal.array;

					var vA, vB, vC,

					pA = new Vector3(),
					pB = new Vector3(),
					pC = new Vector3(),

					cb = new Vector3(),
					ab = new Vector3();

					// indexed elements

					if ( index ) {

						var indices = index.array;

						if ( groups.length === 0 ) {

							this.addGroup( 0, indices.length );

						}

						for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

							var group = groups[ j ];

							var start = group.start;
							var count = group.count;

							for ( var i = start, il = start + count; i < il; i += 3 ) {

								vA = indices[ i + 0 ] * 3;
								vB = indices[ i + 1 ] * 3;
								vC = indices[ i + 2 ] * 3;

								pA.fromArray( positions, vA );
								pB.fromArray( positions, vB );
								pC.fromArray( positions, vC );

								cb.subVectors( pC, pB );
								ab.subVectors( pA, pB );
								cb.cross( ab );

								normals[ vA ] += cb.x;
								normals[ vA + 1 ] += cb.y;
								normals[ vA + 2 ] += cb.z;

								normals[ vB ] += cb.x;
								normals[ vB + 1 ] += cb.y;
								normals[ vB + 2 ] += cb.z;

								normals[ vC ] += cb.x;
								normals[ vC + 1 ] += cb.y;
								normals[ vC + 2 ] += cb.z;

							}

						}

					} else {

						// non-indexed elements (unconnected triangle soup)

						for ( var i = 0, il = positions.length; i < il; i += 9 ) {

							pA.fromArray( positions, i );
							pB.fromArray( positions, i + 3 );
							pC.fromArray( positions, i + 6 );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ i ] = cb.x;
							normals[ i + 1 ] = cb.y;
							normals[ i + 2 ] = cb.z;

							normals[ i + 3 ] = cb.x;
							normals[ i + 4 ] = cb.y;
							normals[ i + 5 ] = cb.z;

							normals[ i + 6 ] = cb.x;
							normals[ i + 7 ] = cb.y;
							normals[ i + 8 ] = cb.z;

						}

					}

					this.normalizeNormals();

					attributes.normal.needsUpdate = true;

				}

			},

			merge: function ( geometry, offset ) {

				if ( (geometry && geometry.isBufferGeometry) === false ) {

					console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
					return;

				}

				if ( offset === undefined ) offset = 0;

				var attributes = this.attributes;

				for ( var key in attributes ) {

					if ( geometry.attributes[ key ] === undefined ) continue;

					var attribute1 = attributes[ key ];
					var attributeArray1 = attribute1.array;

					var attribute2 = geometry.attributes[ key ];
					var attributeArray2 = attribute2.array;

					var attributeSize = attribute2.itemSize;

					for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

						attributeArray1[ j ] = attributeArray2[ i ];

					}

				}

				return this;

			},

			normalizeNormals: function () {

				var normals = this.attributes.normal.array;

				var x, y, z, n;

				for ( var i = 0, il = normals.length; i < il; i += 3 ) {

					x = normals[ i ];
					y = normals[ i + 1 ];
					z = normals[ i + 2 ];

					n = 1.0 / Math.sqrt( x * x + y * y + z * z );

					normals[ i ] *= n;
					normals[ i + 1 ] *= n;
					normals[ i + 2 ] *= n;

				}

			},

			toNonIndexed: function () {

				if ( this.index === null ) {

					console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
					return this;

				}

				var geometry2 = new BufferGeometry();

				var indices = this.index.array;
				var attributes = this.attributes;

				for ( var name in attributes ) {

					var attribute = attributes[ name ];

					var array = attribute.array;
					var itemSize = attribute.itemSize;

					var array2 = new array.constructor( indices.length * itemSize );

					var index = 0, index2 = 0;

					for ( var i = 0, l = indices.length; i < l; i ++ ) {

						index = indices[ i ] * itemSize;

						for ( var j = 0; j < itemSize; j ++ ) {

							array2[ index2 ++ ] = array[ index ++ ];

						}

					}

					geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

				}

				return geometry2;

			},

			toJSON: function () {

				var data = {
					metadata: {
						version: 4.4,
						type: 'BufferGeometry',
						generator: 'BufferGeometry.toJSON'
					}
				};

				// standard BufferGeometry serialization

				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;

				if ( this.parameters !== undefined ) {

					var parameters = this.parameters;

					for ( var key in parameters ) {

						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

					}

					return data;

				}

				data.data = { attributes: {} };

				var index = this.index;

				if ( index !== null ) {

					var array = Array.prototype.slice.call( index.array );

					data.data.index = {
						type: index.array.constructor.name,
						array: array
					};

				}

				var attributes = this.attributes;

				for ( var key in attributes ) {

					var attribute = attributes[ key ];

					var array = Array.prototype.slice.call( attribute.array );

					data.data.attributes[ key ] = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: array,
						normalized: attribute.normalized
					};

				}

				var groups = this.groups;

				if ( groups.length > 0 ) {

					data.data.groups = JSON.parse( JSON.stringify( groups ) );

				}

				var boundingSphere = this.boundingSphere;

				if ( boundingSphere !== null ) {

					data.data.boundingSphere = {
						center: boundingSphere.center.toArray(),
						radius: boundingSphere.radius
					};

				}

				return data;

			},

			clone: function () {

				/*
				// Handle primitives

				var parameters = this.parameters;

				if ( parameters !== undefined ) {

					var values = [];

					for ( var key in parameters ) {

						values.push( parameters[ key ] );

					}

					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;

				}

				return new this.constructor().copy( this );
				*/

				return new BufferGeometry().copy( this );

			},

			copy: function ( source ) {

				var index = source.index;

				if ( index !== null ) {

					this.setIndex( index.clone() );

				}

				var attributes = source.attributes;

				for ( var name in attributes ) {

					var attribute = attributes[ name ];
					this.addAttribute( name, attribute.clone() );

				}

				var groups = source.groups;

				for ( var i = 0, l = groups.length; i < l; i ++ ) {

					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );

				}

				return this;

			},

			dispose: function () {

				this.dispatchEvent( { type: 'dispose' } );

			}

		} );

		BufferGeometry.MaxIndex = 65535;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */

		function Mesh( geometry, material ) {

			Object3D.call( this );

			this.type = 'Mesh';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

			this.drawMode = TrianglesDrawMode;

			this.updateMorphTargets();

		}

		Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Mesh,

			isMesh: true,

			setDrawMode: function ( value ) {

				this.drawMode = value;

			},

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.drawMode = source.drawMode;

				return this;

			},

			updateMorphTargets: function () {

				var morphTargets = this.geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

					}

				}

			},

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				var vA = new Vector3();
				var vB = new Vector3();
				var vC = new Vector3();

				var tempA = new Vector3();
				var tempB = new Vector3();
				var tempC = new Vector3();

				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				var barycoord = new Vector3();

				var intersectionPoint = new Vector3();
				var intersectionPointWorld = new Vector3();

				function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

					Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

					uv1.multiplyScalar( barycoord.x );
					uv2.multiplyScalar( barycoord.y );
					uv3.multiplyScalar( barycoord.z );

					uv1.add( uv2 ).add( uv3 );

					return uv1.clone();

				}

				function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

					var intersect;
					var material = object.material;

					if ( material.side === BackSide ) {

						intersect = ray.intersectTriangle( pC, pB, pA, true, point );

					} else {

						intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

					}

					if ( intersect === null ) return null;

					intersectionPointWorld.copy( point );
					intersectionPointWorld.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

					if ( distance < raycaster.near || distance > raycaster.far ) return null;

					return {
						distance: distance,
						point: intersectionPointWorld.clone(),
						object: object
					};

				}

				function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

					vA.fromArray( positions, a * 3 );
					vB.fromArray( positions, b * 3 );
					vC.fromArray( positions, c * 3 );

					var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

					if ( intersection ) {

						if ( uvs ) {

							uvA.fromArray( uvs, a * 2 );
							uvB.fromArray( uvs, b * 2 );
							uvC.fromArray( uvs, c * 2 );

							intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

						}

						intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
						intersection.faceIndex = a;

					}

					return intersection;

				}

				return function raycast( raycaster, intersects ) {

					var geometry = this.geometry;
					var material = this.material;
					var matrixWorld = this.matrixWorld;

					if ( material === undefined ) return;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					// Check boundingBox before continuing

					if ( geometry.boundingBox !== null ) {

						if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

					}

					var uvs, intersection;

					if ( (geometry && geometry.isBufferGeometry) ) {

						var a, b, c;
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;

						if ( attributes.uv !== undefined ) {

							uvs = attributes.uv.array;

						}

						if ( index !== null ) {

							var indices = index.array;

							for ( var i = 0, l = indices.length; i < l; i += 3 ) {

								a = indices[ i ];
								b = indices[ i + 1 ];
								c = indices[ i + 2 ];

								intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
									intersects.push( intersection );

								}

							}

						} else {


							for ( var i = 0, l = positions.length; i < l; i += 9 ) {

								a = i / 3;
								b = a + 1;
								c = a + 2;

								intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

								if ( intersection ) {

									intersection.index = a; // triangle number in positions buffer semantics
									intersects.push( intersection );

								}

							}

						}

					} else if ( (geometry && geometry.isGeometry) ) {

						var fvA, fvB, fvC;
						var isFaceMaterial = (material && material.isMultiMaterial);
						var materials = isFaceMaterial === true ? material.materials : null;

						var vertices = geometry.vertices;
						var faces = geometry.faces;
						var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
						if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

						for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

							var face = faces[ f ];
							var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

							if ( faceMaterial === undefined ) continue;

							fvA = vertices[ face.a ];
							fvB = vertices[ face.b ];
							fvC = vertices[ face.c ];

							if ( faceMaterial.morphTargets === true ) {

								var morphTargets = geometry.morphTargets;
								var morphInfluences = this.morphTargetInfluences;

								vA.set( 0, 0, 0 );
								vB.set( 0, 0, 0 );
								vC.set( 0, 0, 0 );

								for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

									var influence = morphInfluences[ t ];

									if ( influence === 0 ) continue;

									var targets = morphTargets[ t ].vertices;

									vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
									vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
									vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

								}

								vA.add( fvA );
								vB.add( fvB );
								vC.add( fvC );

								fvA = vA;
								fvB = vB;
								fvC = vC;

							}

							intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

							if ( intersection ) {

								if ( uvs ) {

									var uvs_f = uvs[ f ];
									uvA.copy( uvs_f[ 0 ] );
									uvB.copy( uvs_f[ 1 ] );
									uvC.copy( uvs_f[ 2 ] );

									intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

								}

								intersection.face = face;
								intersection.faceIndex = f;
								intersects.push( intersection );

							}

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

			BufferGeometry.call( this );

			this.type = 'BoxBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			var scope = this;

			// segments
			widthSegments = Math.floor( widthSegments ) || 1;
			heightSegments = Math.floor( heightSegments ) || 1;
			depthSegments = Math.floor( depthSegments ) || 1;

			// these are used to calculate buffer length
			var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
			var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

			// buffers
			var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
			var vertices = new Float32Array( vertexCount * 3 );
			var normals = new Float32Array( vertexCount * 3 );
			var uvs = new Float32Array( vertexCount * 2 );

			// offset variables
			var vertexBufferOffset = 0;
			var uvBufferOffset = 0;
			var indexBufferOffset = 0;
			var numberOfVertices = 0;

			// group variables
			var groupStart = 0;

			// build each side of the box geometry
			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
			buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
			buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

			// build geometry
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

			// helper functions

			function calculateVertexCount( w, h, d ) {

				var vertices = 0;

				// calculate the amount of vertices for each side (plane)
				vertices += (w + 1) * (h + 1) * 2; // xy
				vertices += (w + 1) * (d + 1) * 2; // xz
				vertices += (d + 1) * (h + 1) * 2; // zy

				return vertices;

			}

			function calculateIndexCount( w, h, d ) {

				var index = 0;

				// calculate the amount of squares for each side
				index += w * h * 2; // xy
				index += w * d * 2; // xz
				index += d * h * 2; // zy

				return index * 6; // two triangles per square => six vertices per square

			}

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				var segmentWidth	= width / gridX;
				var segmentHeight = height / gridY;

				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;

				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;

				var vertexCounter = 0;
				var groupCount = 0;

				var vector = new Vector3();

				// generate vertices, normals and uvs

				for ( var iy = 0; iy < gridY1; iy ++ ) {

					var y = iy * segmentHeight - heightHalf;

					for ( var ix = 0; ix < gridX1; ix ++ ) {

						var x = ix * segmentWidth - widthHalf;

						// set values to correct vector component
						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer
						vertices[ vertexBufferOffset ] = vector.x;
						vertices[ vertexBufferOffset + 1 ] = vector.y;
						vertices[ vertexBufferOffset + 2 ] = vector.z;

						// set values to correct vector component
						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer
						normals[ vertexBufferOffset ] = vector.x;
						normals[ vertexBufferOffset + 1 ] = vector.y;
						normals[ vertexBufferOffset + 2 ] = vector.z;

						// uvs
						uvs[ uvBufferOffset ] = ix / gridX;
						uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

						// update offsets and counters
						vertexBufferOffset += 3;
						uvBufferOffset += 2;
						vertexCounter += 1;

					}

				}

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( iy = 0; iy < gridY; iy ++ ) {

					for ( ix = 0; ix < gridX; ix ++ ) {

						// indices
						var a = numberOfVertices + ix + gridX1 * iy;
						var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// face one
						indices[ indexBufferOffset ] = a;
						indices[ indexBufferOffset + 1 ] = b;
						indices[ indexBufferOffset + 2 ] = d;

						// face two
						indices[ indexBufferOffset + 3 ] = b;
						indices[ indexBufferOffset + 4 ] = c;
						indices[ indexBufferOffset + 5 ] = d;

						// update offsets and counters
						indexBufferOffset += 6;
						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups
				groupStart += groupCount;

				// update total number of vertices
				numberOfVertices += vertexCounter;

			}

		}

		BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */

		function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

			BufferGeometry.call( this );

			this.type = 'PlaneBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			var width_half = width / 2;
			var height_half = height / 2;

			var gridX = Math.floor( widthSegments ) || 1;
			var gridY = Math.floor( heightSegments ) || 1;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var segment_width = width / gridX;
			var segment_height = height / gridY;

			var vertices = new Float32Array( gridX1 * gridY1 * 3 );
			var normals = new Float32Array( gridX1 * gridY1 * 3 );
			var uvs = new Float32Array( gridX1 * gridY1 * 2 );

			var offset = 0;
			var offset2 = 0;

			for ( var iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segment_height - height_half;

				for ( var ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segment_width - width_half;

					vertices[ offset ] = x;
					vertices[ offset + 1 ] = - y;

					normals[ offset + 2 ] = 1;

					uvs[ offset2 ] = ix / gridX;
					uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

					offset += 3;
					offset2 += 2;

				}

			}

			offset = 0;

			var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

			for ( var iy = 0; iy < gridY; iy ++ ) {

				for ( var ix = 0; ix < gridX; ix ++ ) {

					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;

					indices[ offset ] = a;
					indices[ offset + 1 ] = b;
					indices[ offset + 2 ] = d;

					indices[ offset + 3 ] = b;
					indices[ offset + 4 ] = c;
					indices[ offset + 5 ] = d;

					offset += 6;

				}

			}

			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

		}

		PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function Camera() {

			Object3D.call( this );

			this.type = 'Camera';

			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();

		}

		Camera.prototype = Object.create( Object3D.prototype );
		Camera.prototype.constructor = Camera;

		Camera.prototype.isCamera = true;

		Camera.prototype.getWorldDirection = function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( optionalTarget ) {

				var result = optionalTarget || new Vector3();

				this.getWorldQuaternion( quaternion );

				return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			};

		}();

		Camera.prototype.lookAt = function () {

			// This routine does not support cameras with rotated and/or translated parent(s)

			var m1 = new Matrix4();

			return function lookAt( vector ) {

				m1.lookAt( this.position, vector, this.up );

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}();

		Camera.prototype.clone = function () {

			return new this.constructor().copy( this );

		};

		Camera.prototype.copy = function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */

		function PerspectiveCamera( fov, aspect, near, far ) {

			Camera.call( this );

			this.type = 'PerspectiveCamera';

			this.fov = fov !== undefined ? fov : 50;
			this.zoom = 1;

			this.near = near !== undefined ? near : 0.1;
			this.far = far !== undefined ? far : 2000;
			this.focus = 10;

			this.aspect = aspect !== undefined ? aspect : 1;
			this.view = null;

			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();

		}

		PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

			constructor: PerspectiveCamera,

			isPerspectiveCamera: true,

			copy: function ( source ) {

				Camera.prototype.copy.call( this, source );

				this.fov = source.fov;
				this.zoom = source.zoom;

				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;

				this.aspect = source.aspect;
				this.view = source.view === null ? null : Object.assign( {}, source.view );

				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;

				return this;

			},

			/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */
			setFocalLength: function ( focalLength ) {

				// see http://www.bobatkins.com/photography/technical/field_of_view.html
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

				this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
				this.updateProjectionMatrix();

			},

			/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */
			getFocalLength: function () {

				var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

				return 0.5 * this.getFilmHeight() / vExtentSlope;

			},

			getEffectiveFOV: function () {

				return _Math.RAD2DEG * 2 * Math.atan(
						Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

			},

			getFilmWidth: function () {

				// film not completely covered in portrait format (aspect < 1)
				return this.filmGauge * Math.min( this.aspect, 1 );

			},

			getFilmHeight: function () {

				// film not completely covered in landscape format (aspect > 1)
				return this.filmGauge / Math.max( this.aspect, 1 );

			},

			/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */
			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

				this.aspect = fullWidth / fullHeight;

				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};

				this.updateProjectionMatrix();

			},

			clearViewOffset: function() {

				this.view = null;
				this.updateProjectionMatrix();

			},

			updateProjectionMatrix: function () {

				var near = this.near,
					top = near * Math.tan(
							_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
					height = 2 * top,
					width = this.aspect * height,
					left = - 0.5 * width,
					view = this.view;

				if ( view !== null ) {

					var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;

					left += view.offsetX * width / fullWidth;
					top -= view.offsetY * height / fullHeight;
					width *= view.width / fullWidth;
					height *= view.height / fullHeight;

				}

				var skew = this.filmOffset;
				if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

				this.projectionMatrix.makeFrustum(
						left, left + width, top - height, top, near, this.far );

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.fov = this.fov;
				data.object.zoom = this.zoom;

				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;

				data.object.aspect = this.aspect;

				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */

		function OrthographicCamera( left, right, top, bottom, near, far ) {

			Camera.call( this );

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = ( near !== undefined ) ? near : 0.1;
			this.far = ( far !== undefined ) ? far : 2000;

			this.updateProjectionMatrix();

		}

		OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

			constructor: OrthographicCamera,

			isOrthographicCamera: true,

			copy: function ( source ) {

				Camera.prototype.copy.call( this, source );

				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;

				this.zoom = source.zoom;
				this.view = source.view === null ? null : Object.assign( {}, source.view );

				return this;

			},

			setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};

				this.updateProjectionMatrix();

			},

			clearViewOffset: function() {

				this.view = null;
				this.updateProjectionMatrix();

			},

			updateProjectionMatrix: function () {

				var dx = ( this.right - this.left ) / ( 2 * this.zoom );
				var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
				var cx = ( this.right + this.left ) / 2;
				var cy = ( this.top + this.bottom ) / 2;

				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;

				if ( this.view !== null ) {

					var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
					var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
					var scaleW = ( this.right - this.left ) / this.view.width;
					var scaleH = ( this.top - this.bottom ) / this.view.height;

					left += scaleW * ( this.view.offsetX / zoomW );
					right = left + scaleW * ( this.view.width / zoomW );
					top -= scaleH * ( this.view.offsetY / zoomH );
					bottom = top - scaleH * ( this.view.height / zoomH );

				}

				this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;

				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

				return data;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

			var mode;

			function setMode( value ) {

				mode = value;

			}

			var type, size;

			function setIndex( index ) {

				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

					type = gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = gl.UNSIGNED_SHORT;
					size = 2;

				}

			}

			function render( start, count ) {

				gl.drawElements( mode, count, type, start * size );

				infoRender.calls ++;
				infoRender.vertices += count;

				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

			}

			function renderInstances( geometry, start, count ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

				extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;

				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

			}

			return {

				setMode: setMode,
				setIndex: setIndex,
				render: render,
				renderInstances: renderInstances

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLBufferRenderer( gl, extensions, infoRender ) {

			var mode;

			function setMode( value ) {

				mode = value;

			}

			function render( start, count ) {

				gl.drawArrays( mode, start, count );

				infoRender.calls ++;
				infoRender.vertices += count;

				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

			}

			function renderInstances( geometry ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

				var position = geometry.attributes.position;

				var count = 0;

				if ( (position && position.isInterleavedBufferAttribute) ) {

					count = position.data.count;

					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

				} else {

					count = position.count;

					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

				}

				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;

				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

			}

			return {
				setMode: setMode,
				render: render,
				renderInstances: renderInstances
			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLLights() {

			var lights = {};

			return {

				get: function ( light ) {

					if ( lights[ light.id ] !== undefined ) {

						return lights[ light.id ];

					}

					var uniforms;

					switch ( light.type ) {

						case 'DirectionalLight':
							uniforms = {
								direction: new Vector3(),
								color: new Color(),

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'SpotLight':
							uniforms = {
								position: new Vector3(),
								direction: new Vector3(),
								color: new Color(),
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0,

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'PointLight':
							uniforms = {
								position: new Vector3(),
								color: new Color(),
								distance: 0,
								decay: 0,

								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;

						case 'HemisphereLight':
							uniforms = {
								direction: new Vector3(),
								skyColor: new Color(),
								groundColor: new Color()
							};
							break;

					}

					lights[ light.id ] = uniforms;

					return uniforms;

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function addLineNumbers( string ) {

			var lines = string.split( '\n' );

			for ( var i = 0; i < lines.length; i ++ ) {

				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

			}

			return lines.join( '\n' );

		}

		function WebGLShader( gl, type, string ) {

			var shader = gl.createShader( type );

			gl.shaderSource( shader, string );
			gl.compileShader( shader );

			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

			}

			if ( gl.getShaderInfoLog( shader ) !== '' ) {

				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

			}

			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

			return shader;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var programIdCount = 0;

		function getEncodingComponents( encoding ) {

			switch ( encoding ) {

				case LinearEncoding:
					return [ 'Linear','( value )' ];
				case sRGBEncoding:
					return [ 'sRGB','( value )' ];
				case RGBEEncoding:
					return [ 'RGBE','( value )' ];
				case RGBM7Encoding:
					return [ 'RGBM','( value, 7.0 )' ];
				case RGBM16Encoding:
					return [ 'RGBM','( value, 16.0 )' ];
				case RGBDEncoding:
					return [ 'RGBD','( value, 256.0 )' ];
				case GammaEncoding:
					return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );

			}

		}

		function getTexelDecodingFunction( functionName, encoding ) {

			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

		}

		function getTexelEncodingFunction( functionName, encoding ) {

			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

		}

		function getToneMappingFunction( functionName, toneMapping ) {

			var toneMappingName;

			switch ( toneMapping ) {

				case LinearToneMapping:
					toneMappingName = "Linear";
					break;

				case ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;

				case Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;

				case CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;

				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );

			}

			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

		}

		function generateExtensions( extensions, parameters, rendererExtensions ) {

			extensions = extensions || {};

			var chunks = [
				( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
			];

			return chunks.filter( filterEmptyLine ).join( '\n' );

		}

		function generateDefines( defines ) {

			var chunks = [];

			for ( var name in defines ) {

				var value = defines[ name ];

				if ( value === false ) continue;

				chunks.push( '#define ' + name + ' ' + value );

			}

			return chunks.join( '\n' );

		}

		function fetchAttributeLocations( gl, program, identifiers ) {

			var attributes = {};

			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

			for ( var i = 0; i < n; i ++ ) {

				var info = gl.getActiveAttrib( program, i );
				var name = info.name;

				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

				attributes[ name ] = gl.getAttribLocation( program, name );

			}

			return attributes;

		}

		function filterEmptyLine( string ) {

			return string !== '';

		}

		function replaceLightNums( string, parameters ) {

			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

		}

		function parseIncludes( string ) {

			var pattern = /#include +<([\w\d.]+)>/g;

			function replace( match, include ) {

				var replace = ShaderChunk[ include ];

				if ( replace === undefined ) {

					throw new Error( 'Can not resolve #include <' + include + '>' );

				}

				return parseIncludes( replace );

			}

			return string.replace( pattern, replace );

		}

		function unrollLoops( string ) {

			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

			function replace( match, start, end, snippet ) {

				var unroll = '';

				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

				}

				return unroll;

			}

			return string.replace( pattern, replace );

		}

		function WebGLProgram( renderer, code, material, parameters ) {

			var gl = renderer.context;

			var extensions = material.extensions;
			var defines = material.defines;

			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;

			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

			if ( parameters.shadowMapType === PCFShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

			} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

			}

			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

			if ( parameters.envMap ) {

				switch ( material.envMap.mapping ) {

					case CubeReflectionMapping:
					case CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;

					case CubeUVReflectionMapping:
					case CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;

					case EquirectangularReflectionMapping:
					case EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;

					case SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;

				}

				switch ( material.envMap.mapping ) {

					case CubeRefractionMapping:
					case EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;

				}

				switch ( material.combine ) {

					case MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;

					case MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;

					case AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;

				}

			}

			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

			// console.log( 'building new program ' );

			//

			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

			var customDefines = generateDefines( defines );

			//

			var program = gl.createProgram();

			var prefixVertex, prefixFragment;

			if ( material.isRawShaderMaterial ) {

				prefixVertex = [

					customDefines,

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					customExtensions,
					customDefines,

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			} else {

				prefixVertex = [

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					'#define MAX_BONES ' + parameters.maxBones,

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',

					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',

					'#ifdef USE_COLOR',

					'	attribute vec3 color;',

					'#endif',

					'#ifdef USE_MORPHTARGETS',

					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',

					'	#ifdef USE_MORPHNORMALS',

					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',

					'	#else',

					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',

					'	#endif',

					'#endif',

					'#ifdef USE_SKINNING',

					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',

					'#endif',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

				prefixFragment = [

					customExtensions,

					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',

					'#define SHADER_NAME ' + material.__webglShader.name,

					customDefines,

					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

					'#define GAMMA_FACTOR ' + gammaFactorDefine,

					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',

					parameters.flatShading ? '#define FLAT_SHADED' : '',

					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',

					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
					'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),

					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',

					( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
					( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

					( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

					'\n'

				].filter( filterEmptyLine ).join( '\n' );

			}

			vertexShader = parseIncludes( vertexShader, parameters );
			vertexShader = replaceLightNums( vertexShader, parameters );

			fragmentShader = parseIncludes( fragmentShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );

			if ( ! material.isShaderMaterial ) {

				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );

			}

			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;

			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );

			var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );

			// Force a particular attribute to index 0.

			if ( material.index0AttributeName !== undefined ) {

				gl.bindAttribLocation( program, 0, material.index0AttributeName );

			} else if ( parameters.morphTargets === true ) {

				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );

			}

			gl.linkProgram( program );

			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

			var runnable = true;
			var haveDiagnostics = true;

			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,
					material: material,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

			// clean up

			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );

			// set up caching for uniform locations

			var cachedUniforms;

			this.getUniforms = function() {

				if ( cachedUniforms === undefined ) {

					cachedUniforms =
							new WebGLUniforms( gl, program, renderer );

				}

				return cachedUniforms;

			};

			// set up caching for attribute locations

			var cachedAttributes;

			this.getAttributes = function() {

				if ( cachedAttributes === undefined ) {

					cachedAttributes = fetchAttributeLocations( gl, program );

				}

				return cachedAttributes;

			};

			// free resource

			this.destroy = function() {

				gl.deleteProgram( program );
				this.program = undefined;

			};

			// DEPRECATED

			Object.defineProperties( this, {

				uniforms: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();

					}
				},

				attributes: {
					get: function() {

						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();

					}
				}

			} );


			//

			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;

			return this;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLPrograms( renderer, capabilities ) {

			var programs = [];

			var shaderIDs = {
				MeshDepthMaterial: 'depth',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points'
			};

			var parameterNames = [
				"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
				"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
				"roughnessMap", "metalnessMap",
				"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
				"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
				"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
				"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
				"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
				"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
				"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
			];


			function allocateBones( object ) {

				if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

					return 1024;

				} else {

					// default for when object is not specified
					// ( for example when prebuilding shader to be used with multiple objects )
					//
					//  - leave some extra space for other uniforms
					//  - limit here is ANGLE's 254 max uniform vectors
					//    (up to 54 should be safe)

					var nVertexUniforms = capabilities.maxVertexUniforms;
					var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

					var maxBones = nVertexMatrices;

					if ( object !== undefined && (object && object.isSkinnedMesh) ) {

						maxBones = Math.min( object.skeleton.bones.length, maxBones );

						if ( maxBones < object.skeleton.bones.length ) {

							console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

						}

					}

					return maxBones;

				}

			}

			function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

				var encoding;

				if ( ! map ) {

					encoding = LinearEncoding;

				} else if ( (map && map.isTexture) ) {

					encoding = map.encoding;

				} else if ( (map && map.isWebGLRenderTarget) ) {

					console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
					encoding = map.texture.encoding;

				}

				// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
				if ( encoding === LinearEncoding && gammaOverrideLinear ) {

					encoding = GammaEncoding;

				}

				return encoding;

			}

			this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {

				var shaderID = shaderIDs[ material.type ];

				// heuristics to create shader parameters according to lights in the scene
				// (not to blow over maxLights budget)

				var maxBones = allocateBones( object );
				var precision = renderer.getPrecision();

				if ( material.precision !== null ) {

					precision = capabilities.getMaxPrecision( material.precision );

					if ( precision !== material.precision ) {

						console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

					}

				}

				var currentRenderTarget = renderer.getCurrentRenderTarget();

				var parameters = {

					shaderID: shaderID,

					precision: precision,
					supportsVertexTextures: capabilities.vertexTextures,
					outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
					map: !! material.map,
					mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
					envMap: !! material.envMap,
					envMapMode: material.envMap && material.envMap.mapping,
					envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
					envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
					lightMap: !! material.lightMap,
					aoMap: !! material.aoMap,
					emissiveMap: !! material.emissiveMap,
					emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
					bumpMap: !! material.bumpMap,
					normalMap: !! material.normalMap,
					displacementMap: !! material.displacementMap,
					roughnessMap: !! material.roughnessMap,
					metalnessMap: !! material.metalnessMap,
					specularMap: !! material.specularMap,
					alphaMap: !! material.alphaMap,

					combine: material.combine,

					vertexColors: material.vertexColors,

					fog: !! fog,
					useFog: material.fog,
					fogExp: (fog && fog.isFogExp2),

					flatShading: material.shading === FlatShading,

					sizeAttenuation: material.sizeAttenuation,
					logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

					skinning: material.skinning,
					maxBones: maxBones,
					useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

					morphTargets: material.morphTargets,
					morphNormals: material.morphNormals,
					maxMorphTargets: renderer.maxMorphTargets,
					maxMorphNormals: renderer.maxMorphNormals,

					numDirLights: lights.directional.length,
					numPointLights: lights.point.length,
					numSpotLights: lights.spot.length,
					numHemiLights: lights.hemi.length,

					numClippingPlanes: nClipPlanes,
					numClipIntersection: nClipIntersection,

					shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
					shadowMapType: renderer.shadowMap.type,

					toneMapping: renderer.toneMapping,
					physicallyCorrectLights: renderer.physicallyCorrectLights,

					premultipliedAlpha: material.premultipliedAlpha,

					alphaTest: material.alphaTest,
					doubleSided: material.side === DoubleSide,
					flipSided: material.side === BackSide,

					depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

				};

				return parameters;

			};

			this.getProgramCode = function ( material, parameters ) {

				var array = [];

				if ( parameters.shaderID ) {

					array.push( parameters.shaderID );

				} else {

					array.push( material.fragmentShader );
					array.push( material.vertexShader );

				}

				if ( material.defines !== undefined ) {

					for ( var name in material.defines ) {

						array.push( name );
						array.push( material.defines[ name ] );

					}

				}

				for ( var i = 0; i < parameterNames.length; i ++ ) {

					array.push( parameters[ parameterNames[ i ] ] );

				}

				return array.join();

			};

			this.acquireProgram = function ( material, parameters, code ) {

				var program;

				// Check if code has been already compiled
				for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

					var programInfo = programs[ p ];

					if ( programInfo.code === code ) {

						program = programInfo;
						++ program.usedTimes;

						break;

					}

				}

				if ( program === undefined ) {

					program = new WebGLProgram( renderer, code, material, parameters );
					programs.push( program );

				}

				return program;

			};

			this.releaseProgram = function( program ) {

				if ( -- program.usedTimes === 0 ) {

					// Remove from unordered set
					var i = programs.indexOf( program );
					programs[ i ] = programs[ programs.length - 1 ];
					programs.pop();

					// Free WebGL resources
					program.destroy();

				}

			};

			// Exposed for resource monitoring & error feedback via renderer.info:
			this.programs = programs;

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLGeometries( gl, properties, info ) {

			var geometries = {};

			function onGeometryDispose( event ) {

				var geometry = event.target;
				var buffergeometry = geometries[ geometry.id ];

				if ( buffergeometry.index !== null ) {

					deleteAttribute( buffergeometry.index );

				}

				deleteAttributes( buffergeometry.attributes );

				geometry.removeEventListener( 'dispose', onGeometryDispose );

				delete geometries[ geometry.id ];

				// TODO

				var property = properties.get( geometry );

				if ( property.wireframe ) {

					deleteAttribute( property.wireframe );

				}

				properties.delete( geometry );

				var bufferproperty = properties.get( buffergeometry );

				if ( bufferproperty.wireframe ) {

					deleteAttribute( bufferproperty.wireframe );

				}

				properties.delete( buffergeometry );

				//

				info.memory.geometries --;

			}

			function getAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					return properties.get( attribute.data ).__webglBuffer;

				}

				return properties.get( attribute ).__webglBuffer;

			}

			function deleteAttribute( attribute ) {

				var buffer = getAttributeBuffer( attribute );

				if ( buffer !== undefined ) {

					gl.deleteBuffer( buffer );
					removeAttributeBuffer( attribute );

				}

			}

			function deleteAttributes( attributes ) {

				for ( var name in attributes ) {

					deleteAttribute( attributes[ name ] );

				}

			}

			function removeAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					properties.delete( attribute.data );

				} else {

					properties.delete( attribute );

				}

			}

			return {

				get: function ( object ) {

					var geometry = object.geometry;

					if ( geometries[ geometry.id ] !== undefined ) {

						return geometries[ geometry.id ];

					}

					geometry.addEventListener( 'dispose', onGeometryDispose );

					var buffergeometry;

					if ( geometry.isBufferGeometry ) {

						buffergeometry = geometry;

					} else if ( geometry.isGeometry ) {

						if ( geometry._bufferGeometry === undefined ) {

							geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

						}

						buffergeometry = geometry._bufferGeometry;

					}

					geometries[ geometry.id ] = buffergeometry;

					info.memory.geometries ++;

					return buffergeometry;

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLObjects( gl, properties, info ) {

			var geometries = new WebGLGeometries( gl, properties, info );

			//

			function update( object ) {

				// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

				var geometry = geometries.get( object );

				if ( object.geometry.isGeometry ) {

					geometry.updateFromObject( object );

				}

				var index = geometry.index;
				var attributes = geometry.attributes;

				if ( index !== null ) {

					updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

				}

				for ( var name in attributes ) {

					updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

				}

				// morph targets

				var morphAttributes = geometry.morphAttributes;

				for ( var name in morphAttributes ) {

					var array = morphAttributes[ name ];

					for ( var i = 0, l = array.length; i < l; i ++ ) {

						updateAttribute( array[ i ], gl.ARRAY_BUFFER );

					}

				}

				return geometry;

			}

			function updateAttribute( attribute, bufferType ) {

				var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

				var attributeProperties = properties.get( data );

				if ( attributeProperties.__webglBuffer === undefined ) {

					createBuffer( attributeProperties, data, bufferType );

				} else if ( attributeProperties.version !== data.version ) {

					updateBuffer( attributeProperties, data, bufferType );

				}

			}

			function createBuffer( attributeProperties, data, bufferType ) {

				attributeProperties.__webglBuffer = gl.createBuffer();
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

				var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

				gl.bufferData( bufferType, data.array, usage );

				attributeProperties.version = data.version;

			}

			function updateBuffer( attributeProperties, data, bufferType ) {

				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

				if ( data.dynamic === false ) {

					gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );

				} else if ( data.updateRange.count === - 1 ) {

					// Not using update ranges

					gl.bufferSubData( bufferType, 0, data.array );

				} else if ( data.updateRange.count === 0 ) {

					console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

				} else {

					gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
									  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

					data.updateRange.count = 0; // reset range

				}

				attributeProperties.version = data.version;

			}

			function getAttributeBuffer( attribute ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					return properties.get( attribute.data ).__webglBuffer;

				}

				return properties.get( attribute ).__webglBuffer;

			}

			function getWireframeAttribute( geometry ) {

				var property = properties.get( geometry );

				if ( property.wireframe !== undefined ) {

					return property.wireframe;

				}

				var indices = [];

				var index = geometry.index;
				var attributes = geometry.attributes;
				var position = attributes.position;

				// console.time( 'wireframe' );

				if ( index !== null ) {

					var edges = {};
					var array = index.array;

					for ( var i = 0, l = array.length; i < l; i += 3 ) {

						var a = array[ i + 0 ];
						var b = array[ i + 1 ];
						var c = array[ i + 2 ];

						indices.push( a, b, b, c, c, a );

					}

				} else {

					var array = attributes.position.array;

					for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

						var a = i + 0;
						var b = i + 1;
						var c = i + 2;

						indices.push( a, b, b, c, c, a );

					}

				}

				// console.timeEnd( 'wireframe' );

				var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
				var attribute = new BufferAttribute( new TypeArray( indices ), 1 );

				updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

				property.wireframe = attribute;

				return attribute;

			}

			return {

				getAttributeBuffer: getAttributeBuffer,
				getWireframeAttribute: getWireframeAttribute,

				update: update

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

			var _infoMemory = info.memory;
			var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

			//

			function clampToMaxSize( image, maxSize ) {

				if ( image.width > maxSize || image.height > maxSize ) {

					// Warning: Scaling through the canvas will only work with images that use
					// premultiplied alpha.

					var scale = maxSize / Math.max( image.width, image.height );

					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = Math.floor( image.width * scale );
					canvas.height = Math.floor( image.height * scale );

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

					console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

					return canvas;

				}

				return image;

			}

			function isPowerOfTwo( image ) {

				return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

			}

			function makePowerOfTwo( image ) {

				if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = _Math.nearestPowerOfTwo( image.width );
					canvas.height = _Math.nearestPowerOfTwo( image.height );

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, canvas.width, canvas.height );

					console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

					return canvas;

				}

				return image;

			}

			function textureNeedsPowerOfTwo( texture ) {

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) return true;
				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) return true;

				return false;

			}

			// Fallback filters for non-power-of-2 textures

			function filterFallback( f ) {

				if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

					return _gl.NEAREST;

				}

				return _gl.LINEAR;

			}

			//

			function onTextureDispose( event ) {

				var texture = event.target;

				texture.removeEventListener( 'dispose', onTextureDispose );

				deallocateTexture( texture );

				_infoMemory.textures --;


			}

			function onRenderTargetDispose( event ) {

				var renderTarget = event.target;

				renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

				deallocateRenderTarget( renderTarget );

				_infoMemory.textures --;

			}

			//

			function deallocateTexture( texture ) {

				var textureProperties = properties.get( texture );

				if ( texture.image && textureProperties.__image__webglTextureCube ) {

					// cube texture

					_gl.deleteTexture( textureProperties.__image__webglTextureCube );

				} else {

					// 2D texture

					if ( textureProperties.__webglInit === undefined ) return;

					_gl.deleteTexture( textureProperties.__webglTexture );

				}

				// remove all webgl properties
				properties.delete( texture );

			}

			function deallocateRenderTarget( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				if ( ! renderTarget ) return;

				if ( textureProperties.__webglTexture !== undefined ) {

					_gl.deleteTexture( textureProperties.__webglTexture );

				}

				if ( renderTarget.depthTexture ) {

					renderTarget.depthTexture.dispose();

				}

				if ( (renderTarget && renderTarget.isWebGLRenderTargetCube) ) {

					for ( var i = 0; i < 6; i ++ ) {

						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
						if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

					}

				} else {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

				}

				properties.delete( renderTarget.texture );
				properties.delete( renderTarget );

			}

			//



			function setTexture2D( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					var image = texture.image;

					if ( image === undefined ) {

						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

					} else if ( image.complete === false ) {

						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

					} else {

						uploadTexture( textureProperties, texture, slot );
						return;

					}

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			}

			function setTextureCube( texture, slot ) {

				var textureProperties = properties.get( texture );

				if ( texture.image.length === 6 ) {

					if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

						if ( ! textureProperties.__image__webglTextureCube ) {

							texture.addEventListener( 'dispose', onTextureDispose );

							textureProperties.__image__webglTextureCube = _gl.createTexture();

							_infoMemory.textures ++;

						}

						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

						_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

						var isCompressed = (texture && texture.isCompressedTexture);
						var isDataTexture = (texture.image[ 0 ] && texture.image[ 0 ].isDataTexture);

						var cubeImage = [];

						for ( var i = 0; i < 6; i ++ ) {

							if ( ! isCompressed && ! isDataTexture ) {

								cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

							} else {

								cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

							}

						}

						var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = paramThreeToGL( texture.format ),
						glType = paramThreeToGL( texture.type );

						setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

						for ( var i = 0; i < 6; i ++ ) {

							if ( ! isCompressed ) {

								if ( isDataTexture ) {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

								}

							} else {

								var mipmap, mipmaps = cubeImage[ i ].mipmaps;

								for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

									mipmap = mipmaps[ j ];

									if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

										if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

											state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

										} else {

											console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

										}

									} else {

										state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

									}

								}

							}

						}

						if ( texture.generateMipmaps && isPowerOfTwoImage ) {

							_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

						}

						textureProperties.__version = texture.version;

						if ( texture.onUpdate ) texture.onUpdate( texture );

					} else {

						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					}

				}

			}

			function setTextureCubeDynamic( texture, slot ) {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

			}

			function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

				var extension;

				if ( isPowerOfTwoImage ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

				} else {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

					if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

					}

					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

					if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

					}

				}

				extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension ) {

					if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
					if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

					if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

						_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
						properties.get( texture ).__currentAnisotropy = texture.anisotropy;

					}

				}

			}

			function uploadTexture( textureProperties, texture, slot ) {

				if ( textureProperties.__webglInit === undefined ) {

					textureProperties.__webglInit = true;

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__webglTexture = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

				var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

				if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

					image = makePowerOfTwo( image );

				}

				var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

				var mipmap, mipmaps = texture.mipmaps;

				if ( (texture && texture.isDepthTexture) ) {

					// populate depth texture with dummy data

					var internalFormat = _gl.DEPTH_COMPONENT;

					if ( texture.type === FloatType ) {

						if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
						internalFormat = _gl.DEPTH_COMPONENT32F;

					} else if ( _isWebGL2 ) {

						// WebGL 2.0 requires signed internalformat for glTexImage2D
						internalFormat = _gl.DEPTH_COMPONENT16;

					}

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.format === DepthStencilFormat ) {

						internalFormat = _gl.DEPTH_STENCIL;

					}

					state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

				} else if ( (texture && texture.isDataTexture) ) {

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

						texture.generateMipmaps = false;

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

					}

				} else if ( (texture && texture.isCompressedTexture) ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

								state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				} else {

					// regular Texture (image, video, canvas)

					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels

					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

						}

						texture.generateMipmaps = false;

					} else {

						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

					}

				}

				if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			}

			// Render targets

			// Setup storage for target texture and bind it to correct framebuffer
			function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

				var glFormat = paramThreeToGL( renderTarget.texture.format );
				var glType = paramThreeToGL( renderTarget.texture.type );
				state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
			function setupRenderBufferStorage( renderbuffer, renderTarget ) {

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

				if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

				} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

				} else {

					// FIXME: We don't support !depth !stencil
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

				}

				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

			}

			// Setup resources for a Depth Texture for a FBO (needs an extension)
			function setupDepthTexture( framebuffer, renderTarget ) {

				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
				if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				if ( !( (renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture) ) ) {

					throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

				}

				// upload an empty depth texture with framebuffer size
				if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
						renderTarget.depthTexture.image.width !== renderTarget.width ||
						renderTarget.depthTexture.image.height !== renderTarget.height ) {
					renderTarget.depthTexture.image.width = renderTarget.width;
					renderTarget.depthTexture.image.height = renderTarget.height;
					renderTarget.depthTexture.needsUpdate = true;
				}

				setTexture2D( renderTarget.depthTexture, 0 );

				var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

				if ( renderTarget.depthTexture.format === DepthFormat ) {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

				} else {

					throw new Error('Unknown depthTexture format')

				}

			}

			// Setup GL resources for a non-texture depth buffer
			function setupDepthRenderbuffer( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );

				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );

				if ( renderTarget.depthTexture ) {

					if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

				} else {

					if ( isCube ) {

						renderTargetProperties.__webglDepthbuffer = [];

						for ( var i = 0; i < 6; i ++ ) {

							_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

						}

					} else {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

					}

				}

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

			}

			// Set up GL resources for the render target
			function setupRenderTarget( renderTarget ) {

				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );

				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				_infoMemory.textures ++;

				var isCube = ( (renderTarget && renderTarget.isWebGLRenderTargetCube) );
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

				// Setup framebuffer

				if ( isCube ) {

					renderTargetProperties.__webglFramebuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

					}

				} else {

					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				}

				// Setup color buffer

				if ( isCube ) {

					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

					for ( var i = 0; i < 6; i ++ ) {

						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

					}

					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

				} else {

					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
					state.bindTexture( _gl.TEXTURE_2D, null );

				}

				// Setup depth and stencil buffers

				if ( renderTarget.depthBuffer ) {

					setupDepthRenderbuffer( renderTarget );

				}

			}

			function updateRenderTargetMipmap( renderTarget ) {

				var texture = renderTarget.texture;

				if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
						texture.minFilter !== NearestFilter &&
						texture.minFilter !== LinearFilter ) {

					var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					var webglTexture = properties.get( texture ).__webglTexture;

					state.bindTexture( target, webglTexture );
					_gl.generateMipmap( target );
					state.bindTexture( target, null );

				}

			}

			this.setTexture2D = setTexture2D;
			this.setTextureCube = setTextureCube;
			this.setTextureCubeDynamic = setTextureCubeDynamic;
			this.setupRenderTarget = setupRenderTarget;
			this.updateRenderTargetMipmap = updateRenderTargetMipmap;

		}

		/**
		 * @author fordacious / fordacious.github.io
		 */

		function WebGLProperties() {

			var properties = {};

			return {

				get: function ( object ) {

					var uuid = object.uuid;
					var map = properties[ uuid ];

					if ( map === undefined ) {

						map = {};
						properties[ uuid ] = map;

					}

					return map;

				},

				delete: function ( object ) {

					delete properties[ object.uuid ];

				},

				clear: function () {

					properties = {};

				}

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLState( gl, extensions, paramThreeToGL ) {

			function ColorBuffer() {

				var locked = false;

				var color = new Vector4();
				var currentColorMask = null;
				var currentColorClear = new Vector4();

				return {

					setMask: function ( colorMask ) {

						if ( currentColorMask !== colorMask && ! locked ) {

							gl.colorMask( colorMask, colorMask, colorMask, colorMask );
							currentColorMask = colorMask;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( r, g, b, a ) {

						color.set( r, g, b, a );

						if ( currentColorClear.equals( color ) === false ) {

							gl.clearColor( r, g, b, a );
							currentColorClear.copy( color );

						}

					},

					reset: function () {

						locked = false;

						currentColorMask = null;
						currentColorClear.set( 0, 0, 0, 1 );

					}

				};

			}

			function DepthBuffer() {

				var locked = false;

				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;

				return {

					setTest: function ( depthTest ) {

						if ( depthTest ) {

							enable( gl.DEPTH_TEST );

						} else {

							disable( gl.DEPTH_TEST );

						}

					},

					setMask: function ( depthMask ) {

						if ( currentDepthMask !== depthMask && ! locked ) {

							gl.depthMask( depthMask );
							currentDepthMask = depthMask;

						}

					},

					setFunc: function ( depthFunc ) {

						if ( currentDepthFunc !== depthFunc ) {

							if ( depthFunc ) {

								switch ( depthFunc ) {

									case NeverDepth:

										gl.depthFunc( gl.NEVER );
										break;

									case AlwaysDepth:

										gl.depthFunc( gl.ALWAYS );
										break;

									case LessDepth:

										gl.depthFunc( gl.LESS );
										break;

									case LessEqualDepth:

										gl.depthFunc( gl.LEQUAL );
										break;

									case EqualDepth:

										gl.depthFunc( gl.EQUAL );
										break;

									case GreaterEqualDepth:

										gl.depthFunc( gl.GEQUAL );
										break;

									case GreaterDepth:

										gl.depthFunc( gl.GREATER );
										break;

									case NotEqualDepth:

										gl.depthFunc( gl.NOTEQUAL );
										break;

									default:

										gl.depthFunc( gl.LEQUAL );

								}

							} else {

								gl.depthFunc( gl.LEQUAL );

							}

							currentDepthFunc = depthFunc;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( depth ) {

						if ( currentDepthClear !== depth ) {

							gl.clearDepth( depth );
							currentDepthClear = depth;

						}

					},

					reset: function () {

						locked = false;

						currentDepthMask = null;
						currentDepthFunc = null;
						currentDepthClear = null;

					}

				};

			}

			function StencilBuffer() {

				var locked = false;

				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail  = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;

				return {

					setTest: function ( stencilTest ) {

						if ( stencilTest ) {

							enable( gl.STENCIL_TEST );

						} else {

							disable( gl.STENCIL_TEST );

						}

					},

					setMask: function ( stencilMask ) {

						if ( currentStencilMask !== stencilMask && ! locked ) {

							gl.stencilMask( stencilMask );
							currentStencilMask = stencilMask;

						}

					},

					setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

						if ( currentStencilFunc !== stencilFunc ||
						     currentStencilRef 	!== stencilRef 	||
						     currentStencilFuncMask !== stencilMask ) {

							gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

							currentStencilFunc = stencilFunc;
							currentStencilRef  = stencilRef;
							currentStencilFuncMask = stencilMask;

						}

					},

					setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

						if ( currentStencilFail	 !== stencilFail 	||
						     currentStencilZFail !== stencilZFail ||
						     currentStencilZPass !== stencilZPass ) {

							gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

							currentStencilFail  = stencilFail;
							currentStencilZFail = stencilZFail;
							currentStencilZPass = stencilZPass;

						}

					},

					setLocked: function ( lock ) {

						locked = lock;

					},

					setClear: function ( stencil ) {

						if ( currentStencilClear !== stencil ) {

							gl.clearStencil( stencil );
							currentStencilClear = stencil;

						}

					},

					reset: function () {

						locked = false;

						currentStencilMask = null;
						currentStencilFunc = null;
						currentStencilRef = null;
						currentStencilFuncMask = null;
						currentStencilFail = null;
						currentStencilZFail = null;
						currentStencilZPass = null;
						currentStencilClear = null;

					}

				};

			}

			//

			var colorBuffer = new ColorBuffer();
			var depthBuffer = new DepthBuffer();
			var stencilBuffer = new StencilBuffer();

			var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var newAttributes = new Uint8Array( maxVertexAttributes );
			var enabledAttributes = new Uint8Array( maxVertexAttributes );
			var attributeDivisors = new Uint8Array( maxVertexAttributes );

			var capabilities = {};

			var compressedTextureFormats = null;

			var currentBlending = null;
			var currentBlendEquation = null;
			var currentBlendSrc = null;
			var currentBlendDst = null;
			var currentBlendEquationAlpha = null;
			var currentBlendSrcAlpha = null;
			var currentBlendDstAlpha = null;
			var currentPremultipledAlpha = false;

			var currentFlipSided = null;
			var currentCullFace = null;

			var currentLineWidth = null;

			var currentPolygonOffsetFactor = null;
			var currentPolygonOffsetUnits = null;

			var currentScissorTest = null;

			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

			var currentTextureSlot = null;
			var currentBoundTextures = {};

			var currentScissor = new Vector4();
			var currentViewport = new Vector4();

			function createTexture( type, target, count ) {

				var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
				var texture = gl.createTexture();

				gl.bindTexture( type, texture );
				gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
				gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

				for ( var i = 0; i < count; i ++ ) {

					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

				}

				return texture;

			}

			var emptyTextures = {};
			emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
			emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

			//

			function init() {

				clearColor( 0, 0, 0, 1 );
				clearDepth( 1 );
				clearStencil( 0 );

				enable( gl.DEPTH_TEST );
				setDepthFunc( LessEqualDepth );

				setFlipSided( false );
				setCullFace( CullFaceBack );
				enable( gl.CULL_FACE );

				enable( gl.BLEND );
				setBlending( NormalBlending );

			}

			function initAttributes() {

				for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

					newAttributes[ i ] = 0;

				}

			}

			function enableAttribute( attribute ) {

				newAttributes[ attribute ] = 1;

				if ( enabledAttributes[ attribute ] === 0 ) {

					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;

				}

				if ( attributeDivisors[ attribute ] !== 0 ) {

					var extension = extensions.get( 'ANGLE_instanced_arrays' );

					extension.vertexAttribDivisorANGLE( attribute, 0 );
					attributeDivisors[ attribute ] = 0;

				}

			}

			function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

				newAttributes[ attribute ] = 1;

				if ( enabledAttributes[ attribute ] === 0 ) {

					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;

				}

				if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

					extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
					attributeDivisors[ attribute ] = meshPerAttribute;

				}

			}

			function disableUnusedAttributes() {

				for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

					if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;

					}

				}

			}

			function enable( id ) {

				if ( capabilities[ id ] !== true ) {

					gl.enable( id );
					capabilities[ id ] = true;

				}

			}

			function disable( id ) {

				if ( capabilities[ id ] !== false ) {

					gl.disable( id );
					capabilities[ id ] = false;

				}

			}

			function getCompressedTextureFormats() {

				if ( compressedTextureFormats === null ) {

					compressedTextureFormats = [];

					if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

						var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

						for ( var i = 0; i < formats.length; i ++ ) {

							compressedTextureFormats.push( formats[ i ] );

						}

					}

				}

				return compressedTextureFormats;

			}

			function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

				if ( blending !== NoBlending ) {

					enable( gl.BLEND );

				} else {

					disable( gl.BLEND );

				}

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( blending === AdditiveBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

						}

					} else if ( blending === SubtractiveBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

						}

					} else if ( blending === MultiplyBlending ) {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

						} else {

							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

						}

					} else {

						if ( premultipliedAlpha ) {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

						} else {

							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

						}

					}

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				if ( blending === CustomBlending ) {

					blendEquationAlpha = blendEquationAlpha || blendEquation;
					blendSrcAlpha = blendSrcAlpha || blendSrc;
					blendDstAlpha = blendDstAlpha || blendDst;

					if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

						gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

						currentBlendEquation = blendEquation;
						currentBlendEquationAlpha = blendEquationAlpha;

					}

					if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

						gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

						currentBlendSrc = blendSrc;
						currentBlendDst = blendDst;
						currentBlendSrcAlpha = blendSrcAlpha;
						currentBlendDstAlpha = blendDstAlpha;

					}

				} else {

					currentBlendEquation = null;
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendEquationAlpha = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

				}

			}

			// TODO Deprecate

			function setColorWrite( colorWrite ) {

				colorBuffer.setMask( colorWrite );

			}

			function setDepthTest( depthTest ) {

				depthBuffer.setTest( depthTest );

			}

			function setDepthWrite( depthWrite ) {

				depthBuffer.setMask( depthWrite );

			}

			function setDepthFunc( depthFunc ) {

				depthBuffer.setFunc( depthFunc );

			}

			function setStencilTest( stencilTest ) {

				stencilBuffer.setTest( stencilTest );

			}

			function setStencilWrite( stencilWrite ) {

				stencilBuffer.setMask( stencilWrite );

			}

			function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

				stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

			}

			function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

				stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

			}

			//

			function setFlipSided( flipSided ) {

				if ( currentFlipSided !== flipSided ) {

					if ( flipSided ) {

						gl.frontFace( gl.CW );

					} else {

						gl.frontFace( gl.CCW );

					}

					currentFlipSided = flipSided;

				}

			}

			function setCullFace( cullFace ) {

				if ( cullFace !== CullFaceNone ) {

					enable( gl.CULL_FACE );

					if ( cullFace !== currentCullFace ) {

						if ( cullFace === CullFaceBack ) {

							gl.cullFace( gl.BACK );

						} else if ( cullFace === CullFaceFront ) {

							gl.cullFace( gl.FRONT );

						} else {

							gl.cullFace( gl.FRONT_AND_BACK );

						}

					}

				} else {

					disable( gl.CULL_FACE );

				}

				currentCullFace = cullFace;

			}

			function setLineWidth( width ) {

				if ( width !== currentLineWidth ) {

					gl.lineWidth( width );

					currentLineWidth = width;

				}

			}

			function setPolygonOffset( polygonOffset, factor, units ) {

				if ( polygonOffset ) {

					enable( gl.POLYGON_OFFSET_FILL );

					if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

						gl.polygonOffset( factor, units );

						currentPolygonOffsetFactor = factor;
						currentPolygonOffsetUnits = units;

					}

				} else {

					disable( gl.POLYGON_OFFSET_FILL );

				}

			}

			function getScissorTest() {

				return currentScissorTest;

			}

			function setScissorTest( scissorTest ) {

				currentScissorTest = scissorTest;

				if ( scissorTest ) {

					enable( gl.SCISSOR_TEST );

				} else {

					disable( gl.SCISSOR_TEST );

				}

			}

			// texture

			function activeTexture( webglSlot ) {

				if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

				if ( currentTextureSlot !== webglSlot ) {

					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;

				}

			}

			function bindTexture( webglType, webglTexture ) {

				if ( currentTextureSlot === null ) {

					activeTexture();

				}

				var boundTexture = currentBoundTextures[ currentTextureSlot ];

				if ( boundTexture === undefined ) {

					boundTexture = { type: undefined, texture: undefined };
					currentBoundTextures[ currentTextureSlot ] = boundTexture;

				}

				if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

					gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

					boundTexture.type = webglType;
					boundTexture.texture = webglTexture;

				}

			}

			function compressedTexImage2D() {

				try {

					gl.compressedTexImage2D.apply( gl, arguments );

				} catch ( error ) {

					console.error( error );

				}

			}

			function texImage2D() {

				try {

					gl.texImage2D.apply( gl, arguments );

				} catch ( error ) {

					console.error( error );

				}

			}

			// TODO Deprecate

			function clearColor( r, g, b, a ) {

				colorBuffer.setClear( r, g, b, a );

			}

			function clearDepth( depth ) {

				depthBuffer.setClear( depth );

			}

			function clearStencil( stencil ) {

				stencilBuffer.setClear( stencil );

			}

			//

			function scissor( scissor ) {

				if ( currentScissor.equals( scissor ) === false ) {

					gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
					currentScissor.copy( scissor );

				}

			}

			function viewport( viewport ) {

				if ( currentViewport.equals( viewport ) === false ) {

					gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
					currentViewport.copy( viewport );

				}

			}

			//

			function reset() {

				for ( var i = 0; i < enabledAttributes.length; i ++ ) {

					if ( enabledAttributes[ i ] === 1 ) {

						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;

					}

				}

				capabilities = {};

				compressedTextureFormats = null;

				currentTextureSlot = null;
				currentBoundTextures = {};

				currentBlending = null;

				currentFlipSided = null;
				currentCullFace = null;

				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();

			}

			return {

				buffers: {
					color: colorBuffer,
					depth: depthBuffer,
					stencil: stencilBuffer
				},

				init: init,
				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,
				getCompressedTextureFormats: getCompressedTextureFormats,

				setBlending: setBlending,

				setColorWrite: setColorWrite,
				setDepthTest: setDepthTest,
				setDepthWrite: setDepthWrite,
				setDepthFunc: setDepthFunc,
				setStencilTest: setStencilTest,
				setStencilWrite: setStencilWrite,
				setStencilFunc: setStencilFunc,
				setStencilOp: setStencilOp,

				setFlipSided: setFlipSided,
				setCullFace: setCullFace,

				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,

				getScissorTest: getScissorTest,
				setScissorTest: setScissorTest,

				activeTexture: activeTexture,
				bindTexture: bindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,

				clearColor: clearColor,
				clearDepth: clearDepth,
				clearStencil: clearStencil,

				scissor: scissor,
				viewport: viewport,

				reset: reset

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLCapabilities( gl, extensions, parameters ) {

			var maxAnisotropy;

			function getMaxAnisotropy() {

				if ( maxAnisotropy !== undefined ) return maxAnisotropy;

				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( extension !== null ) {

					maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

				} else {

					maxAnisotropy = 0;

				}

				return maxAnisotropy;

			}

			function getMaxPrecision( precision ) {

				if ( precision === 'highp' ) {

					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

						return 'highp';

					}

					precision = 'mediump';

				}

				if ( precision === 'mediump' ) {

					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

						return 'mediump';

					}

				}

				return 'lowp';

			}

			var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
			var maxPrecision = getMaxPrecision( precision );

			if ( maxPrecision !== precision ) {

				console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
				precision = maxPrecision;

			}

			var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
			var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
			var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
			var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

			var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
			var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

			var vertexTextures = maxVertexTextures > 0;
			var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
			var floatVertexTextures = vertexTextures && floatFragmentTextures;

			return {

				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,

				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,

				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,

				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures

			};

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WebGLExtensions( gl ) {

			var extensions = {};

			return {

				get: function ( name ) {

					if ( extensions[ name ] !== undefined ) {

						return extensions[ name ];

					}

					var extension;

					switch ( name ) {

						case 'WEBGL_depth_texture':
							extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
							break;

						case 'EXT_texture_filter_anisotropic':
							extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
							break;

						case 'WEBGL_compressed_texture_s3tc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
							break;

						case 'WEBGL_compressed_texture_pvrtc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
							break;

						case 'WEBGL_compressed_texture_etc1':
							extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
							break;

						default:
							extension = gl.getExtension( name );

					}

					if ( extension === null ) {

						console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

					}

					extensions[ name ] = extension;

					return extension;

				}

			};

		}

		/**
		 * @author tschw
		 */

		function WebGLClipping() {

			var scope = this,

				globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false,

				plane = new Plane(),
				viewNormalMatrix = new Matrix3(),

				uniform = { value: null, needsUpdate: false };

			this.uniform = uniform;
			this.numPlanes = 0;
			this.numIntersection = 0;

			this.init = function( planes, enableLocalClipping, camera ) {

				var enabled =
					planes.length !== 0 ||
					enableLocalClipping ||
					// enable state of previous frame - the clipping code has to
					// run another frame in order to reset the state:
					numGlobalPlanes !== 0 ||
					localClippingEnabled;

				localClippingEnabled = enableLocalClipping;

				globalState = projectPlanes( planes, camera, 0 );
				numGlobalPlanes = planes.length;

				return enabled;

			};

			this.beginShadows = function() {

				renderingShadows = true;
				projectPlanes( null );

			};

			this.endShadows = function() {

				renderingShadows = false;
				resetGlobalState();

			};

			this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

				if ( ! localClippingEnabled ||
						planes === null || planes.length === 0 ||
						renderingShadows && ! clipShadows ) {
					// there's no local clipping

					if ( renderingShadows ) {
						// there's no global clipping

						projectPlanes( null );

					} else {

						resetGlobalState();
					}

				} else {

					var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4,

						dstArray = cache.clippingState || null;

					uniform.value = dstArray; // ensure unique state

					dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

					for ( var i = 0; i !== lGlobal; ++ i ) {

						dstArray[ i ] = globalState[ i ];

					}

					cache.clippingState = dstArray;
					this.numIntersection = clipIntersection ? this.numPlanes : 0;
					this.numPlanes += nGlobal;

				}


			};

			function resetGlobalState() {

				if ( uniform.value !== globalState ) {

					uniform.value = globalState;
					uniform.needsUpdate = numGlobalPlanes > 0;

				}

				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;

			}

			function projectPlanes( planes, camera, dstOffset, skipTransform ) {

				var nPlanes = planes !== null ? planes.length : 0,
					dstArray = null;

				if ( nPlanes !== 0 ) {

					dstArray = uniform.value;

					if ( skipTransform !== true || dstArray === null ) {

						var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;

						viewNormalMatrix.getNormalMatrix( viewMatrix );

						if ( dstArray === null || dstArray.length < flatSize ) {

							dstArray = new Float32Array( flatSize );

						}

						for ( var i = 0, i4 = dstOffset;
											i !== nPlanes; ++ i, i4 += 4 ) {

							plane.copy( planes[ i ] ).
									applyMatrix4( viewMatrix, viewNormalMatrix );

							plane.normal.toArray( dstArray, i4 );
							dstArray[ i4 + 3 ] = plane.constant;

						}

					}

					uniform.value = dstArray;
					uniform.needsUpdate = true;

				}

				scope.numPlanes = nPlanes;
				
				return dstArray;

			}

		}

		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */

		function WebGLRenderer( parameters ) {

			console.log( 'THREE.WebGLRenderer', REVISION );

			parameters = parameters || {};

			var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

			var lights = [];

			var opaqueObjects = [];
			var opaqueObjectsLastIndex = - 1;
			var transparentObjects = [];
			var transparentObjectsLastIndex = - 1;

			var morphInfluences = new Float32Array( 8 );

			var sprites = [];
			var lensFlares = [];

			// public properties

			this.domElement = _canvas;
			this.context = null;

			// clearing

			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;

			// scene graph

			this.sortObjects = true;

			// user-defined clipping

			this.clippingPlanes = [];
			this.localClippingEnabled = false;

			// physically based shading

			this.gammaFactor = 2.0;	// for backwards compatibility
			this.gammaInput = false;
			this.gammaOutput = false;

			// physical lights

			this.physicallyCorrectLights = false;

			// tone mapping

			this.toneMapping = LinearToneMapping;
			this.toneMappingExposure = 1.0;
			this.toneMappingWhitePoint = 1.0;

			// morphs

			this.maxMorphTargets = 8;
			this.maxMorphNormals = 4;

			// internal properties

			var _this = this,

			// internal state cache

			_currentProgram = null,
			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
			_currentGeometryProgram = '',
			_currentCamera = null,

			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			_currentViewport = new Vector4(),

			//

			_usedTextureUnits = 0,

			//

			_clearColor = new Color( 0x000000 ),
			_clearAlpha = 0,

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			_viewport = new Vector4( 0, 0, _width, _height ),

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			_sphere = new Sphere(),

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3(),

			// light arrays cache

			_lights = {

				hash: '',

				ambient: [ 0, 0, 0 ],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],

				shadows: []

			},

			// info

			_infoRender = {

				calls: 0,
				vertices: 0,
				faces: 0,
				points: 0

			};

			this.info = {

				render: _infoRender,
				memory: {

					geometries: 0,
					textures: 0

				},
				programs: null

			};


			// initialize

			var _gl;

			try {

				var attributes = {
					alpha: _alpha,
					depth: _depth,
					stencil: _stencil,
					antialias: _antialias,
					premultipliedAlpha: _premultipliedAlpha,
					preserveDrawingBuffer: _preserveDrawingBuffer
				};

				_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

				if ( _gl === null ) {

					if ( _canvas.getContext( 'webgl' ) !== null ) {

						throw 'Error creating WebGL context with your selected attributes.';

					} else {

						throw 'Error creating WebGL context.';

					}

				}

				// Some experimental-webgl implementations do not have getShaderPrecisionFormat

				if ( _gl.getShaderPrecisionFormat === undefined ) {

					_gl.getShaderPrecisionFormat = function () {

						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

					};

				}

				_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

			} catch ( error ) {

				console.error( 'THREE.WebGLRenderer: ' + error );

			}

			var extensions = new WebGLExtensions( _gl );

			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'ANGLE_instanced_arrays' );

			if ( extensions.get( 'OES_element_index_uint' ) ) {

				BufferGeometry.MaxIndex = 4294967296;

			}

			var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			var state = new WebGLState( _gl, extensions, paramThreeToGL );
			var properties = new WebGLProperties();
			var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
			var objects = new WebGLObjects( _gl, properties, this.info );
			var programCache = new WebGLPrograms( this, capabilities );
			var lightCache = new WebGLLights();

			this.info.programs = programCache.programs;

			var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

			//

			var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
			var backgroundCamera2 = new PerspectiveCamera();
			var backgroundPlaneMesh = new Mesh(
				new PlaneBufferGeometry( 2, 2 ),
				new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
			);
			var backgroundBoxShader = ShaderLib[ 'cube' ];
			var backgroundBoxMesh = new Mesh(
				new BoxBufferGeometry( 5, 5, 5 ),
				new ShaderMaterial( {
					uniforms: backgroundBoxShader.uniforms,
					vertexShader: backgroundBoxShader.vertexShader,
					fragmentShader: backgroundBoxShader.fragmentShader,
					side: BackSide,
					depthTest: false,
					depthWrite: false,
					fog: false
				} )
			);

			//

			function getTargetPixelRatio() {

				return _currentRenderTarget === null ? _pixelRatio : 1;

			}

			function glClearColor( r, g, b, a ) {

				if ( _premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				state.clearColor( r, g, b, a );

			}

			function setDefaultGLState() {

				state.init();

				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

			}

			function resetGLState() {

				_currentProgram = null;
				_currentCamera = null;

				_currentGeometryProgram = '';
				_currentMaterialId = - 1;

				state.reset();

			}

			setDefaultGLState();

			this.context = _gl;
			this.capabilities = capabilities;
			this.extensions = extensions;
			this.properties = properties;
			this.state = state;

			// shadow map

			var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

			this.shadowMap = shadowMap;


			// Plugins

			var spritePlugin = new SpritePlugin( this, sprites );
			var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

			// API

			this.getContext = function () {

				return _gl;

			};

			this.getContextAttributes = function () {

				return _gl.getContextAttributes();

			};

			this.forceContextLoss = function () {

				extensions.get( 'WEBGL_lose_context' ).loseContext();

			};

			this.getMaxAnisotropy = function () {

				return capabilities.getMaxAnisotropy();

			};

			this.getPrecision = function () {

				return capabilities.precision;

			};

			this.getPixelRatio = function () {

				return _pixelRatio;

			};

			this.setPixelRatio = function ( value ) {

				if ( value === undefined ) return;

				_pixelRatio = value;

				this.setSize( _viewport.z, _viewport.w, false );

			};

			this.getSize = function () {

				return {
					width: _width,
					height: _height
				};

			};

			this.setSize = function ( width, height, updateStyle ) {

				_width = width;
				_height = height;

				_canvas.width = width * _pixelRatio;
				_canvas.height = height * _pixelRatio;

				if ( updateStyle !== false ) {

					_canvas.style.width = width + 'px';
					_canvas.style.height = height + 'px';

				}

				this.setViewport( 0, 0, width, height );

			};

			this.setViewport = function ( x, y, width, height ) {

				state.viewport( _viewport.set( x, y, width, height ) );

			};

			this.setScissor = function ( x, y, width, height ) {

				state.scissor( _scissor.set( x, y, width, height ) );

			};

			this.setScissorTest = function ( boolean ) {

				state.setScissorTest( _scissorTest = boolean );

			};

			// Clearing

			this.getClearColor = function () {

				return _clearColor;

			};

			this.setClearColor = function ( color, alpha ) {

				_clearColor.set( color );

				_clearAlpha = alpha !== undefined ? alpha : 1;

				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

			};

			this.getClearAlpha = function () {

				return _clearAlpha;

			};

			this.setClearAlpha = function ( alpha ) {

				_clearAlpha = alpha;

				glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

			};

			this.clear = function ( color, depth, stencil ) {

				var bits = 0;

				if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
				if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

				_gl.clear( bits );

			};

			this.clearColor = function () {

				this.clear( true, false, false );

			};

			this.clearDepth = function () {

				this.clear( false, true, false );

			};

			this.clearStencil = function () {

				this.clear( false, false, true );

			};

			this.clearTarget = function ( renderTarget, color, depth, stencil ) {

				this.setRenderTarget( renderTarget );
				this.clear( color, depth, stencil );

			};

			// Reset

			this.resetGLState = resetGLState;

			this.dispose = function() {

				transparentObjects = [];
				transparentObjectsLastIndex = -1;
				opaqueObjects = [];
				opaqueObjectsLastIndex = -1;

				_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

			};

			// Events

			function onContextLost( event ) {

				event.preventDefault();

				resetGLState();
				setDefaultGLState();

				properties.clear();

			}

			function onMaterialDispose( event ) {

				var material = event.target;

				material.removeEventListener( 'dispose', onMaterialDispose );

				deallocateMaterial( material );

			}

			// Buffer deallocation

			function deallocateMaterial( material ) {

				releaseMaterialProgramReference( material );

				properties.delete( material );

			}


			function releaseMaterialProgramReference( material ) {

				var programInfo = properties.get( material ).program;

				material.program = undefined;

				if ( programInfo !== undefined ) {

					programCache.releaseProgram( programInfo );

				}

			}

			// Buffer rendering

			this.renderBufferImmediate = function ( object, program, material ) {

				state.initAttributes();

				var buffers = properties.get( object );

				if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
				if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
				if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
				if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

				var attributes = program.getAttributes();

				if ( object.hasPositions ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

					if ( ! material.isMeshPhongMaterial &&
					     ! material.isMeshStandardMaterial &&
					       material.shading === FlatShading ) {

						for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

							var array = object.normalArray;

							var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
							var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
							var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

							array[ i + 0 ] = nx;
							array[ i + 1 ] = ny;
							array[ i + 2 ] = nz;

							array[ i + 3 ] = nx;
							array[ i + 4 ] = ny;
							array[ i + 5 ] = nz;

							array[ i + 6 ] = nx;
							array[ i + 7 ] = ny;
							array[ i + 8 ] = nz;

						}

					}

					_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.normal );

					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasUvs && material.map ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.uv );

					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				}

				if ( object.hasColors && material.vertexColors !== NoColors ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

					state.enableAttribute( attributes.color );

					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				}

				state.disableUnusedAttributes();

				_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

				object.count = 0;

			};

			this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

				setMaterial( material );

				var program = setProgram( camera, fog, material, object );

				var updateBuffers = false;
				var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

				if ( geometryProgram !== _currentGeometryProgram ) {

					_currentGeometryProgram = geometryProgram;
					updateBuffers = true;

				}

				// morph targets

				var morphTargetInfluences = object.morphTargetInfluences;

				if ( morphTargetInfluences !== undefined ) {

					var activeInfluences = [];

					for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

						var influence = morphTargetInfluences[ i ];
						activeInfluences.push( [ influence, i ] );

					}

					activeInfluences.sort( absNumericalSort );

					if ( activeInfluences.length > 8 ) {

						activeInfluences.length = 8;

					}

					var morphAttributes = geometry.morphAttributes;

					for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

						var influence = activeInfluences[ i ];
						morphInfluences[ i ] = influence[ 0 ];

						if ( influence[ 0 ] !== 0 ) {

							var index = influence[ 1 ];

							if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
							if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

						} else {

							if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
							if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

						}

					}

					for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

						morphInfluences[ i ] = 0.0;

					}

					program.getUniforms().setValue(
							_gl, 'morphTargetInfluences', morphInfluences );

					updateBuffers = true;

				}

				//

				var index = geometry.index;
				var position = geometry.attributes.position;
				var rangeFactor = 1;

				if ( material.wireframe === true ) {

					index = objects.getWireframeAttribute( geometry );
					rangeFactor = 2;

				}

				var renderer;

				if ( index !== null ) {

					renderer = indexedBufferRenderer;
					renderer.setIndex( index );

				} else {

					renderer = bufferRenderer;

				}

				if ( updateBuffers ) {

					setupVertexAttributes( material, program, geometry );

					if ( index !== null ) {

						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

					}

				}

				//

				var dataCount = 0;

				if ( index !== null ) {

					dataCount = index.count;

				} else if ( position !== undefined ) {

					dataCount = position.count;

				}

				var rangeStart = geometry.drawRange.start * rangeFactor;
				var rangeCount = geometry.drawRange.count * rangeFactor;

				var groupStart = group !== null ? group.start * rangeFactor : 0;
				var groupCount = group !== null ? group.count * rangeFactor : Infinity;

				var drawStart = Math.max( rangeStart, groupStart );
				var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

				var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

				if ( drawCount === 0 ) return;

				//

				if ( object.isMesh ) {

					if ( material.wireframe === true ) {

						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );

					} else {

						switch ( object.drawMode ) {

							case TrianglesDrawMode:
								renderer.setMode( _gl.TRIANGLES );
								break;

							case TriangleStripDrawMode:
								renderer.setMode( _gl.TRIANGLE_STRIP );
								break;

							case TriangleFanDrawMode:
								renderer.setMode( _gl.TRIANGLE_FAN );
								break;

						}

					}


				} else if ( object.isLine ) {

					var lineWidth = material.linewidth;

					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

					state.setLineWidth( lineWidth * getTargetPixelRatio() );

					if ( object.isLineSegments ) {

						renderer.setMode( _gl.LINES );

					} else {

						renderer.setMode( _gl.LINE_STRIP );

					}

				} else if ( object.isPoints ) {

					renderer.setMode( _gl.POINTS );

				}

				if ( geometry && geometry.isInstancedBufferGeometry ) {

					if ( geometry.maxInstancedCount > 0 ) {

						renderer.renderInstances( geometry, drawStart, drawCount );

					}

				} else {

					renderer.render( drawStart, drawCount );

				}

			};

			function setupVertexAttributes( material, program, geometry, startIndex ) {

				var extension;

				if ( geometry && geometry.isInstancedBufferGeometry ) {

					extension = extensions.get( 'ANGLE_instanced_arrays' );

					if ( extension === null ) {

						console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;

					}

				}

				if ( startIndex === undefined ) startIndex = 0;

				state.initAttributes();

				var geometryAttributes = geometry.attributes;

				var programAttributes = program.getAttributes();

				var materialDefaultAttributeValues = material.defaultAttributeValues;

				for ( var name in programAttributes ) {

					var programAttribute = programAttributes[ name ];

					if ( programAttribute >= 0 ) {

						var geometryAttribute = geometryAttributes[ name ];

						if ( geometryAttribute !== undefined ) {

							var type = _gl.FLOAT;
							var array = geometryAttribute.array;
							var normalized = geometryAttribute.normalized;

							if ( array instanceof Float32Array ) {

								type = _gl.FLOAT;

							} else if ( array instanceof Float64Array ) {

								console.warn( "Unsupported data buffer format: Float64Array" );

							} else if ( array instanceof Uint16Array ) {

								type = _gl.UNSIGNED_SHORT;

							} else if ( array instanceof Int16Array ) {

								type = _gl.SHORT;

							} else if ( array instanceof Uint32Array ) {

								type = _gl.UNSIGNED_INT;

							} else if ( array instanceof Int32Array ) {

								type = _gl.INT;

							} else if ( array instanceof Int8Array ) {

								type = _gl.BYTE;

							} else if ( array instanceof Uint8Array ) {

								type = _gl.UNSIGNED_BYTE;

							}

							var size = geometryAttribute.itemSize;
							var buffer = objects.getAttributeBuffer( geometryAttribute );

							if ( geometryAttribute.isInterleavedBufferAttribute ) {

								var data = geometryAttribute.data;
								var stride = data.stride;
								var offset = geometryAttribute.offset;

								if ( data && data.isInstancedInterleavedBuffer ) {

									state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

									if ( geometry.maxInstancedCount === undefined ) {

										geometry.maxInstancedCount = data.meshPerAttribute * data.count;

									}

								} else {

									state.enableAttribute( programAttribute );

								}

								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

							} else {

								if ( geometryAttribute.isInstancedBufferAttribute ) {

									state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

									if ( geometry.maxInstancedCount === undefined ) {

										geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

									}

								} else {

									state.enableAttribute( programAttribute );

								}

								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );

							}

						} else if ( materialDefaultAttributeValues !== undefined ) {

							var value = materialDefaultAttributeValues[ name ];

							if ( value !== undefined ) {

								switch ( value.length ) {

									case 2:
										_gl.vertexAttrib2fv( programAttribute, value );
										break;

									case 3:
										_gl.vertexAttrib3fv( programAttribute, value );
										break;

									case 4:
										_gl.vertexAttrib4fv( programAttribute, value );
										break;

									default:
										_gl.vertexAttrib1fv( programAttribute, value );

								}

							}

						}

					}

				}

				state.disableUnusedAttributes();

			}

			// Sorting

			function absNumericalSort( a, b ) {

				return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

			}

			function painterSortStable( a, b ) {

				if ( a.object.renderOrder !== b.object.renderOrder ) {

					return a.object.renderOrder - b.object.renderOrder;

				} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

					return a.material.program.id - b.material.program.id;

				} else if ( a.material.id !== b.material.id ) {

					return a.material.id - b.material.id;

				} else if ( a.z !== b.z ) {

					return a.z - b.z;

				} else {

					return a.id - b.id;

				}

			}

			function reversePainterSortStable( a, b ) {

				if ( a.object.renderOrder !== b.object.renderOrder ) {

					return a.object.renderOrder - b.object.renderOrder;

				} if ( a.z !== b.z ) {

					return b.z - a.z;

				} else {

					return a.id - b.id;

				}

			}

			// Rendering

			this.render = function ( scene, camera, renderTarget, forceClear ) {

				if ( camera !== undefined && camera.isCamera !== true ) {

					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;

				}

				// reset caching for this frame

				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
				_currentCamera = null;

				// update scene graph

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

				// update camera matrices and frustum

				if ( camera.parent === null ) camera.updateMatrixWorld();

				camera.matrixWorldInverse.getInverse( camera.matrixWorld );

				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				lights.length = 0;

				opaqueObjectsLastIndex = - 1;
				transparentObjectsLastIndex = - 1;

				sprites.length = 0;
				lensFlares.length = 0;

				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

				projectObject( scene, camera );

				opaqueObjects.length = opaqueObjectsLastIndex + 1;
				transparentObjects.length = transparentObjectsLastIndex + 1;

				if ( _this.sortObjects === true ) {

					opaqueObjects.sort( painterSortStable );
					transparentObjects.sort( reversePainterSortStable );

				}

				//

				if ( _clippingEnabled ) _clipping.beginShadows();

				setupShadows( lights );

				shadowMap.render( scene, camera );

				setupLights( lights, camera );

				if ( _clippingEnabled ) _clipping.endShadows();

				//

				_infoRender.calls = 0;
				_infoRender.vertices = 0;
				_infoRender.faces = 0;
				_infoRender.points = 0;

				if ( renderTarget === undefined ) {

					renderTarget = null;

				}

				this.setRenderTarget( renderTarget );

				//

				var background = scene.background;

				if ( background === null ) {

					glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

				} else if ( background && background.isColor ) {

					glClearColor( background.r, background.g, background.b, 1 );
					forceClear = true;

				}

				if ( this.autoClear || forceClear ) {

					this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

				}

				if ( background && background.isCubeTexture ) {

					backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

					backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
					backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

					backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
					backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

					objects.update( backgroundBoxMesh );

					_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

				} else if ( background && background.isTexture ) {

					backgroundPlaneMesh.material.map = background;

					objects.update( backgroundPlaneMesh );

					_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

				}

				//

				if ( scene.overrideMaterial ) {

					var overrideMaterial = scene.overrideMaterial;

					renderObjects( opaqueObjects, scene, camera, overrideMaterial );
					renderObjects( transparentObjects, scene, camera, overrideMaterial );

				} else {

					// opaque pass (front-to-back order)

					state.setBlending( NoBlending );
					renderObjects( opaqueObjects, scene, camera );

					// transparent pass (back-to-front order)

					renderObjects( transparentObjects, scene, camera );

				}

				// custom render plugins (post pass)

				spritePlugin.render( scene, camera );
				lensFlarePlugin.render( scene, camera, _currentViewport );

				// Generate mipmap if we're using any kind of mipmap filtering

				if ( renderTarget ) {

					textures.updateRenderTargetMipmap( renderTarget );

				}

				// Ensure depth buffer writing is enabled so it can be cleared on next render

				state.setDepthTest( true );
				state.setDepthWrite( true );
				state.setColorWrite( true );

				// _gl.finish();

			};

			function pushRenderItem( object, geometry, material, z, group ) {

				var array, index;

				// allocate the next position in the appropriate array

				if ( material.transparent ) {

					array = transparentObjects;
					index = ++ transparentObjectsLastIndex;

				} else {

					array = opaqueObjects;
					index = ++ opaqueObjectsLastIndex;

				}

				// recycle existing render item or grow the array

				var renderItem = array[ index ];

				if ( renderItem !== undefined ) {

					renderItem.id = object.id;
					renderItem.object = object;
					renderItem.geometry = geometry;
					renderItem.material = material;
					renderItem.z = _vector3.z;
					renderItem.group = group;

				} else {

					renderItem = {
						id: object.id,
						object: object,
						geometry: geometry,
						material: material,
						z: _vector3.z,
						group: group
					};

					// assert( index === array.length );
					array.push( renderItem );

				}

			}

			// TODO Duplicated code (Frustum)

			function isObjectViewable( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				_sphere.copy( geometry.boundingSphere ).
					applyMatrix4( object.matrixWorld );

				return isSphereViewable( _sphere );

			}

			function isSpriteViewable( sprite ) {

				_sphere.center.set( 0, 0, 0 );
				_sphere.radius = 0.7071067811865476;
				_sphere.applyMatrix4( sprite.matrixWorld );

				return isSphereViewable( _sphere );

			}

			function isSphereViewable( sphere ) {

				if ( ! _frustum.intersectsSphere( sphere ) ) return false;

				var numPlanes = _clipping.numPlanes;

				if ( numPlanes === 0 ) return true;

				var planes = _this.clippingPlanes,

					center = sphere.center,
					negRad = - sphere.radius,
					i = 0;

				do {

					// out when deeper than radius in the negative halfspace
					if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

				} while ( ++ i !== numPlanes );

				return true;

			}

			function projectObject( object, camera ) {

				if ( object.visible === false ) return;

				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

				if ( visible ) {

					if ( object.isLight ) {

						lights.push( object );

					} else if ( object.isSprite ) {

						if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

							sprites.push( object );

						}

					} else if ( object.isLensFlare ) {

						lensFlares.push( object );

					} else if ( object.isImmediateRenderObject ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						pushRenderItem( object, null, object.material, _vector3.z, null );

					} else if ( object.isMesh || object.isLine || object.isPoints ) {

						if ( object.isSkinnedMesh ) {

							object.skeleton.update();

						}

						if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

							var material = object.material;

							if ( material.visible === true ) {

								if ( _this.sortObjects === true ) {

									_vector3.setFromMatrixPosition( object.matrixWorld );
									_vector3.applyProjection( _projScreenMatrix );

								}

								var geometry = objects.update( object );

								if ( material.isMultiMaterial ) {

									var groups = geometry.groups;
									var materials = material.materials;

									for ( var i = 0, l = groups.length; i < l; i ++ ) {

										var group = groups[ i ];
										var groupMaterial = materials[ group.materialIndex ];

										if ( groupMaterial.visible === true ) {

											pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

										}

									}

								} else {

									pushRenderItem( object, geometry, material, _vector3.z, null );

								}

							}

						}

					}

				}

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					projectObject( children[ i ], camera );

				}

			}

			function renderObjects( renderList, scene, camera, overrideMaterial ) {

				for ( var i = 0, l = renderList.length; i < l; i ++ ) {

					var renderItem = renderList[ i ];

					var object = renderItem.object;
					var geometry = renderItem.geometry;
					var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
					var group = renderItem.group;

					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

					object.onBeforeRender( _this, scene, camera, geometry, material, group );

					if ( object.isImmediateRenderObject ) {

						setMaterial( material );

						var program = setProgram( camera, scene.fog, material, object );

						_currentGeometryProgram = '';

						object.render( function ( object ) {

							_this.renderBufferImmediate( object, program, material );

						} );

					} else {

						_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

					}

					object.onAfterRender( _this, scene, camera, geometry, material, group );


				}

			}

			function initMaterial( material, fog, object ) {

				var materialProperties = properties.get( material );

				var parameters = programCache.getParameters(
						material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );

				var code = programCache.getProgramCode( material, parameters );

				var program = materialProperties.program;
				var programChange = true;

				if ( program === undefined ) {

					// new material
					material.addEventListener( 'dispose', onMaterialDispose );

				} else if ( program.code !== code ) {

					// changed glsl or parameters
					releaseMaterialProgramReference( material );

				} else if ( parameters.shaderID !== undefined ) {

					// same glsl and uniform list
					return;

				} else {

					// only rebuild uniform list
					programChange = false;

				}

				if ( programChange ) {

					if ( parameters.shaderID ) {

						var shader = ShaderLib[ parameters.shaderID ];

						materialProperties.__webglShader = {
							name: material.type,
							uniforms: UniformsUtils.clone( shader.uniforms ),
							vertexShader: shader.vertexShader,
							fragmentShader: shader.fragmentShader
						};

					} else {

						materialProperties.__webglShader = {
							name: material.type,
							uniforms: material.uniforms,
							vertexShader: material.vertexShader,
							fragmentShader: material.fragmentShader
						};

					}

					material.__webglShader = materialProperties.__webglShader;

					program = programCache.acquireProgram( material, parameters, code );

					materialProperties.program = program;
					material.program = program;

				}

				var attributes = program.getAttributes();

				if ( material.morphTargets ) {

					material.numSupportedMorphTargets = 0;

					for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

						if ( attributes[ 'morphTarget' + i ] >= 0 ) {

							material.numSupportedMorphTargets ++;

						}

					}

				}

				if ( material.morphNormals ) {

					material.numSupportedMorphNormals = 0;

					for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

						if ( attributes[ 'morphNormal' + i ] >= 0 ) {

							material.numSupportedMorphNormals ++;

						}

					}

				}

				var uniforms = materialProperties.__webglShader.uniforms;

				if ( ! material.isShaderMaterial &&
				     ! material.isRawShaderMaterial ||
				       material.clipping === true ) {

					materialProperties.numClippingPlanes = _clipping.numPlanes;
					materialProperties.numIntersection = _clipping.numIntersection;
					uniforms.clippingPlanes = _clipping.uniform;

				}

				materialProperties.fog = fog;

				// store the light setup it was created for

				materialProperties.lightsHash = _lights.hash;

				if ( material.lights ) {

					// wire up the material to this renderer's lighting state

					uniforms.ambientLightColor.value = _lights.ambient;
					uniforms.directionalLights.value = _lights.directional;
					uniforms.spotLights.value = _lights.spot;
					uniforms.pointLights.value = _lights.point;
					uniforms.hemisphereLights.value = _lights.hemi;

					uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
					uniforms.spotShadowMap.value = _lights.spotShadowMap;
					uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
					uniforms.pointShadowMap.value = _lights.pointShadowMap;
					uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

				}

				var progUniforms = materialProperties.program.getUniforms(),
					uniformsList =
							WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

				materialProperties.uniformsList = uniformsList;

			}

			function setMaterial( material ) {

				material.side === DoubleSide
					? state.disable( _gl.CULL_FACE )
					: state.enable( _gl.CULL_FACE );

				state.setFlipSided( material.side === BackSide );

				material.transparent === true
					? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
					: state.setBlending( NoBlending );

				state.setDepthFunc( material.depthFunc );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
				state.setColorWrite( material.colorWrite );
				state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			function setProgram( camera, fog, material, object ) {

				_usedTextureUnits = 0;

				var materialProperties = properties.get( material );

				if ( _clippingEnabled ) {

					if ( _localClippingEnabled || camera !== _currentCamera ) {

						var useCache =
								camera === _currentCamera &&
								material.id === _currentMaterialId;

						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						_clipping.setState(
								material.clippingPlanes, material.clipIntersection, material.clipShadows,
								camera, materialProperties, useCache );

					}

				}

				if ( material.needsUpdate === false ) {

					if ( materialProperties.program === undefined ) {

						material.needsUpdate = true;

					} else if ( material.fog && materialProperties.fog !== fog ) {

						material.needsUpdate = true;

					} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

						material.needsUpdate = true;

					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== _clipping.numPlanes || 
		 				  materialProperties.numIntersection  !== _clipping.numIntersection ) ) {

						material.needsUpdate = true;

					}

				}

				if ( material.needsUpdate ) {

					initMaterial( material, fog, object );
					material.needsUpdate = false;

				}

				var refreshProgram = false;
				var refreshMaterial = false;
				var refreshLights = false;

				var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.__webglShader.uniforms;

				if ( program.id !== _currentProgram ) {

					_gl.useProgram( program.program );
					_currentProgram = program.id;

					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;

				}

				if ( material.id !== _currentMaterialId ) {

					_currentMaterialId = material.id;

					refreshMaterial = true;

				}

				if ( refreshProgram || camera !== _currentCamera ) {

					p_uniforms.set( _gl, camera, 'projectionMatrix' );

					if ( capabilities.logarithmicDepthBuffer ) {

						p_uniforms.setValue( _gl, 'logDepthBufFC',
								2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

					}


					if ( camera !== _currentCamera ) {

						_currentCamera = camera;

						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:

						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done

					}

					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)

					if ( material.isShaderMaterial ||
					     material.isMeshPhongMaterial ||
					     material.isMeshStandardMaterial ||
					     material.envMap ) {

						var uCamPos = p_uniforms.map.cameraPosition;

						if ( uCamPos !== undefined ) {

							uCamPos.setValue( _gl,
									_vector3.setFromMatrixPosition( camera.matrixWorld ) );

						}

					}

					if ( material.isMeshPhongMaterial ||
					     material.isMeshLambertMaterial ||
					     material.isMeshBasicMaterial ||
					     material.isMeshStandardMaterial ||
					     material.isShaderMaterial ||
					     material.skinning ) {

						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

					}

					p_uniforms.set( _gl, _this, 'toneMappingExposure' );
					p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

				}

				// skinning uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone texture must go before other textures
				// not sure why, but otherwise weird things happen

				if ( material.skinning ) {

					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

					var skeleton = object.skeleton;

					if ( skeleton ) {

						if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

							p_uniforms.set( _gl, skeleton, 'boneTexture' );
							p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
							p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

						} else {

							p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

						}

					}

				}

				if ( refreshMaterial ) {

					if ( material.lights ) {

						// the current material requires lighting info

						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required

						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

					}

					// refresh uniforms common to several materials

					if ( fog && material.fog ) {

						refreshUniformsFog( m_uniforms, fog );

					}

					if ( material.isMeshBasicMaterial ||
					     material.isMeshLambertMaterial ||
					     material.isMeshPhongMaterial ||
					     material.isMeshStandardMaterial ||
					     material.isMeshDepthMaterial ) {

						refreshUniformsCommon( m_uniforms, material );

					}

					// refresh single material specific uniforms

					if ( material.isLineBasicMaterial ) {

						refreshUniformsLine( m_uniforms, material );

					} else if ( material.isLineDashedMaterial ) {

						refreshUniformsLine( m_uniforms, material );
						refreshUniformsDash( m_uniforms, material );

					} else if ( material.isPointsMaterial ) {

						refreshUniformsPoints( m_uniforms, material );

					} else if ( material.isMeshLambertMaterial ) {

						refreshUniformsLambert( m_uniforms, material );

					} else if ( material.isMeshPhongMaterial ) {

						refreshUniformsPhong( m_uniforms, material );

					} else if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else if ( material.isMeshStandardMaterial ) {

						refreshUniformsStandard( m_uniforms, material );

					} else if ( material.isMeshDepthMaterial ) {

						if ( material.displacementMap ) {

							m_uniforms.displacementMap.value = material.displacementMap;
							m_uniforms.displacementScale.value = material.displacementScale;
							m_uniforms.displacementBias.value = material.displacementBias;

						}

					} else if ( material.isMeshNormalMaterial ) {

						m_uniforms.opacity.value = material.opacity;

					}

					WebGLUniforms.upload(
							_gl, materialProperties.uniformsList, m_uniforms, _this );

				}


				// common matrices

				p_uniforms.set( _gl, object, 'modelViewMatrix' );
				p_uniforms.set( _gl, object, 'normalMatrix' );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

				return program;

			}

			// Uniforms (refresh uniforms objects)

			function refreshUniformsCommon( uniforms, material ) {

				uniforms.opacity.value = material.opacity;

				uniforms.diffuse.value = material.color;

				if ( material.emissive ) {

					uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

				}

				uniforms.map.value = material.map;
				uniforms.specularMap.value = material.specularMap;
				uniforms.alphaMap.value = material.alphaMap;

				if ( material.aoMap ) {

					uniforms.aoMap.value = material.aoMap;
					uniforms.aoMapIntensity.value = material.aoMapIntensity;

				}

				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map

				var uvScaleMap;

				if ( material.map ) {

					uvScaleMap = material.map;

				} else if ( material.specularMap ) {

					uvScaleMap = material.specularMap;

				} else if ( material.displacementMap ) {

					uvScaleMap = material.displacementMap;

				} else if ( material.normalMap ) {

					uvScaleMap = material.normalMap;

				} else if ( material.bumpMap ) {

					uvScaleMap = material.bumpMap;

				} else if ( material.roughnessMap ) {

					uvScaleMap = material.roughnessMap;

				} else if ( material.metalnessMap ) {

					uvScaleMap = material.metalnessMap;

				} else if ( material.alphaMap ) {

					uvScaleMap = material.alphaMap;

				} else if ( material.emissiveMap ) {

					uvScaleMap = material.emissiveMap;

				}

				if ( uvScaleMap !== undefined ) {

					// backwards compatibility
					if ( uvScaleMap.isWebGLRenderTarget ) {

						uvScaleMap = uvScaleMap.texture;

					}

					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;

					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

				}

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

			}

			function refreshUniformsLine( uniforms, material ) {

				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;

			}

			function refreshUniformsDash( uniforms, material ) {

				uniforms.dashSize.value = material.dashSize;
				uniforms.totalSize.value = material.dashSize + material.gapSize;
				uniforms.scale.value = material.scale;

			}

			function refreshUniformsPoints( uniforms, material ) {

				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
				uniforms.size.value = material.size * _pixelRatio;
				uniforms.scale.value = _height * 0.5;

				uniforms.map.value = material.map;

				if ( material.map !== null ) {

					var offset = material.map.offset;
					var repeat = material.map.repeat;

					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

				}

			}

			function refreshUniformsFog( uniforms, fog ) {

				uniforms.fogColor.value = fog.color;

				if ( fog.isFog ) {

					uniforms.fogNear.value = fog.near;
					uniforms.fogFar.value = fog.far;

				} else if ( fog.isFogExp2 ) {

					uniforms.fogDensity.value = fog.density;

				}

			}

			function refreshUniformsLambert( uniforms, material ) {

				if ( material.lightMap ) {

					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

			}

			function refreshUniformsPhong( uniforms, material ) {

				uniforms.specular.value = material.specular;
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

				if ( material.lightMap ) {

					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

			}

			function refreshUniformsStandard( uniforms, material ) {

				uniforms.roughness.value = material.roughness;
				uniforms.metalness.value = material.metalness;

				if ( material.roughnessMap ) {

					uniforms.roughnessMap.value = material.roughnessMap;

				}

				if ( material.metalnessMap ) {

					uniforms.metalnessMap.value = material.metalnessMap;

				}

				if ( material.lightMap ) {

					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;

				}

				if ( material.emissiveMap ) {

					uniforms.emissiveMap.value = material.emissiveMap;

				}

				if ( material.bumpMap ) {

					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;

				}

				if ( material.normalMap ) {

					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );

				}

				if ( material.displacementMap ) {

					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;

				}

				if ( material.envMap ) {

					//uniforms.envMap.value = material.envMap; // part of uniforms common
					uniforms.envMapIntensity.value = material.envMapIntensity;

				}

			}

			function refreshUniformsPhysical( uniforms, material ) {

				uniforms.clearCoat.value = material.clearCoat;
				uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

				refreshUniformsStandard( uniforms, material );

			}

			// If uniforms are marked as clean, they don't need to be loaded to the GPU.

			function markUniformsLightsNeedsUpdate( uniforms, value ) {

				uniforms.ambientLightColor.needsUpdate = value;

				uniforms.directionalLights.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;

			}

			// Lighting

			function setupShadows( lights ) {

				var lightShadowsLength = 0;

				for ( var i = 0, l = lights.length; i < l; i ++ ) {

					var light = lights[ i ];

					if ( light.castShadow ) {

						_lights.shadows[ lightShadowsLength ++ ] = light;

					}

				}

				_lights.shadows.length = lightShadowsLength;

			}

			function setupLights( lights, camera ) {

				var l, ll, light,
				r = 0, g = 0, b = 0,
				color,
				intensity,
				distance,
				shadowMap,

				viewMatrix = camera.matrixWorldInverse,

				directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				hemiLength = 0;

				for ( l = 0, ll = lights.length; l < ll; l ++ ) {

					light = lights[ l ];

					color = light.color;
					intensity = light.intensity;
					distance = light.distance;

					shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

					if ( light.isAmbientLight ) {

						r += color.r * intensity;
						g += color.g * intensity;
						b += color.b * intensity;

					} else if ( light.isDirectionalLight ) {

						var uniforms = lightCache.get( light );

						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;

						}

						_lights.directionalShadowMap[ directionalLength ] = shadowMap;
						_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
						_lights.directional[ directionalLength ++ ] = uniforms;

					} else if ( light.isSpotLight ) {

						var uniforms = lightCache.get( light );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						uniforms.color.copy( color ).multiplyScalar( intensity );
						uniforms.distance = distance;

						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );

						uniforms.coneCos = Math.cos( light.angle );
						uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;

						}

						_lights.spotShadowMap[ spotLength ] = shadowMap;
						_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
						_lights.spot[ spotLength ++ ] = uniforms;

					} else if ( light.isPointLight ) {

						var uniforms = lightCache.get( light );

						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );

						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.distance = light.distance;
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

						uniforms.shadow = light.castShadow;

						if ( light.castShadow ) {

							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;

						}

						_lights.pointShadowMap[ pointLength ] = shadowMap;

						if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

							_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

						}

						// for point lights we set the shadow matrix to be a translation-only matrix
						// equal to inverse of the light's position
						_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
						_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

						_lights.point[ pointLength ++ ] = uniforms;

					} else if ( light.isHemisphereLight ) {

						var uniforms = lightCache.get( light );

						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						uniforms.direction.transformDirection( viewMatrix );
						uniforms.direction.normalize();

						uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
						uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

						_lights.hemi[ hemiLength ++ ] = uniforms;

					}

				}

				_lights.ambient[ 0 ] = r;
				_lights.ambient[ 1 ] = g;
				_lights.ambient[ 2 ] = b;

				_lights.directional.length = directionalLength;
				_lights.spot.length = spotLength;
				_lights.point.length = pointLength;
				_lights.hemi.length = hemiLength;

				_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

			}

			// GL state setting

			this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

				state.setCullFace( cullFace );
				state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

			};

			// Textures

			function allocTextureUnit() {

				var textureUnit = _usedTextureUnits;

				if ( textureUnit >= capabilities.maxTextures ) {

					console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

				}

				_usedTextureUnits += 1;

				return textureUnit;

			}

			this.allocTextureUnit = allocTextureUnit;

			// this.setTexture2D = setTexture2D;
			this.setTexture2D = ( function() {

				var warned = false;

				// backwards compatibility: peel texture.texture
				return function setTexture2D( texture, slot ) {

					if ( texture && texture.isWebGLRenderTarget ) {

						if ( ! warned ) {

							console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
							warned = true;

						}

						texture = texture.texture;

					}

					textures.setTexture2D( texture, slot );

				};

			}() );

			this.setTexture = ( function() {

				var warned = false;

				return function setTexture( texture, slot ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
						warned = true;

					}

					textures.setTexture2D( texture, slot );

				};

			}() );

			this.setTextureCube = ( function() {

				var warned = false;

				return function setTextureCube( texture, slot ) {

					// backwards compatibility: peel texture.texture
					if ( texture && texture.isWebGLRenderTargetCube ) {

						if ( ! warned ) {

							console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
							warned = true;

						}

						texture = texture.texture;

					}

					// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
					// TODO: unify these code paths
					if ( ( texture && texture.isCubeTexture ) ||
						 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

						// CompressedTexture can have Array in image :/

						// this function alone should take care of cube textures
						textures.setTextureCube( texture, slot );

					} else {

						// assumed: texture property of THREE.WebGLRenderTargetCube

						textures.setTextureCubeDynamic( texture, slot );

					}

				};

			}() );

			this.getCurrentRenderTarget = function() {

				return _currentRenderTarget;

			};

			this.setRenderTarget = function ( renderTarget ) {

				_currentRenderTarget = renderTarget;

				if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

					textures.setupRenderTarget( renderTarget );

				}

				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				var framebuffer;

				if ( renderTarget ) {

					var renderTargetProperties = properties.get( renderTarget );

					if ( isCube ) {

						framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

					} else {

						framebuffer = renderTargetProperties.__webglFramebuffer;

					}

					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;

					_currentViewport.copy( renderTarget.viewport );

				} else {

					framebuffer = null;

					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
					_currentScissorTest = _scissorTest;

					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

				}

				if ( _currentFramebuffer !== framebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
					_currentFramebuffer = framebuffer;

				}

				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );

				state.viewport( _currentViewport );

				if ( isCube ) {

					var textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

				}

			};

			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

				if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;

				}

				var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( framebuffer ) {

					var restore = false;

					if ( framebuffer !== _currentFramebuffer ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

						restore = true;

					}

					try {

						var texture = renderTarget.texture;
						var textureFormat = texture.format;
						var textureType = texture.type;

						if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;

						}

						if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						     ! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						     ! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;

						}

						if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

							// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

							if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

								_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

							}

						} else {

							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

						}

					} finally {

						if ( restore ) {

							_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

						}

					}

				}

			};

			// Map three.js constants to WebGL constants

			function paramThreeToGL( p ) {

				var extension;

				if ( p === RepeatWrapping ) return _gl.REPEAT;
				if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
				if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

				if ( p === NearestFilter ) return _gl.NEAREST;
				if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
				if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

				if ( p === LinearFilter ) return _gl.LINEAR;
				if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
				if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

				if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
				if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
				if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
				if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

				if ( p === ByteType ) return _gl.BYTE;
				if ( p === ShortType ) return _gl.SHORT;
				if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
				if ( p === IntType ) return _gl.INT;
				if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
				if ( p === FloatType ) return _gl.FLOAT;

				if ( p === HalfFloatType ) {

					extension = extensions.get( 'OES_texture_half_float' );

					if ( extension !== null ) return extension.HALF_FLOAT_OES;

				}

				if ( p === AlphaFormat ) return _gl.ALPHA;
				if ( p === RGBFormat ) return _gl.RGB;
				if ( p === RGBAFormat ) return _gl.RGBA;
				if ( p === LuminanceFormat ) return _gl.LUMINANCE;
				if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
				if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
				if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

				if ( p === AddEquation ) return _gl.FUNC_ADD;
				if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
				if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

				if ( p === ZeroFactor ) return _gl.ZERO;
				if ( p === OneFactor ) return _gl.ONE;
				if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
				if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
				if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
				if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
				if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
				if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

				if ( p === DstColorFactor ) return _gl.DST_COLOR;
				if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
				if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

				if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
					p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

					if ( extension !== null ) {

						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

					}

				}

				if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
					 p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

					if ( extension !== null ) {

						if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
						if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
						if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
						if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

					}

				}

				if ( p === RGB_ETC1_Format ) {

					extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

					if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

				}

				if ( p === MinEquation || p === MaxEquation ) {

					extension = extensions.get( 'EXT_blend_minmax' );

					if ( extension !== null ) {

						if ( p === MinEquation ) return extension.MIN_EXT;
						if ( p === MaxEquation ) return extension.MAX_EXT;

					}

				}

				if ( p === UnsignedInt248Type ) {

					extension = extensions.get( 'WEBGL_depth_texture' );

					if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

				}

				return 0;

			}

		}

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function FogExp2 ( color, density ) {

			this.name = '';

			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;

		}

		FogExp2.prototype.isFogExp2 = true;

		FogExp2.prototype.clone = function () {

			return new FogExp2( this.color.getHex(), this.density );

		};

		FogExp2.prototype.toJSON = function ( meta ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Fog ( color, near, far ) {

			this.name = '';

			this.color = new Color( color );

			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;

		}

		Fog.prototype.isFog = true;

		Fog.prototype.clone = function () {

			return new Fog( this.color.getHex(), this.near, this.far );

		};

		Fog.prototype.toJSON = function ( meta ) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Scene () {

			Object3D.call( this );

			this.type = 'Scene';

			this.background = null;
			this.fog = null;
			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

		}

		Scene.prototype = Object.create( Object3D.prototype );

		Scene.prototype.constructor = Scene;

		Scene.prototype.copy = function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		};

		Scene.prototype.toJSON = function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function LensFlare( texture, size, distance, blending, color ) {

			Object3D.call( this );

			this.lensFlares = [];

			this.positionScreen = new Vector3();
			this.customUpdateCallback = undefined;

			if ( texture !== undefined ) {

				this.add( texture, size, distance, blending, color );

			}

		}

		LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: LensFlare,

			isLensFlare: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.positionScreen.copy( source.positionScreen );
				this.customUpdateCallback = source.customUpdateCallback;

				for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

					this.lensFlares.push( source.lensFlares[ i ] );

				}

				return this;

			},

			add: function ( texture, size, distance, blending, color, opacity ) {

				if ( size === undefined ) size = - 1;
				if ( distance === undefined ) distance = 0;
				if ( opacity === undefined ) opacity = 1;
				if ( color === undefined ) color = new Color( 0xffffff );
				if ( blending === undefined ) blending = NormalBlending;

				distance = Math.min( distance, Math.max( 0, distance ) );

				this.lensFlares.push( {
					texture: texture,	// THREE.Texture
					size: size, 		// size in pixels (-1 = use texture.width)
					distance: distance, 	// distance (0-1) from light source (0=at light source)
					x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
					scale: 1, 		// scale
					rotation: 0, 		// rotation
					opacity: opacity,	// opacity
					color: color,		// color
					blending: blending	// blending
				} );

			},

			/*
			 * Update lens flares update positions on all flares based on the screen position
			 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
			 */

			updateLensFlares: function () {

				var f, fl = this.lensFlares.length;
				var flare;
				var vecX = - this.positionScreen.x * 2;
				var vecY = - this.positionScreen.y * 2;

				for ( f = 0; f < fl; f ++ ) {

					flare = this.lensFlares[ f ];

					flare.x = this.positionScreen.x + vecX * flare.distance;
					flare.y = this.positionScreen.y + vecY * flare.distance;

					flare.wantedRotation = flare.x * Math.PI * 0.25;
					flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

				}

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *	uvOffset: new THREE.Vector2(),
		 *	uvScale: new THREE.Vector2()
		 * }
		 */

		function SpriteMaterial( parameters ) {

			Material.call( this );

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );
			this.map = null;

			this.rotation = 0;

			this.fog = false;
			this.lights = false;

			this.setValues( parameters );

		}

		SpriteMaterial.prototype = Object.create( Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;

		SpriteMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.map = source.map;

			this.rotation = source.rotation;

			return this;

		};

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Sprite( material ) {

			Object3D.call( this );

			this.type = 'Sprite';

			this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		}

		Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Sprite,

			isSprite: true,

			raycast: ( function () {

				var matrixPosition = new Vector3();

				return function raycast( raycaster, intersects ) {

					matrixPosition.setFromMatrixPosition( this.matrixWorld );

					var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
					var guessSizeSq = this.scale.x * this.scale.y / 4;

					if ( distanceSq > guessSizeSq ) {

						return;

					}

					intersects.push( {

						distance: Math.sqrt( distanceSq ),
						point: this.position,
						face: null,
						object: this

					} );

				};

			}() ),

			clone: function () {

				return new this.constructor( this.material ).copy( this );

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LOD() {

			Object3D.call( this );

			this.type = 'LOD';

			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				}
			} );

		}


		LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: LOD,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source, false );

				var levels = source.levels;

				for ( var i = 0, l = levels.length; i < l; i ++ ) {

					var level = levels[ i ];

					this.addLevel( level.object.clone(), level.distance );

				}

				return this;

			},

			addLevel: function ( object, distance ) {

				if ( distance === undefined ) distance = 0;

				distance = Math.abs( distance );

				var levels = this.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					if ( distance < levels[ l ].distance ) {

						break;

					}

				}

				levels.splice( l, 0, { distance: distance, object: object } );

				this.add( object );

			},

			getObjectForDistance: function ( distance ) {

				var levels = this.levels;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance < levels[ i ].distance ) {

						break;

					}

				}

				return levels[ i - 1 ].object;

			},

			raycast: ( function () {

				var matrixPosition = new Vector3();

				return function raycast( raycaster, intersects ) {

					matrixPosition.setFromMatrixPosition( this.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( matrixPosition );

					this.getObjectForDistance( distance ).raycast( raycaster, intersects );

				};

			}() ),

			update: function () {

				var v1 = new Vector3();
				var v2 = new Vector3();

				return function update( camera ) {

					var levels = this.levels;

					if ( levels.length > 1 ) {

						v1.setFromMatrixPosition( camera.matrixWorld );
						v2.setFromMatrixPosition( this.matrixWorld );

						var distance = v1.distanceTo( v2 );

						levels[ 0 ].object.visible = true;

						for ( var i = 1, l = levels.length; i < l; i ++ ) {

							if ( distance >= levels[ i ].distance ) {

								levels[ i - 1 ].object.visible = false;
								levels[ i ].object.visible = true;

							} else {

								break;

							}

						}

						for ( ; i < l; i ++ ) {

							levels[ i ].object.visible = false;

						}

					}

				};

			}(),

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.levels = [];

				var levels = this.levels;

				for ( var i = 0, l = levels.length; i < l; i ++ ) {

					var level = levels[ i ];

					data.object.levels.push( {
						object: level.object.uuid,
						distance: level.distance
					} );

				}

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { data: data, width: width, height: height };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.generateMipmaps  = false;
			this.flipY = false;
			this.unpackAlignment = 1;

		}

		DataTexture.prototype = Object.create( Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;

		DataTexture.prototype.isDataTexture = true;

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author michael guerrero / http://realitymeltdown.com
		 * @author ikerr / http://verold.com
		 */

		function Skeleton( bones, boneInverses, useVertexTexture ) {

			this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

			this.identityMatrix = new Matrix4();

			// copy the bone array

			bones = bones || [];

			this.bones = bones.slice( 0 );

			// create a bone texture or an array of floats

			if ( this.useVertexTexture ) {

				// layout (1 matrix = 4 pixels)
				//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
				//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
				//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
				//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
				//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


				var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
				size = _Math.nextPowerOfTwo( Math.ceil( size ) );
				size = Math.max( size, 4 );

				this.boneTextureWidth = size;
				this.boneTextureHeight = size;

				this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
				this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

			} else {

				this.boneMatrices = new Float32Array( 16 * this.bones.length );

			}

			// use the supplied bone inverses or calculate the inverses

			if ( boneInverses === undefined ) {

				this.calculateInverses();

			} else {

				if ( this.bones.length === boneInverses.length ) {

					this.boneInverses = boneInverses.slice( 0 );

				} else {

					console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

					this.boneInverses = [];

					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

						this.boneInverses.push( new Matrix4() );

					}

				}

			}

		}

		Object.assign( Skeleton.prototype, {

			calculateInverses: function () {

				this.boneInverses = [];

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					var inverse = new Matrix4();

					if ( this.bones[ b ] ) {

						inverse.getInverse( this.bones[ b ].matrixWorld );

					}

					this.boneInverses.push( inverse );

				}

			},

			pose: function () {

				var bone;

				// recover the bind-time world matrices

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					bone = this.bones[ b ];

					if ( bone ) {

						bone.matrixWorld.getInverse( this.boneInverses[ b ] );

					}

				}

				// compute the local matrices, positions, rotations and scales

				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

					bone = this.bones[ b ];

					if ( bone ) {

						if ( (bone.parent && bone.parent.isBone) ) {

							bone.matrix.getInverse( bone.parent.matrixWorld );
							bone.matrix.multiply( bone.matrixWorld );

						} else {

							bone.matrix.copy( bone.matrixWorld );

						}

						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

					}

				}

			},

			update: ( function () {

				var offsetMatrix = new Matrix4();

				return function update() {

					// flatten bone matrices to array

					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

						// compute the offset between the current and the original transform

						var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

						offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
						offsetMatrix.toArray( this.boneMatrices, b * 16 );

					}

					if ( this.useVertexTexture ) {

						this.boneTexture.needsUpdate = true;

					}

				};

			} )(),

			clone: function () {

				return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */

		function Bone( skin ) {

			Object3D.call( this );

			this.type = 'Bone';

			this.skin = skin;

		}

		Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Bone,

			isBone: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.skin = source.skin;

				return this;

			}

		} );

		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */

		function SkinnedMesh( geometry, material, useVertexTexture ) {

			Mesh.call( this, geometry, material );

			this.type = 'SkinnedMesh';

			this.bindMode = "attached";
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();

			// init bones

			// TODO: remove bone creation as there is no reason (other than
			// convenience) for THREE.SkinnedMesh to do this.

			var bones = [];

			if ( this.geometry && this.geometry.bones !== undefined ) {

				var bone, gbone;

				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

					gbone = this.geometry.bones[ b ];

					bone = new Bone( this );
					bones.push( bone );

					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

				}

				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

					gbone = this.geometry.bones[ b ];

					if ( gbone.parent !== - 1 && gbone.parent !== null &&
							bones[ gbone.parent ] !== undefined ) {

						bones[ gbone.parent ].add( bones[ b ] );

					} else {

						this.add( bones[ b ] );

					}

				}

			}

			this.normalizeSkinWeights();

			this.updateMatrixWorld( true );
			this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

		}


		SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

			constructor: SkinnedMesh,

			isSkinnedMesh: true,

			bind: function( skeleton, bindMatrix ) {

				this.skeleton = skeleton;

				if ( bindMatrix === undefined ) {

					this.updateMatrixWorld( true );

					this.skeleton.calculateInverses();

					bindMatrix = this.matrixWorld;

				}

				this.bindMatrix.copy( bindMatrix );
				this.bindMatrixInverse.getInverse( bindMatrix );

			},

			pose: function () {

				this.skeleton.pose();

			},

			normalizeSkinWeights: function () {

				if ( (this.geometry && this.geometry.isGeometry) ) {

					for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

						var sw = this.geometry.skinWeights[ i ];

						var scale = 1.0 / sw.lengthManhattan();

						if ( scale !== Infinity ) {

							sw.multiplyScalar( scale );

						} else {

							sw.set( 1, 0, 0, 0 ); // do something reasonable

						}

					}

				} else if ( (this.geometry && this.geometry.isBufferGeometry) ) {

					var vec = new Vector4();

					var skinWeight = this.geometry.attributes.skinWeight;

					for ( var i = 0; i < skinWeight.count; i ++ ) {

						vec.x = skinWeight.getX( i );
						vec.y = skinWeight.getY( i );
						vec.z = skinWeight.getZ( i );
						vec.w = skinWeight.getW( i );

						var scale = 1.0 / vec.lengthManhattan();

						if ( scale !== Infinity ) {

							vec.multiplyScalar( scale );

						} else {

							vec.set( 1, 0, 0, 0 ); // do something reasonable

						}

						skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

					}

				}

			},

			updateMatrixWorld: function( force ) {

				Mesh.prototype.updateMatrixWorld.call( this, true );

				if ( this.bindMode === "attached" ) {

					this.bindMatrixInverse.getInverse( this.matrixWorld );

				} else if ( this.bindMode === "detached" ) {

					this.bindMatrixInverse.getInverse( this.bindMatrix );

				} else {

					console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

				}

			},

			clone: function() {

				return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */

		function LineBasicMaterial( parameters ) {

			Material.call( this );

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.lights = false;

			this.setValues( parameters );

		}

		LineBasicMaterial.prototype = Object.create( Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;

		LineBasicMaterial.prototype.isLineBasicMaterial = true;

		LineBasicMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Line( geometry, material, mode ) {

			if ( mode === 1 ) {

				console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
				return new LineSegments( geometry, material );

			}

			Object3D.call( this );

			this.type = 'Line';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

		}

		Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Line,

			isLine: true,

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				return function raycast( raycaster, intersects ) {

					var precision = raycaster.linePrecision;
					var precisionSq = precision * precision;

					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					var vStart = new Vector3();
					var vEnd = new Vector3();
					var interSegment = new Vector3();
					var interRay = new Vector3();
					var step = (this && this.isLineSegments) ? 2 : 1;

					if ( (geometry && geometry.isBufferGeometry) ) {

						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;

						if ( index !== null ) {

							var indices = index.array;

							for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

								var a = indices[ i ];
								var b = indices[ i + 1 ];

								vStart.fromArray( positions, a * 3 );
								vEnd.fromArray( positions, b * 3 );

								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

								if ( distSq > precisionSq ) continue;

								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

								var distance = raycaster.ray.origin.distanceTo( interRay );

								if ( distance < raycaster.near || distance > raycaster.far ) continue;

								intersects.push( {

									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this

								} );

							}

						} else {

							for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

								vStart.fromArray( positions, 3 * i );
								vEnd.fromArray( positions, 3 * i + 3 );

								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

								if ( distSq > precisionSq ) continue;

								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

								var distance = raycaster.ray.origin.distanceTo( interRay );

								if ( distance < raycaster.near || distance > raycaster.far ) continue;

								intersects.push( {

									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this

								} );

							}

						}

					} else if ( (geometry && geometry.isGeometry) ) {

						var vertices = geometry.vertices;
						var nbVertices = vertices.length;

						for ( var i = 0; i < nbVertices - 1; i += step ) {

							var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LineSegments( geometry, material ) {

			Line.call( this, geometry, material );

			this.type = 'LineSegments';

		}

		LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

			constructor: LineSegments,

			isLineSegments: true

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */

		function PointsMaterial( parameters ) {

			Material.call( this );

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.lights = false;

			this.setValues( parameters );

		}

		PointsMaterial.prototype = Object.create( Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;

		PointsMaterial.prototype.isPointsMaterial = true;

		PointsMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Points( geometry, material ) {

			Object3D.call( this );

			this.type = 'Points';

			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

		}

		Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Points,

			isPoints: true,

			raycast: ( function () {

				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();

				return function raycast( raycaster, intersects ) {

					var object = this;
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
					var threshold = raycaster.params.Points.threshold;

					// Checking boundingSphere distance to ray

					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );

					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

					//

					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

					var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
					var localThresholdSq = localThreshold * localThreshold;
					var position = new Vector3();

					function testPoint( point, index ) {

						var rayPointDistanceSq = ray.distanceSqToPoint( point );

						if ( rayPointDistanceSq < localThresholdSq ) {

							var intersectPoint = ray.closestPointToPoint( point );
							intersectPoint.applyMatrix4( matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectPoint );

							if ( distance < raycaster.near || distance > raycaster.far ) return;

							intersects.push( {

								distance: distance,
								distanceToRay: Math.sqrt( rayPointDistanceSq ),
								point: intersectPoint.clone(),
								index: index,
								face: null,
								object: object

							} );

						}

					}

					if ( (geometry && geometry.isBufferGeometry) ) {

						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;

						if ( index !== null ) {

							var indices = index.array;

							for ( var i = 0, il = indices.length; i < il; i ++ ) {

								var a = indices[ i ];

								position.fromArray( positions, a * 3 );

								testPoint( position, a );

							}

						} else {

							for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

								position.fromArray( positions, i * 3 );

								testPoint( position, i );

							}

						}

					} else {

						var vertices = geometry.vertices;

						for ( var i = 0, l = vertices.length; i < l; i ++ ) {

							testPoint( vertices[ i ], i );

						}

					}

				};

			}() ),

			clone: function () {

				return new this.constructor( this.geometry, this.material ).copy( this );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Group() {

			Object3D.call( this );

			this.type = 'Group';

		}

		Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Group

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.generateMipmaps = false;

			var scope = this;

			function update() {

				requestAnimationFrame( update );

				if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

					scope.needsUpdate = true;

				}

			}

			update();

		}

		VideoTexture.prototype = Object.create( Texture.prototype );
		VideoTexture.prototype.constructor = VideoTexture;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false;

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;

		}

		CompressedTexture.prototype = Object.create( Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;

		CompressedTexture.prototype.isCompressedTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.needsUpdate = true;

		}

		CanvasTexture.prototype = Object.create( Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;

		/**
		 * @author Matt DesLauriers / @mattdesl
		 * @author atix / arthursilber.de
		 */

		function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

			format = format !== undefined ? format : DepthFormat;

			if ( format !== DepthFormat && format !== DepthStencilFormat ) {

				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

			}

			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

			this.image = { width: width, height: height };

			this.type = type !== undefined ? type : UnsignedShortType;

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.flipY = false;
			this.generateMipmaps	= false;

		}

		DepthTexture.prototype = Object.create( Texture.prototype );
		DepthTexture.prototype.constructor = DepthTexture;
		DepthTexture.prototype.isDepthTexture = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function WireframeGeometry( geometry ) {

			BufferGeometry.call( this );

			var edge = [ 0, 0 ], hash = {};

			function sortFunction( a, b ) {

				return a - b;

			}

			var keys = [ 'a', 'b', 'c' ];

			if ( (geometry && geometry.isGeometry) ) {

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var numEdges = 0;

				// allocate maximal size
				var edges = new Uint32Array( 6 * faces.length );

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = face[ keys[ j ] ];
						edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

				var coords = new Float32Array( numEdges * 2 * 3 );

				for ( var i = 0, l = numEdges; i < l; i ++ ) {

					for ( var j = 0; j < 2; j ++ ) {

						var vertex = vertices[ edges [ 2 * i + j ] ];

						var index = 6 * i + 3 * j;
						coords[ index + 0 ] = vertex.x;
						coords[ index + 1 ] = vertex.y;
						coords[ index + 2 ] = vertex.z;

					}

				}

				this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

			} else if ( (geometry && geometry.isBufferGeometry) ) {

				if ( geometry.index !== null ) {

					// Indexed BufferGeometry

					var indices = geometry.index.array;
					var vertices = geometry.attributes.position;
					var groups = geometry.groups;
					var numEdges = 0;

					if ( groups.length === 0 ) {

						geometry.addGroup( 0, indices.length );

					}

					// allocate maximal size
					var edges = new Uint32Array( 2 * indices.length );

					for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

						var group = groups[ o ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							for ( var j = 0; j < 3; j ++ ) {

								edge[ 0 ] = indices[ i + j ];
								edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
								edge.sort( sortFunction );

								var key = edge.toString();

								if ( hash[ key ] === undefined ) {

									edges[ 2 * numEdges ] = edge[ 0 ];
									edges[ 2 * numEdges + 1 ] = edge[ 1 ];
									hash[ key ] = true;
									numEdges ++;

								}

							}

						}

					}

					var coords = new Float32Array( numEdges * 2 * 3 );

					for ( var i = 0, l = numEdges; i < l; i ++ ) {

						for ( var j = 0; j < 2; j ++ ) {

							var index = 6 * i + 3 * j;
							var index2 = edges[ 2 * i + j ];

							coords[ index + 0 ] = vertices.getX( index2 );
							coords[ index + 1 ] = vertices.getY( index2 );
							coords[ index + 2 ] = vertices.getZ( index2 );

						}

					}

					this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

				} else {

					// non-indexed BufferGeometry

					var vertices = geometry.attributes.position.array;
					var numEdges = vertices.length / 3;
					var numTris = numEdges / 3;

					var coords = new Float32Array( numEdges * 2 * 3 );

					for ( var i = 0, l = numTris; i < l; i ++ ) {

						for ( var j = 0; j < 3; j ++ ) {

							var index = 18 * i + 6 * j;

							var index1 = 9 * i + 3 * j;
							coords[ index + 0 ] = vertices[ index1 ];
							coords[ index + 1 ] = vertices[ index1 + 1 ];
							coords[ index + 2 ] = vertices[ index1 + 2 ];

							var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
							coords[ index + 3 ] = vertices[ index2 ];
							coords[ index + 4 ] = vertices[ index2 + 1 ];
							coords[ index + 5 ] = vertices[ index2 + 2 ];

						}

					}

					this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

				}

			}

		}

		WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
		WireframeGeometry.prototype.constructor = WireframeGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */

		function ParametricBufferGeometry( func, slices, stacks ) {

			BufferGeometry.call( this );

			this.type = 'ParametricBufferGeometry';

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};

			// generate vertices and uvs

			var vertices = [];
			var uvs = [];

			var i, j, p;
			var u, v;

			var sliceCount = slices + 1;

			for ( i = 0; i <= stacks; i ++ ) {

				v = i / stacks;

				for ( j = 0; j <= slices; j ++ ) {

					u = j / slices;

					p = func( u, v );
					vertices.push( p.x, p.y, p.z );

					uvs.push( u, v );

				}

			}

			// generate indices

			var indices = [];
			var a, b, c, d;

			for ( i = 0; i < stacks; i ++ ) {

				for ( j = 0; j < slices; j ++ ) {

					a = i * sliceCount + j;
					b = i * sliceCount + j + 1;
					c = ( i + 1 ) * sliceCount + j + 1;
					d = ( i + 1 ) * sliceCount + j;

					// faces one and two

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', Float32Attribute( vertices, 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );

			// generate normals

			this.computeVertexNormals();

		}

		ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

		/**
		 * @author zz85 / https://github.com/zz85
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */

		function ParametricGeometry( func, slices, stacks ) {

			Geometry.call( this );

			this.type = 'ParametricGeometry';

			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};

			this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
			this.mergeVertices();

		}

		ParametricGeometry.prototype = Object.create( Geometry.prototype );
		ParametricGeometry.prototype.constructor = ParametricGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

			BufferGeometry.call( this );

			this.type = 'PolyhedronBufferGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			radius = radius || 1;
			detail = detail || 0;

			// default buffer data

			var vertexBuffer = [];
			var uvBuffer = [];

			// the subdivision creates the vertex buffer data

			subdivide( detail );

			// all vertices should lie on a conceptual sphere with a given radius

			appplyRadius( radius );

			// finally, create the uv data

			generateUVs();

			// build non-indexed geometry

			this.addAttribute( 'position', Float32Attribute( vertexBuffer, 3 ) );
			this.addAttribute( 'normal', Float32Attribute( vertexBuffer.slice(), 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvBuffer, 2 ) );
			this.normalizeNormals();

			this.boundingSphere = new Sphere( new Vector3(), radius );

			// helper functions

			function subdivide( detail ) {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				// iterate over all faces and apply a subdivison with the given detail value

				for ( var i = 0; i < indices.length; i += 3 ) {

					// get the vertices of the face

					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );

					// perform subdivision

					subdivideFace( a, b, c, detail );

				}

			}

			function subdivideFace( a, b, c, detail ) {

				var cols = Math.pow( 2, detail );

				// we use this multidimensional array as a data structure for creating the subdivision

				var v = [];

				var i, j;

				// construct all of the vertices for this subdivision

				for ( i = 0 ; i <= cols; i ++ ) {

					v[ i ] = [];

					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );

					var rows = cols - i;

					for ( j = 0; j <= rows; j ++ ) {

						if ( j === 0 && i === cols ) {

							v[ i ][ j ] = aj;

						} else {

							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

						}

					}

				}

				// construct all of the faces

				for ( i = 0; i < cols ; i ++ ) {

					for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

						var k = Math.floor( j / 2 );

						if ( j % 2 === 0 ) {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );

						} else {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );

						}

					}

				}

			}

			function appplyRadius( radius ) {

				var vertex = new Vector3();

				// iterate over the entire buffer and apply the radius to each vertex

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					vertex.normalize().multiplyScalar( radius );

					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;

				}

			}

			function generateUVs() {

				var vertex = new Vector3();

				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );

				}

				correctUVs();

				correctSeam();

			}

			function correctSeam() {

				// handle case when face straddles the seam, see #3269

				for ( var i = 0; i < uvBuffer.length; i += 6 ) {

					// uv data of a single face

					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];

					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );

					// 0.9 is somewhat arbitrary

					if ( max > 0.9 && min < 0.1 ) {

						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

					}

				}

			}

			function pushVertex( vertex ) {

				vertexBuffer.push( vertex.x, vertex.y, vertex.z );

			}

			function getVertexByIndex( index, vertex ) {

				var stride = index * 3;

				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];

			}

			function correctUVs() {

				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();

				var centroid = new Vector3();

				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();

				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

					var azi = azimuth( centroid );

					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );

				}

			}

			function correctUV( uv, stride, vector, azimuth  ) {

				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

					uvBuffer[ stride ] =  uv.x - 1;

				}

				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth( vector ) {

				return Math.atan2( vector.z, - vector.x );

			}


			// Angle above the XZ plane.

			function inclination( vector ) {

				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

			}

		}

		PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function TetrahedronBufferGeometry( radius, detail ) {

			var vertices = [
				1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
			];

			var indices = [
				2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'TetrahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function TetrahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'TetrahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
		TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function OctahedronBufferGeometry( radius,detail ) {

			var vertices = [
				1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
			];

			var indices = [
				0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'OctahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function OctahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'OctahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		OctahedronGeometry.prototype = Object.create( Geometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function IcosahedronBufferGeometry( radius, detail ) {

			var t = ( 1 + Math.sqrt( 5 ) ) / 2;

			var vertices = [
				- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
				 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
				 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
			];

			var indices = [
				 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
				 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
				 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
				 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'IcosahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */

		function IcosahedronGeometry( radius, detail ) {

		 	Geometry.call( this );

			this.type = 'IcosahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
		IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function DodecahedronBufferGeometry( radius, detail ) {

			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
			var r = 1 / t;

			var vertices = [

				// (1, 1, 1)
				- 1, - 1, - 1,    - 1, - 1,  1,
				- 1,  1, - 1,    - 1,  1,  1,
				 1, - 1, - 1,     1, - 1,  1,
				 1,  1, - 1,     1,  1,  1,

				// (0, 1/, )
				 0, - r, - t,     0, - r,  t,
				 0,  r, - t,     0,  r,  t,

				// (1/, , 0)
				- r, - t,  0,    - r,  t,  0,
				 r, - t,  0,     r,  t,  0,

				// (, 0, 1/)
				- t,  0, - r,     t,  0, - r,
				- t,  0,  r,     t,  0,  r
			];

			var indices = [
				 3, 11,  7,      3,  7, 15,      3, 15, 13,
				 7, 19, 17,      7, 17,  6,      7,  6, 15,
				17,  4,  8,     17,  8, 10,     17, 10,  6,
				 8,  0, 16,      8, 16,  2,      8,  2, 10,
				 0, 12,  1,      0,  1, 18,      0, 18, 16,
				 6, 10,  2,      6,  2, 13,      6, 13, 15,
				 2, 16, 18,      2, 18,  3,      2,  3, 13,
				18,  1,  9,     18,  9, 11,     18, 11,  3,
				 4, 14, 12,      4, 12,  0,      4,  0,  8,
				11,  9,  5,     11,  5, 19,     11, 19,  7,
				19,  5, 14,     19, 14,  4,     19,  4, 17,
				 1, 12, 14,      1, 14,  5,      1,  5,  9
			];

			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

			this.type = 'DodecahedronBufferGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

		DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

		/**
		 * @author Abe Pazos / https://hamoid.com
		 */

		function DodecahedronGeometry( radius, detail ) {

			Geometry.call( this );

			this.type = 'DodecahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();

		}

		DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
		DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

		/**
		 * @author clockworkgeek / https://github.com/clockworkgeek
		 * @author timothypratley / https://github.com/timothypratley
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function PolyhedronGeometry( vertices, indices, radius, detail ) {

			Geometry.call( this );

			this.type = 'PolyhedronGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
			this.mergeVertices();

		}

		PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 *
		 */

		function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

			BufferGeometry.call( this );

			this.type = 'TubeBufferGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			tubularSegments = tubularSegments || 64;
			radius = radius || 1;
			radialSegments = radialSegments || 8;
			closed = closed || false;

			var frames = path.computeFrenetFrames( tubularSegments, closed );

			// expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;

			// helper variables

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();

			var i, j;

			// buffer

			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];

			// create buffer data

			generateBufferData();

			// build geometry

			this.setIndex( ( indices.length > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', Float32Attribute( vertices, 3 ) );
			this.addAttribute( 'normal', Float32Attribute( normals, 3 ) );
			this.addAttribute( 'uv', Float32Attribute( uvs, 2 ) );

			// functions

			function generateBufferData() {

				for ( i = 0; i < tubularSegments; i ++ ) {

					generateSegment( i );

				}

				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

				generateSegment( ( closed === false ) ? tubularSegments : 0 );

				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs();

				// finally create faces

				generateIndices();

			}

			function generateSegment( i ) {

				// we use getPointAt to sample evenly distributed points from the given path

				var P = path.getPointAt( i / tubularSegments );

				// retrieve corresponding normal and binormal

				var N = frames.normals[ i ];
				var B = frames.binormals[ i ];

				// generate normals and vertices for the current segment

				for ( j = 0; j <= radialSegments; j ++ ) {

					var v = j / radialSegments * Math.PI * 2;

					var sin =   Math.sin( v );
					var cos = - Math.cos( v );

					// normal

					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();

					normals.push( normal.x, normal.y, normal.z );

					// vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;

					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

			function generateIndices() {

				for ( j = 1; j <= tubularSegments; j ++ ) {

					for ( i = 1; i <= radialSegments; i ++ ) {

						var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						var b = ( radialSegments + 1 ) * j + ( i - 1 );
						var c = ( radialSegments + 1 ) * j + i;
						var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

					}

				}

			}

			function generateUVs() {

				for ( i = 0; i <= tubularSegments; i ++ ) {

					for ( j = 0; j <= radialSegments; j ++ ) {

						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;

						uvs.push( uv.x, uv.y );

					}

				}

			}

		}

		TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

		/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 */

		function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

			Geometry.call( this );

			this.type = 'TubeGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

			var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

			// expose internals

			this.tangents = bufferGeometry.tangents;
			this.normals = bufferGeometry.normals;
			this.binormals = bufferGeometry.binormals;

			// create geometry

			this.fromBufferGeometry( bufferGeometry );
			this.mergeVertices();

		}

		TubeGeometry.prototype = Object.create( Geometry.prototype );
		TubeGeometry.prototype.constructor = TubeGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * see: http://www.blackpawn.com/texts/pqtorus/
		 */
		function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

			BufferGeometry.call( this );

			this.type = 'TorusKnotBufferGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			radius = radius || 100;
			tube = tube || 40;
			tubularSegments = Math.floor( tubularSegments ) || 64;
			radialSegments = Math.floor( radialSegments ) || 8;
			p = p || 2;
			q = q || 3;

			// used to calculate buffer length
			var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
			var indexCount = radialSegments * tubularSegments * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables
			var i, j, index = 0, indexOffset = 0;

			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();

			var P1 = new Vector3();
			var P2 = new Vector3();

			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3();

			// generate vertices, normals and uvs

			for ( i = 0; i <= tubularSegments; ++ i ) {

				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

				var u = i / tubularSegments * p * Math.PI * 2;

				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

				// calculate orthonormal basis

				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );

				// normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for ( j = 0; j <= radialSegments; ++ j ) {

					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

					var v = j / radialSegments * Math.PI * 2;
					var cx = - tube * Math.cos( v );
					var cy = tube * Math.sin( v );

					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );

					// vertex
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
					normal.subVectors( vertex, P1 ).normalize();
					normals.setXYZ( index, normal.x, normal.y, normal.z );

					// uv
					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

			}

			// generate indices

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					// indices
					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

					// face two
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			// this function calculates the current position on the torus curve

			function calculatePositionOnCurve( u, p, q, radius, position ) {

				var cu = Math.cos( u );
				var su = Math.sin( u );
				var quOverP = q / p * u;
				var cs = Math.cos( quOverP );

				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;

			}

		}

		TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

		/**
		 * @author oosmoxiecode
		 */

		function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

			Geometry.call( this );

			this.type = 'TorusKnotGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

			this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
			this.mergeVertices();

		}

		TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
		TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

			BufferGeometry.call( this );

			this.type = 'TorusBufferGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			radius = radius || 100;
			tube = tube || 40;
			radialSegments = Math.floor( radialSegments ) || 8;
			tubularSegments = Math.floor( tubularSegments ) || 6;
			arc = arc || Math.PI * 2;

			// used to calculate buffer length
			var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
			var indexCount = radialSegments * tubularSegments * 2 * 3;

			// buffers
			var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
			var vertices = new Float32Array( vertexCount * 3 );
			var normals = new Float32Array( vertexCount * 3 );
			var uvs = new Float32Array( vertexCount * 2 );

			// offset variables
			var vertexBufferOffset = 0;
			var uvBufferOffset = 0;
			var indexBufferOffset = 0;

			// helper variables
			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3();

			var j, i;

			// generate vertices, normals and uvs

			for ( j = 0; j <= radialSegments; j ++ ) {

				for ( i = 0; i <= tubularSegments; i ++ ) {

					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2;

					// vertex
					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );

					vertices[ vertexBufferOffset ] = vertex.x;
					vertices[ vertexBufferOffset + 1 ] = vertex.y;
					vertices[ vertexBufferOffset + 2 ] = vertex.z;

					// this vector is used to calculate the normal
					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );

					// normal
					normal.subVectors( vertex, center ).normalize();

					normals[ vertexBufferOffset ] = normal.x;
					normals[ vertexBufferOffset + 1 ] = normal.y;
					normals[ vertexBufferOffset + 2 ] = normal.z;

					// uv
					uvs[ uvBufferOffset ] = i / tubularSegments;
					uvs[ uvBufferOffset + 1 ] = j / radialSegments;

					// update offsets
					vertexBufferOffset += 3;
					uvBufferOffset += 2;

				}

			}

			// generate indices

			for ( j = 1; j <= radialSegments; j ++ ) {

				for ( i = 1; i <= tubularSegments; i ++ ) {

					// indices
					var a = ( tubularSegments + 1 ) * j + i - 1;
					var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					var d = ( tubularSegments + 1 ) * j + i;

					// face one
					indices[ indexBufferOffset ] = a;
					indices[ indexBufferOffset + 1 ] = b;
					indices[ indexBufferOffset + 2 ] = d;

					// face two
					indices[ indexBufferOffset + 3 ] = b;
					indices[ indexBufferOffset + 4 ] = c;
					indices[ indexBufferOffset + 5 ] = d;

					// update offset
					indexBufferOffset += 6;

				}

			}

			// build geometry
			this.setIndex( new BufferAttribute( indices, 1 ) );
			this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

		}

		TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

		/**
		 * @author oosmoxiecode
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
		 */

		function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

			Geometry.call( this );

			this.type = 'TorusGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

		}

		TorusGeometry.prototype = Object.create( Geometry.prototype );
		TorusGeometry.prototype.constructor = TorusGeometry;

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		var ShapeUtils = {

			// calculate area of the contour polygon

			area: function ( contour ) {

				var n = contour.length;
				var a = 0.0;

				for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

					a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

				}

				return a * 0.5;

			},

			triangulate: ( function () {

				/**
				 * This code is a quick port of code written in C++ which was submitted to
				 * flipcode.com by John W. Ratcliff  // July 22, 2000
				 * See original code and more information here:
				 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
				 *
				 * ported to actionscript by Zevan Rosser
				 * www.actionsnippet.com
				 *
				 * ported to javascript by Joshua Koo
				 * http://www.lab4games.net/zz85/blog
				 *
				 */

				function snip( contour, u, v, w, n, verts ) {

					var p;
					var ax, ay, bx, by;
					var cx, cy, px, py;

					ax = contour[ verts[ u ] ].x;
					ay = contour[ verts[ u ] ].y;

					bx = contour[ verts[ v ] ].x;
					by = contour[ verts[ v ] ].y;

					cx = contour[ verts[ w ] ].x;
					cy = contour[ verts[ w ] ].y;

					if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;

					var aX, aY, bX, bY, cX, cY;
					var apx, apy, bpx, bpy, cpx, cpy;
					var cCROSSap, bCROSScp, aCROSSbp;

					aX = cx - bx;  aY = cy - by;
					bX = ax - cx;  bY = ay - cy;
					cX = bx - ax;  cY = by - ay;

					for ( p = 0; p < n; p ++ ) {

						px = contour[ verts[ p ] ].x;
						py = contour[ verts[ p ] ].y;

						if ( ( ( px === ax ) && ( py === ay ) ) ||
							 ( ( px === bx ) && ( py === by ) ) ||
							 ( ( px === cx ) && ( py === cy ) ) )	continue;

						apx = px - ax;  apy = py - ay;
						bpx = px - bx;  bpy = py - by;
						cpx = px - cx;  cpy = py - cy;

						// see if p is inside triangle abc

						aCROSSbp = aX * bpy - aY * bpx;
						cCROSSap = cX * apy - cY * apx;
						bCROSScp = bX * cpy - bY * cpx;

						if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

					}

					return true;

				}

				// takes in an contour array and returns

				return function triangulate( contour, indices ) {

					var n = contour.length;

					if ( n < 3 ) return null;

					var result = [],
						verts = [],
						vertIndices = [];

					/* we want a counter-clockwise polygon in verts */

					var u, v, w;

					if ( ShapeUtils.area( contour ) > 0.0 ) {

						for ( v = 0; v < n; v ++ ) verts[ v ] = v;

					} else {

						for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

					}

					var nv = n;

					/*  remove nv - 2 vertices, creating 1 triangle every time */

					var count = 2 * nv;   /* error detection */

					for ( v = nv - 1; nv > 2; ) {

						/* if we loop, it is probably a non-simple polygon */

						if ( ( count -- ) <= 0 ) {

							//** Triangulate: ERROR - probable bad polygon!

							//throw ( "Warning, unable to triangulate polygon!" );
							//return null;
							// Sometimes warning is fine, especially polygons are triangulated in reverse.
							console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

							if ( indices ) return vertIndices;
							return result;

						}

						/* three consecutive vertices in current polygon, <u,v,w> */

						u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
						v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
						w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

						if ( snip( contour, u, v, w, nv, verts ) ) {

							var a, b, c, s, t;

							/* true names of the vertices */

							a = verts[ u ];
							b = verts[ v ];
							c = verts[ w ];

							/* output Triangle */

							result.push( [ contour[ a ],
								contour[ b ],
								contour[ c ] ] );


							vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

							/* remove v from the remaining polygon */

							for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

								verts[ s ] = verts[ t ];

							}

							nv --;

							/* reset error detection counter */

							count = 2 * nv;

						}

					}

					if ( indices ) return vertIndices;
					return result;

				}

			} )(),

			triangulateShape: function ( contour, holes ) {

				function removeDupEndPts(points) {

					var l = points.length;

					if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

						points.pop();

					}

				}

				removeDupEndPts( contour );
				holes.forEach( removeDupEndPts );

				function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

					// inOtherPt needs to be collinear to the inSegment
					if ( inSegPt1.x !== inSegPt2.x ) {

						if ( inSegPt1.x < inSegPt2.x ) {

							return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

						} else {

							return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

						}

					} else {

						if ( inSegPt1.y < inSegPt2.y ) {

							return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

						} else {

							return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

						}

					}

				}

				function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

					var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
					var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

					var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
					var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

					var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
					var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

					if ( Math.abs( limit ) > Number.EPSILON ) {

						// not parallel

						var perpSeg2;
						if ( limit > 0 ) {

							if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

						} else {

							if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

						}

						// i.e. to reduce rounding errors
						// intersection at endpoint of segment#1?
						if ( perpSeg2 === 0 ) {

							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt1 ];

						}
						if ( perpSeg2 === limit ) {

							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt2 ];

						}
						// intersection at endpoint of segment#2?
						if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
						if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

						// return real intersection point
						var factorSeg1 = perpSeg2 / limit;
						return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
									y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

					} else {

						// parallel or collinear
						if ( ( perpSeg1 !== 0 ) ||
							 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

						// they are collinear or degenerate
						var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
						var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
						// both segments are points
						if ( seg1Pt && seg2Pt ) {

							if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
								 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
							return [ inSeg1Pt1 ];                 						// they are the same point

						}
						// segment#1  is a single point
						if ( seg1Pt ) {

							if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
							return [ inSeg1Pt1 ];

						}
						// segment#2  is a single point
						if ( seg2Pt ) {

							if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
							return [ inSeg2Pt1 ];

						}

						// they are collinear segments, which might overlap
						var seg1min, seg1max, seg1minVal, seg1maxVal;
						var seg2min, seg2max, seg2minVal, seg2maxVal;
						if ( seg1dx !== 0 ) {

							// the segments are NOT on a vertical line
							if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

							} else {

								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

							}
							if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

							} else {

								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

							}

						} else {

							// the segments are on a vertical line
							if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

							} else {

								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

							}
							if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

							} else {

								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

							}

						}
						if ( seg1minVal <= seg2minVal ) {

							if ( seg1maxVal <  seg2minVal )	return [];
							if ( seg1maxVal === seg2minVal )	{

								if ( inExcludeAdjacentSegs )		return [];
								return [ seg2min ];

							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
							return	[ seg2min, seg2max ];

						} else {

							if ( seg1minVal >  seg2maxVal )	return [];
							if ( seg1minVal === seg2maxVal )	{

								if ( inExcludeAdjacentSegs )		return [];
								return [ seg1min ];

							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
							return	[ seg1min, seg2max ];

						}

					}

				}

				function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

					// The order of legs is important

					// translation of all points, so that Vertex is at (0,0)
					var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
					var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
					var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

					// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
					var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
					var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

					if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

						// angle != 180 deg.

						var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
						// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

						if ( from2toAngle > 0 ) {

							// main angle < 180 deg.
							return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

						} else {

							// main angle > 180 deg.
							return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

						}

					} else {

						// angle == 180 deg.
						// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
						return	( from2otherAngle > 0 );

					}

				}


				function removeHoles( contour, holes ) {

					var shape = contour.concat(); // work on this shape
					var hole;

					function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

						// Check if hole point lies within angle around shape point
						var lastShapeIdx = shape.length - 1;

						var prevShapeIdx = inShapeIdx - 1;
						if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

						var nextShapeIdx = inShapeIdx + 1;
						if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

						var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
						if ( ! insideAngle ) {

							// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
							return	false;

						}

						// Check if shape point lies within angle around hole point
						var lastHoleIdx = hole.length - 1;

						var prevHoleIdx = inHoleIdx - 1;
						if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

						var nextHoleIdx = inHoleIdx + 1;
						if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

						insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
						if ( ! insideAngle ) {

							// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
							return	false;

						}

						return	true;

					}

					function intersectsShapeEdge( inShapePt, inHolePt ) {

						// checks for intersections with shape edges
						var sIdx, nextIdx, intersection;
						for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

							nextIdx = sIdx + 1; nextIdx %= shape.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;

						}

						return	false;

					}

					var indepHoles = [];

					function intersectsHoleEdge( inShapePt, inHolePt ) {

						// checks for intersections with hole edges
						var ihIdx, chkHole,
							hIdx, nextIdx, intersection;
						for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

							chkHole = holes[ indepHoles[ ihIdx ]];
							for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

								nextIdx = hIdx + 1; nextIdx %= chkHole.length;
								intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
								if ( intersection.length > 0 )		return	true;

							}

						}
						return	false;

					}

					var holeIndex, shapeIndex,
						shapePt, holePt,
						holeIdx, cutKey, failedCuts = [],
						tmpShape1, tmpShape2,
						tmpHole1, tmpHole2;

					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

						indepHoles.push( h );

					}

					var minShapeIndex = 0;
					var counter = indepHoles.length * 2;
					while ( indepHoles.length > 0 ) {

						counter --;
						if ( counter < 0 ) {

							console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
							break;

						}

						// search for shape-vertex and hole-vertex,
						// which can be connected without intersections
						for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

							shapePt = shape[ shapeIndex ];
							holeIndex	= - 1;

							// search for hole which can be reached without intersections
							for ( var h = 0; h < indepHoles.length; h ++ ) {

								holeIdx = indepHoles[ h ];

								// prevent multiple checks
								cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
								if ( failedCuts[ cutKey ] !== undefined )			continue;

								hole = holes[ holeIdx ];
								for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

									holePt = hole[ h2 ];
									if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
									if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
									if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

									holeIndex = h2;
									indepHoles.splice( h, 1 );

									tmpShape1 = shape.slice( 0, shapeIndex + 1 );
									tmpShape2 = shape.slice( shapeIndex );
									tmpHole1 = hole.slice( holeIndex );
									tmpHole2 = hole.slice( 0, holeIndex + 1 );

									shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

									minShapeIndex = shapeIndex;

									// Debug only, to show the selected cuts
									// glob_CutLines.push( [ shapePt, holePt ] );

									break;

								}
								if ( holeIndex >= 0 )	break;		// hole-vertex found

								failedCuts[ cutKey ] = true;			// remember failure

							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found

						}

					}

					return shape; 			/* shape with no holes */

				}


				var i, il, f, face,
					key, index,
					allPointsMap = {};

				// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

				var allpoints = contour.concat();

				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

					Array.prototype.push.apply( allpoints, holes[ h ] );

				}

				//console.log( "allpoints",allpoints, allpoints.length );

				// prepare all points map

				for ( i = 0, il = allpoints.length; i < il; i ++ ) {

					key = allpoints[ i ].x + ":" + allpoints[ i ].y;

					if ( allPointsMap[ key ] !== undefined ) {

						console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

					}

					allPointsMap[ key ] = i;

				}

				// remove holes by cutting paths to holes and adding them to the shape
				var shapeWithoutHoles = removeHoles( contour, holes );

				var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
				//console.log( "triangles",triangles, triangles.length );

				// check all face vertices against all points map

				for ( i = 0, il = triangles.length; i < il; i ++ ) {

					face = triangles[ i ];

					for ( f = 0; f < 3; f ++ ) {

						key = face[ f ].x + ":" + face[ f ].y;

						index = allPointsMap[ key ];

						if ( index !== undefined ) {

							face[ f ] = index;

						}

					}

				}

				return triangles.concat();

			},

			isClockWise: function ( pts ) {

				return ShapeUtils.area( pts ) < 0;

			},

			// Bezier Curves formulas obtained from
			// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

			// Quad Bezier Functions

			b2: ( function () {

				function b2p0( t, p ) {

					var k = 1 - t;
					return k * k * p;

				}

				function b2p1( t, p ) {

					return 2 * ( 1 - t ) * t * p;

				}

				function b2p2( t, p ) {

					return t * t * p;

				}

				return function b2( t, p0, p1, p2 ) {

					return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

				};

			} )(),

			// Cubic Bezier Functions

			b3: ( function () {

				function b3p0( t, p ) {

					var k = 1 - t;
					return k * k * k * p;

				}

				function b3p1( t, p ) {

					var k = 1 - t;
					return 3 * k * k * t * p;

				}

				function b3p2( t, p ) {

					var k = 1 - t;
					return 3 * k * t * t * p;

				}

				function b3p3( t, p ) {

					return t * t * t * p;

				}

				return function b3( t, p0, p1, p2, p3 ) {

					return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

				};

			} )()

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  amount: <int>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline is bevel
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
		 *  frames: <Object> // containing arrays of tangents, normals, binormals
		 *
		 *  uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/

		function ExtrudeGeometry( shapes, options ) {

			if ( typeof( shapes ) === "undefined" ) {

				shapes = [];
				return;

			}

			Geometry.call( this );

			this.type = 'ExtrudeGeometry';

			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

			this.addShapeList( shapes, options );

			this.computeFaceNormals();

			// can't really use automatic vertex normals
			// as then front and back sides get smoothed too
			// should do separate smoothing just for sides

			//this.computeVertexNormals();

			//console.log( "took", ( Date.now() - startTime ) );

		}

		ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

		ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

			var sl = shapes.length;

			for ( var s = 0; s < sl; s ++ ) {

				var shape = shapes[ s ];
				this.addShape( shape, options );

			}

		};

		ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

			var amount = options.amount !== undefined ? options.amount : 100;

			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

			var steps = options.steps !== undefined ? options.steps : 1;

			var extrudePath = options.extrudePath;
			var extrudePts, extrudeByPath = false;

			// Use default WorldUVGenerator if no UV generators are specified.
			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

			var splineTube, binormal, normal, position2;
			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;

			}

			// Variables initialization

			var ahole, h, hl; // looping of holes
			var scope = this;

			var shapesOffset = this.vertices.length;

			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

				reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

			}


			var faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			var contour = vertices; // vertices has all points but contour has only points of circumference

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
							  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return	new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					var direction_eq = false;		// assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y =  v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			var contourMovements = [];

			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				oneHoleMovements = [];

				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y,  - z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y,  - z );

					}

				}

			}

			bs = bevelSize;

			// Back facing vertices

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			var s;

			for ( s = 1; s <= steps; s ++ ) {

				for ( i = 0; i < vlen; i ++ ) {

					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, amount / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos ( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y,  amount + z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y,  amount + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				if ( bevelEnabled ) {

					var layer = 0; // steps + 1
					var offset = vlen * layer;

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}

			}

			function sidewalls( contour, layeroffset ) {

				var j, k;
				i = contour.length;

				while ( -- i >= 0 ) {

					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					var s = 0, sl = steps  + bevelSegments * 2;

					for ( s = 0; s < sl; s ++ ) {

						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );

						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d, contour, s, sl, j, k );

					}

				}

			}


			function v( x, y, z ) {

				scope.vertices.push( new Vector3( x, y, z ) );

			}

			function f3( a, b, c ) {

				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;

				scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

				var uvs = uvgen.generateTopUV( scope, a, b, c );

				scope.faceVertexUvs[ 0 ].push( uvs );

			}

			function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
				d += shapesOffset;

				scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
				scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

				var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

				scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

			}

		};

		ExtrudeGeometry.WorldUVGenerator = {

			generateTopUV: function ( geometry, indexA, indexB, indexC ) {

				var vertices = geometry.vertices;

				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];

				return [
					new Vector2( a.x, a.y ),
					new Vector2( b.x, b.y ),
					new Vector2( c.x, c.y )
				];

			},

			generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

				var vertices = geometry.vertices;

				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
				var d = vertices[ indexD ];

				if ( Math.abs( a.y - b.y ) < 0.01 ) {

					return [
						new Vector2( a.x, 1 - a.z ),
						new Vector2( b.x, 1 - b.z ),
						new Vector2( c.x, 1 - c.z ),
						new Vector2( d.x, 1 - d.z )
					];

				} else {

					return [
						new Vector2( a.y, 1 - a.z ),
						new Vector2( b.y, 1 - b.z ),
						new Vector2( c.y, 1 - c.z ),
						new Vector2( d.y, 1 - d.z )
					];

				}

			}
		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * Text = 3D Text
		 *
		 * parameters = {
		 *  font: <THREE.Font>, // font
		 *
		 *  size: <float>, // size of the text
		 *  height: <float>, // thickness to extrude text
		 *  curveSegments: <int>, // number of points on the curves
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into text bevel goes
		 *  bevelSize: <float> // how far from text outline is bevel
		 * }
		 */

		function TextGeometry( text, parameters ) {

			parameters = parameters || {};

			var font = parameters.font;

			if ( (font && font.isFont) === false ) {

				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new Geometry();

			}

			var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

			// translate parameters to ExtrudeGeometry API

			parameters.amount = parameters.height !== undefined ? parameters.height : 50;

			// defaults

			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

			ExtrudeGeometry.call( this, shapes, parameters );

			this.type = 'TextGeometry';

		}

		TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
		TextGeometry.prototype.constructor = TextGeometry;

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * based on THREE.SphereGeometry
		 */

		function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'SphereBufferGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			radius = radius || 50;

			widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

			phiStart = phiStart !== undefined ? phiStart : 0;
			phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

			var thetaEnd = thetaStart + thetaLength;

			var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

			var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			var index = 0, vertices = [], normal = new Vector3();

			for ( var y = 0; y <= heightSegments; y ++ ) {

				var verticesRow = [];

				var v = y / heightSegments;

				for ( var x = 0; x <= widthSegments; x ++ ) {

					var u = x / widthSegments;

					var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					var py = radius * Math.cos( thetaStart + v * thetaLength );
					var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					normal.set( px, py, pz ).normalize();

					positions.setXYZ( index, px, py, pz );
					normals.setXYZ( index, normal.x, normal.y, normal.z );
					uvs.setXY( index, u, 1 - v );

					verticesRow.push( index );

					index ++;

				}

				vertices.push( verticesRow );

			}

			var indices = [];

			for ( var y = 0; y < heightSegments; y ++ ) {

				for ( var x = 0; x < widthSegments; x ++ ) {

					var v1 = vertices[ y ][ x + 1 ];
					var v2 = vertices[ y ][ x ];
					var v3 = vertices[ y + 1 ][ x ];
					var v4 = vertices[ y + 1 ][ x + 1 ];

					if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
					if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

				}

			}

			this.setIndex( new ( positions.count > 65535 ? Uint32Attribute : Uint16Attribute )( indices, 1 ) );
			this.addAttribute( 'position', positions );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			this.boundingSphere = new Sphere( new Vector3(), radius );

		}

		SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

		}

		SphereGeometry.prototype = Object.create( Geometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'RingBufferGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			innerRadius = innerRadius || 20;
			outerRadius = outerRadius || 50;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
			phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

			// these are used to calculate buffer length
			var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
			var indexCount = thetaSegments * phiSegments * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// some helper variables
			var index = 0, indexOffset = 0, segment;
			var radius = innerRadius;
			var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			var vertex = new Vector3();
			var uv = new Vector2();
			var j, i;

			// generate vertices, normals and uvs

			// values are generate from the inside of the ring to the outside

			for ( j = 0; j <= phiSegments; j ++ ) {

				for ( i = 0; i <= thetaSegments; i ++ ) {

					segment = thetaStart + i / thetaSegments * thetaLength;

					// vertex
					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal
					normals.setXYZ( index, 0, 0, 1 );

					// uv
					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index++;

				}

				// increase the radius for next row of vertices
				radius += radiusStep;

			}

			// generate indices

			for ( j = 0; j < phiSegments; j ++ ) {

				var thetaSegmentLevel = j * ( thetaSegments + 1 );

				for ( i = 0; i < thetaSegments; i ++ ) {

					segment = i + thetaSegmentLevel;

					// indices
					var a = segment;
					var b = segment + thetaSegments + 1;
					var c = segment + thetaSegments + 2;
					var d = segment + 1;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;

					// face two
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

		}

		RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		RingBufferGeometry.prototype.constructor = RingBufferGeometry;

		/**
		 * @author Kaleb Murphy
		 */

		function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'RingGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

		}

		RingGeometry.prototype = Object.create( Geometry.prototype );
		RingGeometry.prototype.constructor = RingGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */

		function PlaneGeometry( width, height, widthSegments, heightSegments ) {

			Geometry.call( this );

			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

		}

		PlaneGeometry.prototype = Object.create( Geometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		 // points - to create a closed torus, one must use a set of points
		 //    like so: [ a, b, c, d, a ], see first is the same as last.
		 // segments - the number of circumference segments to create
		 // phiStart - the starting radian
		 // phiLength - the radian (0 to 2PI) range of the lathed section
		 //    2PI is a closed lathe, less than 2PI is a portion.

		function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

			BufferGeometry.call( this );

			this.type = 'LatheBufferGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			segments = Math.floor( segments ) || 12;
			phiStart = phiStart || 0;
			phiLength = phiLength || Math.PI * 2;

			// clamp phiLength so it's in range of [ 0, 2PI ]
			phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );

			// these are used to calculate buffer length
			var vertexCount = ( segments + 1 ) * points.length;
			var indexCount = segments * points.length * 2 * 3;

			// buffers
			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables
			var index = 0, indexOffset = 0, base;
			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2();
			var i, j;

			// generate vertices and uvs

			for ( i = 0; i <= segments; i ++ ) {

				var phi = phiStart + i * inverseSegments * phiLength;

				var sin = Math.sin( phi );
				var cos = Math.cos( phi );

				for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

					// vertex
					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// uv
					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

			}

			// generate indices

			for ( i = 0; i < segments; i ++ ) {

				for ( j = 0; j < ( points.length - 1 ); j ++ ) {

					base = j + i * points.length;

					// indices
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1;

					// face one
					indices.setX( indexOffset, a ); indexOffset++;
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

					// face two
					indices.setX( indexOffset, b ); indexOffset++;
					indices.setX( indexOffset, c ); indexOffset++;
					indices.setX( indexOffset, d ); indexOffset++;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'uv', uvs );

			// generate normals

			this.computeVertexNormals();

			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if( phiLength === Math.PI * 2 ) {

				var normals = this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3();

				// this is the buffer offset for the last line of vertices
				base = segments * points.length * 3;

				for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

					// select the normal of the vertex in the first line
					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];

					// select the normal of the vertex in the last line
					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];

					// average normals
					n.addVectors( n1, n2 ).normalize();

					// assign the new values to both normals
					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

				} // next row

			}

		}

		LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

		/**
		 * @author astrodud / http://astrodud.isgreat.org/
		 * @author zz85 / https://github.com/zz85
		 * @author bhouston / http://clara.io
		 */

		// points - to create a closed torus, one must use a set of points
		//    like so: [ a, b, c, d, a ], see first is the same as last.
		// segments - the number of circumference segments to create
		// phiStart - the starting radian
		// phiLength - the radian (0 to 2PI) range of the lathed section
		//    2PI is a closed lathe, less than 2PI is a portion.

		function LatheGeometry( points, segments, phiStart, phiLength ) {

			Geometry.call( this );

			this.type = 'LatheGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
			this.mergeVertices();

		}

		LatheGeometry.prototype = Object.create( Geometry.prototype );
		LatheGeometry.prototype.constructor = LatheGeometry;

		/**
		 * @author jonobr1 / http://jonobr1.com
		 *
		 * Creates a one-sided polygonal geometry from a path shape. Similar to
		 * ExtrudeGeometry.
		 *
		 * parameters = {
		 *
		 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
		 *
		 *	material: <int> // material index for front and back faces
		 *	uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/

		function ShapeGeometry( shapes, options ) {

			Geometry.call( this );

			this.type = 'ShapeGeometry';

			if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

			this.addShapeList( shapes, options );

			this.computeFaceNormals();

		}

		ShapeGeometry.prototype = Object.create( Geometry.prototype );
		ShapeGeometry.prototype.constructor = ShapeGeometry;

		/**
		 * Add an array of shapes to THREE.ShapeGeometry.
		 */
		ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				this.addShape( shapes[ i ], options );

			}

			return this;

		};

		/**
		 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
		 */
		ShapeGeometry.prototype.addShape = function ( shape, options ) {

			if ( options === undefined ) options = {};
			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

			var material = options.material;
			var uvgen = options.UVGenerator === undefined ? ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

			//

			var i, l, hole;

			var shapesOffset = this.vertices.length;
			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe...

				for ( i = 0, l = holes.length; i < l; i ++ ) {

					hole = holes[ i ];

					if ( ShapeUtils.isClockWise( hole ) ) {

						holes[ i ] = hole.reverse();

					}

				}

				reverse = false;

			}

			var faces = ShapeUtils.triangulateShape( vertices, holes );

			// Vertices

			for ( i = 0, l = holes.length; i < l; i ++ ) {

				hole = holes[ i ];
				vertices = vertices.concat( hole );

			}

			//

			var vert, vlen = vertices.length;
			var face, flen = faces.length;

			for ( i = 0; i < vlen; i ++ ) {

				vert = vertices[ i ];

				this.vertices.push( new Vector3( vert.x, vert.y, 0 ) );

			}

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];

				var a = face[ 0 ] + shapesOffset;
				var b = face[ 1 ] + shapesOffset;
				var c = face[ 2 ] + shapesOffset;

				this.faces.push( new Face3( a, b, c, null, null, material ) );
				this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

			}

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function EdgesGeometry( geometry, thresholdAngle ) {

			BufferGeometry.call( this );

			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

			var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );

			var edge = [ 0, 0 ], hash = {};

			function sortFunction( a, b ) {

				return a - b;

			}

			var keys = [ 'a', 'b', 'c' ];

			var geometry2;

			if ( (geometry && geometry.isBufferGeometry) ) {

				geometry2 = new Geometry();
				geometry2.fromBufferGeometry( geometry );

			} else {

				geometry2 = geometry.clone();

			}

			geometry2.mergeVertices();
			geometry2.computeFaceNormals();

			var vertices = geometry2.vertices;
			var faces = geometry2.faces;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

					} else {

						hash[ key ].face2 = i;

					}

				}

			}

			var coords = [];

			for ( var key in hash ) {

				var h = hash[ key ];

				if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

					var vertex = vertices[ h.vert1 ];
					coords.push( vertex.x );
					coords.push( vertex.y );
					coords.push( vertex.z );

					vertex = vertices[ h.vert2 ];
					coords.push( vertex.x );
					coords.push( vertex.y );
					coords.push( vertex.z );

				}

			}

			this.addAttribute( 'position', new BufferAttribute( new Float32Array( coords ), 3 ) );

		}

		EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
		EdgesGeometry.prototype.constructor = EdgesGeometry;

		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */

		function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'CylinderBufferGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			var scope = this;

			radiusTop = radiusTop !== undefined ? radiusTop : 20;
			radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
			height = height !== undefined ? height : 100;

			radialSegments = Math.floor( radialSegments ) || 8;
			heightSegments = Math.floor( heightSegments ) || 1;

			openEnded = openEnded !== undefined ? openEnded : false;
			thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
			thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

			// used to calculate buffer length

			var nbCap = 0;

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) nbCap ++;
				if ( radiusBottom > 0 ) nbCap ++;

			}

			var vertexCount = calculateVertexCount();
			var indexCount = calculateIndexCount();

			// buffers

			var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
			var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
			var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

			// helper variables

			var index = 0,
			    indexOffset = 0,
			    indexArray = [],
			    halfHeight = height / 2;

			// group variables
			var groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.addAttribute( 'position', vertices );
			this.addAttribute( 'normal', normals );
			this.addAttribute( 'uv', uvs );

			// helper functions

			function calculateVertexCount() {

				var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

				if ( openEnded === false ) {

					count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

				}

				return count;

			}

			function calculateIndexCount() {

				var count = radialSegments * heightSegments * 2 * 3;

				if ( openEnded === false ) {

					count += radialSegments * nbCap * 3;

				}

				return count;

			}

			function generateTorso() {

				var x, y;
				var normal = new Vector3();
				var vertex = new Vector3();

				var groupCount = 0;

				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( y = 0; y <= heightSegments; y ++ ) {

					var indexRow = [];

					var v = y / heightSegments;

					// calculate the radius of the current row
					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( x = 0; x <= radialSegments; x ++ ) {

						var u = x / radialSegments;

						var theta = u * thetaLength + thetaStart;

						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );

						// vertex
						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

						// normal
						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.setXYZ( index, normal.x, normal.y, normal.z );

						// uv
						uvs.setXY( index, u, 1 - v );

						// save index of vertex in respective row
						indexRow.push( index );

						// increase index
						index ++;

					}

					// now save vertices of the row in our index array
					indexArray.push( indexRow );

				}

				// generate indices

				for ( x = 0; x < radialSegments; x ++ ) {

					for ( y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices
						var i1 = indexArray[ y ][ x ];
						var i2 = indexArray[ y + 1 ][ x ];
						var i3 = indexArray[ y + 1 ][ x + 1 ];
						var i4 = indexArray[ y ][ x + 1 ];

						// face one
						indices.setX( indexOffset, i1 ); indexOffset ++;
						indices.setX( indexOffset, i2 ); indexOffset ++;
						indices.setX( indexOffset, i4 ); indexOffset ++;

						// face two
						indices.setX( indexOffset, i2 ); indexOffset ++;
						indices.setX( indexOffset, i3 ); indexOffset ++;
						indices.setX( indexOffset, i4 ); indexOffset ++;

						// update counters
						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups
				groupStart += groupCount;

			}

			function generateCap( top ) {

				var x, centerIndexStart, centerIndexEnd;

				var uv = new Vector2();
				var vertex = new Vector3();

				var groupCount = 0;

				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;

				// save the index of the first center vertex
				centerIndexStart = index;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( x = 1; x <= radialSegments; x ++ ) {

					// vertex
					vertices.setXYZ( index, 0, halfHeight * sign, 0 );

					// normal
					normals.setXYZ( index, 0, sign, 0 );

					// uv
					uv.x = 0.5;
					uv.y = 0.5;

					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

				// save the index of the last center vertex
				centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;
					var theta = u * thetaLength + thetaStart;

					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );

					// vertex
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

					// normal
					normals.setXYZ( index, 0, sign, 0 );

					// uv
					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.setXY( index, uv.x, uv.y );

					// increase index
					index ++;

				}

				// generate indices

				for ( x = 0; x < radialSegments; x ++ ) {

					var c = centerIndexStart + x;
					var i = centerIndexEnd + x;

					if ( top === true ) {

						// face top
						indices.setX( indexOffset, i ); indexOffset ++;
						indices.setX( indexOffset, i + 1 ); indexOffset ++;
						indices.setX( indexOffset, c ); indexOffset ++;

					} else {

						// face bottom
						indices.setX( indexOffset, i + 1 ); indexOffset ++;
						indices.setX( indexOffset, i ); indexOffset ++;
						indices.setX( indexOffset, c ); indexOffset ++;

					}

					// update counters
					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support
				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups
				groupStart += groupCount;

			}

		}

		CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
			this.mergeVertices();

		}

		CylinderGeometry.prototype = Object.create( Geometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;

		/**
		 * @author abelnation / http://github.com/abelnation
		 */

		function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
		ConeGeometry.prototype.constructor = ConeGeometry;

		/**
		 * @author: abelnation / http://github.com/abelnation
		 */

		function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

			CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeBufferGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

		ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
		ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

			BufferGeometry.call( this );

			this.type = 'CircleBufferGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			radius = radius || 50;
			segments = segments !== undefined ? Math.max( 3, segments ) : 8;

			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

			var vertices = segments + 2;

			var positions = new Float32Array( vertices * 3 );
			var normals = new Float32Array( vertices * 3 );
			var uvs = new Float32Array( vertices * 2 );

			// center data is already zero, but need to set a few extras
			normals[ 2 ] = 1.0;
			uvs[ 0 ] = 0.5;
			uvs[ 1 ] = 0.5;

			for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

				var segment = thetaStart + s / segments * thetaLength;

				positions[ i ] = radius * Math.cos( segment );
				positions[ i + 1 ] = radius * Math.sin( segment );

				normals[ i + 2 ] = 1; // normal z

				uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
				uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

			}

			var indices = [];

			for ( var i = 1; i <= segments; i ++ ) {

				indices.push( i, i + 1, 0 );

			}

			this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

			this.boundingSphere = new Sphere( new Vector3(), radius );

		}

		CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

		/**
		 * @author hughes
		 */

		function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

			Geometry.call( this );

			this.type = 'CircleGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

		}

		CircleGeometry.prototype = Object.create( Geometry.prototype );
		CircleGeometry.prototype.constructor = CircleGeometry;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
		 */

		function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

			Geometry.call( this );

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
			this.mergeVertices();

		}

		BoxGeometry.prototype = Object.create( Geometry.prototype );
		BoxGeometry.prototype.constructor = BoxGeometry;



		var Geometries = Object.freeze({
			WireframeGeometry: WireframeGeometry,
			ParametricGeometry: ParametricGeometry,
			ParametricBufferGeometry: ParametricBufferGeometry,
			TetrahedronGeometry: TetrahedronGeometry,
			TetrahedronBufferGeometry: TetrahedronBufferGeometry,
			OctahedronGeometry: OctahedronGeometry,
			OctahedronBufferGeometry: OctahedronBufferGeometry,
			IcosahedronGeometry: IcosahedronGeometry,
			IcosahedronBufferGeometry: IcosahedronBufferGeometry,
			DodecahedronGeometry: DodecahedronGeometry,
			DodecahedronBufferGeometry: DodecahedronBufferGeometry,
			PolyhedronGeometry: PolyhedronGeometry,
			PolyhedronBufferGeometry: PolyhedronBufferGeometry,
			TubeGeometry: TubeGeometry,
			TubeBufferGeometry: TubeBufferGeometry,
			TorusKnotGeometry: TorusKnotGeometry,
			TorusKnotBufferGeometry: TorusKnotBufferGeometry,
			TorusGeometry: TorusGeometry,
			TorusBufferGeometry: TorusBufferGeometry,
			TextGeometry: TextGeometry,
			SphereBufferGeometry: SphereBufferGeometry,
			SphereGeometry: SphereGeometry,
			RingGeometry: RingGeometry,
			RingBufferGeometry: RingBufferGeometry,
			PlaneBufferGeometry: PlaneBufferGeometry,
			PlaneGeometry: PlaneGeometry,
			LatheGeometry: LatheGeometry,
			LatheBufferGeometry: LatheBufferGeometry,
			ShapeGeometry: ShapeGeometry,
			ExtrudeGeometry: ExtrudeGeometry,
			EdgesGeometry: EdgesGeometry,
			ConeGeometry: ConeGeometry,
			ConeBufferGeometry: ConeBufferGeometry,
			CylinderGeometry: CylinderGeometry,
			CylinderBufferGeometry: CylinderBufferGeometry,
			CircleBufferGeometry: CircleBufferGeometry,
			CircleGeometry: CircleGeometry,
			BoxBufferGeometry: BoxBufferGeometry,
			BoxGeometry: BoxGeometry
		});

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ShadowMaterial() {

			ShaderMaterial.call( this, {
				uniforms: UniformsUtils.merge( [
					UniformsLib[ "lights" ],
					{
						opacity: { value: 1.0 }
					}
				] ),
				vertexShader: ShaderChunk[ 'shadow_vert' ],
				fragmentShader: ShaderChunk[ 'shadow_frag' ]
			} );

			this.lights = true;
			this.transparent = true;

			Object.defineProperties( this, {
				opacity: {
					enumerable: true,
					get: function () {
						return this.uniforms.opacity.value;
					},
					set: function ( value ) {
						this.uniforms.opacity.value = value;
					}
				}
			} );

		}

		ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;

		ShadowMaterial.prototype.isShadowMaterial = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function RawShaderMaterial( parameters ) {

			ShaderMaterial.call( this, parameters );

			this.type = 'RawShaderMaterial';

		}

		RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;

		RawShaderMaterial.prototype.isRawShaderMaterial = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function MultiMaterial( materials ) {

			this.uuid = _Math.generateUUID();

			this.type = 'MultiMaterial';

			this.materials = materials instanceof Array ? materials : [];

			this.visible = true;

		}

		MultiMaterial.prototype = {

			constructor: MultiMaterial,

			isMultiMaterial: true,

			toJSON: function ( meta ) {

				var output = {
					metadata: {
						version: 4.2,
						type: 'material',
						generator: 'MaterialExporter'
					},
					uuid: this.uuid,
					type: this.type,
					materials: []
				};

				var materials = this.materials;

				for ( var i = 0, l = materials.length; i < l; i ++ ) {

					var material = materials[ i ].toJSON( meta );
					delete material.metadata;

					output.materials.push( material );

				}

				output.visible = this.visible;

				return output;

			},

			clone: function () {

				var material = new this.constructor();

				for ( var i = 0; i < this.materials.length; i ++ ) {

					material.materials.push( this.materials[ i ].clone() );

				}

				material.visible = this.visible;

				return material;

			}

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  roughness: <float>,
		 *  metalness: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  roughnessMap: new THREE.Texture( <Image> ),
		 *
		 *  metalnessMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  envMapIntensity: <float>
		 *
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshStandardMaterial( parameters ) {

			Material.call( this );

			this.defines = { 'STANDARD': '' };

			this.type = 'MeshStandardMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 0.5;
			this.metalness = 0.5;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.roughnessMap = null;

			this.metalnessMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.envMapIntensity = 1.0;

			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshStandardMaterial.prototype = Object.create( Material.prototype );
		MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

		MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

		MeshStandardMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.defines = { 'STANDARD': '' };

			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.roughnessMap = source.roughnessMap;

			this.metalnessMap = source.metalnessMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;

			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  reflectivity: <float>
		 * }
		 */

		function MeshPhysicalMaterial( parameters ) {

			MeshStandardMaterial.call( this );

			this.defines = { 'PHYSICAL': '' };

			this.type = 'MeshPhysicalMaterial';

			this.reflectivity = 0.5; // maps to F0 = 0.04

			this.clearCoat = 0.0;
			this.clearCoatRoughness = 0.0;

			this.setValues( parameters );

		}

		MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

		MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

		MeshPhysicalMaterial.prototype.copy = function ( source ) {

			MeshStandardMaterial.prototype.copy.call( this, source );

			this.defines = { 'PHYSICAL': '' };

			this.reflectivity = source.reflectivity;

			this.clearCoat = source.clearCoat;
			this.clearCoatRoughness = source.clearCoatRoughness;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshPhongMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshPhongMaterial.prototype = Object.create( Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

		MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

		MeshPhongMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * parameters = {
		 *  opacity: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */

		function MeshNormalMaterial( parameters ) {

			Material.call( this, parameters );

			this.type = 'MeshNormalMaterial';

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;
			this.lights = false;
			this.morphTargets = false;

			this.setValues( parameters );

		}

		MeshNormalMaterial.prototype = Object.create( Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

		MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

		MeshNormalMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */

		function MeshLambertMaterial( parameters ) {

			Material.call( this );

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		MeshLambertMaterial.prototype = Object.create( Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

		MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

		MeshLambertMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *
		 *  scale: <float>,
		 *  dashSize: <float>,
		 *  gapSize: <float>
		 * }
		 */

		function LineDashedMaterial( parameters ) {

			Material.call( this );

			this.type = 'LineDashedMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;

			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;

			this.lights = false;

			this.setValues( parameters );

		}

		LineDashedMaterial.prototype = Object.create( Material.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;

		LineDashedMaterial.prototype.isLineDashedMaterial = true;

		LineDashedMaterial.prototype.copy = function ( source ) {

			Material.prototype.copy.call( this, source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;

			return this;

		};



		var Materials = Object.freeze({
			ShadowMaterial: ShadowMaterial,
			SpriteMaterial: SpriteMaterial,
			RawShaderMaterial: RawShaderMaterial,
			ShaderMaterial: ShaderMaterial,
			PointsMaterial: PointsMaterial,
			MultiMaterial: MultiMaterial,
			MeshPhysicalMaterial: MeshPhysicalMaterial,
			MeshStandardMaterial: MeshStandardMaterial,
			MeshPhongMaterial: MeshPhongMaterial,
			MeshNormalMaterial: MeshNormalMaterial,
			MeshLambertMaterial: MeshLambertMaterial,
			MeshDepthMaterial: MeshDepthMaterial,
			MeshBasicMaterial: MeshBasicMaterial,
			LineDashedMaterial: LineDashedMaterial,
			LineBasicMaterial: LineBasicMaterial,
			Material: Material
		});

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		var Cache = {

			enabled: false,

			files: {},

			add: function ( key, file ) {

				if ( this.enabled === false ) return;

				// console.log( 'THREE.Cache', 'Adding key:', key );

				this.files[ key ] = file;

			},

			get: function ( key ) {

				if ( this.enabled === false ) return;

				// console.log( 'THREE.Cache', 'Checking key:', key );

				return this.files[ key ];

			},

			remove: function ( key ) {

				delete this.files[ key ];

			},

			clear: function () {

				this.files = {};

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LoadingManager( onLoad, onProgress, onError ) {

			var scope = this;

			var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function ( url ) {

				itemsTotal ++;

				if ( isLoading === false ) {

					if ( scope.onStart !== undefined ) {

						scope.onStart( url, itemsLoaded, itemsTotal );

					}

				}

				isLoading = true;

			};

			this.itemEnd = function ( url ) {

				itemsLoaded ++;

				if ( scope.onProgress !== undefined ) {

					scope.onProgress( url, itemsLoaded, itemsTotal );

				}

				if ( itemsLoaded === itemsTotal ) {

					isLoading = false;

					if ( scope.onLoad !== undefined ) {

						scope.onLoad();

					}

				}

			};

			this.itemError = function ( url ) {

				if ( scope.onError !== undefined ) {

					scope.onError( url );

				}

			};

		}

		var DefaultLoadingManager = new LoadingManager();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function XHRLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( XHRLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				if ( url === undefined ) url = '';

				if ( this.path !== undefined ) url = this.path + url;

				var scope = this;

				var cached = Cache.get( url );

				if ( cached !== undefined ) {

					scope.manager.itemStart( url );

					setTimeout( function () {

						if ( onLoad ) onLoad( cached );

						scope.manager.itemEnd( url );

					}, 0 );

					return cached;

				}

				// Check for data: URI
				var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
				var dataUriRegexResult = url.match( dataUriRegex );

				// Safari can not handle Data URIs through XMLHttpRequest so process manually
				if ( dataUriRegexResult ) {

					var mimeType = dataUriRegexResult[1];
					var isBase64 = !!dataUriRegexResult[2];
					var data = dataUriRegexResult[3];

					data = window.decodeURIComponent(data);

					if( isBase64 ) {
						data = window.atob(data);
					}

					try {

						var response;
						var responseType = ( this.responseType || '' ).toLowerCase();

						switch ( responseType ) {

							case 'arraybuffer':
							case 'blob':

							 	response = new ArrayBuffer( data.length );
								var view = new Uint8Array( response );
								for ( var i = 0; i < data.length; i ++ ) {

										view[ i ] = data.charCodeAt( i );

								}

								if ( responseType === 'blob' ) {

									response = new Blob( [ response ], { "type" : mimeType } );

								}

								break;

							case 'document':

								var parser = new DOMParser();
								response = parser.parseFromString( data, mimeType );

								break;

							case 'json':

								response = JSON.parse( data );

								break;

							default: // 'text' or other

								response = data;

								break;

						}

						// Wait for next browser tick
						window.setTimeout( function() {

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						}, 0);

					} catch ( error ) {

						// Wait for next browser tick
						window.setTimeout( function() {

							if ( onError ) onError( error );

							scope.manager.itemError( url );

						}, 0);

					}

				} else {

					var request = new XMLHttpRequest();
					request.open( 'GET', url, true );

					request.addEventListener( 'load', function ( event ) {

						var response = event.target.response;

						Cache.add( url, response );

						if ( this.status === 200 ) {

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						} else if ( this.status === 0 ) {

							// Some browsers return HTTP Status 0 when using non-http protocol
							// e.g. 'file://' or 'data://'. Handle as success.

							console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

							if ( onLoad ) onLoad( response );

							scope.manager.itemEnd( url );

						} else {

							if ( onError ) onError( event );

							scope.manager.itemError( url );

						}

					}, false );

					if ( onProgress !== undefined ) {

						request.addEventListener( 'progress', function ( event ) {

							onProgress( event );

						}, false );

					}

					request.addEventListener( 'error', function ( event ) {

						if ( onError ) onError( event );

						scope.manager.itemError( url );

					}, false );

					if ( this.responseType !== undefined ) request.responseType = this.responseType;
					if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

					if ( request.overrideMimeType ) request.overrideMimeType( 'text/plain' );

					request.send( null );

				}

				scope.manager.itemStart( url );

				return request;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			},

			setResponseType: function ( value ) {

				this.responseType = value;
				return this;

			},

			setWithCredentials: function ( value ) {

				this.withCredentials = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Abstract Base class to block based textures loader (dds, pvr, ...)
		 */

		function CompressedTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			// override in sub classes
			this._parser = null;

		}

		Object.assign( CompressedTextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var images = [];

				var texture = new CompressedTexture();
				texture.image = images;

				var loader = new XHRLoader( this.manager );
				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );

				function loadTexture( i ) {

					loader.load( url[ i ], function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};

						loaded += 1;

						if ( loaded === 6 ) {

							if ( texDatas.mipmapCount === 1 )
								texture.minFilter = LinearFilter;

							texture.format = texDatas.format;
							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, onProgress, onError );

				}

				if ( Array.isArray( url ) ) {

					var loaded = 0;

					for ( var i = 0, il = url.length; i < il; ++ i ) {

						loadTexture( i );

					}

				} else {

					// compressed cubemap texture stored in a single DDS file

					loader.load( url, function ( buffer ) {

						var texDatas = scope._parser( buffer, true );

						if ( texDatas.isCubemap ) {

							var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

							for ( var f = 0; f < faces; f ++ ) {

								images[ f ] = { mipmaps : [] };

								for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

									images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
									images[ f ].format = texDatas.format;
									images[ f ].width = texDatas.width;
									images[ f ].height = texDatas.height;

								}

							}

						} else {

							texture.image.width = texDatas.width;
							texture.image.height = texDatas.height;
							texture.mipmaps = texDatas.mipmaps;

						}

						if ( texDatas.mipmapCount === 1 ) {

							texture.minFilter = LinearFilter;

						}

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}, onProgress, onError );

				}

				return texture;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author Nikos M. / https://github.com/foo123/
		 *
		 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
		 */

		var DataTextureLoader = BinaryTextureLoader;
		function BinaryTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			// override in sub classes
			this._parser = null;

		}

		Object.assign( BinaryTextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var texture = new DataTexture();

				var loader = new XHRLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );

				loader.load( url, function ( buffer ) {

					var texData = scope._parser( buffer );

					if ( ! texData ) return;

					if ( undefined !== texData.image ) {

						texture.image = texData.image;

					} else if ( undefined !== texData.data ) {

						texture.image.width = texData.width;
						texture.image.height = texData.height;
						texture.image.data = texData.data;

					}

					texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
					texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

					texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
					texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

					texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

					if ( undefined !== texData.format ) {

						texture.format = texData.format;

					}
					if ( undefined !== texData.type ) {

						texture.type = texData.type;

					}

					if ( undefined !== texData.mipmaps ) {

						texture.mipmaps = texData.mipmaps;

					}

					if ( 1 === texData.mipmapCount ) {

						texture.minFilter = LinearFilter;

					}

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture, texData );

				}, onProgress, onError );


				return texture;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ImageLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( ImageLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
				image.onload = function () {

					image.onload = null;

					URL.revokeObjectURL( image.src );

					if ( onLoad ) onLoad( image );

					scope.manager.itemEnd( url );

				};
				image.onerror = onError;

				if ( url.indexOf( 'data:' ) === 0 ) {

					image.src = url;

				} else {

					var loader = new XHRLoader();
					loader.setPath( this.path );
					loader.setResponseType( 'blob' );
					loader.setWithCredentials( this.withCredentials );
					loader.load( url, function ( blob ) {

						image.src = URL.createObjectURL( blob );

					}, onProgress, onError );

				}

				scope.manager.itemStart( url );

				return image;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setWithCredentials: function ( value ) {

				this.withCredentials = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function CubeTextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( CubeTextureLoader.prototype, {

			load: function ( urls, onLoad, onProgress, onError ) {

				var texture = new CubeTexture();

				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );

				var loaded = 0;

				function loadTexture( i ) {

					loader.load( urls[ i ], function ( image ) {

						texture.images[ i ] = image;

						loaded ++;

						if ( loaded === 6 ) {

							texture.needsUpdate = true;

							if ( onLoad ) onLoad( texture );

						}

					}, undefined, onError );

				}

				for ( var i = 0; i < urls.length; ++ i ) {

					loadTexture( i );

				}

				return texture;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function TextureLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( TextureLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var texture = new Texture();

				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setWithCredentials( this.withCredentials );
				loader.setPath( this.path );
				loader.load( url, function ( image ) {

					// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
					var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

					texture.format = isJPEG ? RGBFormat : RGBAFormat;
					texture.image = image;
					texture.needsUpdate = true;

					if ( onLoad !== undefined ) {

						onLoad( texture );

					}

				}, onProgress, onError );

				return texture;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;
				return this;

			},

			setWithCredentials: function ( value ) {

				this.withCredentials = value;
				return this;

			},

			setPath: function ( value ) {

				this.path = value;
				return this;

			}



		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Light( color, intensity ) {

			Object3D.call( this );

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity !== undefined ? intensity : 1;

			this.receiveShadow = undefined;

		}

		Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Light,

			isLight: true,

			copy: function ( source ) {

				Object3D.prototype.copy.call( this, source );

				this.color.copy( source.color );
				this.intensity = source.intensity;

				return this;

			},

			toJSON: function ( meta ) {

				var data = Object3D.prototype.toJSON.call( this, meta );

				data.object.color = this.color.getHex();
				data.object.intensity = this.intensity;

				if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

				if ( this.distance !== undefined ) data.object.distance = this.distance;
				if ( this.angle !== undefined ) data.object.angle = this.angle;
				if ( this.decay !== undefined ) data.object.decay = this.decay;
				if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

				if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

				return data;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function HemisphereLight( skyColor, groundColor, intensity ) {

			Light.call( this, skyColor, intensity );

			this.type = 'HemisphereLight';

			this.castShadow = undefined;

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: HemisphereLight,

			isHemisphereLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.groundColor.copy( source.groundColor );

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function LightShadow( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.radius = 1;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.matrix = new Matrix4();

		}

		Object.assign( LightShadow.prototype, {

			copy: function ( source ) {

				this.camera = source.camera.clone();

				this.bias = source.bias;
				this.radius = source.radius;

				this.mapSize.copy( source.mapSize );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			toJSON: function () {

				var object = {};

				if ( this.bias !== 0 ) object.bias = this.bias;
				if ( this.radius !== 1 ) object.radius = this.radius;
				if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

				object.camera = this.camera.toJSON( false ).object;
				delete object.camera.matrix;

				return object;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function SpotLightShadow() {

			LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		}

		SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: SpotLightShadow,

			isSpotLightShadow: true,

			update: function ( light ) {

				var fov = _Math.RAD2DEG * 2 * light.angle;
				var aspect = this.mapSize.width / this.mapSize.height;
				var far = light.distance || 500;

				var camera = this.camera;

				if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

					camera.fov = fov;
					camera.aspect = aspect;
					camera.far = far;
					camera.updateProjectionMatrix();

				}

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

			Light.call( this, color, intensity );

			this.type = 'SpotLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * Math.PI;
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / Math.PI;
				}
			} );

			this.distance = ( distance !== undefined ) ? distance : 0;
			this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
			this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();

		}

		SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: SpotLight,

			isSpotLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.distance = source.distance;
				this.angle = source.angle;
				this.penumbra = source.penumbra;
				this.decay = source.decay;

				this.target = source.target.clone();

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */


		function PointLight( color, intensity, distance, decay ) {

			Light.call( this, color, intensity );

			this.type = 'PointLight';

			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * 4 * Math.PI;

				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / ( 4 * Math.PI );
				}
			} );

			this.distance = ( distance !== undefined ) ? distance : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

			this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		}

		PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: PointLight,

			isPointLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.distance = source.distance;
				this.decay = source.decay;

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function DirectionalLightShadow( light ) {

			LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		}

		DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

			constructor: DirectionalLightShadow

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function DirectionalLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: DirectionalLight,

			isDirectionalLight: true,

			copy: function ( source ) {

				Light.prototype.copy.call( this, source );

				this.target = source.target.clone();

				this.shadow = source.shadow.clone();

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AmbientLight( color, intensity ) {

			Light.call( this, color, intensity );

			this.type = 'AmbientLight';

			this.castShadow = undefined;

		}

		AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

			constructor: AmbientLight,

			isAmbientLight: true,

		} );

		/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */

		var AnimationUtils = {

			// same as Array.prototype.slice, but also works on typed arrays
			arraySlice: function( array, from, to ) {

				if ( AnimationUtils.isTypedArray( array ) ) {

					return new array.constructor( array.subarray( from, to ) );

				}

				return array.slice( from, to );

			},

			// converts an array to a specific type
			convertArray: function( array, type, forceClone ) {

				if ( ! array || // let 'undefined' and 'null' pass
						! forceClone && array.constructor === type ) return array;

				if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

					return new type( array ); // create typed array

				}

				return Array.prototype.slice.call( array ); // create Array

			},

			isTypedArray: function( object ) {

				return ArrayBuffer.isView( object ) &&
						! ( object instanceof DataView );

			},

			// returns an array by which times and values can be sorted
			getKeyframeOrder: function( times ) {

				function compareTime( i, j ) {

					return times[ i ] - times[ j ];

				}

				var n = times.length;
				var result = new Array( n );
				for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

				result.sort( compareTime );

				return result;

			},

			// uses the array previously returned by 'getKeyframeOrder' to sort data
			sortedArray: function( values, stride, order ) {

				var nValues = values.length;
				var result = new values.constructor( nValues );

				for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

					var srcOffset = order[ i ] * stride;

					for ( var j = 0; j !== stride; ++ j ) {

						result[ dstOffset ++ ] = values[ srcOffset + j ];

					}

				}

				return result;

			},

			// function for parsing AOS keyframe formats
			flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

				var i = 1, key = jsonKeys[ 0 ];

				while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

					key = jsonKeys[ i ++ ];

				}

				if ( key === undefined ) return; // no data

				var value = key[ valuePropertyName ];
				if ( value === undefined ) return; // no data

				if ( Array.isArray( value ) ) {

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							values.push.apply( values, value ); // push all elements

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				} else if ( value.toArray !== undefined ) {
					// ...assume THREE.Math-ish

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							value.toArray( values, values.length );

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				} else {
					// otherwise push as-is

					do {

						value = key[ valuePropertyName ];

						if ( value !== undefined ) {

							times.push( key.time );
							values.push( value );

						}

						key = jsonKeys[ i ++ ];

					} while ( key !== undefined );

				}

			}

		};

		/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */

		function Interpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;

			this.resultBuffer = resultBuffer !== undefined ?
					resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;

		}

		Interpolant.prototype = {

			constructor: Interpolant,

			evaluate: function( t ) {

				var pp = this.parameterPositions,
					i1 = this._cachedIndex,

					t1 = pp[   i1   ],
					t0 = pp[ i1 - 1 ];

				validate_interval: {

					seek: {

						var right;

						linear_scan: {
		//- See http://jsperf.com/comparison-to-undefined/3
		//- slower code:
		//-
		//- 				if ( t >= t1 || t1 === undefined ) {
							forward_scan: if ( ! ( t < t1 ) ) {

								for ( var giveUpAt = i1 + 2; ;) {

									if ( t1 === undefined ) {

										if ( t < t0 ) break forward_scan;

										// after end

										i1 = pp.length;
										this._cachedIndex = i1;
										return this.afterEnd_( i1 - 1, t, t0 );

									}

									if ( i1 === giveUpAt ) break; // this loop

									t0 = t1;
									t1 = pp[ ++ i1 ];

									if ( t < t1 ) {

										// we have arrived at the sought interval
										break seek;

									}

								}

								// prepare binary search on the right side of the index
								right = pp.length;
								break linear_scan;

							}

		//- slower code:
		//-					if ( t < t0 || t0 === undefined ) {
							if ( ! ( t >= t0 ) ) {

								// looping?

								var t1global = pp[ 1 ];

								if ( t < t1global ) {

									i1 = 2; // + 1, using the scan for the details
									t0 = t1global;

								}

								// linear reverse scan

								for ( var giveUpAt = i1 - 2; ;) {

									if ( t0 === undefined ) {

										// before start

										this._cachedIndex = 0;
										return this.beforeStart_( 0, t, t1 );

									}

									if ( i1 === giveUpAt ) break; // this loop

									t1 = t0;
									t0 = pp[ -- i1 - 1 ];

									if ( t >= t0 ) {

										// we have arrived at the sought interval
										break seek;

									}

								}

								// prepare binary search on the left side of the index
								right = i1;
								i1 = 0;
								break linear_scan;

							}

							// the interval is valid

							break validate_interval;

						} // linear scan

						// binary search

						while ( i1 < right ) {

							var mid = ( i1 + right ) >>> 1;

							if ( t < pp[ mid ] ) {

								right = mid;

							} else {

								i1 = mid + 1;

							}

						}

						t1 = pp[   i1   ];
						t0 = pp[ i1 - 1 ];

						// check boundary cases, again

						if ( t0 === undefined ) {

							this._cachedIndex = 0;
							return this.beforeStart_( 0, t, t1 );

						}

						if ( t1 === undefined ) {

							i1 = pp.length;
							this._cachedIndex = i1;
							return this.afterEnd_( i1 - 1, t0, t );

						}

					} // seek

					this._cachedIndex = i1;

					this.intervalChanged_( i1, t0, t1 );

				} // validate_interval

				return this.interpolate_( i1, t0, t, t1 );

			},

			settings: null, // optional, subclass-specific settings structure
			// Note: The indirection allows central control of many interpolants.

			// --- Protected interface

			DefaultSettings_: {},

			getSettings_: function() {

				return this.settings || this.DefaultSettings_;

			},

			copySampleValue_: function( index ) {

				// copies a sample value to the result buffer

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] = values[ offset + i ];

				}

				return result;

			},

			// Template methods for derived classes:

			interpolate_: function( i1, t0, t, t1 ) {

				throw new Error( "call to abstract method" );
				// implementations shall return this.resultBuffer

			},

			intervalChanged_: function( i1, t0, t1 ) {

				// empty

			}

		};

		Object.assign( Interpolant.prototype, {

			beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_,

			afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_

		} );

		/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */

		function CubicInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;

		}

		CubicInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: CubicInterpolant,

			DefaultSettings_: {

				endingStart: 	ZeroCurvatureEnding,
				endingEnd:		ZeroCurvatureEnding

			},

			intervalChanged_: function( i1, t0, t1 ) {

				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,

					tPrev = pp[ iPrev ],
					tNext = pp[ iNext ];

				if ( tPrev === undefined ) {

					switch ( this.getSettings_().endingStart ) {

						case ZeroSlopeEnding:

							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;

							break;

						case WrapAroundEnding:

							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

							break;

						default: // ZeroCurvatureEnding

							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;

					}

				}

				if ( tNext === undefined ) {

					switch ( this.getSettings_().endingEnd ) {

						case ZeroSlopeEnding:

							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;

							break;

						case WrapAroundEnding:

							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[ 1 ] - pp[ 0 ];

							break;

						default: // ZeroCurvatureEnding

							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;

					}

				}

				var halfDt = ( t1 - t0 ) * 0.5,
					stride = this.valueSize;

				this._weightPrev = halfDt / ( t0 - tPrev );
				this._weightNext = halfDt / ( tNext - t1 );
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;

			},

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					o1 = i1 * stride,		o0 = o1 - stride,
					oP = this._offsetPrev, 	oN = this._offsetNext,
					wP = this._weightPrev,	wN = this._weightNext,

					p = ( t - t0 ) / ( t1 - t0 ),
					pp = p * p,
					ppp = pp * p;

				// evaluate polynomials

				var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
				var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
				var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
				var sN =       wN   * ppp   -           wN      * pp;

				// combine data linearly

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] =
							sP * values[ oP + i ] +
							s0 * values[ o0 + i ] +
							s1 * values[ o1 + i ] +
							sN * values[ oN + i ];

				}

				return result;

			}

		} );

		/**
		 * @author tschw
		 */

		function LinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		LinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: LinearInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset1 = i1 * stride,
					offset0 = offset1 - stride,

					weight1 = ( t - t0 ) / ( t1 - t0 ),
					weight0 = 1 - weight1;

				for ( var i = 0; i !== stride; ++ i ) {

					result[ i ] =
							values[ offset0 + i ] * weight0 +
							values[ offset1 + i ] * weight1;

				}

				return result;

			}

		} );

		/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */

		function DiscreteInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		DiscreteInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: DiscreteInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				return this.copySampleValue_( i1 - 1 );

			}

		} );

		var KeyframeTrackPrototype;

		KeyframeTrackPrototype = {

			TimeBufferType: Float32Array,
			ValueBufferType: Float32Array,

			DefaultInterpolation: InterpolateLinear,

			InterpolantFactoryMethodDiscrete: function( result ) {

				return new DiscreteInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodLinear: function( result ) {

				return new LinearInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodSmooth: function( result ) {

				return new CubicInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			setInterpolation: function( interpolation ) {

				var factoryMethod;

				switch ( interpolation ) {

					case InterpolateDiscrete:

						factoryMethod = this.InterpolantFactoryMethodDiscrete;

						break;

					case InterpolateLinear:

						factoryMethod = this.InterpolantFactoryMethodLinear;

						break;

					case InterpolateSmooth:

						factoryMethod = this.InterpolantFactoryMethodSmooth;

						break;

				}

				if ( factoryMethod === undefined ) {

					var message = "unsupported interpolation for " +
							this.ValueTypeName + " keyframe track named " + this.name;

					if ( this.createInterpolant === undefined ) {

						// fall back to default, unless the default itself is messed up
						if ( interpolation !== this.DefaultInterpolation ) {

							this.setInterpolation( this.DefaultInterpolation );

						} else {

							throw new Error( message ); // fatal, in this case

						}

					}

					console.warn( message );
					return;

				}

				this.createInterpolant = factoryMethod;

			},

			getInterpolation: function() {

				switch ( this.createInterpolant ) {

					case this.InterpolantFactoryMethodDiscrete:

						return InterpolateDiscrete;

					case this.InterpolantFactoryMethodLinear:

						return InterpolateLinear;

					case this.InterpolantFactoryMethodSmooth:

						return InterpolateSmooth;

				}

			},

			getValueSize: function() {

				return this.values.length / this.times.length;

			},

			// move all keyframes either forwards or backwards in time
			shift: function( timeOffset ) {

				if( timeOffset !== 0.0 ) {

					var times = this.times;

					for( var i = 0, n = times.length; i !== n; ++ i ) {

						times[ i ] += timeOffset;

					}

				}

				return this;

			},

			// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
			scale: function( timeScale ) {

				if( timeScale !== 1.0 ) {

					var times = this.times;

					for( var i = 0, n = times.length; i !== n; ++ i ) {

						times[ i ] *= timeScale;

					}

				}

				return this;

			},

			// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
			// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
			trim: function( startTime, endTime ) {

				var times = this.times,
					nKeys = times.length,
					from = 0,
					to = nKeys - 1;

				while ( from !== nKeys && times[ from ] < startTime ) ++ from;
				while ( to !== -1 && times[ to ] > endTime ) -- to;

				++ to; // inclusive -> exclusive bound

				if( from !== 0 || to !== nKeys ) {

					// empty tracks are forbidden, so keep at least one keyframe
					if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;

					var stride = this.getValueSize();
					this.times = AnimationUtils.arraySlice( times, from, to );
					this.values = AnimationUtils.
							arraySlice( this.values, from * stride, to * stride );

				}

				return this;

			},

			// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
			validate: function() {

				var valid = true;

				var valueSize = this.getValueSize();
				if ( valueSize - Math.floor( valueSize ) !== 0 ) {

					console.error( "invalid value size in track", this );
					valid = false;

				}

				var times = this.times,
					values = this.values,

					nKeys = times.length;

				if( nKeys === 0 ) {

					console.error( "track is empty", this );
					valid = false;

				}

				var prevTime = null;

				for( var i = 0; i !== nKeys; i ++ ) {

					var currTime = times[ i ];

					if ( typeof currTime === 'number' && isNaN( currTime ) ) {

						console.error( "time is not a valid number", this, i, currTime );
						valid = false;
						break;

					}

					if( prevTime !== null && prevTime > currTime ) {

						console.error( "out of order keys", this, i, currTime, prevTime );
						valid = false;
						break;

					}

					prevTime = currTime;

				}

				if ( values !== undefined ) {

					if ( AnimationUtils.isTypedArray( values ) ) {

						for ( var i = 0, n = values.length; i !== n; ++ i ) {

							var value = values[ i ];

							if ( isNaN( value ) ) {

								console.error( "value is not a valid number", this, i, value );
								valid = false;
								break;

							}

						}

					}

				}

				return valid;

			},

			// removes equivalent sequential keys as common in morph target sequences
			// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
			optimize: function() {

				var times = this.times,
					values = this.values,
					stride = this.getValueSize(),

					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

					writeIndex = 1,
					lastIndex = times.length - 1;

				for( var i = 1; i < lastIndex; ++ i ) {

					var keep = false;

					var time = times[ i ];
					var timeNext = times[ i + 1 ];

					// remove adjacent keyframes scheduled at the same time

					if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

						if ( ! smoothInterpolation ) {

							// remove unnecessary keyframes same as their neighbors

							var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;

							for ( var j = 0; j !== stride; ++ j ) {

								var value = values[ offset + j ];

								if ( value !== values[ offsetP + j ] ||
										value !== values[ offsetN + j ] ) {

									keep = true;
									break;

								}

							}

						} else keep = true;

					}

					// in-place compaction

					if ( keep ) {

						if ( i !== writeIndex ) {

							times[ writeIndex ] = times[ i ];

							var readOffset = i * stride,
								writeOffset = writeIndex * stride;

							for ( var j = 0; j !== stride; ++ j )

								values[ writeOffset + j ] = values[ readOffset + j ];

						}

						++ writeIndex;

					}

				}

				// flush last keyframe (compaction looks ahead)

				if ( lastIndex > 0 ) {

					times[ writeIndex ] = times[ lastIndex ];

					for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

						values[ writeOffset + j ] = values[ readOffset + j ];

					++ writeIndex;

				}

				if ( writeIndex !== times.length ) {

					this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
					this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

				}

				return this;

			}

		};

		function KeyframeTrackConstructor( name, times, values, interpolation ) {

			if( name === undefined ) throw new Error( "track name is undefined" );

			if( times === undefined || times.length === 0 ) {

				throw new Error( "no keyframes in track named " + name );

			}

			this.name = name;

			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

			this.setInterpolation( interpolation || this.DefaultInterpolation );

			this.validate();
			this.optimize();

		}

		/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function VectorKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		VectorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: VectorKeyframeTrack,

			ValueTypeName: 'vector'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		} );

		/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */

		function QuaternionLinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {

			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		}

		QuaternionLinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {

			constructor: QuaternionLinearInterpolant,

			interpolate_: function( i1, t0, t, t1 ) {

				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,

					offset = i1 * stride,

					alpha = ( t - t0 ) / ( t1 - t0 );

				for ( var end = offset + stride; offset !== end; offset += 4 ) {

					Quaternion.slerpFlat( result, 0,
							values, offset - stride, values, offset, alpha );

				}

				return result;

			}

		} );

		/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function QuaternionKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		QuaternionKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: QuaternionKeyframeTrack,

			ValueTypeName: 'quaternion',

			// ValueBufferType is inherited

			DefaultInterpolation: InterpolateLinear,

			InterpolantFactoryMethodLinear: function( result ) {

				return new QuaternionLinearInterpolant(
						this.times, this.values, this.getValueSize(), result );

			},

			InterpolantFactoryMethodSmooth: undefined // not yet implemented

		} );

		/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function NumberKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		NumberKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: NumberKeyframeTrack,

			ValueTypeName: 'number',

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited

		} );

		/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function StringKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		StringKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: StringKeyframeTrack,

			ValueTypeName: 'string',
			ValueBufferType: Array,

			DefaultInterpolation: InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,

			InterpolantFactoryMethodSmooth: undefined

		} );

		/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function BooleanKeyframeTrack( name, times, values ) {

			KeyframeTrackConstructor.call( this, name, times, values );

		}

		BooleanKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: BooleanKeyframeTrack,

			ValueTypeName: 'bool',
			ValueBufferType: Array,

			DefaultInterpolation: InterpolateDiscrete,

			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined

			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".

		} );

		/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function ColorKeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.call( this, name, times, values, interpolation );

		}

		ColorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {

			constructor: ColorKeyframeTrack,

			ValueTypeName: 'color'

			// ValueBufferType is inherited

			// DefaultInterpolation is inherited


			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.

		} );

		/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function KeyframeTrack( name, times, values, interpolation ) {

			KeyframeTrackConstructor.apply( this, arguments );

		}

		KeyframeTrack.prototype = KeyframeTrackPrototype;
		KeyframeTrackPrototype.constructor = KeyframeTrack;

		// Static methods:

		Object.assign( KeyframeTrack, {

			// Serialization (in static context, because of constructor invocation
			// and automatic invocation of .toJSON):

			parse: function( json ) {

				if( json.type === undefined ) {

					throw new Error( "track type undefined, can not parse" );

				}

				var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

				if ( json.times === undefined ) {

					var times = [], values = [];

					AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

					json.times = times;
					json.values = values;

				}

				// derived classes can define a static parse method
				if ( trackType.parse !== undefined ) {

					return trackType.parse( json );

				} else {

					// by default, we asssume a constructor compatible with the base
					return new trackType(
							json.name, json.times, json.values, json.interpolation );

				}

			},

			toJSON: function( track ) {

				var trackType = track.constructor;

				var json;

				// derived classes can define a static toJSON method
				if ( trackType.toJSON !== undefined ) {

					json = trackType.toJSON( track );

				} else {

					// by default, we assume the data can be serialized as-is
					json = {

						'name': track.name,
						'times': AnimationUtils.convertArray( track.times, Array ),
						'values': AnimationUtils.convertArray( track.values, Array )

					};

					var interpolation = track.getInterpolation();

					if ( interpolation !== track.DefaultInterpolation ) {

						json.interpolation = interpolation;

					}

				}

				json.type = track.ValueTypeName; // mandatory

				return json;

			},

			_getTrackTypeForValueTypeName: function( typeName ) {

				switch( typeName.toLowerCase() ) {

					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":

						return NumberKeyframeTrack;

					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":

						return VectorKeyframeTrack;

					case "color":

						return ColorKeyframeTrack;

					case "quaternion":

						return QuaternionKeyframeTrack;

					case "bool":
					case "boolean":

						return BooleanKeyframeTrack;

					case "string":

						return StringKeyframeTrack;

				}

				throw new Error( "Unsupported typeName: " + typeName );

			}

		} );

		/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */

		function AnimationClip( name, duration, tracks ) {

			this.name = name;
			this.tracks = tracks;
			this.duration = ( duration !== undefined ) ? duration : -1;

			this.uuid = _Math.generateUUID();

			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {

				this.resetDuration();

			}

			this.optimize();

		}

		AnimationClip.prototype = {

			constructor: AnimationClip,

			resetDuration: function() {

				var tracks = this.tracks,
					duration = 0;

				for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

					var track = this.tracks[ i ];

					duration = Math.max(
							duration, track.times[ track.times.length - 1 ] );

				}

				this.duration = duration;

			},

			trim: function() {

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					this.tracks[ i ].trim( 0, this.duration );

				}

				return this;

			},

			optimize: function() {

				for ( var i = 0; i < this.tracks.length; i ++ ) {

					this.tracks[ i ].optimize();

				}

				return this;

			}

		};

		// Static methods:

		Object.assign( AnimationClip, {

			parse: function( json ) {

				var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / ( json.fps || 1.0 );

				for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

					tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

				}

				return new AnimationClip( json.name, json.duration, tracks );

			},


			toJSON: function( clip ) {

				var tracks = [],
					clipTracks = clip.tracks;

				var json = {

					'name': clip.name,
					'duration': clip.duration,
					'tracks': tracks

				};

				for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

					tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

				}

				return json;

			},


			CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

				var numMorphTargets = morphTargetSequence.length;
				var tracks = [];

				for ( var i = 0; i < numMorphTargets; i ++ ) {

					var times = [];
					var values = [];

					times.push(
							( i + numMorphTargets - 1 ) % numMorphTargets,
							i,
							( i + 1 ) % numMorphTargets );

					values.push( 0, 1, 0 );

					var order = AnimationUtils.getKeyframeOrder( times );
					times = AnimationUtils.sortedArray( times, 1, order );
					values = AnimationUtils.sortedArray( values, 1, order );

					// if there is a key at the first frame, duplicate it as the
					// last frame as well for perfect loop.
					if ( ! noLoop && times[ 0 ] === 0 ) {

						times.push( numMorphTargets );
						values.push( values[ 0 ] );

					}

					tracks.push(
							new NumberKeyframeTrack(
								'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
								times, values
							).scale( 1.0 / fps ) );
				}

				return new AnimationClip( name, -1, tracks );

			},

			findByName: function( objectOrClipArray, name ) {

				var clipArray = objectOrClipArray;

				if ( ! Array.isArray( objectOrClipArray ) ) {

					var o = objectOrClipArray;
					clipArray = o.geometry && o.geometry.animations || o.animations;

				}

				for ( var i = 0; i < clipArray.length; i ++ ) {

					if ( clipArray[ i ].name === name ) {

						return clipArray[ i ];

					}
				}

				return null;

			},

			CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

				var animationToMorphTargets = {};

				// tested with https://regex101.com/ on trick sequences
				// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
				var pattern = /^([\w-]*?)([\d]+)$/;

				// sort morph target names into animation groups based
				// patterns like Walk_001, Walk_002, Run_001, Run_002
				for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

					var morphTarget = morphTargets[ i ];
					var parts = morphTarget.name.match( pattern );

					if ( parts && parts.length > 1 ) {

						var name = parts[ 1 ];

						var animationMorphTargets = animationToMorphTargets[ name ];
						if ( ! animationMorphTargets ) {

							animationToMorphTargets[ name ] = animationMorphTargets = [];

						}

						animationMorphTargets.push( morphTarget );

					}

				}

				var clips = [];

				for ( var name in animationToMorphTargets ) {

					clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

				}

				return clips;

			},

			// parse the animation.hierarchy format
			parseAnimation: function( animation, bones ) {

				if ( ! animation ) {

					console.error( "  no animation in JSONLoader data" );
					return null;

				}

				var addNonemptyTrack = function(
						trackType, trackName, animationKeys, propertyName, destTracks ) {

					// only return track if there are actually keys.
					if ( animationKeys.length !== 0 ) {

						var times = [];
						var values = [];

						AnimationUtils.flattenJSON(
								animationKeys, times, values, propertyName );

						// empty keys are filtered out, so check again
						if ( times.length !== 0 ) {

							destTracks.push( new trackType( trackName, times, values ) );

						}

					}

				};

				var tracks = [];

				var clipName = animation.name || 'default';
				// automatic length determination in AnimationClip.
				var duration = animation.length || -1;
				var fps = animation.fps || 30;

				var hierarchyTracks = animation.hierarchy || [];

				for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

					var animationKeys = hierarchyTracks[ h ].keys;

					// skip empty tracks
					if ( ! animationKeys || animationKeys.length === 0 ) continue;

					// process morph targets in a way exactly compatible
					// with AnimationHandler.init( animation )
					if ( animationKeys[0].morphTargets ) {

						// figure out all morph targets used in this track
						var morphTargetNames = {};
						for ( var k = 0; k < animationKeys.length; k ++ ) {

							if ( animationKeys[k].morphTargets ) {

								for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

									morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
								}

							}

						}

						// create a track for each morph target with all zero
						// morphTargetInfluences except for the keys in which
						// the morphTarget is named.
						for ( var morphTargetName in morphTargetNames ) {

							var times = [];
							var values = [];

							for ( var m = 0;
									m !== animationKeys[k].morphTargets.length; ++ m ) {

								var animationKey = animationKeys[k];

								times.push( animationKey.time );
								values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

							}

							tracks.push( new NumberKeyframeTrack(
									'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

						}

						duration = morphTargetNames.length * ( fps || 1.0 );

					} else {
						// ...assume skeletal animation

						var boneName = '.bones[' + bones[ h ].name + ']';

						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.position',
								animationKeys, 'pos', tracks );

						addNonemptyTrack(
								QuaternionKeyframeTrack, boneName + '.quaternion',
								animationKeys, 'rot', tracks );

						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.scale',
								animationKeys, 'scl', tracks );

					}

				}

				if ( tracks.length === 0 ) {

					return null;

				}

				var clip = new AnimationClip( clipName, duration, tracks );

				return clip;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function MaterialLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.textures = {};

		}

		Object.assign( MaterialLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			setTextures: function ( value ) {

				this.textures = value;

			},

			parse: function ( json ) {

				var textures = this.textures;

				function getTexture( name ) {

					if ( textures[ name ] === undefined ) {

						console.warn( 'THREE.MaterialLoader: Undefined texture', name );

					}

					return textures[ name ];

				}

				var material = new Materials[ json.type ]();

				if ( json.uuid !== undefined ) material.uuid = json.uuid;
				if ( json.name !== undefined ) material.name = json.name;
				if ( json.color !== undefined ) material.color.setHex( json.color );
				if ( json.roughness !== undefined ) material.roughness = json.roughness;
				if ( json.metalness !== undefined ) material.metalness = json.metalness;
				if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
				if ( json.specular !== undefined ) material.specular.setHex( json.specular );
				if ( json.shininess !== undefined ) material.shininess = json.shininess;
				if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
				if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
				if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
				if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
				if ( json.fog !== undefined ) material.fog = json.fog;
				if ( json.shading !== undefined ) material.shading = json.shading;
				if ( json.blending !== undefined ) material.blending = json.blending;
				if ( json.side !== undefined ) material.side = json.side;
				if ( json.opacity !== undefined ) material.opacity = json.opacity;
				if ( json.transparent !== undefined ) material.transparent = json.transparent;
				if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
				if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
				if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
				if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
				if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
				if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
				if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
				if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
				if ( json.skinning !== undefined ) material.skinning = json.skinning;
				if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

				// for PointsMaterial

				if ( json.size !== undefined ) material.size = json.size;
				if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

				// maps

				if ( json.map !== undefined ) material.map = getTexture( json.map );

				if ( json.alphaMap !== undefined ) {

					material.alphaMap = getTexture( json.alphaMap );
					material.transparent = true;

				}

				if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
				if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

				if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
				if ( json.normalScale !== undefined ) {

					var normalScale = json.normalScale;

					if ( Array.isArray( normalScale ) === false ) {

						// Blender exporter used to export a scalar. See #7459

						normalScale = [ normalScale, normalScale ];

					}

					material.normalScale = new Vector2().fromArray( normalScale );

				}

				if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
				if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
				if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

				if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
				if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

				if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
				if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

				if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

				if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

				if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

				if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
				if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

				if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
				if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

				// MultiMaterial

				if ( json.materials !== undefined ) {

					for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

						material.materials.push( this.parse( json.materials[ i ] ) );

					}

				}

				return material;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BufferGeometryLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( BufferGeometryLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {

					onLoad( scope.parse( JSON.parse( text ) ) );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				var geometry = new BufferGeometry();

				var index = json.data.index;

				var TYPED_ARRAYS = {
					'Int8Array': Int8Array,
					'Uint8Array': Uint8Array,
					'Uint8ClampedArray': Uint8ClampedArray,
					'Int16Array': Int16Array,
					'Uint16Array': Uint16Array,
					'Int32Array': Int32Array,
					'Uint32Array': Uint32Array,
					'Float32Array': Float32Array,
					'Float64Array': Float64Array
				};

				if ( index !== undefined ) {

					var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
					geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

				}

				var attributes = json.data.attributes;

				for ( var key in attributes ) {

					var attribute = attributes[ key ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

					geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

				}

				var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

				if ( groups !== undefined ) {

					for ( var i = 0, n = groups.length; i !== n; ++ i ) {

						var group = groups[ i ];

						geometry.addGroup( group.start, group.count, group.materialIndex );

					}

				}

				var boundingSphere = json.data.boundingSphere;

				if ( boundingSphere !== undefined ) {

					var center = new Vector3();

					if ( boundingSphere.center !== undefined ) {

						center.fromArray( boundingSphere.center );

					}

					geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

				}

				return geometry;

			}

		} );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Loader() {

			this.onLoadStart = function () {};
			this.onLoadProgress = function () {};
			this.onLoadComplete = function () {};

		}

		Loader.prototype = {

			constructor: Loader,

			crossOrigin: undefined,

			extractUrlBase: function ( url ) {

				var parts = url.split( '/' );

				if ( parts.length === 1 ) return './';

				parts.pop();

				return parts.join( '/' ) + '/';

			},

			initMaterials: function ( materials, texturePath, crossOrigin ) {

				var array = [];

				for ( var i = 0; i < materials.length; ++ i ) {

					array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

				}

				return array;

			},

			createMaterial: ( function () {

				var color, textureLoader, materialLoader;

				return function createMaterial( m, texturePath, crossOrigin ) {

					if ( color === undefined ) color = new Color();
					if ( textureLoader === undefined ) textureLoader = new TextureLoader();
					if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

					// convert from old material format

					var textures = {};

					function loadTexture( path, repeat, offset, wrap, anisotropy ) {

						var fullPath = texturePath + path;
						var loader = Loader.Handlers.get( fullPath );

						var texture;

						if ( loader !== null ) {

							texture = loader.load( fullPath );

						} else {

							textureLoader.setCrossOrigin( crossOrigin );
							texture = textureLoader.load( fullPath );

						}

						if ( repeat !== undefined ) {

							texture.repeat.fromArray( repeat );

							if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
							if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

						}

						if ( offset !== undefined ) {

							texture.offset.fromArray( offset );

						}

						if ( wrap !== undefined ) {

							if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
							if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

							if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
							if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

						}

						if ( anisotropy !== undefined ) {

							texture.anisotropy = anisotropy;

						}

						var uuid = _Math.generateUUID();

						textures[ uuid ] = texture;

						return uuid;

					}

					//

					var json = {
						uuid: _Math.generateUUID(),
						type: 'MeshLambertMaterial'
					};

					for ( var name in m ) {

						var value = m[ name ];

						switch ( name ) {
							case 'DbgColor':
							case 'DbgIndex':
							case 'opticalDensity':
							case 'illumination':
								break;
							case 'DbgName':
								json.name = value;
								break;
							case 'blending':
								json.blending = BlendingMode[ value ];
								break;
							case 'colorAmbient':
							case 'mapAmbient':
								console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
								break;
							case 'colorDiffuse':
								json.color = color.fromArray( value ).getHex();
								break;
							case 'colorSpecular':
								json.specular = color.fromArray( value ).getHex();
								break;
							case 'colorEmissive':
								json.emissive = color.fromArray( value ).getHex();
								break;
							case 'specularCoef':
								json.shininess = value;
								break;
							case 'shading':
								if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
								if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
								if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
								break;
							case 'mapDiffuse':
								json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
								break;
							case 'mapDiffuseRepeat':
							case 'mapDiffuseOffset':
							case 'mapDiffuseWrap':
							case 'mapDiffuseAnisotropy':
								break;
							case 'mapEmissive':
								json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
								break;
							case 'mapEmissiveRepeat':
							case 'mapEmissiveOffset':
							case 'mapEmissiveWrap':
							case 'mapEmissiveAnisotropy':
								break;
							case 'mapLight':
								json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
								break;
							case 'mapLightRepeat':
							case 'mapLightOffset':
							case 'mapLightWrap':
							case 'mapLightAnisotropy':
								break;
							case 'mapAO':
								json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
								break;
							case 'mapAORepeat':
							case 'mapAOOffset':
							case 'mapAOWrap':
							case 'mapAOAnisotropy':
								break;
							case 'mapBump':
								json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
								break;
							case 'mapBumpScale':
								json.bumpScale = value;
								break;
							case 'mapBumpRepeat':
							case 'mapBumpOffset':
							case 'mapBumpWrap':
							case 'mapBumpAnisotropy':
								break;
							case 'mapNormal':
								json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
								break;
							case 'mapNormalFactor':
								json.normalScale = [ value, value ];
								break;
							case 'mapNormalRepeat':
							case 'mapNormalOffset':
							case 'mapNormalWrap':
							case 'mapNormalAnisotropy':
								break;
							case 'mapSpecular':
								json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
								break;
							case 'mapSpecularRepeat':
							case 'mapSpecularOffset':
							case 'mapSpecularWrap':
							case 'mapSpecularAnisotropy':
								break;
							case 'mapMetalness':
								json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
								break;
							case 'mapMetalnessRepeat':
							case 'mapMetalnessOffset':
							case 'mapMetalnessWrap':
							case 'mapMetalnessAnisotropy':
								break;
							case 'mapRoughness':
								json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
								break;
							case 'mapRoughnessRepeat':
							case 'mapRoughnessOffset':
							case 'mapRoughnessWrap':
							case 'mapRoughnessAnisotropy':
								break;
							case 'mapAlpha':
								json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
								break;
							case 'mapAlphaRepeat':
							case 'mapAlphaOffset':
							case 'mapAlphaWrap':
							case 'mapAlphaAnisotropy':
								break;
							case 'flipSided':
								json.side = BackSide;
								break;
							case 'doubleSided':
								json.side = DoubleSide;
								break;
							case 'transparency':
								console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
								json.opacity = value;
								break;
							case 'depthTest':
							case 'depthWrite':
							case 'colorWrite':
							case 'opacity':
							case 'reflectivity':
							case 'transparent':
							case 'visible':
							case 'wireframe':
								json[ name ] = value;
								break;
							case 'vertexColors':
								if ( value === true ) json.vertexColors = VertexColors;
								if ( value === 'face' ) json.vertexColors = FaceColors;
								break;
							default:
								console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
								break;
						}

					}

					if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
					if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

					if ( json.opacity < 1 ) json.transparent = true;

					materialLoader.setTextures( textures );

					return materialLoader.parse( json );

				};

			} )()

		};

		Loader.Handlers = {

			handlers: [],

			add: function ( regex, loader ) {

				this.handlers.push( regex, loader );

			},

			get: function ( file ) {

				var handlers = this.handlers;

				for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

					var regex = handlers[ i ];
					var loader  = handlers[ i + 1 ];

					if ( regex.test( file ) ) {

						return loader;

					}

				}

				return null;

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function JSONLoader( manager ) {

			if ( typeof manager === 'boolean' ) {

				console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
				manager = undefined;

			}

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

			this.withCredentials = false;

		}

		Object.assign( JSONLoader.prototype, {

			load: function( url, onLoad, onProgress, onError ) {

				var scope = this;

				var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

				var loader = new XHRLoader( this.manager );
				loader.setWithCredentials( this.withCredentials );
				loader.load( url, function ( text ) {

					var json = JSON.parse( text );
					var metadata = json.metadata;

					if ( metadata !== undefined ) {

						var type = metadata.type;

						if ( type !== undefined ) {

							if ( type.toLowerCase() === 'object' ) {

								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;

							}

							if ( type.toLowerCase() === 'scene' ) {

								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
								return;

							}

						}

					}

					var object = scope.parse( json, texturePath );
					onLoad( object.geometry, object.materials );

				}, onProgress, onError );

			},

			setTexturePath: function ( value ) {

				this.texturePath = value;

			},

			parse: function ( json, texturePath ) {

				var geometry = new Geometry(),
				scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

				parseModel( scale );

				parseSkin();
				parseMorphing( scale );
				parseAnimations();

				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();

				function parseModel( scale ) {

					function isBitSet( value, position ) {

						return value & ( 1 << position );

					}

					var i, j, fi,

					offset, zLength,

				colorIndex, normalIndex, uvIndex, materialIndex,

					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,

				vertex, face, faceA, faceB, hex, normal,

					uvLayer, uv, u, v,

					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,

					nUvLayers = 0;

					if ( json.uvs !== undefined ) {

						// disregard empty arrays

						for ( i = 0; i < json.uvs.length; i ++ ) {

							if ( json.uvs[ i ].length ) nUvLayers ++;

						}

						for ( i = 0; i < nUvLayers; i ++ ) {

							geometry.faceVertexUvs[ i ] = [];

						}

					}

					offset = 0;
					zLength = vertices.length;

					while ( offset < zLength ) {

						vertex = new Vector3();

						vertex.x = vertices[ offset ++ ] * scale;
						vertex.y = vertices[ offset ++ ] * scale;
						vertex.z = vertices[ offset ++ ] * scale;

						geometry.vertices.push( vertex );

					}

					offset = 0;
					zLength = faces.length;

					while ( offset < zLength ) {

						type = faces[ offset ++ ];


						isQuad              = isBitSet( type, 0 );
						hasMaterial         = isBitSet( type, 1 );
						hasFaceVertexUv     = isBitSet( type, 3 );
						hasFaceNormal       = isBitSet( type, 4 );
						hasFaceVertexNormal = isBitSet( type, 5 );
						hasFaceColor	     = isBitSet( type, 6 );
						hasFaceVertexColor  = isBitSet( type, 7 );

						// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

						if ( isQuad ) {

							faceA = new Face3();
							faceA.a = faces[ offset ];
							faceA.b = faces[ offset + 1 ];
							faceA.c = faces[ offset + 3 ];

							faceB = new Face3();
							faceB.a = faces[ offset + 1 ];
							faceB.b = faces[ offset + 2 ];
							faceB.c = faces[ offset + 3 ];

							offset += 4;

							if ( hasMaterial ) {

								materialIndex = faces[ offset ++ ];
								faceA.materialIndex = materialIndex;
								faceB.materialIndex = materialIndex;

							}

							// to get face <=> uv index correspondence

							fi = geometry.faces.length;

							if ( hasFaceVertexUv ) {

								for ( i = 0; i < nUvLayers; i ++ ) {

									uvLayer = json.uvs[ i ];

									geometry.faceVertexUvs[ i ][ fi ] = [];
									geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

									for ( j = 0; j < 4; j ++ ) {

										uvIndex = faces[ offset ++ ];

										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];

										uv = new Vector2( u, v );

										if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
										if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

									}

								}

							}

							if ( hasFaceNormal ) {

								normalIndex = faces[ offset ++ ] * 3;

								faceA.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								faceB.normal.copy( faceA.normal );

							}

							if ( hasFaceVertexNormal ) {

								for ( i = 0; i < 4; i ++ ) {

									normalIndex = faces[ offset ++ ] * 3;

									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);


									if ( i !== 2 ) faceA.vertexNormals.push( normal );
									if ( i !== 0 ) faceB.vertexNormals.push( normal );

								}

							}


							if ( hasFaceColor ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								faceA.color.setHex( hex );
								faceB.color.setHex( hex );

							}


							if ( hasFaceVertexColor ) {

								for ( i = 0; i < 4; i ++ ) {

									colorIndex = faces[ offset ++ ];
									hex = colors[ colorIndex ];

									if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
									if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

								}

							}

							geometry.faces.push( faceA );
							geometry.faces.push( faceB );

						} else {

							face = new Face3();
							face.a = faces[ offset ++ ];
							face.b = faces[ offset ++ ];
							face.c = faces[ offset ++ ];

							if ( hasMaterial ) {

								materialIndex = faces[ offset ++ ];
								face.materialIndex = materialIndex;

							}

							// to get face <=> uv index correspondence

							fi = geometry.faces.length;

							if ( hasFaceVertexUv ) {

								for ( i = 0; i < nUvLayers; i ++ ) {

									uvLayer = json.uvs[ i ];

									geometry.faceVertexUvs[ i ][ fi ] = [];

									for ( j = 0; j < 3; j ++ ) {

										uvIndex = faces[ offset ++ ];

										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];

										uv = new Vector2( u, v );

										geometry.faceVertexUvs[ i ][ fi ].push( uv );

									}

								}

							}

							if ( hasFaceNormal ) {

								normalIndex = faces[ offset ++ ] * 3;

								face.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

							}

							if ( hasFaceVertexNormal ) {

								for ( i = 0; i < 3; i ++ ) {

									normalIndex = faces[ offset ++ ] * 3;

									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);

									face.vertexNormals.push( normal );

								}

							}


							if ( hasFaceColor ) {

								colorIndex = faces[ offset ++ ];
								face.color.setHex( colors[ colorIndex ] );

							}


							if ( hasFaceVertexColor ) {

								for ( i = 0; i < 3; i ++ ) {

									colorIndex = faces[ offset ++ ];
									face.vertexColors.push( new Color( colors[ colorIndex ] ) );

								}

							}

							geometry.faces.push( face );

						}

					}

				}

				function parseSkin() {

					var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

					if ( json.skinWeights ) {

						for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

							var x =                               json.skinWeights[ i ];
							var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
							var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
							var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

							geometry.skinWeights.push( new Vector4( x, y, z, w ) );

						}

					}

					if ( json.skinIndices ) {

						for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

							var a =                               json.skinIndices[ i ];
							var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

							geometry.skinIndices.push( new Vector4( a, b, c, d ) );

						}

					}

					geometry.bones = json.bones;

					if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

						console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
							geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

					}

				}

				function parseMorphing( scale ) {

					if ( json.morphTargets !== undefined ) {

						for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

							geometry.morphTargets[ i ] = {};
							geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
							geometry.morphTargets[ i ].vertices = [];

							var dstVertices = geometry.morphTargets[ i ].vertices;
							var srcVertices = json.morphTargets[ i ].vertices;

							for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

								var vertex = new Vector3();
								vertex.x = srcVertices[ v ] * scale;
								vertex.y = srcVertices[ v + 1 ] * scale;
								vertex.z = srcVertices[ v + 2 ] * scale;

								dstVertices.push( vertex );

							}

						}

					}

					if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

						console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

						var faces = geometry.faces;
						var morphColors = json.morphColors[ 0 ].colors;

						for ( var i = 0, l = faces.length; i < l; i ++ ) {

							faces[ i ].color.fromArray( morphColors, i * 3 );

						}

					}

				}

				function parseAnimations() {

					var outputAnimations = [];

					// parse old style Bone/Hierarchy animations
					var animations = [];

					if ( json.animation !== undefined ) {

						animations.push( json.animation );

					}

					if ( json.animations !== undefined ) {

						if ( json.animations.length ) {

							animations = animations.concat( json.animations );

						} else {

							animations.push( json.animations );

						}

					}

					for ( var i = 0; i < animations.length; i ++ ) {

						var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
						if ( clip ) outputAnimations.push( clip );

					}

					// parse implicit morph animations
					if ( geometry.morphTargets ) {

						// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
						var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
						outputAnimations = outputAnimations.concat( morphAnimationClips );

					}

					if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

				}

				if ( json.materials === undefined || json.materials.length === 0 ) {

					return { geometry: geometry };

				} else {

					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

					return { geometry: geometry, materials: materials };

				}

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function ObjectLoader ( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.texturePath = '';

		}

		Object.assign( ObjectLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				if ( this.texturePath === '' ) {

					this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

				}

				var scope = this;

				var loader = new XHRLoader( scope.manager );
				loader.load( url, function ( text ) {

					scope.parse( JSON.parse( text ), onLoad );

				}, onProgress, onError );

			},

			setTexturePath: function ( value ) {

				this.texturePath = value;

			},

			setCrossOrigin: function ( value ) {

				this.crossOrigin = value;

			},

			parse: function ( json, onLoad ) {

				var geometries = this.parseGeometries( json.geometries );

				var images = this.parseImages( json.images, function () {

					if ( onLoad !== undefined ) onLoad( object );

				} );

				var textures  = this.parseTextures( json.textures, images );
				var materials = this.parseMaterials( json.materials, textures );

				var object = this.parseObject( json.object, geometries, materials );

				if ( json.animations ) {

					object.animations = this.parseAnimations( json.animations );

				}

				if ( json.images === undefined || json.images.length === 0 ) {

					if ( onLoad !== undefined ) onLoad( object );

				}

				return object;

			},

			parseGeometries: function ( json ) {

				var geometries = {};

				if ( json !== undefined ) {

					var geometryLoader = new JSONLoader();
					var bufferGeometryLoader = new BufferGeometryLoader();

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var geometry;
						var data = json[ i ];

						switch ( data.type ) {

							case 'PlaneGeometry':
							case 'PlaneBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.widthSegments,
									data.heightSegments
								);

								break;

							case 'BoxGeometry':
							case 'BoxBufferGeometry':
							case 'CubeGeometry': // backwards compatible

								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.depth,
									data.widthSegments,
									data.heightSegments,
									data.depthSegments
								);

								break;

							case 'CircleGeometry':
							case 'CircleBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.segments,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'CylinderGeometry':
							case 'CylinderBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radiusTop,
									data.radiusBottom,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'ConeGeometry':
							case 'ConeBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'SphereGeometry':
							case 'SphereBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.widthSegments,
									data.heightSegments,
									data.phiStart,
									data.phiLength,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'DodecahedronGeometry':
							case 'IcosahedronGeometry':
							case 'OctahedronGeometry':
							case 'TetrahedronGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.detail
								);

								break;

							case 'RingGeometry':
							case 'RingBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.innerRadius,
									data.outerRadius,
									data.thetaSegments,
									data.phiSegments,
									data.thetaStart,
									data.thetaLength
								);

								break;

							case 'TorusGeometry':
							case 'TorusBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.radialSegments,
									data.tubularSegments,
									data.arc
								);

								break;

							case 'TorusKnotGeometry':
							case 'TorusKnotBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.tubularSegments,
									data.radialSegments,
									data.p,
									data.q
								);

								break;

							case 'LatheGeometry':
							case 'LatheBufferGeometry':

								geometry = new Geometries[ data.type ](
									data.points,
									data.segments,
									data.phiStart,
									data.phiLength
								);

								break;

							case 'BufferGeometry':

								geometry = bufferGeometryLoader.parse( data );

								break;

							case 'Geometry':

								geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

								break;

							default:

								console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

								continue;

						}

						geometry.uuid = data.uuid;

						if ( data.name !== undefined ) geometry.name = data.name;

						geometries[ data.uuid ] = geometry;

					}

				}

				return geometries;

			},

			parseMaterials: function ( json, textures ) {

				var materials = {};

				if ( json !== undefined ) {

					var loader = new MaterialLoader();
					loader.setTextures( textures );

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var material = loader.parse( json[ i ] );
						materials[ material.uuid ] = material;

					}

				}

				return materials;

			},

			parseAnimations: function ( json ) {

				var animations = [];

				for ( var i = 0; i < json.length; i ++ ) {

					var clip = AnimationClip.parse( json[ i ] );

					animations.push( clip );

				}

				return animations;

			},

			parseImages: function ( json, onLoad ) {

				var scope = this;
				var images = {};

				function loadImage( url ) {

					scope.manager.itemStart( url );

					return loader.load( url, function () {

						scope.manager.itemEnd( url );

					}, undefined, function () {

						scope.manager.itemError( url );

					} );

				}

				if ( json !== undefined && json.length > 0 ) {

					var manager = new LoadingManager( onLoad );

					var loader = new ImageLoader( manager );
					loader.setCrossOrigin( this.crossOrigin );

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var image = json[ i ];
						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

						images[ image.uuid ] = loadImage( path );

					}

				}

				return images;

			},

			parseTextures: function ( json, images ) {

				function parseConstant( value, type ) {

					if ( typeof( value ) === 'number' ) return value;

					console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

					return type[ value ];

				}

				var textures = {};

				if ( json !== undefined ) {

					for ( var i = 0, l = json.length; i < l; i ++ ) {

						var data = json[ i ];

						if ( data.image === undefined ) {

							console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

						}

						if ( images[ data.image ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

						}

						var texture = new Texture( images[ data.image ] );
						texture.needsUpdate = true;

						texture.uuid = data.uuid;

						if ( data.name !== undefined ) texture.name = data.name;

						if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

						if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
						if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
						if ( data.wrap !== undefined ) {

							texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
							texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

						}

						if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
						if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
						if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

						if ( data.flipY !== undefined ) texture.flipY = data.flipY;

						textures[ data.uuid ] = texture;

					}

				}

				return textures;

			},

			parseObject: function () {

				var matrix = new Matrix4();

				return function parseObject( data, geometries, materials ) {

					var object;

					function getGeometry( name ) {

						if ( geometries[ name ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

						}

						return geometries[ name ];

					}

					function getMaterial( name ) {

						if ( name === undefined ) return undefined;

						if ( materials[ name ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', name );

						}

						return materials[ name ];

					}

					switch ( data.type ) {

						case 'Scene':

							object = new Scene();

							if ( data.background !== undefined ) {

								if ( Number.isInteger( data.background ) ) {

									object.background = new Color( data.background );

								}

							}

							if ( data.fog !== undefined ) {

								if ( data.fog.type === 'Fog' ) {

									object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

								} else if ( data.fog.type === 'FogExp2' ) {

									object.fog = new FogExp2( data.fog.color, data.fog.density );

								}

							}

							break;

						case 'PerspectiveCamera':

							object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

							if ( data.focus !== undefined ) object.focus = data.focus;
							if ( data.zoom !== undefined ) object.zoom = data.zoom;
							if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
							if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
							if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

							break;

						case 'OrthographicCamera':

							object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

							break;

						case 'AmbientLight':

							object = new AmbientLight( data.color, data.intensity );

							break;

						case 'DirectionalLight':

							object = new DirectionalLight( data.color, data.intensity );

							break;

						case 'PointLight':

							object = new PointLight( data.color, data.intensity, data.distance, data.decay );

							break;

						case 'SpotLight':

							object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

							break;

						case 'HemisphereLight':

							object = new HemisphereLight( data.color, data.groundColor, data.intensity );

							break;

						case 'Mesh':

							var geometry = getGeometry( data.geometry );
							var material = getMaterial( data.material );

							if ( geometry.bones && geometry.bones.length > 0 ) {

								object = new SkinnedMesh( geometry, material );

							} else {

								object = new Mesh( geometry, material );

							}

							break;

						case 'LOD':

							object = new LOD();

							break;

						case 'Line':

							object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

							break;

						case 'LineSegments':

							object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

							break;

						case 'PointCloud':
						case 'Points':

							object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

							break;

						case 'Sprite':

							object = new Sprite( getMaterial( data.material ) );

							break;

						case 'Group':

							object = new Group();

							break;

						default:

							object = new Object3D();

					}

					object.uuid = data.uuid;

					if ( data.name !== undefined ) object.name = data.name;
					if ( data.matrix !== undefined ) {

						matrix.fromArray( data.matrix );
						matrix.decompose( object.position, object.quaternion, object.scale );

					} else {

						if ( data.position !== undefined ) object.position.fromArray( data.position );
						if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
						if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
						if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

					}

					if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
					if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

					if ( data.shadow ) {

						if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
						if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
						if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
						if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

					}

					if ( data.visible !== undefined ) object.visible = data.visible;
					if ( data.userData !== undefined ) object.userData = data.userData;

					if ( data.children !== undefined ) {

						for ( var child in data.children ) {

							object.add( this.parseObject( data.children[ child ], geometries, materials ) );

						}

					}

					if ( data.type === 'LOD' ) {

						var levels = data.levels;

						for ( var l = 0; l < levels.length; l ++ ) {

							var level = levels[ l ];
							var child = object.getObjectByProperty( 'uuid', level.object );

							if ( child !== undefined ) {

								object.addLevel( child, level.distance );

							}

						}

					}

					return object;

				};

			}()

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of Curve methods
		 * .getPoint(t), getTangent(t)
		 * .getPointAt(u), getTangentAt(u)
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following classes subclasses THREE.Curve:
		 *
		 * -- 2d classes --
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.CubicBezierCurve
		 * THREE.SplineCurve
		 * THREE.ArcCurve
		 * THREE.EllipseCurve
		 *
		 * -- 3d classes --
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.SplineCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath
		 *
		 **/

		/**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/

		function Curve() {}

		Curve.prototype = {

			constructor: Curve,

			// Virtual base class method to overwrite and implement in subclasses
			//	- t [0 .. 1]

			getPoint: function ( t ) {

				console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
				return null;

			},

			// Get point at relative position in curve according to arc length
			// - u [0 .. 1]

			getPointAt: function ( u ) {

				var t = this.getUtoTmapping( u );
				return this.getPoint( t );

			},

			// Get sequence of points using getPoint( t )

			getPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 5;

				var points = [];

				for ( var d = 0; d <= divisions; d ++ ) {

					points.push( this.getPoint( d / divisions ) );

				}

				return points;

			},

			// Get sequence of points using getPointAt( u )

			getSpacedPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 5;

				var points = [];

				for ( var d = 0; d <= divisions; d ++ ) {

					points.push( this.getPointAt( d / divisions ) );

				}

				return points;

			},

			// Get total curve arc length

			getLength: function () {

				var lengths = this.getLengths();
				return lengths[ lengths.length - 1 ];

			},

			// Get list of cumulative segment lengths

			getLengths: function ( divisions ) {

				if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

				if ( this.cacheArcLengths
					&& ( this.cacheArcLengths.length === divisions + 1 )
					&& ! this.needsUpdate ) {

					//console.log( "cached", this.cacheArcLengths );
					return this.cacheArcLengths;

				}

				this.needsUpdate = false;

				var cache = [];
				var current, last = this.getPoint( 0 );
				var p, sum = 0;

				cache.push( 0 );

				for ( p = 1; p <= divisions; p ++ ) {

					current = this.getPoint ( p / divisions );
					sum += current.distanceTo( last );
					cache.push( sum );
					last = current;

				}

				this.cacheArcLengths = cache;

				return cache; // { sums: cache, sum:sum }; Sum is in the last element.

			},

			updateArcLengths: function() {

				this.needsUpdate = true;
				this.getLengths();

			},

			// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

			getUtoTmapping: function ( u, distance ) {

				var arcLengths = this.getLengths();

				var i = 0, il = arcLengths.length;

				var targetArcLength; // The targeted u distance value to get

				if ( distance ) {

					targetArcLength = distance;

				} else {

					targetArcLength = u * arcLengths[ il - 1 ];

				}

				//var time = Date.now();

				// binary search for the index with largest value smaller than target u distance

				var low = 0, high = il - 1, comparison;

				while ( low <= high ) {

					i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

					comparison = arcLengths[ i ] - targetArcLength;

					if ( comparison < 0 ) {

						low = i + 1;

					} else if ( comparison > 0 ) {

						high = i - 1;

					} else {

						high = i;
						break;

						// DONE

					}

				}

				i = high;

				//console.log('b' , i, low, high, Date.now()- time);

				if ( arcLengths[ i ] === targetArcLength ) {

					var t = i / ( il - 1 );
					return t;

				}

				// we could get finer grain at lengths, or use simple interpolation between two points

				var lengthBefore = arcLengths[ i ];
				var lengthAfter = arcLengths[ i + 1 ];

				var segmentLength = lengthAfter - lengthBefore;

				// determine where we are between the 'before' and 'after' points

				var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

				// add that fractional amount to t

				var t = ( i + segmentFraction ) / ( il - 1 );

				return t;

			},

			// Returns a unit vector tangent at t
			// In case any sub curve does not implement its tangent derivation,
			// 2 points a small delta apart will be used to find its gradient
			// which seems to give a reasonable approximation

			getTangent: function( t ) {

				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;

				// Capping in case of danger

				if ( t1 < 0 ) t1 = 0;
				if ( t2 > 1 ) t2 = 1;

				var pt1 = this.getPoint( t1 );
				var pt2 = this.getPoint( t2 );

				var vec = pt2.clone().sub( pt1 );
				return vec.normalize();

			},

			getTangentAt: function ( u ) {

				var t = this.getUtoTmapping( u );
				return this.getTangent( t );

			},

			computeFrenetFrames: function ( segments, closed ) {

				// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

				var normal = new Vector3();

				var tangents = [];
				var normals = [];
				var binormals = [];

				var vec = new Vector3();
				var mat = new Matrix4();

				var i, u, theta;

				// compute the tangent vectors for each segment on the curve

				for ( i = 0; i <= segments; i ++ ) {

					u = i / segments;

					tangents[ i ] = this.getTangentAt( u );
					tangents[ i ].normalize();

				}

				// select an initial normal vector perpendicular to the first tangent vector,
				// and in the direction of the minimum tangent xyz component

				normals[ 0 ] = new Vector3();
				binormals[ 0 ] = new Vector3();
				var min = Number.MAX_VALUE;
				var tx = Math.abs( tangents[ 0 ].x );
				var ty = Math.abs( tangents[ 0 ].y );
				var tz = Math.abs( tangents[ 0 ].z );

				if ( tx <= min ) {

					min = tx;
					normal.set( 1, 0, 0 );

				}

				if ( ty <= min ) {

					min = ty;
					normal.set( 0, 1, 0 );

				}

				if ( tz <= min ) {

					normal.set( 0, 0, 1 );

				}

				vec.crossVectors( tangents[ 0 ], normal ).normalize();

				normals[ 0 ].crossVectors( tangents[ 0 ], vec );
				binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


				// compute the slowly-varying normal and binormal vectors for each segment on the curve

				for ( i = 1; i <= segments; i ++ ) {

					normals[ i ] = normals[ i - 1 ].clone();

					binormals[ i ] = binormals[ i - 1 ].clone();

					vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

					if ( vec.length() > Number.EPSILON ) {

						vec.normalize();

						theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

						normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

					}

					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

				// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

				if ( closed === true ) {

					theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
					theta /= segments;

					if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

						theta = - theta;

					}

					for ( i = 1; i <= segments; i ++ ) {

						// twist a little...
						normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
						binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

					}

				}

				return {
					tangents: tangents,
					normals: normals,
					binormals: binormals
				};

			}

		};

		// TODO: Transformation for Curves?

		/**************************************************************
		 *	3D Curves
		 **************************************************************/

		// A Factory method for creating new curve subclasses

		Curve.create = function ( constructor, getPointFunc ) {

			constructor.prototype = Object.create( Curve.prototype );
			constructor.prototype.constructor = constructor;
			constructor.prototype.getPoint = getPointFunc;

			return constructor;

		};

		/**************************************************************
		 *	Line
		 **************************************************************/

		function LineCurve( v1, v2 ) {

			this.v1 = v1;
			this.v2 = v2;

		}

		LineCurve.prototype = Object.create( Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;

		LineCurve.prototype.isLineCurve = true;

		LineCurve.prototype.getPoint = function ( t ) {

			if ( t === 1 ) {

				return this.v2.clone();

			}

			var point = this.v2.clone().sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

			return point;

		};

		// Line curve is linear, so we can overwrite default getPointAt

		LineCurve.prototype.getPointAt = function ( u ) {

			return this.getPoint( u );

		};

		LineCurve.prototype.getTangent = function( t ) {

			var tangent = this.v2.clone().sub( this.v1 );

			return tangent.normalize();

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **/

		/**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/

		function CurvePath() {

			this.curves = [];

			this.autoClose = false; // Automatically closes the path

		}

		CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

			constructor: CurvePath,

			add: function ( curve ) {

				this.curves.push( curve );

			},

			closePath: function () {

				// Add a line curve if start and end of lines are not connected
				var startPoint = this.curves[ 0 ].getPoint( 0 );
				var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

				if ( ! startPoint.equals( endPoint ) ) {

					this.curves.push( new LineCurve( endPoint, startPoint ) );

				}

			},

			// To get accurate point with reference to
			// entire path distance at time t,
			// following has to be done:

			// 1. Length of each sub path have to be known
			// 2. Locate and identify type of curve
			// 3. Get t for the curve
			// 4. Return curve.getPointAt(t')

			getPoint: function ( t ) {

				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;

				// To think about boundaries points.

				while ( i < curveLengths.length ) {

					if ( curveLengths[ i ] >= d ) {

						var diff = curveLengths[ i ] - d;
						var curve = this.curves[ i ];

						var segmentLength = curve.getLength();
						var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

						return curve.getPointAt( u );

					}

					i ++;

				}

				return null;

				// loop where sum != 0, sum > d , sum+1 <d

			},

			// We cannot use the default THREE.Curve getPoint() with getLength() because in
			// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
			// getPoint() depends on getLength

			getLength: function () {

				var lens = this.getCurveLengths();
				return lens[ lens.length - 1 ];

			},

			// cacheLengths must be recalculated.
			updateArcLengths: function () {

				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getLengths();

			},

			// Compute lengths and cache them
			// We cannot overwrite getLengths() because UtoT mapping uses it.

			getCurveLengths: function () {

				// We use cache values if curves and cache array are same length

				if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

					return this.cacheLengths;

				}

				// Get length of sub-curve
				// Push sums into cached array

				var lengths = [], sums = 0;

				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

					sums += this.curves[ i ].getLength();
					lengths.push( sums );

				}

				this.cacheLengths = lengths;

				return lengths;

			},

			getSpacedPoints: function ( divisions ) {

				if ( ! divisions ) divisions = 40;

				var points = [];

				for ( var i = 0; i <= divisions; i ++ ) {

					points.push( this.getPoint( i / divisions ) );

				}

				if ( this.autoClose ) {

					points.push( points[ 0 ] );

				}

				return points;

			},

			getPoints: function ( divisions ) {

				divisions = divisions || 12;

				var points = [], last;

				for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

					var curve = curves[ i ];
					var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
						: (curve && curve.isLineCurve) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
						: divisions;

					var pts = curve.getPoints( resolution );

					for ( var j = 0; j < pts.length; j++ ) {

						var point = pts[ j ];

						if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

						points.push( point );
						last = point;

					}

				}

				if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

					points.push( points[ 0 ] );

				}

				return points;

			},

			/**************************************************************
			 *	Create Geometries Helpers
			 **************************************************************/

			/// Generate geometry from path points (for Line or Points objects)

			createPointsGeometry: function ( divisions ) {

				var pts = this.getPoints( divisions );
				return this.createGeometry( pts );

			},

			// Generate geometry from equidistant sampling along the path

			createSpacedPointsGeometry: function ( divisions ) {

				var pts = this.getSpacedPoints( divisions );
				return this.createGeometry( pts );

			},

			createGeometry: function ( points ) {

				var geometry = new Geometry();

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					var point = points[ i ];
					geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

				}

				return geometry;

			}

		} );

		/**************************************************************
		 *	Ellipse curve
		 **************************************************************/

		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			this.aX = aX;
			this.aY = aY;

			this.xRadius = xRadius;
			this.yRadius = yRadius;

			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;

			this.aClockwise = aClockwise;

			this.aRotation = aRotation || 0;

		}

		EllipseCurve.prototype = Object.create( Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;

		EllipseCurve.prototype.isEllipseCurve = true;

		EllipseCurve.prototype.getPoint = function( t ) {

			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

			if ( deltaAngle < Number.EPSILON ) {

				if ( samePoints ) {

					deltaAngle = 0;

				} else {

					deltaAngle = twoPi;

				}

			}

			if ( this.aClockwise === true && ! samePoints ) {

				if ( deltaAngle === twoPi ) {

					deltaAngle = - twoPi;

				} else {

					deltaAngle = deltaAngle - twoPi;

				}

			}

			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );

			if ( this.aRotation !== 0 ) {

				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );

				var tx = x - this.aX;
				var ty = y - this.aY;

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;

			}

			return new Vector2( x, y );

		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */

		var CurveUtils = {

			tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

				return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

			},

			// Puay Bing, thanks for helping with this derivative!

			tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

				return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
					3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
					6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
					3 * t * t * p3;

			},

			tangentSpline: function ( t, p0, p1, p2, p3 ) {

				// To check if my formulas are correct

				var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
				var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
				var h01 = - 6 * t * t + 6 * t; 	//  2t3 + 3t2
				var h11 = 3 * t * t - 2 * t;	// t3  t2

				return h00 + h10 + h01 + h11;

			},

			// Catmull-Rom

			interpolate: function( p0, p1, p2, p3, t ) {

				var v0 = ( p2 - p0 ) * 0.5;
				var v1 = ( p3 - p1 ) * 0.5;
				var t2 = t * t;
				var t3 = t * t2;
				return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			}

		};

		/**************************************************************
		 *	Spline curve
		 **************************************************************/

		function SplineCurve( points /* array of Vector2 */ ) {

			this.points = ( points === undefined ) ? [] : points;

		}

		SplineCurve.prototype = Object.create( Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;

		SplineCurve.prototype.isSplineCurve = true;

		SplineCurve.prototype.getPoint = function ( t ) {

			var points = this.points;
			var point = ( points.length - 1 ) * t;

			var intPoint = Math.floor( point );
			var weight = point - intPoint;

			var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			var interpolate = CurveUtils.interpolate;

			return new Vector2(
				interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
				interpolate( point0.y, point1.y, point2.y, point3.y, weight )
			);

		};

		/**************************************************************
		 *	Cubic Bezier curve
		 **************************************************************/

		function CubicBezierCurve( v0, v1, v2, v3 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		CubicBezierCurve.prototype = Object.create( Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;

		CubicBezierCurve.prototype.getPoint = function ( t ) {

			var b3 = ShapeUtils.b3;

			return new Vector2(
				b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
			);

		};

		CubicBezierCurve.prototype.getTangent = function( t ) {

			var tangentCubicBezier = CurveUtils.tangentCubicBezier;

			return new Vector2(
				tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
				tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
			).normalize();

		};

		/**************************************************************
		 *	Quadratic Bezier curve
		 **************************************************************/


		function QuadraticBezierCurve( v0, v1, v2 ) {

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;


		QuadraticBezierCurve.prototype.getPoint = function ( t ) {

			var b2 = ShapeUtils.b2;

			return new Vector2(
				b2( t, this.v0.x, this.v1.x, this.v2.x ),
				b2( t, this.v0.y, this.v1.y, this.v2.y )
			);

		};


		QuadraticBezierCurve.prototype.getTangent = function( t ) {

			var tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;

			return new Vector2(
				tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
				tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
			).normalize();

		};

		var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

			fromPoints: function ( vectors ) {

				this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

				for ( var i = 1, l = vectors.length; i < l; i ++ ) {

					this.lineTo( vectors[ i ].x, vectors[ i ].y );

				}

			},

			moveTo: function ( x, y ) {

				this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

			},

			lineTo: function ( x, y ) {

				var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
				this.curves.push( curve );

				this.currentPoint.set( x, y );

			},

			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

				var curve = new QuadraticBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCPx, aCPy ),
					new Vector2( aX, aY )
				);

				this.curves.push( curve );

				this.currentPoint.set( aX, aY );

			},

			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

				var curve = new CubicBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCP1x, aCP1y ),
					new Vector2( aCP2x, aCP2y ),
					new Vector2( aX, aY )
				);

				this.curves.push( curve );

				this.currentPoint.set( aX, aY );

			},

			splineThru: function ( pts /*Array of Vector*/ ) {

				var npts = [ this.currentPoint.clone() ].concat( pts );

				var curve = new SplineCurve( npts );
				this.curves.push( curve );

				this.currentPoint.copy( pts[ pts.length - 1 ] );

			},

			arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;

				this.absarc( aX + x0, aY + y0, aRadius,
					aStartAngle, aEndAngle, aClockwise );

			},

			absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

				this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			},

			ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;

				this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			},

			absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

				var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

				if ( this.curves.length > 0 ) {

					// if a previous curve is present, attempt to join
					var firstPoint = curve.getPoint( 0 );

					if ( ! firstPoint.equals( this.currentPoint ) ) {

						this.lineTo( firstPoint.x, firstPoint.y );

					}

				}

				this.curves.push( curve );

				var lastPoint = curve.getPoint( 1 );
				this.currentPoint.copy( lastPoint );

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/

		// STEP 1 Create a path.
		// STEP 2 Turn path into shape.
		// STEP 3 ExtrudeGeometry takes in Shape/Shapes
		// STEP 3a - Extract points from each shape, turn to vertices
		// STEP 3b - Triangulate each shape, add faces.

		function Shape() {

			Path.apply( this, arguments );

			this.holes = [];

		}

		Shape.prototype = Object.assign( Object.create( PathPrototype ), {

			constructor: Shape,

			getPointsHoles: function ( divisions ) {

				var holesPts = [];

				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

					holesPts[ i ] = this.holes[ i ].getPoints( divisions );

				}

				return holesPts;

			},

			// Get points of shape and holes (keypoints based on segments parameter)

			extractAllPoints: function ( divisions ) {

				return {

					shape: this.getPoints( divisions ),
					holes: this.getPointsHoles( divisions )

				};

			},

			extractPoints: function ( divisions ) {

				return this.extractAllPoints( divisions );

			}

		} );

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 *
		 **/

		function Path( points ) {

			CurvePath.call( this );
			this.currentPoint = new Vector2();

			if ( points ) {

				this.fromPoints( points );

			}

		}

		Path.prototype = PathPrototype;
		PathPrototype.constructor = Path;


		// minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		function ShapePath() {
			this.subPaths = [];
			this.currentPath = null;
		}

		ShapePath.prototype = {
			moveTo: function ( x, y ) {
				this.currentPath = new Path();
				this.subPaths.push(this.currentPath);
				this.currentPath.moveTo( x, y );
			},
			lineTo: function ( x, y ) {
				this.currentPath.lineTo( x, y );
			},
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
				this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
			},
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
				this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
			},
			splineThru: function ( pts ) {
				this.currentPath.splineThru( pts );
			},

			toShapes: function ( isCCW, noHoles ) {

				function toShapesNoHoles( inSubpaths ) {

					var shapes = [];

					for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

						var tmpPath = inSubpaths[ i ];

						var tmpShape = new Shape();
						tmpShape.curves = tmpPath.curves;

						shapes.push( tmpShape );

					}

					return shapes;

				}

				function isPointInsidePolygon( inPt, inPolygon ) {

					var polyLen = inPolygon.length;

					// inPt on polygon contour => immediate success    or
					// toggling of inside/outside at every single! intersection point of an edge
					//  with the horizontal line through inPt, left of inPt
					//  not counting lowerY endpoints of edges and whole edges on that line
					var inside = false;
					for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

						var edgeLowPt  = inPolygon[ p ];
						var edgeHighPt = inPolygon[ q ];

						var edgeDx = edgeHighPt.x - edgeLowPt.x;
						var edgeDy = edgeHighPt.y - edgeLowPt.y;

						if ( Math.abs( edgeDy ) > Number.EPSILON ) {

							// not parallel
							if ( edgeDy < 0 ) {

								edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
								edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

							}
							if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

							if ( inPt.y === edgeLowPt.y ) {

								if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
								// continue;				// no intersection or edgeLowPt => doesn't count !!!

							} else {

								var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
								if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
								if ( perpEdge < 0 ) 				continue;
								inside = ! inside;		// true intersection left of inPt

							}

						} else {

							// parallel or collinear
							if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
							// edge lies on the same horizontal line as inPt
							if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
								 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
							// continue;

						}

					}

					return	inside;

				}

				var isClockWise = ShapeUtils.isClockWise;

				var subPaths = this.subPaths;
				if ( subPaths.length === 0 ) return [];

				if ( noHoles === true )	return	toShapesNoHoles( subPaths );


				var solid, tmpPath, tmpShape, shapes = [];

				if ( subPaths.length === 1 ) {

					tmpPath = subPaths[ 0 ];
					tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push( tmpShape );
					return shapes;

				}

				var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
				holesFirst = isCCW ? ! holesFirst : holesFirst;

				// console.log("Holes first", holesFirst);

				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;

				newShapes[ mainIdx ] = undefined;
				newShapeHoles[ mainIdx ] = [];

				for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

					tmpPath = subPaths[ i ];
					tmpPoints = tmpPath.getPoints();
					solid = isClockWise( tmpPoints );
					solid = isCCW ? ! solid : solid;

					if ( solid ) {

						if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

						newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
						newShapes[ mainIdx ].s.curves = tmpPath.curves;

						if ( holesFirst )	mainIdx ++;
						newShapeHoles[ mainIdx ] = [];

						//console.log('cw', i);

					} else {

						newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

						//console.log('ccw', i);

					}

				}

				// only Holes? -> probably all Shapes with wrong orientation
				if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


				if ( newShapes.length > 1 ) {

					var ambiguous = false;
					var toChange = [];

					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

						betterShapeHoles[ sIdx ] = [];

					}

					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

						var sho = newShapeHoles[ sIdx ];

						for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

							var ho = sho[ hIdx ];
							var hole_unassigned = true;

							for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

								if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

									if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
									if ( hole_unassigned ) {

										hole_unassigned = false;
										betterShapeHoles[ s2Idx ].push( ho );

									} else {

										ambiguous = true;

									}

								}

							}
							if ( hole_unassigned ) {

								betterShapeHoles[ sIdx ].push( ho );

							}

						}

					}
					// console.log("ambiguous: ", ambiguous);
					if ( toChange.length > 0 ) {

						// console.log("to change: ", toChange);
						if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

					}

				}

				var tmpHoles;

				for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

					tmpShape = newShapes[ i ].s;
					shapes.push( tmpShape );
					tmpHoles = newShapeHoles[ i ];

					for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

						tmpShape.holes.push( tmpHoles[ j ].h );

					}

				}

				//console.log("shape", shapes);

				return shapes;

			}
		};

		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Font( data ) {

			this.data = data;

		}

		Object.assign( Font.prototype, {

			isFont: true,

			generateShapes: function ( text, size, divisions ) {

				function createPaths( text ) {

					var chars = String( text ).split( '' );
					var scale = size / data.resolution;
					var offset = 0;

					var paths = [];

					for ( var i = 0; i < chars.length; i ++ ) {

						var ret = createPath( chars[ i ], scale, offset );
						offset += ret.offset;

						paths.push( ret.path );

					}

					return paths;

				}

				function createPath( c, scale, offset ) {

					var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

					if ( ! glyph ) return;

					var path = new ShapePath();

					var pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;
					var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

					if ( glyph.o ) {

						var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

						for ( var i = 0, l = outline.length; i < l; ) {

							var action = outline[ i ++ ];

							switch ( action ) {

								case 'm': // moveTo

									x = outline[ i ++ ] * scale + offset;
									y = outline[ i ++ ] * scale;

									path.moveTo( x, y );

									break;

								case 'l': // lineTo

									x = outline[ i ++ ] * scale + offset;
									y = outline[ i ++ ] * scale;

									path.lineTo( x, y );

									break;

								case 'q': // quadraticCurveTo

									cpx  = outline[ i ++ ] * scale + offset;
									cpy  = outline[ i ++ ] * scale;
									cpx1 = outline[ i ++ ] * scale + offset;
									cpy1 = outline[ i ++ ] * scale;

									path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

									laste = pts[ pts.length - 1 ];

									if ( laste ) {

										cpx0 = laste.x;
										cpy0 = laste.y;

										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

											var t = i2 / divisions;
											b2( t, cpx0, cpx1, cpx );
											b2( t, cpy0, cpy1, cpy );

										}

									}

									break;

								case 'b': // bezierCurveTo

									cpx  = outline[ i ++ ] * scale + offset;
									cpy  = outline[ i ++ ] * scale;
									cpx1 = outline[ i ++ ] * scale + offset;
									cpy1 = outline[ i ++ ] * scale;
									cpx2 = outline[ i ++ ] * scale + offset;
									cpy2 = outline[ i ++ ] * scale;

									path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

									laste = pts[ pts.length - 1 ];

									if ( laste ) {

										cpx0 = laste.x;
										cpy0 = laste.y;

										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

											var t = i2 / divisions;
											b3( t, cpx0, cpx1, cpx2, cpx );
											b3( t, cpy0, cpy1, cpy2, cpy );

										}

									}

									break;

							}

						}

					}

					return { offset: glyph.ha * scale, path: path };

				}

				//

				if ( size === undefined ) size = 100;
				if ( divisions === undefined ) divisions = 4;

				var data = this.data;

				var paths = createPaths( text );
				var shapes = [];

				for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

					Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

				}

				return shapes;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function FontLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( FontLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var scope = this;

				var loader = new XHRLoader( this.manager );
				loader.load( url, function ( text ) {

					var json;

					try {

						json = JSON.parse( text );

					} catch ( e ) {

						console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
						json = JSON.parse( text.substring( 65, text.length - 2 ) );

					}

					var font = scope.parse( json );

					if ( onLoad ) onLoad( font );

				}, onProgress, onError );

			},

			parse: function ( json ) {

				return new Font( json );

			}

		} );

		var context;

		function getAudioContext() {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		}

		/**
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */

		function AudioLoader( manager ) {

			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		}

		Object.assign( AudioLoader.prototype, {

			load: function ( url, onLoad, onProgress, onError ) {

				var loader = new XHRLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.load( url, function ( buffer ) {

					var context = getAudioContext();

					context.decodeAudioData( buffer, function ( audioBuffer ) {

						onLoad( audioBuffer );

					} );

				}, onProgress, onError );

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function StereoCamera() {

			this.type = 'StereoCamera';

			this.aspect = 1;

			this.eyeSep = 0.064;

			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;

			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;

		}

		Object.assign( StereoCamera.prototype, {

			update: ( function () {

				var instance, focus, fov, aspect, near, far, zoom;

				var eyeRight = new Matrix4();
				var eyeLeft = new Matrix4();

				return function update( camera ) {

					var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
														aspect !== camera.aspect * this.aspect || near !== camera.near ||
														far !== camera.far || zoom !== camera.zoom;

					if ( needsUpdate ) {

						instance = this;
						focus = camera.focus;
						fov = camera.fov;
						aspect = camera.aspect * this.aspect;
						near = camera.near;
						far = camera.far;
						zoom = camera.zoom;

						// Off-axis stereoscopic effect based on
						// http://paulbourke.net/stereographics/stereorender/

						var projectionMatrix = camera.projectionMatrix.clone();
						var eyeSep = this.eyeSep / 2;
						var eyeSepOnProjection = eyeSep * near / focus;
						var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
						var xmin, xmax;

						// translate xOffset

						eyeLeft.elements[ 12 ] = - eyeSep;
						eyeRight.elements[ 12 ] = eyeSep;

						// for left eye

						xmin = - ymax * aspect + eyeSepOnProjection;
						xmax = ymax * aspect + eyeSepOnProjection;

						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

						this.cameraL.projectionMatrix.copy( projectionMatrix );

						// for right eye

						xmin = - ymax * aspect - eyeSepOnProjection;
						xmax = ymax * aspect - eyeSepOnProjection;

						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

						this.cameraR.projectionMatrix.copy( projectionMatrix );

					}

					this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
					this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

				};

			} )()

		} );

		/**
		 * Camera for rendering cube maps
		 *	- renders scene into axis-aligned cube
		 *
		 * @author alteredq / http://alteredqualia.com/
		 */

		function CubeCamera( near, far, cubeResolution ) {

			Object3D.call( this );

			this.type = 'CubeCamera';

			var fov = 90, aspect = 1;

			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );

			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );

			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );

			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );

			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );

			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );

			var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

			this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

			this.updateCubeMap = function ( renderer, scene ) {

				if ( this.parent === null ) this.updateMatrixWorld();

				var renderTarget = this.renderTarget;
				var generateMipmaps = renderTarget.texture.generateMipmaps;

				renderTarget.texture.generateMipmaps = false;

				renderTarget.activeCubeFace = 0;
				renderer.render( scene, cameraPX, renderTarget );

				renderTarget.activeCubeFace = 1;
				renderer.render( scene, cameraNX, renderTarget );

				renderTarget.activeCubeFace = 2;
				renderer.render( scene, cameraPY, renderTarget );

				renderTarget.activeCubeFace = 3;
				renderer.render( scene, cameraNY, renderTarget );

				renderTarget.activeCubeFace = 4;
				renderer.render( scene, cameraPZ, renderTarget );

				renderTarget.texture.generateMipmaps = generateMipmaps;

				renderTarget.activeCubeFace = 5;
				renderer.render( scene, cameraNZ, renderTarget );

				renderer.setRenderTarget( null );

			};

		}

		CubeCamera.prototype = Object.create( Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AudioListener() {

			Object3D.call( this );

			this.type = 'AudioListener';

			this.context = getAudioContext();

			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );

			this.filter = null;

		}

		AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: AudioListener,

			getInput: function () {

				return this.gain;

			},

			removeFilter: function ( ) {

				if ( this.filter !== null ) {

					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
					this.gain.connect( this.context.destination );
					this.filter = null;

				}

			},

			getFilter: function () {

				return this.filter;

			},

			setFilter: function ( value ) {

				if ( this.filter !== null ) {

					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );

				} else {

					this.gain.disconnect( this.context.destination );

				}

				this.filter = value;
				this.gain.connect( this.filter );
				this.filter.connect( this.context.destination );

			},

			getMasterVolume: function () {

				return this.gain.gain.value;

			},

			setMasterVolume: function ( value ) {

				this.gain.gain.value = value;

			},

			updateMatrixWorld: ( function () {

				var position = new Vector3();
				var quaternion = new Quaternion();
				var scale = new Vector3();

				var orientation = new Vector3();

				return function updateMatrixWorld( force ) {

					Object3D.prototype.updateMatrixWorld.call( this, force );

					var listener = this.context.listener;
					var up = this.up;

					this.matrixWorld.decompose( position, quaternion, scale );

					orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

				};

			} )()

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */

		function Audio( listener ) {

			Object3D.call( this );

			this.type = 'Audio';

			this.context = listener.context;
			this.source = this.context.createBufferSource();
			this.source.onended = this.onEnded.bind( this );

			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );

			this.autoplay = false;

			this.startTime = 0;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.sourceType = 'empty';

			this.filters = [];

		}

		Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

			constructor: Audio,

			getOutput: function () {

				return this.gain;

			},

			setNodeSource: function ( audioNode ) {

				this.hasPlaybackControl = false;
				this.sourceType = 'audioNode';
				this.source = audioNode;
				this.connect();

				return this;

			},

			setBuffer: function ( audioBuffer ) {

				this.source.buffer = audioBuffer;
				this.sourceType = 'buffer';

				if ( this.autoplay ) this.play();

				return this;

			},

			play: function () {

				if ( this.isPlaying === true ) {

					console.warn( 'THREE.Audio: Audio is already playing.' );
					return;

				}

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				var source = this.context.createBufferSource();

				source.buffer = this.source.buffer;
				source.loop = this.source.loop;
				source.onended = this.source.onended;
				source.start( 0, this.startTime );
				source.playbackRate.value = this.playbackRate;

				this.isPlaying = true;

				this.source = source;

				return this.connect();

			},

			pause: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.source.stop();
				this.startTime = this.context.currentTime;
				this.isPlaying = false;

				return this;

			},

			stop: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.source.stop();
				this.startTime = 0;
				this.isPlaying = false;

				return this;

			},

			connect: function () {

				if ( this.filters.length > 0 ) {

					this.source.connect( this.filters[ 0 ] );

					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

						this.filters[ i - 1 ].connect( this.filters[ i ] );

					}

					this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

				} else {

					this.source.connect( this.getOutput() );

				}

				return this;

			},

			disconnect: function () {

				if ( this.filters.length > 0 ) {

					this.source.disconnect( this.filters[ 0 ] );

					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

						this.filters[ i - 1 ].disconnect( this.filters[ i ] );

					}

					this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

				} else {

					this.source.disconnect( this.getOutput() );

				}

				return this;

			},

			getFilters: function () {

				return this.filters;

			},

			setFilters: function ( value ) {

				if ( ! value ) value = [];

				if ( this.isPlaying === true ) {

					this.disconnect();
					this.filters = value;
					this.connect();

				} else {

					this.filters = value;

				}

				return this;

			},

			getFilter: function () {

				return this.getFilters()[ 0 ];

			},

			setFilter: function ( filter ) {

				return this.setFilters( filter ? [ filter ] : [] );

			},

			setPlaybackRate: function ( value ) {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.playbackRate = value;

				if ( this.isPlaying === true ) {

					this.source.playbackRate.value = this.playbackRate;

				}

				return this;

			},

			getPlaybackRate: function () {

				return this.playbackRate;

			},

			onEnded: function () {

				this.isPlaying = false;

			},

			getLoop: function () {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return false;

				}

				return this.source.loop;

			},

			setLoop: function ( value ) {

				if ( this.hasPlaybackControl === false ) {

					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;

				}

				this.source.loop = value;

			},

			getVolume: function () {

				return this.gain.gain.value;

			},


			setVolume: function ( value ) {

				this.gain.gain.value = value;

				return this;

			}

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function PositionalAudio( listener ) {

			Audio.call( this, listener );

			this.panner = this.context.createPanner();
			this.panner.connect( this.gain );

		}

		PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

			constructor: PositionalAudio,

			getOutput: function () {

				return this.panner;

			},

			getRefDistance: function () {

				return this.panner.refDistance;

			},

			setRefDistance: function ( value ) {

				this.panner.refDistance = value;

			},

			getRolloffFactor: function () {

				return this.panner.rolloffFactor;

			},

			setRolloffFactor: function ( value ) {

				this.panner.rolloffFactor = value;

			},

			getDistanceModel: function () {

				return this.panner.distanceModel;

			},

			setDistanceModel: function ( value ) {

				this.panner.distanceModel = value;

			},

			getMaxDistance: function () {

				return this.panner.maxDistance;

			},

			setMaxDistance: function ( value ) {

				this.panner.maxDistance = value;

			},

			updateMatrixWorld: ( function () {

				var position = new Vector3();

				return function updateMatrixWorld( force ) {

					Object3D.prototype.updateMatrixWorld.call( this, force );

					position.setFromMatrixPosition( this.matrixWorld );

					this.panner.setPosition( position.x, position.y, position.z );

				};

			} )()


		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AudioAnalyser( audio, fftSize ) {

			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

			this.data = new Uint8Array( this.analyser.frequencyBinCount );

			audio.getOutput().connect( this.analyser );

		}

		Object.assign( AudioAnalyser.prototype, {

			getFrequencyData: function () {

				this.analyser.getByteFrequencyData( this.data );

				return this.data;

			},

			getAverageFrequency: function () {

				var value = 0, data = this.getFrequencyData();

				for ( var i = 0; i < data.length; i ++ ) {

					value += data[ i ];

				}

				return value / data.length;

			}

		} );

		/**
		 *
		 * Buffered scene graph property that allows weighted accumulation.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function PropertyMixer( binding, typeName, valueSize ) {

			this.binding = binding;
			this.valueSize = valueSize;

			var bufferType = Float64Array,
				mixFunction;

			switch ( typeName ) {

				case 'quaternion':			mixFunction = this._slerp;		break;

				case 'string':
				case 'bool':

					bufferType = Array,		mixFunction = this._select;		break;

				default:					mixFunction = this._lerp;

			}

			this.buffer = new bufferType( valueSize * 4 );
			// layout: [ incoming | accu0 | accu1 | orig ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property

			this._mixBufferRegion = mixFunction;

			this.cumulativeWeight = 0;

			this.useCount = 0;
			this.referenceCount = 0;

		}

		PropertyMixer.prototype = {

			constructor: PropertyMixer,

			// accumulate data in the 'incoming' region into 'accu<i>'
			accumulate: function( accuIndex, weight ) {

				// note: happily accumulating nothing when weight = 0, the caller knows
				// the weight and shouldn't have made the call in the first place

				var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride,

					currentWeight = this.cumulativeWeight;

				if ( currentWeight === 0 ) {

					// accuN := incoming * weight

					for ( var i = 0; i !== stride; ++ i ) {

						buffer[ offset + i ] = buffer[ i ];

					}

					currentWeight = weight;

				} else {

					// accuN := accuN + incoming * weight

					currentWeight += weight;
					var mix = weight / currentWeight;
					this._mixBufferRegion( buffer, offset, 0, mix, stride );

				}

				this.cumulativeWeight = currentWeight;

			},

			// apply the state of 'accu<i>' to the binding when accus differ
			apply: function( accuIndex ) {

				var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,

					weight = this.cumulativeWeight,

					binding = this.binding;

				this.cumulativeWeight = 0;

				if ( weight < 1 ) {

					// accuN := accuN + original * ( 1 - cumulativeWeight )

					var originalValueOffset = stride * 3;

					this._mixBufferRegion(
							buffer, offset, originalValueOffset, 1 - weight, stride );

				}

				for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

					if ( buffer[ i ] !== buffer[ i + stride ] ) {

						// value has changed -> update scene graph

						binding.setValue( buffer, offset );
						break;

					}

				}

			},

			// remember the state of the bound property and copy it to both accus
			saveOriginalState: function() {

				var binding = this.binding;

				var buffer = this.buffer,
					stride = this.valueSize,

					originalValueOffset = stride * 3;

				binding.getValue( buffer, originalValueOffset );

				// accu[0..1] := orig -- initially detect changes against the original
				for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

					buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

				}

				this.cumulativeWeight = 0;

			},

			// apply the state previously taken via 'saveOriginalState' to the binding
			restoreOriginalState: function() {

				var originalValueOffset = this.valueSize * 3;
				this.binding.setValue( this.buffer, originalValueOffset );

			},


			// mix functions

			_select: function( buffer, dstOffset, srcOffset, t, stride ) {

				if ( t >= 0.5 ) {

					for ( var i = 0; i !== stride; ++ i ) {

						buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

					}

				}

			},

			_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

				Quaternion.slerpFlat( buffer, dstOffset,
						buffer, dstOffset, buffer, srcOffset, t );

			},

			_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

				var s = 1 - t;

				for ( var i = 0; i !== stride; ++ i ) {

					var j = dstOffset + i;

					buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

				}

			}

		};

		/**
		 *
		 * A reference to a real property in the scene graph.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function PropertyBinding( rootNode, path, parsedPath ) {

			this.path = path;
			this.parsedPath = parsedPath ||
					PropertyBinding.parseTrackName( path );

			this.node = PropertyBinding.findNode(
					rootNode, this.parsedPath.nodeName ) || rootNode;

			this.rootNode = rootNode;

		}

		PropertyBinding.prototype = {

			constructor: PropertyBinding,

			getValue: function getValue_unbound( targetArray, offset ) {

				this.bind();
				this.getValue( targetArray, offset );

				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.

			},

			setValue: function getValue_unbound( sourceArray, offset ) {

				this.bind();
				this.setValue( sourceArray, offset );

			},

			// create getter / setter pair for a property in the scene graph
			bind: function() {

				var targetObject = this.node,
					parsedPath = this.parsedPath,

					objectName = parsedPath.objectName,
					propertyName = parsedPath.propertyName,
					propertyIndex = parsedPath.propertyIndex;

				if ( ! targetObject ) {

					targetObject = PropertyBinding.findNode(
							this.rootNode, parsedPath.nodeName ) || this.rootNode;

					this.node = targetObject;

				}

				// set fail state so we can just 'return' on error
				this.getValue = this._getValue_unavailable;
				this.setValue = this._setValue_unavailable;

		 		// ensure there is a value node
				if ( ! targetObject ) {

					console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
					return;

				}

				if ( objectName ) {

					var objectIndex = parsedPath.objectIndex;

					// special cases were we need to reach deeper into the hierarchy to get the face materials....
					switch ( objectName ) {

						case 'materials':

							if ( ! targetObject.material ) {

								console.error( '  can not bind to material as node does not have a material', this );
								return;

							}

							if ( ! targetObject.material.materials ) {

								console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
								return;

							}

							targetObject = targetObject.material.materials;

							break;

						case 'bones':

							if ( ! targetObject.skeleton ) {

								console.error( '  can not bind to bones as node does not have a skeleton', this );
								return;

							}

							// potential future optimization: skip this if propertyIndex is already an integer
							// and convert the integer string to a true integer.

							targetObject = targetObject.skeleton.bones;

							// support resolving morphTarget names into indices.
							for ( var i = 0; i < targetObject.length; i ++ ) {

								if ( targetObject[ i ].name === objectIndex ) {

									objectIndex = i;
									break;

								}

							}

							break;

						default:

							if ( targetObject[ objectName ] === undefined ) {

								console.error( '  can not bind to objectName of node, undefined', this );
								return;

							}

							targetObject = targetObject[ objectName ];

					}


					if ( objectIndex !== undefined ) {

						if ( targetObject[ objectIndex ] === undefined ) {

							console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
							return;

						}

						targetObject = targetObject[ objectIndex ];

					}

				}

				// resolve property
				var nodeProperty = targetObject[ propertyName ];

				if ( nodeProperty === undefined ) {

					var nodeName = parsedPath.nodeName;

					console.error( "  trying to update property for track: " + nodeName +
							'.' + propertyName + " but it wasn't found.", targetObject );
					return;

				}

				// determine versioning scheme
				var versioning = this.Versioning.None;

				if ( targetObject.needsUpdate !== undefined ) { // material

					versioning = this.Versioning.NeedsUpdate;
					this.targetObject = targetObject;

				} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

					versioning = this.Versioning.MatrixWorldNeedsUpdate;
					this.targetObject = targetObject;

				}

				// determine how the property gets bound
				var bindingType = this.BindingType.Direct;

				if ( propertyIndex !== undefined ) {
					// access a sub element of the property array (only primitives are supported right now)

					if ( propertyName === "morphTargetInfluences" ) {
						// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

						// support resolving morphTarget names into indices.
						if ( ! targetObject.geometry ) {

							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
							return;

						}

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

					bindingType = this.BindingType.ArrayElement;

					this.resolvedProperty = nodeProperty;
					this.propertyIndex = propertyIndex;

				} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
					// must use copy for Object3D.Euler/Quaternion

					bindingType = this.BindingType.HasFromToArray;

					this.resolvedProperty = nodeProperty;

				} else if ( nodeProperty.length !== undefined ) {

					bindingType = this.BindingType.EntireArray;

					this.resolvedProperty = nodeProperty;

				} else {

					this.propertyName = propertyName;

				}

				// select getter / setter
				this.getValue = this.GetterByBindingType[ bindingType ];
				this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

			},

			unbind: function() {

				this.node = null;

				// back to the prototype version of getValue / setValue
				// note: avoiding to mutate the shape of 'this' via 'delete'
				this.getValue = this._getValue_unbound;
				this.setValue = this._setValue_unbound;

			}

		};

		Object.assign( PropertyBinding.prototype, { // prototype, continued

			// these are used to "bind" a nonexistent property
			_getValue_unavailable: function() {},
			_setValue_unavailable: function() {},

			// initial state of these methods that calls 'bind'
			_getValue_unbound: PropertyBinding.prototype.getValue,
			_setValue_unbound: PropertyBinding.prototype.setValue,

			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			},

			Versioning: {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			},

			GetterByBindingType: [

				function getValue_direct( buffer, offset ) {

					buffer[ offset ] = this.node[ this.propertyName ];

				},

				function getValue_array( buffer, offset ) {

					var source = this.resolvedProperty;

					for ( var i = 0, n = source.length; i !== n; ++ i ) {

						buffer[ offset ++ ] = source[ i ];

					}

				},

				function getValue_arrayElement( buffer, offset ) {

					buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

				},

				function getValue_toArray( buffer, offset ) {

					this.resolvedProperty.toArray( buffer, offset );

				}

			],

			SetterByBindingTypeAndVersioning: [

				[
					// Direct

					function setValue_direct( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];

					},

					function setValue_direct_setNeedsUpdate( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;

					},

					function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// EntireArray

					function setValue_array( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

					},

					function setValue_array_setNeedsUpdate( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

						this.targetObject.needsUpdate = true;

					},

					function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

						var dest = this.resolvedProperty;

						for ( var i = 0, n = dest.length; i !== n; ++ i ) {

							dest[ i ] = buffer[ offset ++ ];

						}

						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// ArrayElement

					function setValue_arrayElement( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

					},

					function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;

					},

					function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				], [

					// HasToFromArray

					function setValue_fromArray( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );

					},

					function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.needsUpdate = true;

					},

					function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

				]

			]

		} );

		PropertyBinding.Composite =
				function( targetGroup, path, optionalParsedPath ) {

			var parsedPath = optionalParsedPath ||
					PropertyBinding.parseTrackName( path );

			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );

		};

		PropertyBinding.Composite.prototype = {

			constructor: PropertyBinding.Composite,

			getValue: function( array, offset ) {

				this.bind(); // bind all binding

				var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[ firstValidIndex ];

				// and only call .getValue on the first
				if ( binding !== undefined ) binding.getValue( array, offset );

			},

			setValue: function( array, offset ) {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].setValue( array, offset );

				}

			},

			bind: function() {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].bind();

				}

			},

			unbind: function() {

				var bindings = this._bindings;

				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {

					bindings[ i ].unbind();

				}

			}

		};

		PropertyBinding.create = function( root, path, parsedPath ) {

			if ( ! ( (root && root.isAnimationObjectGroup) ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		};

		PropertyBinding.parseTrackName = function( trackName ) {

			// matches strings in the form of:
			//    nodeName.property
			//    nodeName.property[accessor]
			//    nodeName.material.property[accessor]
			//    uuid.property[accessor]
			//    uuid.objectName[objectIndex].propertyName[propertyIndex]
			//    parentName/nodeName.property
			//    parentName/parentName/nodeName.property[index]
			//    .bone[Armature.DEF_cog].position
			//    scene:helium_balloon_model:helium_balloon_model.position
			// created and tested via https://regex101.com/#javascript

			var re = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/;
			var matches = re.exec( trackName );

			if ( ! matches ) {

				throw new Error( "cannot parse trackName at all: " + trackName );

			}

			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ],
				propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
			};

			if ( results.propertyName === null || results.propertyName.length === 0 ) {

				throw new Error( "can not parse propertyName from trackName: " + trackName );

			}

			return results;

		};

		PropertyBinding.findNode = function( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var searchSkeleton = function( skeleton ) {

					for( var i = 0; i < skeleton.bones.length; i ++ ) {

						var bone = skeleton.bones[ i ];

						if ( bone.name === nodeName ) {

							return bone;

						}
					}

					return null;

				};

				var bone = searchSkeleton( root.skeleton );

				if ( bone ) {

					return bone;

				}
			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function( children ) {

					for( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		};

		/**
		 *
		 * A group of objects that receives a shared animation state.
		 *
		 * Usage:
		 *
		 * 	-	Add objects you would otherwise pass as 'root' to the
		 * 		constructor or the .clipAction method of AnimationMixer.
		 *
		 * 	-	Instead pass this object as 'root'.
		 *
		 * 	-	You can also add and remove objects later when the mixer
		 * 		is running.
		 *
		 * Note:
		 *
		 *  	Objects of this class appear as one object to the mixer,
		 *  	so cache control of the individual objects must be done
		 *  	on the group.
		 *
		 * Limitation:
		 *
		 * 	- 	The animated properties must be compatible among the
		 * 		all objects in the group.
		 *
		 *  -	A single property can either be controlled through a
		 *  	target group or directly, but not both.
		 *
		 * @author tschw
		 */

		function AnimationObjectGroup( var_args ) {

			this.uuid = _Math.generateUUID();

			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );

			this.nCachedObjects_ = 0;			// threshold
			// note: read by PropertyBinding.Composite

			var indices = {};
			this._indicesByUUID = indices;		// for bookkeeping

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				indices[ arguments[ i ].uuid ] = i;

			}

			this._paths = [];					// inside: string
			this._parsedPaths = [];				// inside: { we don't care, here }
			this._bindings = []; 				// inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

			var scope = this;

			this.stats = {

				objects: {
					get total() { return scope._objects.length; },
					get inUse() { return this.total - scope.nCachedObjects_;  }
				},

				get bindingsPerObject() { return scope._bindings.length; }

			};

		}

		AnimationObjectGroup.prototype = {

			constructor: AnimationObjectGroup,

			isAnimationObjectGroup: true,

			add: function( var_args ) {

				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index === undefined ) {

						// unknown object -> add it to the ACTIVE region

						index = nObjects ++;
						indicesByUUID[ uuid ] = index;
						objects.push( object );

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							bindings[ j ].push(
									new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] ) );

						}

					} else if ( index < nCachedObjects ) {

						var knownObject = objects[ index ];

						// move existing object to the ACTIVE region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ];

						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						indicesByUUID[ uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = object;

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								binding = bindingsForPath[ index ];

							bindingsForPath[ index ] = lastCached;

							if ( binding === undefined ) {

								// since we do not bother to create new bindings
								// for objects that are cached, the binding may
								// or may not exist

								binding = new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] );

							}

							bindingsForPath[ firstActiveIndex ] = binding;

						}

					} else if ( objects[ index ] !== knownObject) {

						console.error( "Different objects with the same UUID " +
								"detected. Clean the caches or recreate your " +
								"infrastructure when reloading scenes..." );

					} // else the object is already where we want it to be

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			remove: function( var_args ) {

				var objects = this._objects,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index !== undefined && index >= nCachedObjects ) {

						// move existing object into the CACHED region

						var lastCachedIndex = nCachedObjects ++,
							firstActiveObject = objects[ lastCachedIndex ];

						indicesByUUID[ firstActiveObject.uuid ] = index;
						objects[ index ] = firstActiveObject;

						indicesByUUID[ uuid ] = lastCachedIndex;
						objects[ lastCachedIndex ] = object;

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								firstActive = bindingsForPath[ lastCachedIndex ],
								binding = bindingsForPath[ index ];

							bindingsForPath[ index ] = firstActive;
							bindingsForPath[ lastCachedIndex ] = binding;

						}

					}

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			// remove & forget
			uncache: function( var_args ) {

				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;

				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];

					if ( index !== undefined ) {

						delete indicesByUUID[ uuid ];

						if ( index < nCachedObjects ) {

							// object is cached, shrink the CACHED region

							var firstActiveIndex = -- nCachedObjects,
								lastCachedObject = objects[ firstActiveIndex ],
								lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];

							// last cached object takes this object's place
							indicesByUUID[ lastCachedObject.uuid ] = index;
							objects[ index ] = lastCachedObject;

							// last object goes to the activated slot and pop
							indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
							objects[ firstActiveIndex ] = lastObject;
							objects.pop();

							// accounting is done, now do the same for all bindings

							for ( var j = 0, m = nBindings; j !== m; ++ j ) {

								var bindingsForPath = bindings[ j ],
									lastCached = bindingsForPath[ firstActiveIndex ],
									last = bindingsForPath[ lastIndex ];

								bindingsForPath[ index ] = lastCached;
								bindingsForPath[ firstActiveIndex ] = last;
								bindingsForPath.pop();

							}

						} else {

							// object is active, just swap with the last and pop

							var lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];

							indicesByUUID[ lastObject.uuid ] = index;
							objects[ index ] = lastObject;
							objects.pop();

							// accounting is done, now do the same for all bindings

							for ( var j = 0, m = nBindings; j !== m; ++ j ) {

								var bindingsForPath = bindings[ j ];

								bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
								bindingsForPath.pop();

							}

						} // cached or active

					} // if object is known

				} // for arguments

				this.nCachedObjects_ = nCachedObjects;

			},

			// Internal interface used by befriended PropertyBinding.Composite:

			subscribe_: function( path, parsedPath ) {
				// returns an array of bindings for the given path that is changed
				// according to the contained objects in the group

				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ],
					bindings = this._bindings;

				if ( index !== undefined ) return bindings[ index ];

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array( nObjects );

				index = bindings.length;

				indicesByPath[ path ] = index;

				paths.push( path );
				parsedPaths.push( parsedPath );
				bindings.push( bindingsForPath );

				for ( var i = nCachedObjects,
						n = objects.length; i !== n; ++ i ) {

					var object = objects[ i ];

					bindingsForPath[ i ] =
							new PropertyBinding( object, path, parsedPath );

				}

				return bindingsForPath;

			},

			unsubscribe_: function( path ) {
				// tells the group to forget about a property path and no longer
				// update the array previously obtained with 'subscribe_'

				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ];

				if ( index !== undefined ) {

					var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[ lastBindingsIndex ],
						lastBindingsPath = path[ lastBindingsIndex ];

					indicesByPath[ lastBindingsPath ] = index;

					bindings[ index ] = lastBindings;
					bindings.pop();

					parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
					parsedPaths.pop();

					paths[ index ] = paths[ lastBindingsIndex ];
					paths.pop();

				}

			}

		};

		/**
		 *
		 * Action provided by AnimationMixer for scheduling clip playback on specific
		 * objects.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 *
		 */

		function AnimationAction( mixer, clip, localRoot ) {

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;

			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );

			var interpolantSettings = {
					endingStart: 	ZeroCurvatureEnding,
					endingEnd:		ZeroCurvatureEnding
			};

			for ( var i = 0; i !== nTracks; ++ i ) {

				var interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;

			}

			this._interpolantSettings = interpolantSettings;

			this._interpolants = interpolants;	// bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );

			this._cacheIndex = null;			// for the memory manager
			this._byClipCacheIndex = null;		// for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;

			this.loop = LoopRepeat;
			this._loopCount = -1;

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;

			this.timeScale = 1;
			this._effectiveTimeScale = 1;

			this.weight = 1;
			this._effectiveWeight = 1;

			this.repetitions = Infinity; 		// no. of repetitions when looping

			this.paused = false;				// false -> zero effective time scale
			this.enabled = true;				// true -> zero effective weight

			this.clampWhenFinished 	= false;	// keep feeding the last frame?

			this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

		}

		AnimationAction.prototype = {

			constructor: AnimationAction,

			// State & Scheduling

			play: function() {

				this._mixer._activateAction( this );

				return this;

			},

			stop: function() {

				this._mixer._deactivateAction( this );

				return this.reset();

			},

			reset: function() {

				this.paused = false;
				this.enabled = true;

				this.time = 0;			// restart clip
				this._loopCount = -1;	// forget previous loops
				this._startTime = null;	// forget scheduling

				return this.stopFading().stopWarping();

			},

			isRunning: function() {

				return this.enabled && ! this.paused && this.timeScale !== 0 &&
						this._startTime === null && this._mixer._isActiveAction( this );

			},

			// return true when play has been called
			isScheduled: function() {

				return this._mixer._isActiveAction( this );

			},

			startAt: function( time ) {

				this._startTime = time;

				return this;

			},

			setLoop: function( mode, repetitions ) {

				this.loop = mode;
				this.repetitions = repetitions;

				return this;

			},

			// Weight

			// set the weight stopping any scheduled fading
			// although .enabled = false yields an effective weight of zero, this
			// method does *not* change .enabled, because it would be confusing
			setEffectiveWeight: function( weight ) {

				this.weight = weight;

				// note: same logic as when updated at runtime
				this._effectiveWeight = this.enabled ? weight : 0;

				return this.stopFading();

			},

			// return the weight considering fading and .enabled
			getEffectiveWeight: function() {

				return this._effectiveWeight;

			},

			fadeIn: function( duration ) {

				return this._scheduleFading( duration, 0, 1 );

			},

			fadeOut: function( duration ) {

				return this._scheduleFading( duration, 1, 0 );

			},

			crossFadeFrom: function( fadeOutAction, duration, warp ) {

				fadeOutAction.fadeOut( duration );
				this.fadeIn( duration );

				if( warp ) {

					var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,

						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;

					fadeOutAction.warp( 1.0, startEndRatio, duration );
					this.warp( endStartRatio, 1.0, duration );

				}

				return this;

			},

			crossFadeTo: function( fadeInAction, duration, warp ) {

				return fadeInAction.crossFadeFrom( this, duration, warp );

			},

			stopFading: function() {

				var weightInterpolant = this._weightInterpolant;

				if ( weightInterpolant !== null ) {

					this._weightInterpolant = null;
					this._mixer._takeBackControlInterpolant( weightInterpolant );

				}

				return this;

			},

			// Time Scale Control

			// set the weight stopping any scheduled warping
			// although .paused = true yields an effective time scale of zero, this
			// method does *not* change .paused, because it would be confusing
			setEffectiveTimeScale: function( timeScale ) {

				this.timeScale = timeScale;
				this._effectiveTimeScale = this.paused ? 0 :timeScale;

				return this.stopWarping();

			},

			// return the time scale considering warping and .paused
			getEffectiveTimeScale: function() {

				return this._effectiveTimeScale;

			},

			setDuration: function( duration ) {

				this.timeScale = this._clip.duration / duration;

				return this.stopWarping();

			},

			syncWith: function( action ) {

				this.time = action.time;
				this.timeScale = action.timeScale;

				return this.stopWarping();

			},

			halt: function( duration ) {

				return this.warp( this._effectiveTimeScale, 0, duration );

			},

			warp: function( startTimeScale, endTimeScale, duration ) {

				var mixer = this._mixer, now = mixer.time,
					interpolant = this._timeScaleInterpolant,

					timeScale = this.timeScale;

				if ( interpolant === null ) {

					interpolant = mixer._lendControlInterpolant(),
					this._timeScaleInterpolant = interpolant;

				}

				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;

				times[ 0 ] = now;
				times[ 1 ] = now + duration;

				values[ 0 ] = startTimeScale / timeScale;
				values[ 1 ] = endTimeScale / timeScale;

				return this;

			},

			stopWarping: function() {

				var timeScaleInterpolant = this._timeScaleInterpolant;

				if ( timeScaleInterpolant !== null ) {

					this._timeScaleInterpolant = null;
					this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

				}

				return this;

			},

			// Object Accessors

			getMixer: function() {

				return this._mixer;

			},

			getClip: function() {

				return this._clip;

			},

			getRoot: function() {

				return this._localRoot || this._mixer._root;

			},

			// Interna

			_update: function( time, deltaTime, timeDirection, accuIndex ) {
				// called by the mixer

				var startTime = this._startTime;

				if ( startTime !== null ) {

					// check for scheduled start of action

					var timeRunning = ( time - startTime ) * timeDirection;
					if ( timeRunning < 0 || timeDirection === 0 ) {

						return; // yet to come / don't decide when delta = 0

					}

					// start

					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;

				}

				// apply time scale and advance time

				deltaTime *= this._updateTimeScale( time );
				var clipTime = this._updateTime( deltaTime );

				// note: _updateTime may disable the action resulting in
				// an effective weight of 0

				var weight = this._updateWeight( time );

				if ( weight > 0 ) {

					var interpolants = this._interpolants;
					var propertyMixers = this._propertyBindings;

					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

				}

			},

			_updateWeight: function( time ) {

				var weight = 0;

				if ( this.enabled ) {

					weight = this.weight;
					var interpolant = this._weightInterpolant;

					if ( interpolant !== null ) {

						var interpolantValue = interpolant.evaluate( time )[ 0 ];

						weight *= interpolantValue;

						if ( time > interpolant.parameterPositions[ 1 ] ) {

							this.stopFading();

							if ( interpolantValue === 0 ) {

								// faded out, disable
								this.enabled = false;

							}

						}

					}

				}

				this._effectiveWeight = weight;
				return weight;

			},

			_updateTimeScale: function( time ) {

				var timeScale = 0;

				if ( ! this.paused ) {

					timeScale = this.timeScale;

					var interpolant = this._timeScaleInterpolant;

					if ( interpolant !== null ) {

						var interpolantValue = interpolant.evaluate( time )[ 0 ];

						timeScale *= interpolantValue;

						if ( time > interpolant.parameterPositions[ 1 ] ) {

							this.stopWarping();

							if ( timeScale === 0 ) {

								// motion has halted, pause
								this.paused = true;

							} else {

								// warp done - apply final time scale
								this.timeScale = timeScale;

							}

						}

					}

				}

				this._effectiveTimeScale = timeScale;
				return timeScale;

			},

			_updateTime: function( deltaTime ) {

				var time = this.time + deltaTime;

				if ( deltaTime === 0 ) return time;

				var duration = this._clip.duration,

					loop = this.loop,
					loopCount = this._loopCount;

				if ( loop === LoopOnce ) {

					if ( loopCount === -1 ) {
						// just started

						this.loopCount = 0;
						this._setEndings( true, true, false );

					}

					handle_stop: {

						if ( time >= duration ) {

							time = duration;

						} else if ( time < 0 ) {

							time = 0;

						} else break handle_stop;

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime < 0 ? -1 : 1
						} );

					}

				} else { // repetitive Repeat or PingPong

					var pingPong = ( loop === LoopPingPong );

					if ( loopCount === -1 ) {
						// just started

						if ( deltaTime >= 0 ) {

							loopCount = 0;

							this._setEndings(
									true, this.repetitions === 0, pingPong );

						} else {

							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1

							this._setEndings(
									this.repetitions === 0, true, pingPong );

						}

					}

					if ( time >= duration || time < 0 ) {
						// wrap around

						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;

						loopCount += Math.abs( loopDelta );

						var pending = this.repetitions - loopCount;

						if ( pending < 0 ) {
							// have to stop (switch state, clamp time, fire event)

							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;

							time = deltaTime > 0 ? duration : 0;

							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );

						} else {
							// keep running

							if ( pending === 0 ) {
								// entering the last round

								var atStart = deltaTime < 0;
								this._setEndings( atStart, ! atStart, pingPong );

							} else {

								this._setEndings( false, false, pingPong );

							}

							this._loopCount = loopCount;

							this._mixer.dispatchEvent( {
								type: 'loop', action: this, loopDelta: loopDelta
							} );

						}

					}

					if ( pingPong && ( loopCount & 1 ) === 1 ) {
						// invert time for the "pong round"

						this.time = time;
						return duration - time;

					}

				}

				this.time = time;
				return time;

			},

			_setEndings: function( atStart, atEnd, pingPong ) {

				var settings = this._interpolantSettings;

				if ( pingPong ) {

					settings.endingStart 	= ZeroSlopeEnding;
					settings.endingEnd		= ZeroSlopeEnding;

				} else {

					// assuming for LoopOnce atStart == atEnd == true

					if ( atStart ) {

						settings.endingStart = this.zeroSlopeAtStart ?
								ZeroSlopeEnding : ZeroCurvatureEnding;

					} else {

						settings.endingStart = WrapAroundEnding;

					}

					if ( atEnd ) {

						settings.endingEnd = this.zeroSlopeAtEnd ?
								ZeroSlopeEnding : ZeroCurvatureEnding;

					} else {

						settings.endingEnd 	 = WrapAroundEnding;

					}

				}

			},

			_scheduleFading: function( duration, weightNow, weightThen ) {

				var mixer = this._mixer, now = mixer.time,
					interpolant = this._weightInterpolant;

				if ( interpolant === null ) {

					interpolant = mixer._lendControlInterpolant(),
					this._weightInterpolant = interpolant;

				}

				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;

				times[ 0 ] = now; 				values[ 0 ] = weightNow;
				times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

				return this;

			}

		};

		/**
		 *
		 * Player for AnimationClips.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */

		function AnimationMixer( root ) {

			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;

			this.time = 0;

			this.timeScale = 1.0;

		}

		Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

			// return an action for a clip optionally using a custom root target
			// object (this method allocates a lot of dynamic memory in case a
			// previously unknown clip/root combination is specified)
			clipAction: function( clip, optionalRoot ) {

				var root = optionalRoot || this._root,
					rootUuid = root.uuid,

					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,

					clipUuid = clipObject !== null ? clipObject.uuid : clip,

					actionsForClip = this._actionsByClip[ clipUuid ],
					prototypeAction = null;

				if ( actionsForClip !== undefined ) {

					var existingAction =
							actionsForClip.actionByRoot[ rootUuid ];

					if ( existingAction !== undefined ) {

						return existingAction;

					}

					// we know the clip, so we don't have to parse all
					// the bindings again but can just copy
					prototypeAction = actionsForClip.knownActions[ 0 ];

					// also, take the clip from the prototype action
					if ( clipObject === null )
						clipObject = prototypeAction._clip;

				}

				// clip must be known when specified via string
				if ( clipObject === null ) return null;

				// allocate all resources required to run it
				var newAction = new AnimationAction( this, clipObject, optionalRoot );

				this._bindAction( newAction, prototypeAction );

				// and make the action known to the memory manager
				this._addInactiveAction( newAction, clipUuid, rootUuid );

				return newAction;

			},

			// get an existing action
			existingAction: function( clip, optionalRoot ) {

				var root = optionalRoot || this._root,
					rootUuid = root.uuid,

					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,

					clipUuid = clipObject ? clipObject.uuid : clip,

					actionsForClip = this._actionsByClip[ clipUuid ];

				if ( actionsForClip !== undefined ) {

					return actionsForClip.actionByRoot[ rootUuid ] || null;

				}

				return null;

			},

			// deactivates all previously scheduled actions
			stopAllAction: function() {

				var actions = this._actions,
					nActions = this._nActiveActions,
					bindings = this._bindings,
					nBindings = this._nActiveBindings;

				this._nActiveActions = 0;
				this._nActiveBindings = 0;

				for ( var i = 0; i !== nActions; ++ i ) {

					actions[ i ].reset();

				}

				for ( var i = 0; i !== nBindings; ++ i ) {

					bindings[ i ].useCount = 0;

				}

				return this;

			},

			// advance the time and update apply the animation
			update: function( deltaTime ) {

				deltaTime *= this.timeScale;

				var actions = this._actions,
					nActions = this._nActiveActions,

					time = this.time += deltaTime,
					timeDirection = Math.sign( deltaTime ),

					accuIndex = this._accuIndex ^= 1;

				// run active actions

				for ( var i = 0; i !== nActions; ++ i ) {

					var action = actions[ i ];

					if ( action.enabled ) {

						action._update( time, deltaTime, timeDirection, accuIndex );

					}

				}

				// update scene graph

				var bindings = this._bindings,
					nBindings = this._nActiveBindings;

				for ( var i = 0; i !== nBindings; ++ i ) {

					bindings[ i ].apply( accuIndex );

				}

				return this;

			},

			// return this mixer's root target object
			getRoot: function() {

				return this._root;

			},

			// free all resources specific to a particular clip
			uncacheClip: function( clip ) {

				var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];

				if ( actionsForClip !== undefined ) {

					// note: just calling _removeInactiveAction would mess up the
					// iteration state and also require updating the state we can
					// just throw away

					var actionsToRemove = actionsForClip.knownActions;

					for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

						var action = actionsToRemove[ i ];

						this._deactivateAction( action );

						var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[ actions.length - 1 ];

						action._cacheIndex = null;
						action._byClipCacheIndex = null;

						lastInactiveAction._cacheIndex = cacheIndex;
						actions[ cacheIndex ] = lastInactiveAction;
						actions.pop();

						this._removeInactiveBindingsForAction( action );

					}

					delete actionsByClip[ clipUuid ];

				}

			},

			// free all resources specific to a particular root target object
			uncacheRoot: function( root ) {

				var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;

				for ( var clipUuid in actionsByClip ) {

					var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
						action = actionByRoot[ rootUuid ];

					if ( action !== undefined ) {

						this._deactivateAction( action );
						this._removeInactiveAction( action );

					}

				}

				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ];

				if ( bindingByName !== undefined ) {

					for ( var trackName in bindingByName ) {

						var binding = bindingByName[ trackName ];
						binding.restoreOriginalState();
						this._removeInactiveBinding( binding );

					}

				}

			},

			// remove a targeted clip from the cache
			uncacheAction: function( clip, optionalRoot ) {

				var action = this.existingAction( clip, optionalRoot );

				if ( action !== null ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

		} );

		// Implementation details:

		Object.assign( AnimationMixer.prototype, {

			_bindAction: function( action, prototypeAction ) {

				var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingsByName = bindingsByRoot[ rootUuid ];

				if ( bindingsByName === undefined ) {

					bindingsByName = {};
					bindingsByRoot[ rootUuid ] = bindingsByName;

				}

				for ( var i = 0; i !== nTracks; ++ i ) {

					var track = tracks[ i ],
						trackName = track.name,
						binding = bindingsByName[ trackName ];

					if ( binding !== undefined ) {

						bindings[ i ] = binding;

					} else {

						binding = bindings[ i ];

						if ( binding !== undefined ) {

							// existing binding, make sure the cache knows

							if ( binding._cacheIndex === null ) {

								++ binding.referenceCount;
								this._addInactiveBinding( binding, rootUuid, trackName );

							}

							continue;

						}

						var path = prototypeAction && prototypeAction.
								_propertyBindings[ i ].binding.parsedPath;

						binding = new PropertyMixer(
								PropertyBinding.create( root, trackName, path ),
								track.ValueTypeName, track.getValueSize() );

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

						bindings[ i ] = binding;

					}

					interpolants[ i ].resultBuffer = binding.buffer;

				}

			},

			_activateAction: function( action ) {

				if ( ! this._isActiveAction( action ) ) {

					if ( action._cacheIndex === null ) {

						// this action has been forgotten by the cache, but the user
						// appears to be still using it -> rebind

						var rootUuid = ( action._localRoot || this._root ).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[ clipUuid ];

						this._bindAction( action,
								actionsForClip && actionsForClip.knownActions[ 0 ] );

						this._addInactiveAction( action, clipUuid, rootUuid );

					}

					var bindings = action._propertyBindings;

					// increment reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

						var binding = bindings[ i ];

						if ( binding.useCount ++ === 0 ) {

							this._lendBinding( binding );
							binding.saveOriginalState();

						}

					}

					this._lendAction( action );

				}

			},

			_deactivateAction: function( action ) {

				if ( this._isActiveAction( action ) ) {

					var bindings = action._propertyBindings;

					// decrement reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

						var binding = bindings[ i ];

						if ( -- binding.useCount === 0 ) {

							binding.restoreOriginalState();
							this._takeBackBinding( binding );

						}

					}

					this._takeBackAction( action );

				}

			},

			// Memory manager

			_initMemoryManager: function() {

				this._actions = []; // 'nActiveActions' followed by inactive ones
				this._nActiveActions = 0;

				this._actionsByClip = {};
				// inside:
				// {
				// 		knownActions: Array< AnimationAction >	- used as prototypes
				// 		actionByRoot: AnimationAction			- lookup
				// }


				this._bindings = []; // 'nActiveBindings' followed by inactive ones
				this._nActiveBindings = 0;

				this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


				this._controlInterpolants = []; // same game as above
				this._nActiveControlInterpolants = 0;

				var scope = this;

				this.stats = {

					actions: {
						get total() { return scope._actions.length; },
						get inUse() { return scope._nActiveActions; }
					},
					bindings: {
						get total() { return scope._bindings.length; },
						get inUse() { return scope._nActiveBindings; }
					},
					controlInterpolants: {
						get total() { return scope._controlInterpolants.length; },
						get inUse() { return scope._nActiveControlInterpolants; }
					}

				};

			},

			// Memory management for AnimationAction objects

			_isActiveAction: function( action ) {

				var index = action._cacheIndex;
				return index !== null && index < this._nActiveActions;

			},

			_addInactiveAction: function( action, clipUuid, rootUuid ) {

				var actions = this._actions,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];

				if ( actionsForClip === undefined ) {

					actionsForClip = {

						knownActions: [ action ],
						actionByRoot: {}

					};

					action._byClipCacheIndex = 0;

					actionsByClip[ clipUuid ] = actionsForClip;

				} else {

					var knownActions = actionsForClip.knownActions;

					action._byClipCacheIndex = knownActions.length;
					knownActions.push( action );

				}

				action._cacheIndex = actions.length;
				actions.push( action );

				actionsForClip.actionByRoot[ rootUuid ] = action;

			},

			_removeInactiveAction: function( action ) {

				var actions = this._actions,
					lastInactiveAction = actions[ actions.length - 1 ],
					cacheIndex = action._cacheIndex;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				action._cacheIndex = null;


				var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ],
					knownActionsForClip = actionsForClip.knownActions,

					lastKnownAction =
						knownActionsForClip[ knownActionsForClip.length - 1 ],

					byClipCacheIndex = action._byClipCacheIndex;

				lastKnownAction._byClipCacheIndex = byClipCacheIndex;
				knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
				knownActionsForClip.pop();

				action._byClipCacheIndex = null;


				var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = ( actions._localRoot || this._root ).uuid;

				delete actionByRoot[ rootUuid ];

				if ( knownActionsForClip.length === 0 ) {

					delete actionsByClip[ clipUuid ];

				}

				this._removeInactiveBindingsForAction( action );

			},

			_removeInactiveBindingsForAction: function( action ) {

				var bindings = action._propertyBindings;
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.referenceCount === 0 ) {

						this._removeInactiveBinding( binding );

					}

				}

			},

			_lendAction: function( action ) {

				// [ active actions |  inactive actions  ]
				// [  active actions >| inactive actions ]
				//                 s        a
				//                  <-swap->
				//                 a        s

				var actions = this._actions,
					prevIndex = action._cacheIndex,

					lastActiveIndex = this._nActiveActions ++,

					firstInactiveAction = actions[ lastActiveIndex ];

				action._cacheIndex = lastActiveIndex;
				actions[ lastActiveIndex ] = action;

				firstInactiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = firstInactiveAction;

			},

			_takeBackAction: function( action ) {

				// [  active actions  | inactive actions ]
				// [ active actions |< inactive actions  ]
				//        a        s
				//         <-swap->
				//        s        a

				var actions = this._actions,
					prevIndex = action._cacheIndex,

					firstInactiveIndex = -- this._nActiveActions,

					lastActiveAction = actions[ firstInactiveIndex ];

				action._cacheIndex = firstInactiveIndex;
				actions[ firstInactiveIndex ] = action;

				lastActiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = lastActiveAction;

			},

			// Memory management for PropertyMixer objects

			_addInactiveBinding: function( binding, rootUuid, trackName ) {

				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],

					bindings = this._bindings;

				if ( bindingByName === undefined ) {

					bindingByName = {};
					bindingsByRoot[ rootUuid ] = bindingByName;

				}

				bindingByName[ trackName ] = binding;

				binding._cacheIndex = bindings.length;
				bindings.push( binding );

			},

			_removeInactiveBinding: function( binding ) {

				var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],

					lastInactiveBinding = bindings[ bindings.length - 1 ],
					cacheIndex = binding._cacheIndex;

				lastInactiveBinding._cacheIndex = cacheIndex;
				bindings[ cacheIndex ] = lastInactiveBinding;
				bindings.pop();

				delete bindingByName[ trackName ];

				remove_empty_map: {

					for ( var _ in bindingByName ) break remove_empty_map;

					delete bindingsByRoot[ rootUuid ];

				}

			},

			_lendBinding: function( binding ) {

				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,

					lastActiveIndex = this._nActiveBindings ++,

					firstInactiveBinding = bindings[ lastActiveIndex ];

				binding._cacheIndex = lastActiveIndex;
				bindings[ lastActiveIndex ] = binding;

				firstInactiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = firstInactiveBinding;

			},

			_takeBackBinding: function( binding ) {

				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,

					firstInactiveIndex = -- this._nActiveBindings,

					lastActiveBinding = bindings[ firstInactiveIndex ];

				binding._cacheIndex = firstInactiveIndex;
				bindings[ firstInactiveIndex ] = binding;

				lastActiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = lastActiveBinding;

			},


			// Memory management of Interpolants for weight and time scale

			_lendControlInterpolant: function() {

				var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants ++,
					interpolant = interpolants[ lastActiveIndex ];

				if ( interpolant === undefined ) {

					interpolant = new LinearInterpolant(
							new Float32Array( 2 ), new Float32Array( 2 ),
								1, this._controlInterpolantsResultBuffer );

					interpolant.__cacheIndex = lastActiveIndex;
					interpolants[ lastActiveIndex ] = interpolant;

				}

				return interpolant;

			},

			_takeBackControlInterpolant: function( interpolant ) {

				var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,

					firstInactiveIndex = -- this._nActiveControlInterpolants,

					lastActiveInterpolant = interpolants[ firstInactiveIndex ];

				interpolant.__cacheIndex = firstInactiveIndex;
				interpolants[ firstInactiveIndex ] = interpolant;

				lastActiveInterpolant.__cacheIndex = prevIndex;
				interpolants[ prevIndex ] = lastActiveInterpolant;

			},

			_controlInterpolantsResultBuffer: new Float32Array( 1 )

		} );

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Uniform( value ) {

			if ( typeof value === 'string' ) {

				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];

			}

			this.value = value;

		}

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedBufferGeometry() {

			BufferGeometry.call( this );

			this.type = 'InstancedBufferGeometry';
			this.maxInstancedCount = undefined;

		}

		InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

		InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

		InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		};

		InstancedBufferGeometry.prototype.copy = function ( source ) {

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			var attributes = source.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			var groups = source.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			return this;

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

			this.uuid = _Math.generateUUID();

			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;

			this.normalized = normalized === true;

		}


		InterleavedBufferAttribute.prototype = {

			constructor: InterleavedBufferAttribute,

			isInterleavedBufferAttribute: true,

			get count() {

				return this.data.count;

			},

			get array() {

				return this.data.array;

			},

			setX: function ( index, x ) {

				this.data.array[ index * this.data.stride + this.offset ] = x;

				return this;

			},

			setY: function ( index, y ) {

				this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

				return this;

			},

			setZ: function ( index, z ) {

				this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

				return this;

			},

			setW: function ( index, w ) {

				this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

				return this;

			},

			getX: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset ];

			},

			getY: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 1 ];

			},

			getZ: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 2 ];

			},

			getW: function ( index ) {

				return this.data.array[ index * this.data.stride + this.offset + 3 ];

			},

			setXY: function ( index, x, y ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;

				return this;

			},

			setXYZ: function ( index, x, y, z ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;

				return this;

			},

			setXYZW: function ( index, x, y, z, w ) {

				index = index * this.data.stride + this.offset;

				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
				this.data.array[ index + 3 ] = w;

				return this;

			}

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InterleavedBuffer( array, stride ) {

			this.uuid = _Math.generateUUID();

			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;

			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };

			this.version = 0;

		}

		InterleavedBuffer.prototype = {

			constructor: InterleavedBuffer,

			isInterleavedBuffer: true,

			set needsUpdate( value ) {

				if ( value === true ) this.version ++;

			},

			setArray: function ( array ) {

				if ( Array.isArray( array ) ) {

					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

				}

				this.count = array !== undefined ? array.length / this.stride : 0;
				this.array = array;

			},

			setDynamic: function ( value ) {

				this.dynamic = value;

				return this;

			},

			copy: function ( source ) {

				this.array = new source.array.constructor( source.array );
				this.count = source.count;
				this.stride = source.stride;
				this.dynamic = source.dynamic;

				return this;

			},

			copyAt: function ( index1, attribute, index2 ) {

				index1 *= this.stride;
				index2 *= attribute.stride;

				for ( var i = 0, l = this.stride; i < l; i ++ ) {

					this.array[ index1 + i ] = attribute.array[ index2 + i ];

				}

				return this;

			},

			set: function ( value, offset ) {

				if ( offset === undefined ) offset = 0;

				this.array.set( value, offset );

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			}

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

			InterleavedBuffer.call( this, array, stride );

			this.meshPerAttribute = meshPerAttribute || 1;

		}

		InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
		InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

		InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

		InstancedInterleavedBuffer.prototype.copy = function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		};

		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */

		function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

			BufferAttribute.call( this, array, itemSize );

			this.meshPerAttribute = meshPerAttribute || 1;

		}

		InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

		InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

		InstancedBufferAttribute.prototype.copy = function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */

		function Raycaster( origin, direction, near, far ) {

			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)

			this.near = near || 0;
			this.far = far || Infinity;

			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};

			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );

		}

		function ascSort( a, b ) {

			return a.distance - b.distance;

		}

		function intersectObject( object, raycaster, intersects, recursive ) {

			if ( object.visible === false ) return;

			object.raycast( raycaster, intersects );

			if ( recursive === true ) {

				var children = object.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					intersectObject( children[ i ], raycaster, intersects, true );

				}

			}

		}

		//

		Raycaster.prototype = {

			constructor: Raycaster,

			linePrecision: 1,

			set: function ( origin, direction ) {

				// direction is assumed to be normalized (for accurate distance calculations)

				this.ray.set( origin, direction );

			},

			setFromCamera: function ( coords, camera ) {

				if ( (camera && camera.isPerspectiveCamera) ) {

					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

				} else if ( (camera && camera.isOrthographicCamera) ) {

					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

				} else {

					console.error( 'THREE.Raycaster: Unsupported camera type.' );

				}

			},

			intersectObject: function ( object, recursive ) {

				var intersects = [];

				intersectObject( object, this, intersects, recursive );

				intersects.sort( ascSort );

				return intersects;

			},

			intersectObjects: function ( objects, recursive ) {

				var intersects = [];

				if ( Array.isArray( objects ) === false ) {

					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;

				}

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					intersectObject( objects[ i ], this, intersects, recursive );

				}

				intersects.sort( ascSort );

				return intersects;

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Clock( autoStart ) {

			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;

			this.running = false;

		}

		Clock.prototype = {

			constructor: Clock,

			start: function () {

				this.startTime = ( performance || Date ).now();

				this.oldTime = this.startTime;
				this.elapsedTime = 0;
				this.running = true;

			},

			stop: function () {

				this.getElapsedTime();
				this.running = false;

			},

			getElapsedTime: function () {

				this.getDelta();
				return this.elapsedTime;

			},

			getDelta: function () {

				var diff = 0;

				if ( this.autoStart && ! this.running ) {

					this.start();

				}

				if ( this.running ) {

					var newTime = ( performance || Date ).now();

					diff = ( newTime - this.oldTime ) / 1000;
					this.oldTime = newTime;

					this.elapsedTime += diff;

				}

				return diff;

			}

		};

		/**
		 * Spline from Tween.js, slightly optimized (and trashed)
		 * http://sole.github.com/tween.js/examples/05_spline.html
		 *
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */

		function Spline( points ) {

			this.points = points;

			var c = [], v3 = { x: 0, y: 0, z: 0 },
			point, intPoint, weight, w2, w3,
			pa, pb, pc, pd;

			this.initFromArray = function ( a ) {

				this.points = [];

				for ( var i = 0; i < a.length; i ++ ) {

					this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

				}

			};

			this.getPoint = function ( k ) {

				point = ( this.points.length - 1 ) * k;
				intPoint = Math.floor( point );
				weight = point - intPoint;

				c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
				c[ 1 ] = intPoint;
				c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
				c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

				pa = this.points[ c[ 0 ] ];
				pb = this.points[ c[ 1 ] ];
				pc = this.points[ c[ 2 ] ];
				pd = this.points[ c[ 3 ] ];

				w2 = weight * weight;
				w3 = weight * w2;

				v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
				v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
				v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

				return v3;

			};

			this.getControlPointsArray = function () {

				var i, p, l = this.points.length,
					coords = [];

				for ( i = 0; i < l; i ++ ) {

					p = this.points[ i ];
					coords[ i ] = [ p.x, p.y, p.z ];

				}

				return coords;

			};

			// approximate length by summing linear segments

			this.getLength = function ( nSubDivisions ) {

				var i, index, nSamples, position,
					point = 0, intPoint = 0, oldIntPoint = 0,
					oldPosition = new Vector3(),
					tmpVec = new Vector3(),
					chunkLengths = [],
					totalLength = 0;

				// first point has 0 length

				chunkLengths[ 0 ] = 0;

				if ( ! nSubDivisions ) nSubDivisions = 100;

				nSamples = this.points.length * nSubDivisions;

				oldPosition.copy( this.points[ 0 ] );

				for ( i = 1; i < nSamples; i ++ ) {

					index = i / nSamples;

					position = this.getPoint( index );
					tmpVec.copy( position );

					totalLength += tmpVec.distanceTo( oldPosition );

					oldPosition.copy( position );

					point = ( this.points.length - 1 ) * index;
					intPoint = Math.floor( point );

					if ( intPoint !== oldIntPoint ) {

						chunkLengths[ intPoint ] = totalLength;
						oldIntPoint = intPoint;

					}

				}

				// last point ends with total length

				chunkLengths[ chunkLengths.length ] = totalLength;

				return { chunks: chunkLengths, total: totalLength };

			};

			this.reparametrizeByArcLength = function ( samplingCoef ) {

				var i, j,
					index, indexCurrent, indexNext,
					realDistance,
					sampling, position,
					newpoints = [],
					tmpVec = new Vector3(),
					sl = this.getLength();

				newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

				for ( i = 1; i < this.points.length; i ++ ) {

					//tmpVec.copy( this.points[ i - 1 ] );
					//linearDistance = tmpVec.distanceTo( this.points[ i ] );

					realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

					sampling = Math.ceil( samplingCoef * realDistance / sl.total );

					indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
					indexNext = i / ( this.points.length - 1 );

					for ( j = 1; j < sampling - 1; j ++ ) {

						index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

						position = this.getPoint( index );
						newpoints.push( tmpVec.copy( position ).clone() );

					}

					newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

				}

				this.points = newpoints;

			};

			// Catmull-Rom

			function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

				var v0 = ( p2 - p0 ) * 0.5,
					v1 = ( p3 - p1 ) * 0.5;

				return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

			}

		}

		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The poles (phi) are at the positive and negative y axis.
		 * The equator starts at positive z.
		 */

		function Spherical( radius, phi, theta ) {

			this.radius = ( radius !== undefined ) ? radius : 1.0;
			this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
			this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

			return this;

		}

		Spherical.prototype = {

			constructor: Spherical,

			set: function ( radius, phi, theta ) {

				this.radius = radius;
				this.phi = phi;
				this.theta = theta;

				return this;

			},

			clone: function () {

				return new this.constructor().copy( this );

			},

			copy: function ( other ) {

				this.radius = other.radius;
				this.phi = other.phi;
				this.theta = other.theta;

				return this;

			},

			// restrict phi to be betwee EPS and PI-EPS
			makeSafe: function() {

				var EPS = 0.000001;
				this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

				return this;

			},

			setFromVector3: function( vec3 ) {

				this.radius = vec3.length();

				if ( this.radius === 0 ) {

					this.theta = 0;
					this.phi = 0;

				} else {

					this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
					this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

				}

				return this;

			},

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function MorphBlendMesh( geometry, material ) {

			Mesh.call( this, geometry, material );

			this.animationsMap = {};
			this.animationsList = [];

			// prepare default animation
			// (all frames played together in 1 second)

			var numFrames = this.geometry.morphTargets.length;

			var name = "__default";

			var startFrame = 0;
			var endFrame = numFrames - 1;

			var fps = numFrames / 1;

			this.createAnimation( name, startFrame, endFrame, fps );
			this.setAnimationWeight( name, 1 );

		}

		MorphBlendMesh.prototype = Object.create( Mesh.prototype );
		MorphBlendMesh.prototype.constructor = MorphBlendMesh;

		MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

			var animation = {

				start: start,
				end: end,

				length: end - start + 1,

				fps: fps,
				duration: ( end - start ) / fps,

				lastFrame: 0,
				currentFrame: 0,

				active: false,

				time: 0,
				direction: 1,
				weight: 1,

				directionBackwards: false,
				mirroredLoop: false

			};

			this.animationsMap[ name ] = animation;
			this.animationsList.push( animation );

		};

		MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

			var pattern = /([a-z]+)_?(\d+)/i;

			var firstAnimation, frameRanges = {};

			var geometry = this.geometry;

			for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

				var morph = geometry.morphTargets[ i ];
				var chunks = morph.name.match( pattern );

				if ( chunks && chunks.length > 1 ) {

					var name = chunks[ 1 ];

					if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

					var range = frameRanges[ name ];

					if ( i < range.start ) range.start = i;
					if ( i > range.end ) range.end = i;

					if ( ! firstAnimation ) firstAnimation = name;

				}

			}

			for ( var name in frameRanges ) {

				var range = frameRanges[ name ];
				this.createAnimation( name, range.start, range.end, fps );

			}

			this.firstAnimation = firstAnimation;

		};

		MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.direction = 1;
				animation.directionBackwards = false;

			}

		};

		MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.direction = - 1;
				animation.directionBackwards = true;

			}

		};

		MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.fps = fps;
				animation.duration = ( animation.end - animation.start ) / animation.fps;

			}

		};

		MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.duration = duration;
				animation.fps = ( animation.end - animation.start ) / animation.duration;

			}

		};

		MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.weight = weight;

			}

		};

		MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.time = time;

			}

		};

		MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

			var time = 0;

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				time = animation.time;

			}

			return time;

		};

		MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

			var duration = - 1;

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				duration = animation.duration;

			}

			return duration;

		};

		MorphBlendMesh.prototype.playAnimation = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.time = 0;
				animation.active = true;

			} else {

				console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

			}

		};

		MorphBlendMesh.prototype.stopAnimation = function ( name ) {

			var animation = this.animationsMap[ name ];

			if ( animation ) {

				animation.active = false;

			}

		};

		MorphBlendMesh.prototype.update = function ( delta ) {

			for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

				var animation = this.animationsList[ i ];

				if ( ! animation.active ) continue;

				var frameTime = animation.duration / animation.length;

				animation.time += animation.direction * delta;

				if ( animation.mirroredLoop ) {

					if ( animation.time > animation.duration || animation.time < 0 ) {

						animation.direction *= - 1;

						if ( animation.time > animation.duration ) {

							animation.time = animation.duration;
							animation.directionBackwards = true;

						}

						if ( animation.time < 0 ) {

							animation.time = 0;
							animation.directionBackwards = false;

						}

					}

				} else {

					animation.time = animation.time % animation.duration;

					if ( animation.time < 0 ) animation.time += animation.duration;

				}

				var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
				var weight = animation.weight;

				if ( keyframe !== animation.currentFrame ) {

					this.morphTargetInfluences[ animation.lastFrame ] = 0;
					this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

					this.morphTargetInfluences[ keyframe ] = 0;

					animation.lastFrame = animation.currentFrame;
					animation.currentFrame = keyframe;

				}

				var mix = ( animation.time % frameTime ) / frameTime;

				if ( animation.directionBackwards ) mix = 1 - mix;

				if ( animation.currentFrame !== animation.lastFrame ) {

					this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
					this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

				} else {

					this.morphTargetInfluences[ animation.currentFrame ] = weight;

				}

			}

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		function ImmediateRenderObject( material ) {

			Object3D.call( this );

			this.material = material;
			this.render = function ( renderCallback ) {};

		}

		ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
		ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

		ImmediateRenderObject.prototype.isImmediateRenderObject = true;

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function VertexNormalsHelper( object, size, hex, linewidth ) {

			this.object = object;

			this.size = ( size !== undefined ) ? size : 1;

			var color = ( hex !== undefined ) ? hex : 0xff0000;

			var width = ( linewidth !== undefined ) ? linewidth : 1;

			//

			var nNormals = 0;

			var objGeometry = this.object.geometry;

			if ( (objGeometry && objGeometry.isGeometry) ) {

				nNormals = objGeometry.faces.length * 3;

			} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

				nNormals = objGeometry.attributes.normal.count;

			}

			//

			var geometry = new BufferGeometry();

			var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

			geometry.addAttribute( 'position', positions );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

			//

			this.matrixAutoUpdate = false;

			this.update();

		}

		VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
		VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

		VertexNormalsHelper.prototype.update = ( function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();

			return function update() {

				var keys = [ 'a', 'b', 'c' ];

				this.object.updateMatrixWorld( true );

				normalMatrix.getNormalMatrix( this.object.matrixWorld );

				var matrixWorld = this.object.matrixWorld;

				var position = this.geometry.attributes.position;

				//

				var objGeometry = this.object.geometry;

				if ( (objGeometry && objGeometry.isGeometry) ) {

					var vertices = objGeometry.vertices;

					var faces = objGeometry.faces;

					var idx = 0;

					for ( var i = 0, l = faces.length; i < l; i ++ ) {

						var face = faces[ i ];

						for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

							var vertex = vertices[ face[ keys[ j ] ] ];

							var normal = face.vertexNormals[ j ];

							v1.copy( vertex ).applyMatrix4( matrixWorld );

							v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

							position.setXYZ( idx, v1.x, v1.y, v1.z );

							idx = idx + 1;

							position.setXYZ( idx, v2.x, v2.y, v2.z );

							idx = idx + 1;

						}

					}

				} else if ( (objGeometry && objGeometry.isBufferGeometry) ) {

					var objPos = objGeometry.attributes.position;

					var objNorm = objGeometry.attributes.normal;

					var idx = 0;

					// for simplicity, ignore index and drawcalls, and render every normal

					for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

						v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

						v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

						v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

				position.needsUpdate = true;

				return this;

			};

		}() );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function SpotLightHelper( light ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			var geometry = new BufferGeometry();

			var positions = [
				0, 0, 0,   0,   0,   1,
				0, 0, 0,   1,   0,   1,
				0, 0, 0, - 1,   0,   1,
				0, 0, 0,   0,   1,   1,
				0, 0, 0,   0, - 1,   1
			];

			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;

				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);

			}

			geometry.addAttribute( 'position', new Float32Attribute( positions, 3 ) );

			var material = new LineBasicMaterial( { fog: false } );

			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );

			this.update();

		}

		SpotLightHelper.prototype = Object.create( Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;

		SpotLightHelper.prototype.dispose = function () {

			this.cone.geometry.dispose();
			this.cone.material.dispose();

		};

		SpotLightHelper.prototype.update = function () {

			var vector = new Vector3();
			var vector2 = new Vector3();

			return function update() {

				var coneLength = this.light.distance ? this.light.distance : 1000;
				var coneWidth = coneLength * Math.tan( this.light.angle );

				this.cone.scale.set( coneWidth, coneWidth, coneLength );

				vector.setFromMatrixPosition( this.light.matrixWorld );
				vector2.setFromMatrixPosition( this.light.target.matrixWorld );

				this.cone.lookAt( vector2.sub( vector ) );

				this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			};

		}();

		/**
		 * @author Sean Griffin / http://twitter.com/sgrif
		 * @author Michael Guerrero / http://realitymeltdown.com
		 * @author mrdoob / http://mrdoob.com/
		 * @author ikerr / http://verold.com
		 */

		function SkeletonHelper( object ) {

			this.bones = this.getBoneList( object );

			var geometry = new Geometry();

			for ( var i = 0; i < this.bones.length; i ++ ) {

				var bone = this.bones[ i ];

				if ( (bone.parent && bone.parent.isBone) ) {

					geometry.vertices.push( new Vector3() );
					geometry.vertices.push( new Vector3() );
					geometry.colors.push( new Color( 0, 0, 1 ) );
					geometry.colors.push( new Color( 0, 1, 0 ) );

				}

			}

			geometry.dynamic = true;

			var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

			LineSegments.call( this, geometry, material );

			this.root = object;

			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;

			this.update();

		}


		SkeletonHelper.prototype = Object.create( LineSegments.prototype );
		SkeletonHelper.prototype.constructor = SkeletonHelper;

		SkeletonHelper.prototype.getBoneList = function( object ) {

			var boneList = [];

			if ( (object && object.isBone) ) {

				boneList.push( object );

			}

			for ( var i = 0; i < object.children.length; i ++ ) {

				boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

			}

			return boneList;

		};

		SkeletonHelper.prototype.update = function () {

			var geometry = this.geometry;

			var matrixWorldInv = new Matrix4().getInverse( this.root.matrixWorld );

			var boneMatrix = new Matrix4();

			var j = 0;

			for ( var i = 0; i < this.bones.length; i ++ ) {

				var bone = this.bones[ i ];

				if ( (bone.parent && bone.parent.isBone) ) {

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

					j += 2;

				}

			}

			geometry.verticesNeedUpdate = true;

			geometry.computeBoundingSphere();

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function PointLightHelper( light, sphereSize ) {

			this.light = light;
			this.light.updateMatrixWorld();

			var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
			material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			Mesh.call( this, geometry, material );

			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;

			/*
			var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
			var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

			var d = light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.scale.set( d, d, d );

			}

			this.add( this.lightDistance );
			*/

		}

		PointLightHelper.prototype = Object.create( Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;

		PointLightHelper.prototype.dispose = function () {

			this.geometry.dispose();
			this.material.dispose();

		};

		PointLightHelper.prototype.update = function () {

			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

			/*
			var d = this.light.distance;

			if ( d === 0.0 ) {

				this.lightDistance.visible = false;

			} else {

				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );

			}
			*/

		};

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function HemisphereLightHelper( light, sphereSize ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			this.colors = [ new Color(), new Color() ];

			var geometry = new SphereGeometry( sphereSize, 4, 2 );
			geometry.rotateX( - Math.PI / 2 );

			for ( var i = 0, il = 8; i < il; i ++ ) {

				geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

			}

			var material = new MeshBasicMaterial( { vertexColors: FaceColors, wireframe: true } );

			this.lightSphere = new Mesh( geometry, material );
			this.add( this.lightSphere );

			this.update();

		}

		HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

		HemisphereLightHelper.prototype.dispose = function () {

			this.lightSphere.geometry.dispose();
			this.lightSphere.material.dispose();

		};

		HemisphereLightHelper.prototype.update = function () {

			var vector = new Vector3();

			return function update() {

				this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
				this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

				this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
				this.lightSphere.geometry.colorsNeedUpdate = true;

			};

		}();

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function GridHelper( size, divisions, color1, color2 ) {

			divisions = divisions || 1;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

			var center = divisions / 2;
			var step = ( size * 2 ) / divisions;
			var vertices = [], colors = [];

			for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {

				vertices.push( - size, 0, k, size, 0, k );
				vertices.push( k, 0, - size, k, 0, size );

				var color = i === center ? color1 : color2;

				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;

			}

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32Attribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: VertexColors } );

			LineSegments.call( this, geometry, material );

		}

		GridHelper.prototype = Object.create( LineSegments.prototype );
		GridHelper.prototype.constructor = GridHelper;

		GridHelper.prototype.setColors = function () {

			console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/

		function FaceNormalsHelper( object, size, hex, linewidth ) {

			// FaceNormalsHelper only supports THREE.Geometry

			this.object = object;

			this.size = ( size !== undefined ) ? size : 1;

			var color = ( hex !== undefined ) ? hex : 0xffff00;

			var width = ( linewidth !== undefined ) ? linewidth : 1;

			//

			var nNormals = 0;

			var objGeometry = this.object.geometry;

			if ( (objGeometry && objGeometry.isGeometry) ) {

				nNormals = objGeometry.faces.length;

			} else {

				console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

			}

			//

			var geometry = new BufferGeometry();

			var positions = new Float32Attribute( nNormals * 2 * 3, 3 );

			geometry.addAttribute( 'position', positions );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

			//

			this.matrixAutoUpdate = false;
			this.update();

		}

		FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
		FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

		FaceNormalsHelper.prototype.update = ( function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();

			return function update() {

				this.object.updateMatrixWorld( true );

				normalMatrix.getNormalMatrix( this.object.matrixWorld );

				var matrixWorld = this.object.matrixWorld;

				var position = this.geometry.attributes.position;

				//

				var objGeometry = this.object.geometry;

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					var normal = face.normal;

					v1.copy( vertices[ face.a ] )
						.add( vertices[ face.b ] )
						.add( vertices[ face.c ] )
						.divideScalar( 3 )
						.applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

				position.needsUpdate = true;

				return this;

			};

		}() );

		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */

		function DirectionalLightHelper( light, size ) {

			Object3D.call( this );

			this.light = light;
			this.light.updateMatrixWorld();

			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;

			if ( size === undefined ) size = 1;

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( [
				- size,   size, 0,
				  size,   size, 0,
				  size, - size, 0,
				- size, - size, 0,
				- size,   size, 0
			], 3 ) );

			var material = new LineBasicMaterial( { fog: false } );

			this.add( new Line( geometry, material ) );

			geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

			this.add( new Line( geometry, material ));

			this.update();

		}

		DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

		DirectionalLightHelper.prototype.dispose = function () {

			var lightPlane = this.children[ 0 ];
			var targetLine = this.children[ 1 ];

			lightPlane.geometry.dispose();
			lightPlane.material.dispose();
			targetLine.geometry.dispose();
			targetLine.material.dispose();

		};

		DirectionalLightHelper.prototype.update = function () {

			var v1 = new Vector3();
			var v2 = new Vector3();
			var v3 = new Vector3();

			return function update() {

				v1.setFromMatrixPosition( this.light.matrixWorld );
				v2.setFromMatrixPosition( this.light.target.matrixWorld );
				v3.subVectors( v2, v1 );

				var lightPlane = this.children[ 0 ];
				var targetLine = this.children[ 1 ];

				lightPlane.lookAt( v3 );
				lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

				targetLine.lookAt( v3 );
				targetLine.scale.z = v3.length();

			};

		}();

		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 *	- shows frustum, line of sight and up of the camera
		 *	- suitable for fast updates
		 * 	- based on frustum visualization in lightgl.js shadowmap example
		 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
		 */

		function CameraHelper( camera ) {

			var geometry = new Geometry();
			var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

			var pointMap = {};

			// colors

			var hexFrustum = 0xffaa00;
			var hexCone = 0xff0000;
			var hexUp = 0x00aaff;
			var hexTarget = 0xffffff;
			var hexCross = 0x333333;

			// near

			addLine( "n1", "n2", hexFrustum );
			addLine( "n2", "n4", hexFrustum );
			addLine( "n4", "n3", hexFrustum );
			addLine( "n3", "n1", hexFrustum );

			// far

			addLine( "f1", "f2", hexFrustum );
			addLine( "f2", "f4", hexFrustum );
			addLine( "f4", "f3", hexFrustum );
			addLine( "f3", "f1", hexFrustum );

			// sides

			addLine( "n1", "f1", hexFrustum );
			addLine( "n2", "f2", hexFrustum );
			addLine( "n3", "f3", hexFrustum );
			addLine( "n4", "f4", hexFrustum );

			// cone

			addLine( "p", "n1", hexCone );
			addLine( "p", "n2", hexCone );
			addLine( "p", "n3", hexCone );
			addLine( "p", "n4", hexCone );

			// up

			addLine( "u1", "u2", hexUp );
			addLine( "u2", "u3", hexUp );
			addLine( "u3", "u1", hexUp );

			// target

			addLine( "c", "t", hexTarget );
			addLine( "p", "c", hexCross );

			// cross

			addLine( "cn1", "cn2", hexCross );
			addLine( "cn3", "cn4", hexCross );

			addLine( "cf1", "cf2", hexCross );
			addLine( "cf3", "cf4", hexCross );

			function addLine( a, b, hex ) {

				addPoint( a, hex );
				addPoint( b, hex );

			}

			function addPoint( id, hex ) {

				geometry.vertices.push( new Vector3() );
				geometry.colors.push( new Color( hex ) );

				if ( pointMap[ id ] === undefined ) {

					pointMap[ id ] = [];

				}

				pointMap[ id ].push( geometry.vertices.length - 1 );

			}

			LineSegments.call( this, geometry, material );

			this.camera = camera;
			if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;

			this.pointMap = pointMap;

			this.update();

		}

		CameraHelper.prototype = Object.create( LineSegments.prototype );
		CameraHelper.prototype.constructor = CameraHelper;

		CameraHelper.prototype.update = function () {

			var geometry, pointMap;

			var vector = new Vector3();
			var camera = new Camera();

			function setPoint( point, x, y, z ) {

				vector.set( x, y, z ).unproject( camera );

				var points = pointMap[ point ];

				if ( points !== undefined ) {

					for ( var i = 0, il = points.length; i < il; i ++ ) {

						geometry.vertices[ points[ i ] ].copy( vector );

					}

				}

			}

			return function update() {

				geometry = this.geometry;
				pointMap = this.pointMap;

				var w = 1, h = 1;

				// we need just camera projection matrix
				// world matrix must be identity

				camera.projectionMatrix.copy( this.camera.projectionMatrix );

				// center / target

				setPoint( "c", 0, 0, - 1 );
				setPoint( "t", 0, 0,  1 );

				// near

				setPoint( "n1", - w, - h, - 1 );
				setPoint( "n2",   w, - h, - 1 );
				setPoint( "n3", - w,   h, - 1 );
				setPoint( "n4",   w,   h, - 1 );

				// far

				setPoint( "f1", - w, - h, 1 );
				setPoint( "f2",   w, - h, 1 );
				setPoint( "f3", - w,   h, 1 );
				setPoint( "f4",   w,   h, 1 );

				// up

				setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
				setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
				setPoint( "u3",         0, h * 2,   - 1 );

				// cross

				setPoint( "cf1", - w,   0, 1 );
				setPoint( "cf2",   w,   0, 1 );
				setPoint( "cf3",   0, - h, 1 );
				setPoint( "cf4",   0,   h, 1 );

				setPoint( "cn1", - w,   0, - 1 );
				setPoint( "cn2",   w,   0, - 1 );
				setPoint( "cn3",   0, - h, - 1 );
				setPoint( "cn4",   0,   h, - 1 );

				geometry.verticesNeedUpdate = true;

			};

		}();

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 */

		// a helper to show the world-axis-aligned bounding box for an object

		function BoundingBoxHelper( object, hex ) {

			var color = ( hex !== undefined ) ? hex : 0x888888;

			this.object = object;

			this.box = new Box3();

			Mesh.call( this, new BoxGeometry( 1, 1, 1 ), new MeshBasicMaterial( { color: color, wireframe: true } ) );

		}

		BoundingBoxHelper.prototype = Object.create( Mesh.prototype );
		BoundingBoxHelper.prototype.constructor = BoundingBoxHelper;

		BoundingBoxHelper.prototype.update = function () {

			this.box.setFromObject( this.object );

			this.box.getSize( this.scale );

			this.box.getCenter( this.position );

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function BoxHelper( object, color ) {

			if ( color === undefined ) color = 0xffff00;

			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			var positions = new Float32Array( 8 * 3 );

			var geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

			if ( object !== undefined ) {

				this.update( object );

			}

		}

		BoxHelper.prototype = Object.create( LineSegments.prototype );
		BoxHelper.prototype.constructor = BoxHelper;

		BoxHelper.prototype.update = ( function () {

			var box = new Box3();

			return function update( object ) {

				if ( (object && object.isBox3) ) {

					box.copy( object );

				} else {

					box.setFromObject( object );

				}

				if ( box.isEmpty() ) return;

				var min = box.min;
				var max = box.max;

				/*
				  5____4
				1/___0/|
				| 6__|_7
				2/___3/

				0: max.x, max.y, max.z
				1: min.x, max.y, max.z
				2: min.x, min.y, max.z
				3: max.x, min.y, max.z
				4: max.x, max.y, min.z
				5: min.x, max.y, min.z
				6: min.x, min.y, min.z
				7: max.x, min.y, min.z
				*/

				var position = this.geometry.attributes.position;
				var array = position.array;

				array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
				array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
				array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
				array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
				array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
				array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
				array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
				array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

				position.needsUpdate = true;

				this.geometry.computeBoundingSphere();

			};

		} )();

		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author zz85 / http://github.com/zz85
		 * @author bhouston / http://clara.io
		 *
		 * Creates an arrow for visualizing directions
		 *
		 * Parameters:
		 *  dir - Vector3
		 *  origin - Vector3
		 *  length - Number
		 *  color - color in hex value
		 *  headLength - Number
		 *  headWidth - Number
		 */

		var lineGeometry = new BufferGeometry();
		lineGeometry.addAttribute( 'position', new Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

		var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
		coneGeometry.translate( 0, - 0.5, 0 );

		function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

			// dir is assumed to be normalized

			Object3D.call( this );

			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.position.copy( origin );

			this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );

			this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );

			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );

		}

		ArrowHelper.prototype = Object.create( Object3D.prototype );
		ArrowHelper.prototype.constructor = ArrowHelper;

		ArrowHelper.prototype.setDirection = ( function () {

			var axis = new Vector3();
			var radians;

			return function setDirection( dir ) {

				// dir is assumed to be normalized

				if ( dir.y > 0.99999 ) {

					this.quaternion.set( 0, 0, 0, 1 );

				} else if ( dir.y < - 0.99999 ) {

					this.quaternion.set( 1, 0, 0, 0 );

				} else {

					axis.set( dir.z, 0, - dir.x ).normalize();

					radians = Math.acos( dir.y );

					this.quaternion.setFromAxisAngle( axis, radians );

				}

			};

		}() );

		ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;

			this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
			this.line.updateMatrix();

			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();

		};

		ArrowHelper.prototype.setColor = function ( color ) {

			this.line.material.color.copy( color );
			this.cone.material.color.copy( color );

		};

		/**
		 * @author sroucheray / http://sroucheray.org/
		 * @author mrdoob / http://mrdoob.com/
		 */

		function AxisHelper( size ) {

			size = size || 1;

			var vertices = new Float32Array( [
				0, 0, 0,  size, 0, 0,
				0, 0, 0,  0, size, 0,
				0, 0, 0,  0, 0, size
			] );

			var colors = new Float32Array( [
				1, 0, 0,  1, 0.6, 0,
				0, 1, 0,  0.6, 1, 0,
				0, 0, 1,  0, 0.6, 1
			] );

			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

			var material = new LineBasicMaterial( { vertexColors: VertexColors } );

			LineSegments.call( this, geometry, material );

		}

		AxisHelper.prototype = Object.create( LineSegments.prototype );
		AxisHelper.prototype.constructor = AxisHelper;

		/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 */

		var CatmullRomCurve3 = ( function() {

			var
				tmp = new Vector3(),
				px = new CubicPoly(),
				py = new CubicPoly(),
				pz = new CubicPoly();

			/*
			Based on an optimized c++ solution in
			 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
			 - http://ideone.com/NoEbVM

			This CubicPoly class could be used for reusing some variables and calculations,
			but for three.js curve use, it could be possible inlined and flatten into a single function call
			which can be placed in CurveUtils.
			*/

			function CubicPoly() {}

			/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */
			CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

				this.c0 = x0;
				this.c1 = t0;
				this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
				this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

			};

			CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				// initCubicPoly
				this.init( x1, x2, t1, t2 );

			};

			// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
			CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

				this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			};

			CubicPoly.prototype.calc = function( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

			};

			// Subclass Three.js curve
			return Curve.create(

				function ( p /* array of Vector3 */ ) {

					this.points = p || [];
					this.closed = false;

				},

				function ( t ) {

					var points = this.points,
						point, intPoint, weight, l;

					l = points.length;

					if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

					point = ( l - ( this.closed ? 0 : 1 ) ) * t;
					intPoint = Math.floor( point );
					weight = point - intPoint;

					if ( this.closed ) {

						intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

					} else if ( weight === 0 && intPoint === l - 1 ) {

						intPoint = l - 2;
						weight = 1;

					}

					var p0, p1, p2, p3; // 4 points

					if ( this.closed || intPoint > 0 ) {

						p0 = points[ ( intPoint - 1 ) % l ];

					} else {

						// extrapolate first point
						tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
						p0 = tmp;

					}

					p1 = points[ intPoint % l ];
					p2 = points[ ( intPoint + 1 ) % l ];

					if ( this.closed || intPoint + 2 < l ) {

						p3 = points[ ( intPoint + 2 ) % l ];

					} else {

						// extrapolate last point
						tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
						p3 = tmp;

					}

					if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

						// init Centripetal / Chordal Catmull-Rom
						var pow = this.type === 'chordal' ? 0.5 : 0.25;
						var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
						var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
						var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

						// safety check for repeated points
						if ( dt1 < 1e-4 ) dt1 = 1.0;
						if ( dt0 < 1e-4 ) dt0 = dt1;
						if ( dt2 < 1e-4 ) dt2 = dt1;

						px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
						py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
						pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

					} else if ( this.type === 'catmullrom' ) {

						var tension = this.tension !== undefined ? this.tension : 0.5;
						px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
						py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
						pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

					}

					var v = new Vector3(
						px.calc( weight ),
						py.calc( weight ),
						pz.calc( weight )
					);

					return v;

				}

			);

		} )();

		/**************************************************************
		 *	Closed Spline 3D curve
		 **************************************************************/


		function ClosedSplineCurve3( points ) {

			console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
			this.closed = true;

		}

		ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

		/**************************************************************
		 *	Spline 3D curve
		 **************************************************************/


		var SplineCurve3 = Curve.create(

			function ( points /* array of Vector3 */ ) {

				console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
				this.points = ( points === undefined ) ? [] : points;

			},

			function ( t ) {

				var points = this.points;
				var point = ( points.length - 1 ) * t;

				var intPoint = Math.floor( point );
				var weight = point - intPoint;

				var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
				var point1 = points[ intPoint ];
				var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
				var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

				var interpolate = CurveUtils.interpolate;

				return new Vector3(
					interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
					interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
					interpolate( point0.z, point1.z, point2.z, point3.z, weight )
				);

			}

		);

		/**************************************************************
		 *	Cubic Bezier 3D curve
		 **************************************************************/

		var CubicBezierCurve3 = Curve.create(

			function ( v0, v1, v2, v3 ) {

				this.v0 = v0;
				this.v1 = v1;
				this.v2 = v2;
				this.v3 = v3;

			},

			function ( t ) {

				var b3 = ShapeUtils.b3;

				return new Vector3(
					b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
					b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
					b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
				);

			}

		);

		/**************************************************************
		 *	Quadratic Bezier 3D curve
		 **************************************************************/

		var QuadraticBezierCurve3 = Curve.create(

			function ( v0, v1, v2 ) {

				this.v0 = v0;
				this.v1 = v1;
				this.v2 = v2;

			},

			function ( t ) {

				var b2 = ShapeUtils.b2;

				return new Vector3(
					b2( t, this.v0.x, this.v1.x, this.v2.x ),
					b2( t, this.v0.y, this.v1.y, this.v2.y ),
					b2( t, this.v0.z, this.v1.z, this.v2.z )
				);

			}

		);

		/**************************************************************
		 *	Line3D
		 **************************************************************/

		var LineCurve3 = Curve.create(

			function ( v1, v2 ) {

				this.v1 = v1;
				this.v2 = v2;

			},

			function ( t ) {

				if ( t === 1 ) {

					return this.v2.clone();

				}

				var vector = new Vector3();

				vector.subVectors( this.v2, this.v1 ); // diff
				vector.multiplyScalar( t );
				vector.add( this.v1 );

				return vector;

			}

		);

		/**************************************************************
		 *	Arc curve
		 **************************************************************/

		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		}

		ArcCurve.prototype = Object.create( EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;

		/**
		 * @author alteredq / http://alteredqualia.com/
		 */

		var SceneUtils = {

			createMultiMaterialObject: function ( geometry, materials ) {

				var group = new Group();

				for ( var i = 0, l = materials.length; i < l; i ++ ) {

					group.add( new Mesh( geometry, materials[ i ] ) );

				}

				return group;

			},

			detach: function ( child, parent, scene ) {

				child.applyMatrix( parent.matrixWorld );
				parent.remove( child );
				scene.add( child );

			},

			attach: function ( child, scene, parent ) {

				var matrixWorldInverse = new Matrix4();
				matrixWorldInverse.getInverse( parent.matrixWorld );
				child.applyMatrix( matrixWorldInverse );

				scene.remove( child );
				parent.add( child );

			}

		};

		/**
		 * @author mrdoob / http://mrdoob.com/
		 */

		function Face4 ( a, b, c, d, normal, color, materialIndex ) {
			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new Face3( a, b, c, normal, color, materialIndex );
		}

		var LineStrip = 0;

		var LinePieces = 1;

		function PointCloud ( geometry, material ) {
			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new Points( geometry, material );
		}

		function ParticleSystem ( geometry, material ) {
			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new Points( geometry, material );
		}

		function PointCloudMaterial ( parameters ) {
			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}

		function ParticleBasicMaterial ( parameters ) {
			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}

		function ParticleSystemMaterial ( parameters ) {
			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
		}

		function Vertex ( x, y, z ) {
			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new Vector3( x, y, z );
		}

		//

		function EdgesHelper( object, hex ) {
			console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
			return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
		}

		function WireframeHelper( object, hex ) {
			console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
			return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
		}

		//

		Object.assign( Box2.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			},
			empty: function () {
				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			},
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			size: function ( optionalTarget ) {
				console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
			}
		} );

		Object.assign( Box3.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			},
			empty: function () {
				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
			},
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			isIntersectionSphere: function ( sphere ) {
				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			},
			size: function ( optionalTarget ) {
				console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
			}
		} );

		Object.assign( Line3.prototype, {
			center: function ( optionalTarget ) {
				console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
			}
		} );

		Object.assign( Matrix3.prototype, {
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );
			},
			multiplyVector3Array: function ( a ) {
				console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			}
		} );

		Object.assign( Matrix4.prototype, {
			extractPosition: function ( m ) {
				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );
			},
			setRotationFromQuaternion: function ( q ) {
				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );
			},
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
				return vector.applyProjection( this );
			},
			multiplyVector4: function ( vector ) {
				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			},
			multiplyVector3Array: function ( a ) {
				console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
			},
			rotateAxis: function ( v ) {
				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );
			},
			crossVector: function ( vector ) {
				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
			},
			translate: function ( v ) {
				console.error( 'THREE.Matrix4: .translate() has been removed.' );
			},
			rotateX: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
			},
			rotateY: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
			},
			rotateZ: function ( angle ) {
				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
			},
			rotateByAxis: function ( axis, angle ) {
				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
			}
		} );

		Object.assign( Plane.prototype, {
			isIntersectionLine: function ( line ) {
				console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
				return this.intersectsLine( line );
			}
		} );

		Object.assign( Quaternion.prototype, {
			multiplyVector3: function ( vector ) {
				console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
				return vector.applyQuaternion( this );
			}
		} );

		Object.assign( Ray.prototype, {
			isIntersectionBox: function ( box ) {
				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
			},
			isIntersectionPlane: function ( plane ) {
				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );
			},
			isIntersectionSphere: function ( sphere ) {
				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
			}
		} );

		Object.assign( Shape.prototype, {
			extrude: function ( options ) {
				console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
				return new ExtrudeGeometry( this, options );
			},
			makeGeometry: function ( options ) {
				console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
				return new ShapeGeometry( this, options );
			}
		} );

		Object.assign( Vector3.prototype, {
			setEulerFromRotationMatrix: function () {
				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
			},
			setEulerFromQuaternion: function () {
				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
			},
			getPositionFromMatrix: function ( m ) {
				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );
			},
			getScaleFromMatrix: function ( m ) {
				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );
			},
			getColumnFromMatrix: function ( index, matrix ) {
				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( matrix, index );
			}
		} );

		//

		Object.assign( Object3D.prototype, {
			getChildByName: function ( name ) {
				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );
			},
			renderDepth: function ( value ) {
				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
			},
			translate: function ( distance, axis ) {
				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );
			}
		} );

		Object.defineProperties( Object3D.prototype, {
			eulerOrder: {
				get: function () {
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					return this.rotation.order;
				},
				set: function ( value ) {
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					this.rotation.order = value;
				}
			},
			useQuaternion: {
				get: function () {
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
				},
				set: function ( value ) {
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
				}
			}
		} );

		Object.defineProperties( LOD.prototype, {
			objects: {
				get: function () {
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
				}
			}
		} );

		//

		PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

			console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
					"Use .setFocalLength and .filmGauge for a photographic setup." );

			if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
			this.setFocalLength( focalLength );

		};

		//

		Object.defineProperties( Light.prototype, {
			onlyShadow: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .onlyShadow has been removed.' );
				}
			},
			shadowCameraFov: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
					this.shadow.camera.fov = value;
				}
			},
			shadowCameraLeft: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
					this.shadow.camera.left = value;
				}
			},
			shadowCameraRight: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
					this.shadow.camera.right = value;
				}
			},
			shadowCameraTop: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
					this.shadow.camera.top = value;
				}
			},
			shadowCameraBottom: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
					this.shadow.camera.bottom = value;
				}
			},
			shadowCameraNear: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
					this.shadow.camera.near = value;
				}
			},
			shadowCameraFar: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
					this.shadow.camera.far = value;
				}
			},
			shadowCameraVisible: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
				}
			},
			shadowBias: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
					this.shadow.bias = value;
				}
			},
			shadowDarkness: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
				}
			},
			shadowMapWidth: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
					this.shadow.mapSize.width = value;
				}
			},
			shadowMapHeight: {
				set: function ( value ) {
					console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
					this.shadow.mapSize.height = value;
				}
			}
		} );

		//

		Object.defineProperties( BufferAttribute.prototype, {
			length: {
				get: function () {
					console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
					return this.array.length;
				}
			}
		} );

		Object.assign( BufferGeometry.prototype, {
			addIndex: function ( index ) {
				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );
			},
			addDrawCall: function ( start, count, indexOffset ) {
				if ( indexOffset !== undefined ) {
					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );
			},
			clearDrawCalls: function () {
				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();
			},
			computeTangents: function () {
				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
			},
			computeOffsets: function () {
				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
			}
		} );

		Object.defineProperties( BufferGeometry.prototype, {
			drawcalls: {
				get: function () {
					console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
					return this.groups;
				}
			},
			offsets: {
				get: function () {
					console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
					return this.groups;
				}
			}
		} );

		//

		Object.defineProperties( Material.prototype, {
			wrapAround: {
				get: function () {
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
				},
				set: function ( value ) {
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
				}
			},
			wrapRGB: {
				get: function () {
					console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
					return new Color();
				}
			}
		} );

		Object.defineProperties( MeshPhongMaterial.prototype, {
			metal: {
				get: function () {
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
					return false;
				},
				set: function ( value ) {
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
				}
			}
		} );

		Object.defineProperties( ShaderMaterial.prototype, {
			derivatives: {
				get: function () {
					console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					return this.extensions.derivatives;
				},
				set: function ( value ) {
					console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					this.extensions.derivatives = value;
				}
			}
		} );

		//

		EventDispatcher.prototype = Object.assign( Object.create( {

			// Note: Extra base ensures these properties are not 'assign'ed.

			constructor: EventDispatcher,

			apply: function ( target ) {

				console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
						"just inherit or Object.assign the prototype to mix-in." );

				Object.assign( target, this );

			}

		} ), EventDispatcher.prototype );

		//

		Object.defineProperties( Uniform.prototype, {
			dynamic: {
				set: function ( value ) {
					console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
				}
			},
			onUpdate: {
				value: function () {
					console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
					return this;
				}
			}
		} );

		//

		Object.assign( WebGLRenderer.prototype, {
			supportsFloatTextures: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );
			},
			supportsHalfFloatTextures: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );
			},
			supportsStandardDerivatives: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );
			},
			supportsCompressedTextureS3TC: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
			},
			supportsCompressedTexturePVRTC: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
			},
			supportsBlendMinMax: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );
			},
			supportsVertexTextures: function () {
				return this.capabilities.vertexTextures;
			},
			supportsInstancedArrays: function () {
				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );
			},
			enableScissorTest: function ( boolean ) {
				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );
			},
			initMaterial: function () {
				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
			},
			addPrePlugin: function () {
				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
			},
			addPostPlugin: function () {
				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
			},
			updateShadowMap: function () {
				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
			}
		} );

		Object.defineProperties( WebGLRenderer.prototype, {
			shadowMapEnabled: {
				get: function () {
					return this.shadowMap.enabled;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					this.shadowMap.enabled = value;
				}
			},
			shadowMapType: {
				get: function () {
					return this.shadowMap.type;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					this.shadowMap.type = value;
				}
			},
			shadowMapCullFace: {
				get: function () {
					return this.shadowMap.cullFace;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					this.shadowMap.cullFace = value;
				}
			}
		} );

		Object.defineProperties( WebGLShadowMap.prototype, {
			cullFace: {
				get: function () {
					return this.renderReverseSided ? CullFaceFront : CullFaceBack;
				},
				set: function ( cullFace ) {
					var value = ( cullFace !== CullFaceBack );
					console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
					this.renderReverseSided = value;
				}
			}
		} );

		//

		Object.defineProperties( WebGLRenderTarget.prototype, {
			wrapS: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					return this.texture.wrapS;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					this.texture.wrapS = value;
				}
			},
			wrapT: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					return this.texture.wrapT;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					this.texture.wrapT = value;
				}
			},
			magFilter: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					return this.texture.magFilter;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					this.texture.magFilter = value;
				}
			},
			minFilter: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					return this.texture.minFilter;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					this.texture.minFilter = value;
				}
			},
			anisotropy: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					return this.texture.anisotropy;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					this.texture.anisotropy = value;
				}
			},
			offset: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					return this.texture.offset;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					this.texture.offset = value;
				}
			},
			repeat: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					return this.texture.repeat;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					this.texture.repeat = value;
				}
			},
			format: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					return this.texture.format;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					this.texture.format = value;
				}
			},
			type: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					return this.texture.type;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					this.texture.type = value;
				}
			},
			generateMipmaps: {
				get: function () {
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					return this.texture.generateMipmaps;
				},
				set: function ( value ) {
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					this.texture.generateMipmaps = value;
				}
			}
		} );

		//

		Object.assign( Audio.prototype, {
			load: function ( file ) {
				console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
				var scope = this;
				var audioLoader = new AudioLoader();
				audioLoader.load( file, function ( buffer ) {
					scope.setBuffer( buffer );
				} );
				return this;
			}
		} );

		Object.assign( AudioAnalyser.prototype, {
			getData: function ( file ) {
				console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
				return this.getFrequencyData();
			}
		} );

		//

		var GeometryUtils = {

			merge: function ( geometry1, geometry2, materialIndexOffset ) {

				console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

				var matrix;

				if ( geometry2.isMesh ) {

					geometry2.matrixAutoUpdate && geometry2.updateMatrix();

					matrix = geometry2.matrix;
					geometry2 = geometry2.geometry;

				}

				geometry1.merge( geometry2, matrix, materialIndexOffset );

			},

			center: function ( geometry ) {

				console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
				return geometry.center();

			}

		};

		var ImageUtils = {

			crossOrigin: undefined,

			loadTexture: function ( url, mapping, onLoad, onError ) {

				console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

				var loader = new TextureLoader();
				loader.setCrossOrigin( this.crossOrigin );

				var texture = loader.load( url, onLoad, undefined, onError );

				if ( mapping ) texture.mapping = mapping;

				return texture;

			},

			loadTextureCube: function ( urls, mapping, onLoad, onError ) {

				console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

				var loader = new CubeTextureLoader();
				loader.setCrossOrigin( this.crossOrigin );

				var texture = loader.load( urls, onLoad, undefined, onError );

				if ( mapping ) texture.mapping = mapping;

				return texture;

			},

			loadCompressedTexture: function () {

				console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

			},

			loadCompressedTextureCube: function () {

				console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

			}

		};

		//

		function Projector () {

			console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

			this.projectVector = function ( vector, camera ) {

				console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
				vector.project( camera );

			};

			this.unprojectVector = function ( vector, camera ) {

				console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
				vector.unproject( camera );

			};

			this.pickingRay = function ( vector, camera ) {

				console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

			};

		}

		//

		function CanvasRenderer () {

			console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

			this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			this.clear = function () {};
			this.render = function () {};
			this.setClearColor = function () {};
			this.setSize = function () {};

		}

		exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
		exports.WebGLRenderTarget = WebGLRenderTarget;
		exports.WebGLRenderer = WebGLRenderer;
		exports.ShaderLib = ShaderLib;
		exports.UniformsLib = UniformsLib;
		exports.UniformsUtils = UniformsUtils;
		exports.ShaderChunk = ShaderChunk;
		exports.FogExp2 = FogExp2;
		exports.Fog = Fog;
		exports.Scene = Scene;
		exports.LensFlare = LensFlare;
		exports.Sprite = Sprite;
		exports.LOD = LOD;
		exports.SkinnedMesh = SkinnedMesh;
		exports.Skeleton = Skeleton;
		exports.Bone = Bone;
		exports.Mesh = Mesh;
		exports.LineSegments = LineSegments;
		exports.Line = Line;
		exports.Points = Points;
		exports.Group = Group;
		exports.VideoTexture = VideoTexture;
		exports.DataTexture = DataTexture;
		exports.CompressedTexture = CompressedTexture;
		exports.CubeTexture = CubeTexture;
		exports.CanvasTexture = CanvasTexture;
		exports.DepthTexture = DepthTexture;
		exports.TextureIdCount = TextureIdCount;
		exports.Texture = Texture;
		exports.MaterialIdCount = MaterialIdCount;
		exports.CompressedTextureLoader = CompressedTextureLoader;
		exports.BinaryTextureLoader = BinaryTextureLoader;
		exports.DataTextureLoader = DataTextureLoader;
		exports.CubeTextureLoader = CubeTextureLoader;
		exports.TextureLoader = TextureLoader;
		exports.ObjectLoader = ObjectLoader;
		exports.MaterialLoader = MaterialLoader;
		exports.BufferGeometryLoader = BufferGeometryLoader;
		exports.DefaultLoadingManager = DefaultLoadingManager;
		exports.LoadingManager = LoadingManager;
		exports.JSONLoader = JSONLoader;
		exports.ImageLoader = ImageLoader;
		exports.FontLoader = FontLoader;
		exports.XHRLoader = XHRLoader;
		exports.Loader = Loader;
		exports.Cache = Cache;
		exports.AudioLoader = AudioLoader;
		exports.SpotLightShadow = SpotLightShadow;
		exports.SpotLight = SpotLight;
		exports.PointLight = PointLight;
		exports.HemisphereLight = HemisphereLight;
		exports.DirectionalLightShadow = DirectionalLightShadow;
		exports.DirectionalLight = DirectionalLight;
		exports.AmbientLight = AmbientLight;
		exports.LightShadow = LightShadow;
		exports.Light = Light;
		exports.StereoCamera = StereoCamera;
		exports.PerspectiveCamera = PerspectiveCamera;
		exports.OrthographicCamera = OrthographicCamera;
		exports.CubeCamera = CubeCamera;
		exports.Camera = Camera;
		exports.AudioListener = AudioListener;
		exports.PositionalAudio = PositionalAudio;
		exports.getAudioContext = getAudioContext;
		exports.AudioAnalyser = AudioAnalyser;
		exports.Audio = Audio;
		exports.VectorKeyframeTrack = VectorKeyframeTrack;
		exports.StringKeyframeTrack = StringKeyframeTrack;
		exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
		exports.NumberKeyframeTrack = NumberKeyframeTrack;
		exports.ColorKeyframeTrack = ColorKeyframeTrack;
		exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
		exports.PropertyMixer = PropertyMixer;
		exports.PropertyBinding = PropertyBinding;
		exports.KeyframeTrack = KeyframeTrack;
		exports.AnimationUtils = AnimationUtils;
		exports.AnimationObjectGroup = AnimationObjectGroup;
		exports.AnimationMixer = AnimationMixer;
		exports.AnimationClip = AnimationClip;
		exports.Uniform = Uniform;
		exports.InstancedBufferGeometry = InstancedBufferGeometry;
		exports.BufferGeometry = BufferGeometry;
		exports.GeometryIdCount = GeometryIdCount;
		exports.Geometry = Geometry;
		exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
		exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
		exports.InterleavedBuffer = InterleavedBuffer;
		exports.InstancedBufferAttribute = InstancedBufferAttribute;
		exports.DynamicBufferAttribute = DynamicBufferAttribute;
		exports.Float64Attribute = Float64Attribute;
		exports.Float32Attribute = Float32Attribute;
		exports.Uint32Attribute = Uint32Attribute;
		exports.Int32Attribute = Int32Attribute;
		exports.Uint16Attribute = Uint16Attribute;
		exports.Int16Attribute = Int16Attribute;
		exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
		exports.Uint8Attribute = Uint8Attribute;
		exports.Int8Attribute = Int8Attribute;
		exports.BufferAttribute = BufferAttribute;
		exports.Face3 = Face3;
		exports.Object3DIdCount = Object3DIdCount;
		exports.Object3D = Object3D;
		exports.Raycaster = Raycaster;
		exports.Layers = Layers;
		exports.EventDispatcher = EventDispatcher;
		exports.Clock = Clock;
		exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
		exports.LinearInterpolant = LinearInterpolant;
		exports.DiscreteInterpolant = DiscreteInterpolant;
		exports.CubicInterpolant = CubicInterpolant;
		exports.Interpolant = Interpolant;
		exports.Triangle = Triangle;
		exports.Spline = Spline;
		exports.Math = _Math;
		exports.Spherical = Spherical;
		exports.Plane = Plane;
		exports.Frustum = Frustum;
		exports.Sphere = Sphere;
		exports.Ray = Ray;
		exports.Matrix4 = Matrix4;
		exports.Matrix3 = Matrix3;
		exports.Box3 = Box3;
		exports.Box2 = Box2;
		exports.Line3 = Line3;
		exports.Euler = Euler;
		exports.Vector4 = Vector4;
		exports.Vector3 = Vector3;
		exports.Vector2 = Vector2;
		exports.Quaternion = Quaternion;
		exports.ColorKeywords = ColorKeywords;
		exports.Color = Color;
		exports.MorphBlendMesh = MorphBlendMesh;
		exports.ImmediateRenderObject = ImmediateRenderObject;
		exports.VertexNormalsHelper = VertexNormalsHelper;
		exports.SpotLightHelper = SpotLightHelper;
		exports.SkeletonHelper = SkeletonHelper;
		exports.PointLightHelper = PointLightHelper;
		exports.HemisphereLightHelper = HemisphereLightHelper;
		exports.GridHelper = GridHelper;
		exports.FaceNormalsHelper = FaceNormalsHelper;
		exports.DirectionalLightHelper = DirectionalLightHelper;
		exports.CameraHelper = CameraHelper;
		exports.BoundingBoxHelper = BoundingBoxHelper;
		exports.BoxHelper = BoxHelper;
		exports.ArrowHelper = ArrowHelper;
		exports.AxisHelper = AxisHelper;
		exports.ClosedSplineCurve3 = ClosedSplineCurve3;
		exports.CatmullRomCurve3 = CatmullRomCurve3;
		exports.SplineCurve3 = SplineCurve3;
		exports.CubicBezierCurve3 = CubicBezierCurve3;
		exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
		exports.LineCurve3 = LineCurve3;
		exports.ArcCurve = ArcCurve;
		exports.EllipseCurve = EllipseCurve;
		exports.SplineCurve = SplineCurve;
		exports.CubicBezierCurve = CubicBezierCurve;
		exports.QuadraticBezierCurve = QuadraticBezierCurve;
		exports.LineCurve = LineCurve;
		exports.Shape = Shape;
		exports.ShapePath = ShapePath;
		exports.Path = Path;
		exports.Font = Font;
		exports.CurvePath = CurvePath;
		exports.Curve = Curve;
		exports.ShapeUtils = ShapeUtils;
		exports.SceneUtils = SceneUtils;
		exports.CurveUtils = CurveUtils;
		exports.WireframeGeometry = WireframeGeometry;
		exports.ParametricGeometry = ParametricGeometry;
		exports.ParametricBufferGeometry = ParametricBufferGeometry;
		exports.TetrahedronGeometry = TetrahedronGeometry;
		exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
		exports.OctahedronGeometry = OctahedronGeometry;
		exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
		exports.IcosahedronGeometry = IcosahedronGeometry;
		exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
		exports.DodecahedronGeometry = DodecahedronGeometry;
		exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
		exports.PolyhedronGeometry = PolyhedronGeometry;
		exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
		exports.TubeGeometry = TubeGeometry;
		exports.TubeBufferGeometry = TubeBufferGeometry;
		exports.TorusKnotGeometry = TorusKnotGeometry;
		exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
		exports.TorusGeometry = TorusGeometry;
		exports.TorusBufferGeometry = TorusBufferGeometry;
		exports.TextGeometry = TextGeometry;
		exports.SphereBufferGeometry = SphereBufferGeometry;
		exports.SphereGeometry = SphereGeometry;
		exports.RingGeometry = RingGeometry;
		exports.RingBufferGeometry = RingBufferGeometry;
		exports.PlaneBufferGeometry = PlaneBufferGeometry;
		exports.PlaneGeometry = PlaneGeometry;
		exports.LatheGeometry = LatheGeometry;
		exports.LatheBufferGeometry = LatheBufferGeometry;
		exports.ShapeGeometry = ShapeGeometry;
		exports.ExtrudeGeometry = ExtrudeGeometry;
		exports.EdgesGeometry = EdgesGeometry;
		exports.ConeGeometry = ConeGeometry;
		exports.ConeBufferGeometry = ConeBufferGeometry;
		exports.CylinderGeometry = CylinderGeometry;
		exports.CylinderBufferGeometry = CylinderBufferGeometry;
		exports.CircleBufferGeometry = CircleBufferGeometry;
		exports.CircleGeometry = CircleGeometry;
		exports.BoxBufferGeometry = BoxBufferGeometry;
		exports.BoxGeometry = BoxGeometry;
		exports.ShadowMaterial = ShadowMaterial;
		exports.SpriteMaterial = SpriteMaterial;
		exports.RawShaderMaterial = RawShaderMaterial;
		exports.ShaderMaterial = ShaderMaterial;
		exports.PointsMaterial = PointsMaterial;
		exports.MultiMaterial = MultiMaterial;
		exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
		exports.MeshStandardMaterial = MeshStandardMaterial;
		exports.MeshPhongMaterial = MeshPhongMaterial;
		exports.MeshNormalMaterial = MeshNormalMaterial;
		exports.MeshLambertMaterial = MeshLambertMaterial;
		exports.MeshDepthMaterial = MeshDepthMaterial;
		exports.MeshBasicMaterial = MeshBasicMaterial;
		exports.LineDashedMaterial = LineDashedMaterial;
		exports.LineBasicMaterial = LineBasicMaterial;
		exports.Material = Material;
		exports.REVISION = REVISION;
		exports.MOUSE = MOUSE;
		exports.CullFaceNone = CullFaceNone;
		exports.CullFaceBack = CullFaceBack;
		exports.CullFaceFront = CullFaceFront;
		exports.CullFaceFrontBack = CullFaceFrontBack;
		exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
		exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
		exports.BasicShadowMap = BasicShadowMap;
		exports.PCFShadowMap = PCFShadowMap;
		exports.PCFSoftShadowMap = PCFSoftShadowMap;
		exports.FrontSide = FrontSide;
		exports.BackSide = BackSide;
		exports.DoubleSide = DoubleSide;
		exports.FlatShading = FlatShading;
		exports.SmoothShading = SmoothShading;
		exports.NoColors = NoColors;
		exports.FaceColors = FaceColors;
		exports.VertexColors = VertexColors;
		exports.NoBlending = NoBlending;
		exports.NormalBlending = NormalBlending;
		exports.AdditiveBlending = AdditiveBlending;
		exports.SubtractiveBlending = SubtractiveBlending;
		exports.MultiplyBlending = MultiplyBlending;
		exports.CustomBlending = CustomBlending;
		exports.BlendingMode = BlendingMode;
		exports.AddEquation = AddEquation;
		exports.SubtractEquation = SubtractEquation;
		exports.ReverseSubtractEquation = ReverseSubtractEquation;
		exports.MinEquation = MinEquation;
		exports.MaxEquation = MaxEquation;
		exports.ZeroFactor = ZeroFactor;
		exports.OneFactor = OneFactor;
		exports.SrcColorFactor = SrcColorFactor;
		exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
		exports.SrcAlphaFactor = SrcAlphaFactor;
		exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
		exports.DstAlphaFactor = DstAlphaFactor;
		exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
		exports.DstColorFactor = DstColorFactor;
		exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
		exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
		exports.NeverDepth = NeverDepth;
		exports.AlwaysDepth = AlwaysDepth;
		exports.LessDepth = LessDepth;
		exports.LessEqualDepth = LessEqualDepth;
		exports.EqualDepth = EqualDepth;
		exports.GreaterEqualDepth = GreaterEqualDepth;
		exports.GreaterDepth = GreaterDepth;
		exports.NotEqualDepth = NotEqualDepth;
		exports.MultiplyOperation = MultiplyOperation;
		exports.MixOperation = MixOperation;
		exports.AddOperation = AddOperation;
		exports.NoToneMapping = NoToneMapping;
		exports.LinearToneMapping = LinearToneMapping;
		exports.ReinhardToneMapping = ReinhardToneMapping;
		exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
		exports.CineonToneMapping = CineonToneMapping;
		exports.UVMapping = UVMapping;
		exports.CubeReflectionMapping = CubeReflectionMapping;
		exports.CubeRefractionMapping = CubeRefractionMapping;
		exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
		exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
		exports.SphericalReflectionMapping = SphericalReflectionMapping;
		exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
		exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
		exports.TextureMapping = TextureMapping;
		exports.RepeatWrapping = RepeatWrapping;
		exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
		exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
		exports.TextureWrapping = TextureWrapping;
		exports.NearestFilter = NearestFilter;
		exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
		exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
		exports.LinearFilter = LinearFilter;
		exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
		exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
		exports.TextureFilter = TextureFilter;
		exports.UnsignedByteType = UnsignedByteType;
		exports.ByteType = ByteType;
		exports.ShortType = ShortType;
		exports.UnsignedShortType = UnsignedShortType;
		exports.IntType = IntType;
		exports.UnsignedIntType = UnsignedIntType;
		exports.FloatType = FloatType;
		exports.HalfFloatType = HalfFloatType;
		exports.UnsignedShort4444Type = UnsignedShort4444Type;
		exports.UnsignedShort5551Type = UnsignedShort5551Type;
		exports.UnsignedShort565Type = UnsignedShort565Type;
		exports.UnsignedInt248Type = UnsignedInt248Type;
		exports.AlphaFormat = AlphaFormat;
		exports.RGBFormat = RGBFormat;
		exports.RGBAFormat = RGBAFormat;
		exports.LuminanceFormat = LuminanceFormat;
		exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
		exports.RGBEFormat = RGBEFormat;
		exports.DepthFormat = DepthFormat;
		exports.DepthStencilFormat = DepthStencilFormat;
		exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
		exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
		exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
		exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
		exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
		exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
		exports.RGB_ETC1_Format = RGB_ETC1_Format;
		exports.LoopOnce = LoopOnce;
		exports.LoopRepeat = LoopRepeat;
		exports.LoopPingPong = LoopPingPong;
		exports.InterpolateDiscrete = InterpolateDiscrete;
		exports.InterpolateLinear = InterpolateLinear;
		exports.InterpolateSmooth = InterpolateSmooth;
		exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
		exports.ZeroSlopeEnding = ZeroSlopeEnding;
		exports.WrapAroundEnding = WrapAroundEnding;
		exports.TrianglesDrawMode = TrianglesDrawMode;
		exports.TriangleStripDrawMode = TriangleStripDrawMode;
		exports.TriangleFanDrawMode = TriangleFanDrawMode;
		exports.LinearEncoding = LinearEncoding;
		exports.sRGBEncoding = sRGBEncoding;
		exports.GammaEncoding = GammaEncoding;
		exports.RGBEEncoding = RGBEEncoding;
		exports.LogLuvEncoding = LogLuvEncoding;
		exports.RGBM7Encoding = RGBM7Encoding;
		exports.RGBM16Encoding = RGBM16Encoding;
		exports.RGBDEncoding = RGBDEncoding;
		exports.BasicDepthPacking = BasicDepthPacking;
		exports.RGBADepthPacking = RGBADepthPacking;
		exports.CubeGeometry = BoxGeometry;
		exports.Face4 = Face4;
		exports.LineStrip = LineStrip;
		exports.LinePieces = LinePieces;
		exports.MeshFaceMaterial = MultiMaterial;
		exports.PointCloud = PointCloud;
		exports.Particle = Sprite;
		exports.ParticleSystem = ParticleSystem;
		exports.PointCloudMaterial = PointCloudMaterial;
		exports.ParticleBasicMaterial = ParticleBasicMaterial;
		exports.ParticleSystemMaterial = ParticleSystemMaterial;
		exports.Vertex = Vertex;
		exports.EdgesHelper = EdgesHelper;
		exports.WireframeHelper = WireframeHelper;
		exports.GeometryUtils = GeometryUtils;
		exports.ImageUtils = ImageUtils;
		exports.Projector = Projector;
		exports.CanvasRenderer = CanvasRenderer;

		Object.defineProperty(exports, '__esModule', { value: true });

		Object.defineProperty( exports, 'AudioContext', {
			get: function () {
				return exports.getAudioContext();
			}
		});

	})));


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./Animator.js": 6,
		"./Browser.js": 11,
		"./Camera.js": 12,
		"./Compositions.js": 13,
		"./Debugger.js": 21,
		"./Light.js": 23,
		"./Loader.js": 24,
		"./Loaders/Animation.js": 25,
		"./Loaders/Material.js": 27,
		"./Loaders/Model.js": 35,
		"./Loaders/Objects.js": 36,
		"./Manager.js": 79,
		"./Mouse.js": 80,
		"./Renderer.js": 81,
		"./Scene.js": 82,
		"./Tween.js": 17
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 5;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Promise = __webpack_require__(7);
	/**
	 * Animator Class
	 */
	var Animator = (function () {
	    function Animator() {
	    }
	    /**
	     * Constructor, needs to be called first
	     *
	     * @param character
	     * @returns {Animator}
	     */
	    Animator.from = function (character) {
	        if (character instanceof THREE.Object3D == false)
	            throw "You must to provide an object 3D";
	        this.model = character;
	        return this;
	    };
	    /**
	     * Play An animation
	     *
	     * @param anim
	     * @returns {Animator}
	     */
	    Animator.play = function (name) {
	        this.currentAnim = this.getAnimation(name).play();
	        return this;
	    };
	    Animator.prototype.animate = function (properties, target) {
	        return new Promise(function (accept, reject) {
	            accept();
	        });
	    };
	    /**
	     * Get Animation
	     *
	     * @param name
	     * @returns {any}
	     */
	    Animator.getAnimation = function (name) {
	        if (this.model.userData.animations.hasOwnProperty(name))
	            return this.model.userData.animations[name];
	        throw this.model.name + ", doesnt have an animation called: " + name + " \u00AF\\_(\u30C4)_/\u00AF";
	    };
	    /**
	     * CrossFade Animations
	     *
	     * @param anim
	     * @param duration
	     * @param warp
	     * @returns {Animator}
	     */
	    Animator.crossFadeTo = function (anim, duration, warp) {
	        if (duration === void 0) { duration = .3; }
	        this.currentAnim.crossFadeTo(this.getAnimation(anim).play(), duration, warp);
	        return this;
	    };
	    Animator.prototype.boot = function () { };
	    /**
	     * Update Animations
	     * @param time
	     * @param delta
	     */
	    Animator.prototype.update = function (time, delta) { };
	    return Animator;
	}());
	exports.Animator = Animator;
	//# sourceMappingURL=Animator.js.map

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2015 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 3.4.6
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}

	Promise.any = function (promises) {
	    return any(promises);
	};

	Promise.prototype.any = function () {
	    return any(this);
	};

	};

	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule");
	var Queue = _dereq_("./queue");
	var util = _dereq_("./util");

	function Async() {
	    this._customScheduler = false;
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._haveDrainedQueues = false;
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule = schedule;
	}

	Async.prototype.setScheduler = function(fn) {
	    var prev = this._schedule;
	    this._schedule = fn;
	    this._customScheduler = true;
	    return prev;
	};

	Async.prototype.hasCustomScheduler = function() {
	    return this._customScheduler;
	};

	Async.prototype.enableTrampoline = function() {
	    this._trampolineEnabled = true;
	};

	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};

	Async.prototype.haveItemsQueued = function () {
	    return this._isTickUsed || this._haveDrainedQueues;
	};


	Async.prototype.fatalError = function(e, isNode) {
	    if (isNode) {
	        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
	            "\n");
	        process.exit(2);
	    } else {
	        this.throwLater(e);
	    }
	};

	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	};

	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}

	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };

	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };

	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}

	Async.prototype.invokeFirst = function (fn, receiver, arg) {
	    this._normalQueue.unshift(fn, receiver, arg);
	    this._queueTick();
	};

	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};

	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._haveDrainedQueues = true;
	    this._drainQueue(this._lateQueue);
	};

	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};

	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};

	module.exports = Async;
	module.exports.firstLineError = firstLineError;

	},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
	var calledBind = false;
	var rejectThis = function(_, e) {
	    this._reject(e);
	};

	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};

	var bindingResolved = function(thisArg, context) {
	    if (((this._bitField & 50397184) === 0)) {
	        this._resolveCallback(context.target);
	    }
	};

	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};

	Promise.prototype.bind = function (thisArg) {
	    if (!calledBind) {
	        calledBind = true;
	        Promise.prototype._propagateFrom = debug.propagateFromFunction();
	        Promise.prototype._boundValue = debug.boundValueFunction();
	    }
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, undefined, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, undefined, ret, context);
	        ret._setOnCancel(maybePromise);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};

	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 2097152;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~2097152);
	    }
	};

	Promise.prototype._isBound = function () {
	    return (this._bitField & 2097152) === 2097152;
	};

	Promise.bind = function (thisArg, value) {
	    return Promise.resolve(value).bind(thisArg);
	};
	};

	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;

	},{"./promise":22}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}

	module.exports = function(Promise) {
	var util = _dereq_("./util");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;

	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};

	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};

	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};

	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};

	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}

	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}

	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var args = [].slice.call(arguments, 1);;
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};

	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};

	},{"./util":36}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, debug) {
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;

	Promise.prototype["break"] = Promise.prototype.cancel = function() {
	    if (!debug.cancellation()) return this._warn("cancellation is disabled");

	    var promise = this;
	    var child = promise;
	    while (promise._isCancellable()) {
	        if (!promise._cancelBy(child)) {
	            if (child._isFollowing()) {
	                child._followee().cancel();
	            } else {
	                child._cancelBranched();
	            }
	            break;
	        }

	        var parent = promise._cancellationParent;
	        if (parent == null || !parent._isCancellable()) {
	            if (promise._isFollowing()) {
	                promise._followee().cancel();
	            } else {
	                promise._cancelBranched();
	            }
	            break;
	        } else {
	            if (promise._isFollowing()) promise._followee().cancel();
	            promise._setWillBeCancelled();
	            child = promise;
	            promise = parent;
	        }
	    }
	};

	Promise.prototype._branchHasCancelled = function() {
	    this._branchesRemainingToCancel--;
	};

	Promise.prototype._enoughBranchesHaveCancelled = function() {
	    return this._branchesRemainingToCancel === undefined ||
	           this._branchesRemainingToCancel <= 0;
	};

	Promise.prototype._cancelBy = function(canceller) {
	    if (canceller === this) {
	        this._branchesRemainingToCancel = 0;
	        this._invokeOnCancel();
	        return true;
	    } else {
	        this._branchHasCancelled();
	        if (this._enoughBranchesHaveCancelled()) {
	            this._invokeOnCancel();
	            return true;
	        }
	    }
	    return false;
	};

	Promise.prototype._cancelBranched = function() {
	    if (this._enoughBranchesHaveCancelled()) {
	        this._cancel();
	    }
	};

	Promise.prototype._cancel = function() {
	    if (!this._isCancellable()) return;
	    this._setCancelled();
	    async.invoke(this._cancelPromises, this, undefined);
	};

	Promise.prototype._cancelPromises = function() {
	    if (this._length() > 0) this._settlePromises();
	};

	Promise.prototype._unsetOnCancel = function() {
	    this._onCancelField = undefined;
	};

	Promise.prototype._isCancellable = function() {
	    return this.isPending() && !this._isCancelled();
	};

	Promise.prototype.isCancellable = function() {
	    return this.isPending() && !this.isCancelled();
	};

	Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
	    if (util.isArray(onCancelCallback)) {
	        for (var i = 0; i < onCancelCallback.length; ++i) {
	            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
	        }
	    } else if (onCancelCallback !== undefined) {
	        if (typeof onCancelCallback === "function") {
	            if (!internalOnly) {
	                var e = tryCatch(onCancelCallback).call(this._boundValue());
	                if (e === errorObj) {
	                    this._attachExtraTrace(e.e);
	                    async.throwLater(e.e);
	                }
	            }
	        } else {
	            onCancelCallback._resultCancelled(this);
	        }
	    }
	};

	Promise.prototype._invokeOnCancel = function() {
	    var onCancelCallback = this._onCancel();
	    this._unsetOnCancel();
	    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
	};

	Promise.prototype._invokeInternalOnCancel = function() {
	    if (this._isCancellable()) {
	        this._doInvokeOnCancel(this._onCancel(), true);
	        this._unsetOnCancel();
	    }
	};

	Promise.prototype._resultCancelled = function() {
	    this.cancel();
	};

	};

	},{"./util":36}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util");
	var getKeys = _dereq_("./es5").keys;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function catchFilter(instances, cb, promise) {
	    return function(e) {
	        var boundTo = promise._boundValue();
	        predicateLoop: for (var i = 0; i < instances.length; ++i) {
	            var item = instances[i];

	            if (item === Error ||
	                (item != null && item.prototype instanceof Error)) {
	                if (e instanceof item) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (typeof item === "function") {
	                var matchesPredicate = tryCatch(item).call(boundTo, e);
	                if (matchesPredicate === errorObj) {
	                    return matchesPredicate;
	                } else if (matchesPredicate) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (util.isObject(e)) {
	                var keys = getKeys(item);
	                for (var j = 0; j < keys.length; ++j) {
	                    var key = keys[j];
	                    if (item[key] != e[key]) {
	                        continue predicateLoop;
	                    }
	                }
	                return tryCatch(cb).call(boundTo, e);
	            }
	        }
	        return NEXT_FILTER;
	    };
	}

	return catchFilter;
	};

	},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var longStackTraces = false;
	var contextStack = [];

	Promise.prototype._promiseCreated = function() {};
	Promise.prototype._pushContext = function() {};
	Promise.prototype._popContext = function() {return null;};
	Promise._peekContext = Promise.prototype._peekContext = function() {};

	function Context() {
	    this._trace = new Context.CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (this._trace !== undefined) {
	        this._trace._promiseCreated = null;
	        contextStack.push(this._trace);
	    }
	};

	Context.prototype._popContext = function () {
	    if (this._trace !== undefined) {
	        var trace = contextStack.pop();
	        var ret = trace._promiseCreated;
	        trace._promiseCreated = null;
	        return ret;
	    }
	    return null;
	};

	function createContext() {
	    if (longStackTraces) return new Context();
	}

	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	Context.CapturedTrace = null;
	Context.create = createContext;
	Context.deactivateLongStackTraces = function() {};
	Context.activateLongStackTraces = function() {
	    var Promise_pushContext = Promise.prototype._pushContext;
	    var Promise_popContext = Promise.prototype._popContext;
	    var Promise_PeekContext = Promise._peekContext;
	    var Promise_peekContext = Promise.prototype._peekContext;
	    var Promise_promiseCreated = Promise.prototype._promiseCreated;
	    Context.deactivateLongStackTraces = function() {
	        Promise.prototype._pushContext = Promise_pushContext;
	        Promise.prototype._popContext = Promise_popContext;
	        Promise._peekContext = Promise_PeekContext;
	        Promise.prototype._peekContext = Promise_peekContext;
	        Promise.prototype._promiseCreated = Promise_promiseCreated;
	        longStackTraces = false;
	    };
	    longStackTraces = true;
	    Promise.prototype._pushContext = Context.prototype._pushContext;
	    Promise.prototype._popContext = Context.prototype._popContext;
	    Promise._peekContext = Promise.prototype._peekContext = peekContext;
	    Promise.prototype._promiseCreated = function() {
	        var ctx = this._peekContext();
	        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
	    };
	};
	return Context;
	};

	},{}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, Context) {
	var getDomain = Promise._getDomain;
	var async = Promise._async;
	var Warning = _dereq_("./errors").Warning;
	var util = _dereq_("./util");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
	var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
	var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var printWarning;
	var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
	                        (true ||
	                         util.env("BLUEBIRD_DEBUG") ||
	                         util.env("NODE_ENV") === "development"));

	var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
	    (debugging || util.env("BLUEBIRD_WARNINGS")));

	var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
	    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

	var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
	    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

	Promise.prototype.suppressUnhandledRejections = function() {
	    var target = this._target();
	    target._bitField = ((target._bitField & (~1048576)) |
	                      524288);
	};

	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 524288) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};

	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};

	Promise.prototype._setReturnedNonUndefined = function() {
	    this._bitField = this._bitField | 268435456;
	};

	Promise.prototype._returnedNonUndefined = function() {
	    return (this._bitField & 268435456) !== 0;
	};

	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._settledValue();
	        this._setUnhandledRejectionIsNotified();
	        fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};

	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 262144;
	};

	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~262144);
	};

	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 262144) > 0;
	};

	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 1048576;
	};

	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~1048576);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};

	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 1048576) > 0;
	};

	Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
	    return warn(message, shouldUseOwnTrace, promise || this);
	};

	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};

	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};

	var disableLongStackTraces = function() {};
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() && !config.longStackTraces) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (!config.longStackTraces && longStackTracesIsSupported()) {
	        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
	        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
	        config.longStackTraces = true;
	        disableLongStackTraces = function() {
	            if (async.haveItemsQueued() && !config.longStackTraces) {
	                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	            }
	            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
	            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
	            Context.deactivateLongStackTraces();
	            async.enableTrampoline();
	            config.longStackTraces = false;
	        };
	        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
	        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
	        Context.activateLongStackTraces();
	        async.disableTrampolineIfNecessary();
	    }
	};

	Promise.hasLongStackTraces = function () {
	    return config.longStackTraces && longStackTracesIsSupported();
	};

	var fireDomEvent = (function() {
	    try {
	        if (typeof CustomEvent === "function") {
	            var event = new CustomEvent("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new CustomEvent(name.toLowerCase(), {
	                    detail: event,
	                    cancelable: true
	                });
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else if (typeof Event === "function") {
	            var event = new Event("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new Event(name.toLowerCase(), {
	                    cancelable: true
	                });
	                domEvent.detail = event;
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else {
	            var event = document.createEvent("CustomEvent");
	            event.initCustomEvent("testingtheevent", false, true, {});
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = document.createEvent("CustomEvent");
	                domEvent.initCustomEvent(name.toLowerCase(), false, true,
	                    event);
	                return !util.global.dispatchEvent(domEvent);
	            };
	        }
	    } catch (e) {}
	    return function() {
	        return false;
	    };
	})();

	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function() {
	            return process.emit.apply(process, arguments);
	        };
	    } else {
	        if (!util.global) {
	            return function() {
	                return false;
	            };
	        }
	        return function(name) {
	            var methodName = "on" + name.toLowerCase();
	            var method = util.global[methodName];
	            if (!method) return false;
	            method.apply(util.global, [].slice.call(arguments, 1));
	            return true;
	        };
	    }
	})();

	function generatePromiseLifecycleEventObject(name, promise) {
	    return {promise: promise};
	}

	var eventToObjectGenerator = {
	    promiseCreated: generatePromiseLifecycleEventObject,
	    promiseFulfilled: generatePromiseLifecycleEventObject,
	    promiseRejected: generatePromiseLifecycleEventObject,
	    promiseResolved: generatePromiseLifecycleEventObject,
	    promiseCancelled: generatePromiseLifecycleEventObject,
	    promiseChained: function(name, promise, child) {
	        return {promise: promise, child: child};
	    },
	    warning: function(name, warning) {
	        return {warning: warning};
	    },
	    unhandledRejection: function (name, reason, promise) {
	        return {reason: reason, promise: promise};
	    },
	    rejectionHandled: generatePromiseLifecycleEventObject
	};

	var activeFireEvent = function (name) {
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent.apply(null, arguments);
	    } catch (e) {
	        async.throwLater(e);
	        globalEventFired = true;
	    }

	    var domEventFired = false;
	    try {
	        domEventFired = fireDomEvent(name,
	                    eventToObjectGenerator[name].apply(null, arguments));
	    } catch (e) {
	        async.throwLater(e);
	        domEventFired = true;
	    }

	    return domEventFired || globalEventFired;
	};

	Promise.config = function(opts) {
	    opts = Object(opts);
	    if ("longStackTraces" in opts) {
	        if (opts.longStackTraces) {
	            Promise.longStackTraces();
	        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
	            disableLongStackTraces();
	        }
	    }
	    if ("warnings" in opts) {
	        var warningsOption = opts.warnings;
	        config.warnings = !!warningsOption;
	        wForgottenReturn = config.warnings;

	        if (util.isObject(warningsOption)) {
	            if ("wForgottenReturn" in warningsOption) {
	                wForgottenReturn = !!warningsOption.wForgottenReturn;
	            }
	        }
	    }
	    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
	        if (async.haveItemsQueued()) {
	            throw new Error(
	                "cannot enable cancellation after promises are in use");
	        }
	        Promise.prototype._clearCancellationData =
	            cancellationClearCancellationData;
	        Promise.prototype._propagateFrom = cancellationPropagateFrom;
	        Promise.prototype._onCancel = cancellationOnCancel;
	        Promise.prototype._setOnCancel = cancellationSetOnCancel;
	        Promise.prototype._attachCancellationCallback =
	            cancellationAttachCancellationCallback;
	        Promise.prototype._execute = cancellationExecute;
	        propagateFromFunction = cancellationPropagateFrom;
	        config.cancellation = true;
	    }
	    if ("monitoring" in opts) {
	        if (opts.monitoring && !config.monitoring) {
	            config.monitoring = true;
	            Promise.prototype._fireEvent = activeFireEvent;
	        } else if (!opts.monitoring && config.monitoring) {
	            config.monitoring = false;
	            Promise.prototype._fireEvent = defaultFireEvent;
	        }
	    }
	};

	function defaultFireEvent() { return false; }

	Promise.prototype._fireEvent = defaultFireEvent;
	Promise.prototype._execute = function(executor, resolve, reject) {
	    try {
	        executor(resolve, reject);
	    } catch (e) {
	        return e;
	    }
	};
	Promise.prototype._onCancel = function () {};
	Promise.prototype._setOnCancel = function (handler) { ; };
	Promise.prototype._attachCancellationCallback = function(onCancel) {
	    ;
	};
	Promise.prototype._captureStackTrace = function () {};
	Promise.prototype._attachExtraTrace = function () {};
	Promise.prototype._clearCancellationData = function() {};
	Promise.prototype._propagateFrom = function (parent, flags) {
	    ;
	    ;
	};

	function cancellationExecute(executor, resolve, reject) {
	    var promise = this;
	    try {
	        executor(resolve, reject, function(onCancel) {
	            if (typeof onCancel !== "function") {
	                throw new TypeError("onCancel must be a function, got: " +
	                                    util.toString(onCancel));
	            }
	            promise._attachCancellationCallback(onCancel);
	        });
	    } catch (e) {
	        return e;
	    }
	}

	function cancellationAttachCancellationCallback(onCancel) {
	    if (!this._isCancellable()) return this;

	    var previousOnCancel = this._onCancel();
	    if (previousOnCancel !== undefined) {
	        if (util.isArray(previousOnCancel)) {
	            previousOnCancel.push(onCancel);
	        } else {
	            this._setOnCancel([previousOnCancel, onCancel]);
	        }
	    } else {
	        this._setOnCancel(onCancel);
	    }
	}

	function cancellationOnCancel() {
	    return this._onCancelField;
	}

	function cancellationSetOnCancel(onCancel) {
	    this._onCancelField = onCancel;
	}

	function cancellationClearCancellationData() {
	    this._cancellationParent = undefined;
	    this._onCancelField = undefined;
	}

	function cancellationPropagateFrom(parent, flags) {
	    if ((flags & 1) !== 0) {
	        this._cancellationParent = parent;
	        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
	        if (branchesRemainingToCancel === undefined) {
	            branchesRemainingToCancel = 0;
	        }
	        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
	    }
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}

	function bindingPropagateFrom(parent, flags) {
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	var propagateFromFunction = bindingPropagateFrom;

	function boundValueFunction() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	}

	function longStackTracesCaptureStackTrace() {
	    this._trace = new CapturedTrace(this._peekContext());
	}

	function longStackTracesAttachExtraTrace(error, ignoreSelf) {
	    if (canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	}

	function checkForgottenReturns(returnValue, promiseCreated, name, promise,
	                               parent) {
	    if (returnValue === undefined && promiseCreated !== null &&
	        wForgottenReturn) {
	        if (parent !== undefined && parent._returnedNonUndefined()) return;
	        if ((promise._bitField & 65535) === 0) return;

	        if (name) name = name + " ";
	        var handlerLine = "";
	        var creatorLine = "";
	        if (promiseCreated._trace) {
	            var traceLines = promiseCreated._trace.stack.split("\n");
	            var stack = cleanStack(traceLines);
	            for (var i = stack.length - 1; i >= 0; --i) {
	                var line = stack[i];
	                if (!nodeFramePattern.test(line)) {
	                    var lineMatches = line.match(parseLinePattern);
	                    if (lineMatches) {
	                        handlerLine  = "at " + lineMatches[1] +
	                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
	                    }
	                    break;
	                }
	            }

	            if (stack.length > 0) {
	                var firstUserLine = stack[0];
	                for (var i = 0; i < traceLines.length; ++i) {

	                    if (traceLines[i] === firstUserLine) {
	                        if (i > 0) {
	                            creatorLine = "\n" + traceLines[i - 1];
	                        }
	                        break;
	                    }
	                }

	            }
	        }
	        var msg = "a promise was created in a " + name +
	            "handler " + handlerLine + "but was not returned from it, " +
	            "see http://goo.gl/rRqMUw" +
	            creatorLine;
	        promise._warn(msg, true, promiseCreated);
	    }
	}

	function deprecated(name, replacement) {
	    var message = name +
	        " is deprecated and will be removed in a future version.";
	    if (replacement) message += " Use " + replacement + " instead.";
	    return warn(message);
	}

	function warn(message, shouldUseOwnTrace, promise) {
	    if (!config.warnings) return;
	    var warning = new Warning(message);
	    var ctx;
	    if (shouldUseOwnTrace) {
	        promise._attachExtraTrace(warning);
	    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }

	    if (!activeFireEvent("warning", warning)) {
	        formatAndLogError(warning, "", true);
	    }
	}

	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}

	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}

	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;

	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }

	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}

	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = "    (No stack trace)" === line ||
	            stackFramePattern.test(line);
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}

	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0) {
	        stack = stack.slice(i);
	    }
	    return stack;
	}

	function parseStackAndMessage(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: cleanStack(stack)
	    };
	}

	function formatAndLogError(error, title, isSoft) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (util.isObject(error)) {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof printWarning === "function") {
	            printWarning(message, isSoft);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	}

	function fireRejectionEvent(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }

	    if (name === "unhandledRejection") {
	        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
	            formatAndLogError(reason, "Unhandled rejection ");
	        }
	    } else {
	        activeFireEvent(name, promise);
	    }
	}

	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj && typeof obj.toString === "function"
	            ? obj.toString() : util.toString(obj);
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {

	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}

	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}

	function longStackTracesIsSupported() {
	    return typeof captureStackTrace === "function";
	}

	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}

	function setBounds(firstLineError, lastLineError) {
	    if (!longStackTracesIsSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }

	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}

	function CapturedTrace(parent) {
	    this._parent = parent;
	    this._promisesCreated = 0;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	Context.CapturedTrace = CapturedTrace;

	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};

	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};

	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];

	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};

	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit += 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;

	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit += 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit -= 6;
	        };
	    }
	    var err = new Error();

	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }

	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit += 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit -= 6;
	        };
	    }

	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    return null;

	})([]);

	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    printWarning = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        printWarning = function(message, isSoft) {
	            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
	            console.warn(color + message + "\u001b[0m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        printWarning = function(message, isSoft) {
	            console.warn("%c" + message,
	                        isSoft ? "color: darkorange" : "color: red");
	        };
	    }
	}

	var config = {
	    warnings: warnings,
	    longStackTraces: false,
	    cancellation: false,
	    monitoring: false
	};

	if (longStackTraces) Promise.longStackTraces();

	return {
	    longStackTraces: function() {
	        return config.longStackTraces;
	    },
	    warnings: function() {
	        return config.warnings;
	    },
	    cancellation: function() {
	        return config.cancellation;
	    },
	    monitoring: function() {
	        return config.monitoring;
	    },
	    propagateFromFunction: function() {
	        return propagateFromFunction;
	    },
	    boundValueFunction: function() {
	        return boundValueFunction;
	    },
	    checkForgottenReturns: checkForgottenReturns,
	    setBounds: setBounds,
	    warn: warn,
	    deprecated: deprecated,
	    CapturedTrace: CapturedTrace,
	    fireDomEvent: fireDomEvent,
	    fireGlobalEvent: fireGlobalEvent
	};
	};

	},{"./errors":12,"./util":36}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function returner() {
	    return this.value;
	}
	function thrower() {
	    throw this.reason;
	}

	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value instanceof Promise) value.suppressUnhandledRejections();
	    return this._then(
	        returner, undefined, undefined, {value: value}, undefined);
	};

	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    return this._then(
	        thrower, undefined, undefined, {reason: reason}, undefined);
	};

	Promise.prototype.catchThrow = function (reason) {
	    if (arguments.length <= 1) {
	        return this._then(
	            undefined, thrower, undefined, {reason: reason}, undefined);
	    } else {
	        var _reason = arguments[1];
	        var handler = function() {throw _reason;};
	        return this.caught(reason, handler);
	    }
	};

	Promise.prototype.catchReturn = function (value) {
	    if (arguments.length <= 1) {
	        if (value instanceof Promise) value.suppressUnhandledRejections();
	        return this._then(
	            undefined, returner, undefined, {value: value}, undefined);
	    } else {
	        var _value = arguments[1];
	        if (_value instanceof Promise) _value.suppressUnhandledRejections();
	        var handler = function() {return _value;};
	        return this.caught(value, handler);
	    }
	};
	};

	},{}],11:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	var PromiseAll = Promise.all;

	function promiseAllThis() {
	    return PromiseAll(this);
	}

	function PromiseMapSeries(promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
	}

	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, this, undefined);
	};

	Promise.prototype.mapSeries = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
	};

	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, promises, undefined);
	};

	Promise.mapSeries = PromiseMapSeries;
	};


	},{}],12:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;

	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}

	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}

	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}

	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};

	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;

	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }

	}
	inherits(OperationalError, Error);

	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
	        value: errorTypes,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	}

	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};

	},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();

	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;

	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };

	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };

	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };

	    var ObjectFreeze = function (obj) {
	        return obj;
	    };

	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };

	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };

	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}

	},{}],14:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;

	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};

	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};

	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, tryConvertToPromise) {
	var util = _dereq_("./util");
	var CancellationError = Promise.CancellationError;
	var errorObj = util.errorObj;

	function PassThroughHandlerContext(promise, type, handler) {
	    this.promise = promise;
	    this.type = type;
	    this.handler = handler;
	    this.called = false;
	    this.cancelPromise = null;
	}

	PassThroughHandlerContext.prototype.isFinallyHandler = function() {
	    return this.type === 0;
	};

	function FinallyHandlerCancelReaction(finallyHandler) {
	    this.finallyHandler = finallyHandler;
	}

	FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
	    checkCancel(this.finallyHandler);
	};

	function checkCancel(ctx, reason) {
	    if (ctx.cancelPromise != null) {
	        if (arguments.length > 1) {
	            ctx.cancelPromise._reject(reason);
	        } else {
	            ctx.cancelPromise._cancel();
	        }
	        ctx.cancelPromise = null;
	        return true;
	    }
	    return false;
	}

	function succeed() {
	    return finallyHandler.call(this, this.promise._target()._settledValue());
	}
	function fail(reason) {
	    if (checkCancel(this, reason)) return;
	    errorObj.e = reason;
	    return errorObj;
	}
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;

	    if (!this.called) {
	        this.called = true;
	        var ret = this.isFinallyHandler()
	            ? handler.call(promise._boundValue())
	            : handler.call(promise._boundValue(), reasonOrValue);
	        if (ret !== undefined) {
	            promise._setReturnedNonUndefined();
	            var maybePromise = tryConvertToPromise(ret, promise);
	            if (maybePromise instanceof Promise) {
	                if (this.cancelPromise != null) {
	                    if (maybePromise._isCancelled()) {
	                        var reason =
	                            new CancellationError("late cancellation observer");
	                        promise._attachExtraTrace(reason);
	                        errorObj.e = reason;
	                        return errorObj;
	                    } else if (maybePromise.isPending()) {
	                        maybePromise._attachCancellationCallback(
	                            new FinallyHandlerCancelReaction(this));
	                    }
	                }
	                return maybePromise._then(
	                    succeed, fail, undefined, this, undefined);
	            }
	        }
	    }

	    if (promise.isRejected()) {
	        checkCancel(this);
	        errorObj.e = reasonOrValue;
	        return errorObj;
	    } else {
	        checkCancel(this);
	        return reasonOrValue;
	    }
	}

	Promise.prototype._passThrough = function(handler, type, success, fail) {
	    if (typeof handler !== "function") return this.then();
	    return this._then(success,
	                      fail,
	                      undefined,
	                      new PassThroughHandlerContext(this, type, handler),
	                      undefined);
	};

	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThrough(handler,
	                             0,
	                             finallyHandler,
	                             finallyHandler);
	};

	Promise.prototype.tap = function (handler) {
	    return this._passThrough(handler, 1, finallyHandler);
	};

	return PassThroughHandlerContext;
	};

	},{"./util":36}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise,
	                          Proxyable,
	                          debug) {
	var errors = _dereq_("./errors");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];

	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}

	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    if (debug.cancellation()) {
	        var internal = new Promise(INTERNAL);
	        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
	        this._promise = internal.lastly(function() {
	            return _finallyPromise;
	        });
	        internal._captureStackTrace();
	        internal._setOnCancel(this);
	    } else {
	        var promise = this._promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	    }
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	    this._yieldedPromise = null;
	    this._cancellationPhase = false;
	}
	util.inherits(PromiseSpawn, Proxyable);

	PromiseSpawn.prototype._isResolved = function() {
	    return this._promise === null;
	};

	PromiseSpawn.prototype._cleanup = function() {
	    this._promise = this._generator = null;
	    if (debug.cancellation() && this._finallyPromise !== null) {
	        this._finallyPromise._fulfill();
	        this._finallyPromise = null;
	    }
	};

	PromiseSpawn.prototype._promiseCancelled = function() {
	    if (this._isResolved()) return;
	    var implementsReturn = typeof this._generator["return"] !== "undefined";

	    var result;
	    if (!implementsReturn) {
	        var reason = new Promise.CancellationError(
	            "generator .return() sentinel");
	        Promise.coroutine.returnSentinel = reason;
	        this._promise._attachExtraTrace(reason);
	        this._promise._pushContext();
	        result = tryCatch(this._generator["throw"]).call(this._generator,
	                                                         reason);
	        this._promise._popContext();
	    } else {
	        this._promise._pushContext();
	        result = tryCatch(this._generator["return"]).call(this._generator,
	                                                          undefined);
	        this._promise._popContext();
	    }
	    this._cancellationPhase = true;
	    this._yieldedPromise = null;
	    this._continue(result);
	};

	PromiseSpawn.prototype._promiseFulfilled = function(value) {
	    this._yieldedPromise = null;
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._promiseRejected = function(reason) {
	    this._yieldedPromise = null;
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._resultCancelled = function() {
	    if (this._yieldedPromise instanceof Promise) {
	        var promise = this._yieldedPromise;
	        this._yieldedPromise = null;
	        promise.cancel();
	    }
	};

	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};

	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._promiseFulfilled(undefined);
	};

	PromiseSpawn.prototype._continue = function (result) {
	    var promise = this._promise;
	    if (result === errorObj) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._rejectCallback(result.e, false);
	        }
	    }

	    var value = result.value;
	    if (result.done === true) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._resolveCallback(value);
	        }
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._promiseRejected(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise = maybePromise._target();
	        var bitField = maybePromise._bitField;
	        ;
	        if (((bitField & 50397184) === 0)) {
	            this._yieldedPromise = maybePromise;
	            maybePromise._proxy(this, null);
	        } else if (((bitField & 33554432) !== 0)) {
	            Promise._async.invoke(
	                this._promiseFulfilled, this, maybePromise._value()
	            );
	        } else if (((bitField & 16777216) !== 0)) {
	            Promise._async.invoke(
	                this._promiseRejected, this, maybePromise._reason()
	            );
	        } else {
	            this._promiseCancelled();
	        }
	    }
	};

	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        var ret = spawn.promise();
	        spawn._generator = generator;
	        spawn._promiseFulfilled(undefined);
	        return ret;
	    };
	};

	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    yieldHandlers.push(fn);
	};

	Promise.spawn = function (generatorFunction) {
	    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};

	},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
	         getDomain) {
	var util = _dereq_("./util");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;

	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };

	    var promiseSetter = function(i) {
	        return new Function("promise", "holder", "                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g, i));
	    };

	    var generateHolderClass = function(total) {
	        var props = new Array(total);
	        for (var i = 0; i < props.length; ++i) {
	            props[i] = "this.p" + (i+1);
	        }
	        var assignment = props.join(" = ") + " = null;";
	        var cancellationCode= "var promise;\n" + props.map(function(prop) {
	            return "                                                         \n\
	                promise = " + prop + ";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";
	        }).join("\n");
	        var passedArguments = props.join(", ");
	        var name = "Holder$" + total;


	        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.asyncNeeded = true;                                     \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	                                                                             \n\
	            [TheName].prototype._callFunction = function(promise) {          \n\
	                promise._pushContext();                                      \n\
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
	                promise._popContext();                                       \n\
	                if (ret === errorObj) {                                      \n\
	                    promise._rejectCallback(ret.e, false);                   \n\
	                } else {                                                     \n\
	                    promise._resolveCallback(ret);                           \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    if (this.asyncNeeded) {                                  \n\
	                        async.invoke(this._callFunction, this, promise);     \n\
	                    } else {                                                 \n\
	                        this._callFunction(promise);                         \n\
	                    }                                                        \n\
	                                                                             \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise, async);                               \n\
	        ";

	        code = code.replace(/\[TheName\]/g, name)
	            .replace(/\[TheTotal\]/g, total)
	            .replace(/\[ThePassedArguments\]/g, passedArguments)
	            .replace(/\[TheProperties\]/g, assignment)
	            .replace(/\[CancellationCode\]/g, cancellationCode);

	        return new Function("tryCatch", "errorObj", "Promise", "async", code)
	                           (tryCatch, errorObj, Promise, async);
	    };

	    var holderClasses = [];
	    var thenCallbacks = [];
	    var promiseSetters = [];

	    for (var i = 0; i < 8; ++i) {
	        holderClasses.push(generateHolderClass(i + 1));
	        thenCallbacks.push(thenCallback(i + 1));
	        promiseSetters.push(promiseSetter(i + 1));
	    }

	    reject = function (reason) {
	        this._reject(reason);
	    };
	}}

	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last <= 8 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var HolderClass = holderClasses[last - 1];
	                var holder = new HolderClass(fn);
	                var callbacks = thenCallbacks;

	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        var bitField = maybePromise._bitField;
	                        ;
	                        if (((bitField & 50397184) === 0)) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                            promiseSetters[i](maybePromise, holder);
	                            holder.asyncNeeded = false;
	                        } else if (((bitField & 33554432) !== 0)) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else if (((bitField & 16777216) !== 0)) {
	                            ret._reject(maybePromise._reason());
	                        } else {
	                            ret._cancel();
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }

	                if (!ret._isFateSealed()) {
	                    if (holder.asyncNeeded) {
	                        var domain = getDomain();
	                        if (domain !== null) {
	                            holder.fn = util.domainBind(domain, holder.fn);
	                        }
	                    }
	                    ret._setAsyncGuaranteed();
	                    ret._setOnCancel(holder);
	                }
	                return ret;
	            }
	        }
	    }
	    var args = [].slice.call(arguments);;
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};

	};

	},{"./util":36}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;

	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : util.domainBind(domain, fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = [];
	    async.invoke(this._asyncInit, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);

	MappingPromiseArray.prototype._asyncInit = function() {
	    this._init$(undefined, -2);
	};

	MappingPromiseArray.prototype._init = function () {};

	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;

	    if (index < 0) {
	        index = (index * -1) - 1;
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return true;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return false;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;

	        var promise = this._promise;
	        var callback = this._callback;
	        var receiver = promise._boundValue();
	        promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        var promiseCreated = promise._popContext();
	        debug.checkForgottenReturns(
	            ret,
	            promiseCreated,
	            preservedValues !== null ? "Promise.filter" : "Promise.map",
	            promise
	        );
	        if (ret === errorObj) {
	            this._reject(ret.e);
	            return true;
	        }

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            var bitField = maybePromise._bitField;
	            ;
	            if (((bitField & 50397184) === 0)) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = maybePromise;
	                maybePromise._proxy(this, (index + 1) * -1);
	                return false;
	            } else if (((bitField & 33554432) !== 0)) {
	                ret = maybePromise._value();
	            } else if (((bitField & 16777216) !== 0)) {
	                this._reject(maybePromise._reason());
	                return true;
	            } else {
	                this._cancel();
	                return true;
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	        return true;
	    }
	    return false;
	};

	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};

	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};

	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};

	function map(promises, fn, options, _filter) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }

	    var limit = 0;
	    if (options !== undefined) {
	        if (typeof options === "object" && options !== null) {
	            if (typeof options.concurrency !== "number") {
	                return Promise.reject(
	                    new TypeError("'concurrency' must be a number but it is " +
	                                    util.classString(options.concurrency)));
	            }
	            limit = options.concurrency;
	        } else {
	            return Promise.reject(new TypeError(
	                            "options argument must be an object but it is " +
	                             util.classString(options)));
	        }
	    }
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
	}

	Promise.prototype.map = function (fn, options) {
	    return map(this, fn, options, null);
	};

	Promise.map = function (promises, fn, options, _filter) {
	    return map(promises, fn, options, _filter);
	};


	};

	},{"./util":36}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;

	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        var promiseCreated = ret._popContext();
	        debug.checkForgottenReturns(
	            value, promiseCreated, "Promise.method", ret);
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};

	Promise.attempt = Promise["try"] = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value;
	    if (arguments.length > 1) {
	        debug.deprecated("calling Promise.try with more than 1 argument");
	        var arg = arguments[1];
	        var ctx = arguments[2];
	        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
	                                  : tryCatch(fn).call(ctx, arg);
	    } else {
	        value = tryCatch(fn)();
	    }
	    var promiseCreated = ret._popContext();
	    debug.checkForgottenReturns(
	        value, promiseCreated, "Promise.try", ret);
	    ret._resolveFromSyncValue(value);
	    return ret;
	};

	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};

	},{"./util":36}],20:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors");
	var OperationalError = errors.OperationalError;
	var es5 = _dereq_("./es5");

	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}

	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}

	function nodebackForPromise(promise, multiArgs) {
	    return function(err, value) {
	        if (promise === null) return;
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (!multiArgs) {
	            promise._fulfill(value);
	        } else {
	            var args = [].slice.call(arguments, 1);;
	            promise._fulfill(args);
	        }
	        promise = null;
	    };
	}

	module.exports = nodebackForPromise;

	},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util");
	var async = Promise._async;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var newReason = new Error(reason + "");
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
	                                                                     options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};

	},{"./util":36}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var reflectHandler = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	function Proxyable() {}
	var UNDEFINED_BINDING = {};
	var util = _dereq_("./util");

	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);

	var es5 = _dereq_("./es5");
	var Async = _dereq_("./async");
	var async = new Async();
	es5.defineProperty(Promise, "_async", {value: async});
	var errors = _dereq_("./errors");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	var CancellationError = Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {};
	var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array")(Promise, INTERNAL,
	                               tryConvertToPromise, apiRejection, Proxyable);
	var Context = _dereq_("./context")(Promise);
	 /*jshint unused:false*/
	var createContext = Context.create;
	var debug = _dereq_("./debuggability")(Promise, Context);
	var CapturedTrace = debug.CapturedTrace;
	var PassThroughHandlerContext =
	    _dereq_("./finally")(Promise, tryConvertToPromise);
	var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
	var nodebackForPromise = _dereq_("./nodeback");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function check(self, executor) {
	    if (typeof executor !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(executor));
	    }
	    if (self.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	}

	function Promise(executor) {
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    if (executor !== INTERNAL) {
	        check(this, executor);
	        this._resolveFromExecutor(executor);
	    }
	    this._promiseCreated();
	    this._fireEvent("promiseCreated", this);
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return apiRejection("expecting an object but got " +
	                    "A catch statement predicate " + util.classString(item));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        return this.then(undefined, catchFilter(catchInstances, fn, this));
	    }
	    return this.then(undefined, fn);
	};

	Promise.prototype.reflect = function () {
	    return this._then(reflectHandler,
	        reflectHandler, undefined, this, undefined);
	};

	Promise.prototype.then = function (didFulfill, didReject) {
	    if (debug.warnings() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, undefined, undefined, undefined);
	};

	Promise.prototype.done = function (didFulfill, didReject) {
	    var promise =
	        this._then(didFulfill, didReject, undefined, undefined, undefined);
	    promise._setIsFinal();
	};

	Promise.prototype.spread = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
	};

	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};

	Promise.prototype.all = function () {
	    if (arguments.length > 0) {
	        this._warn(".all() was passed arguments but it does not take any");
	    }
	    return new PromiseArray(this).promise();
	};

	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};

	Promise.getNewLibraryCopy = module.exports;

	Promise.is = function (val) {
	    return val instanceof Promise;
	};

	Promise.fromNode = Promise.fromCallback = function(fn) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
	                                         : false;
	    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true);
	    }
	    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
	    return ret;
	};

	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};

	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._setFulfilled();
	        ret._rejectionHandler0 = obj;
	    }
	    return ret;
	};

	Promise.resolve = Promise.fulfilled = Promise.cast;

	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};

	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return async.setScheduler(fn);
	};

	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    _,    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
	    var target = this._target();
	    var bitField = target._bitField;

	    if (!haveInternalData) {
	        promise._propagateFrom(this, 3);
	        promise._captureStackTrace();
	        if (receiver === undefined &&
	            ((this._bitField & 2097152) !== 0)) {
	            if (!((bitField & 50397184) === 0)) {
	                receiver = this._boundValue();
	            } else {
	                receiver = target === this ? undefined : this._boundTo;
	            }
	        }
	        this._fireEvent("promiseChained", this, promise);
	    }

	    var domain = getDomain();
	    if (!((bitField & 50397184) === 0)) {
	        var handler, value, settler = target._settlePromiseCtx;
	        if (((bitField & 33554432) !== 0)) {
	            value = target._rejectionHandler0;
	            handler = didFulfill;
	        } else if (((bitField & 16777216) !== 0)) {
	            value = target._fulfillmentHandler0;
	            handler = didReject;
	            target._unsetRejectionIsUnhandled();
	        } else {
	            settler = target._settlePromiseLateCancellationObserver;
	            value = new CancellationError("late cancellation observer");
	            target._attachExtraTrace(value);
	            handler = didReject;
	        }

	        async.invoke(settler, target, {
	            handler: domain === null ? handler
	                : (typeof handler === "function" &&
	                    util.domainBind(domain, handler)),
	            promise: promise,
	            receiver: receiver,
	            value: value
	        });
	    } else {
	        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
	    }

	    return promise;
	};

	Promise.prototype._length = function () {
	    return this._bitField & 65535;
	};

	Promise.prototype._isFateSealed = function () {
	    return (this._bitField & 117506048) !== 0;
	};

	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 67108864) === 67108864;
	};

	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -65536) |
	        (len & 65535);
	};

	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 33554432;
	    this._fireEvent("promiseFulfilled", this);
	};

	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 16777216;
	    this._fireEvent("promiseRejected", this);
	};

	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 67108864;
	    this._fireEvent("promiseResolved", this);
	};

	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 4194304;
	};

	Promise.prototype._isFinal = function () {
	    return (this._bitField & 4194304) > 0;
	};

	Promise.prototype._unsetCancelled = function() {
	    this._bitField = this._bitField & (~65536);
	};

	Promise.prototype._setCancelled = function() {
	    this._bitField = this._bitField | 65536;
	    this._fireEvent("promiseCancelled", this);
	};

	Promise.prototype._setWillBeCancelled = function() {
	    this._bitField = this._bitField | 8388608;
	};

	Promise.prototype._setAsyncGuaranteed = function() {
	    if (async.hasCustomScheduler()) return;
	    this._bitField = this._bitField | 134217728;
	};

	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0 ? this._receiver0 : this[
	            index * 4 - 4 + 3];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};

	Promise.prototype._promiseAt = function (index) {
	    return this[
	            index * 4 - 4 + 2];
	};

	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 0];
	};

	Promise.prototype._rejectionHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 1];
	};

	Promise.prototype._boundValue = function() {};

	Promise.prototype._migrateCallback0 = function (follower) {
	    var bitField = follower._bitField;
	    var fulfill = follower._fulfillmentHandler0;
	    var reject = follower._rejectionHandler0;
	    var promise = follower._promise0;
	    var receiver = follower._receiverAt(0);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};

	Promise.prototype._migrateCallbackAt = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};

	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();

	    if (index >= 65535 - 4) {
	        index = 0;
	        this._setLength(0);
	    }

	    if (index === 0) {
	        this._promise0 = promise;
	        this._receiver0 = receiver;
	        if (typeof fulfill === "function") {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    } else {
	        var base = index * 4 - 4;
	        this[base + 2] = promise;
	        this[base + 3] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};

	Promise.prototype._proxy = function (proxyable, arg) {
	    this._addCallbacks(undefined, undefined, arg, proxyable, null);
	};

	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (((this._bitField & 117506048) !== 0)) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

	    if (shouldBind) this._propagateFrom(maybePromise, 2);

	    var promise = maybePromise._target();

	    if (promise === this) {
	        this._reject(makeSelfResolutionError());
	        return;
	    }

	    var bitField = promise._bitField;
	    if (((bitField & 50397184) === 0)) {
	        var len = this._length();
	        if (len > 0) promise._migrateCallback0(this);
	        for (var i = 1; i < len; ++i) {
	            promise._migrateCallbackAt(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (((bitField & 33554432) !== 0)) {
	        this._fulfill(promise._value());
	    } else if (((bitField & 16777216) !== 0)) {
	        this._reject(promise._reason());
	    } else {
	        var reason = new CancellationError("late cancellation observer");
	        promise._attachExtraTrace(reason);
	        this._reject(reason);
	    }
	};

	Promise.prototype._rejectCallback =
	function(reason, synchronous, ignoreNonErrorWarnings) {
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
	        var message = "a promise was rejected with a non-error: " +
	            util.classString(reason);
	        this._warn(message, true);
	    }
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason);
	};

	Promise.prototype._resolveFromExecutor = function (executor) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = this._execute(executor, function(value) {
	        promise._resolveCallback(value);
	    }, function (reason) {
	        promise._rejectCallback(reason, synchronous);
	    });
	    synchronous = false;
	    this._popContext();

	    if (r !== undefined) {
	        promise._rejectCallback(r, true);
	    }
	};

	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    var bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY) {
	        if (!value || typeof value.length !== "number") {
	            x = errorObj;
	            x.e = new TypeError("cannot .spread() a non-array: " +
	                                    util.classString(value));
	        } else {
	            x = tryCatch(handler).apply(this._boundValue(), value);
	        }
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    var promiseCreated = promise._popContext();
	    bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;

	    if (x === NEXT_FILTER) {
	        promise._reject(value);
	    } else if (x === errorObj) {
	        promise._rejectCallback(x.e, false);
	    } else {
	        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
	        promise._resolveCallback(x);
	    }
	};

	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};

	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};

	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};

	Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
	    var isPromise = promise instanceof Promise;
	    var bitField = this._bitField;
	    var asyncGuaranteed = ((bitField & 134217728) !== 0);
	    if (((bitField & 65536) !== 0)) {
	        if (isPromise) promise._invokeInternalOnCancel();

	        if (receiver instanceof PassThroughHandlerContext &&
	            receiver.isFinallyHandler()) {
	            receiver.cancelPromise = promise;
	            if (tryCatch(handler).call(receiver, value) === errorObj) {
	                promise._reject(errorObj.e);
	            }
	        } else if (handler === reflectHandler) {
	            promise._fulfill(reflectHandler.call(receiver));
	        } else if (receiver instanceof Proxyable) {
	            receiver._promiseCancelled(promise);
	        } else if (isPromise || promise instanceof PromiseArray) {
	            promise._cancel();
	        } else {
	            receiver.cancel();
	        }
	    } else if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            if (asyncGuaranteed) promise._setAsyncGuaranteed();
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof Proxyable) {
	        if (!receiver._isResolved()) {
	            if (((bitField & 33554432) !== 0)) {
	                receiver._promiseFulfilled(value, promise);
	            } else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (asyncGuaranteed) promise._setAsyncGuaranteed();
	        if (((bitField & 33554432) !== 0)) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value);
	        }
	    }
	};

	Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
	    var handler = ctx.handler;
	    var promise = ctx.promise;
	    var receiver = ctx.receiver;
	    var value = ctx.value;
	    if (typeof handler === "function") {
	        if (!(promise instanceof Promise)) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (promise instanceof Promise) {
	        promise._reject(value);
	    }
	};

	Promise.prototype._settlePromiseCtx = function(ctx) {
	    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
	};

	Promise.prototype._settlePromise0 = function(handler, value, bitField) {
	    var promise = this._promise0;
	    var receiver = this._receiverAt(0);
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settlePromise(promise, handler, receiver, value);
	};

	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    var base = index * 4 - 4;
	    this[base + 2] =
	    this[base + 3] =
	    this[base + 0] =
	    this[base + 1] = undefined;
	};

	Promise.prototype._fulfill = function (value) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._reject(err);
	    }
	    this._setFulfilled();
	    this._rejectionHandler0 = value;

	    if ((bitField & 65535) > 0) {
	        if (((bitField & 134217728) !== 0)) {
	            this._settlePromises();
	        } else {
	            async.settlePromises(this);
	        }
	    }
	};

	Promise.prototype._reject = function (reason) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    this._setRejected();
	    this._fulfillmentHandler0 = reason;

	    if (this._isFinal()) {
	        return async.fatalError(reason, util.isNode);
	    }

	    if ((bitField & 65535) > 0) {
	        async.settlePromises(this);
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};

	Promise.prototype._fulfillPromises = function (len, value) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._fulfillmentHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, value);
	    }
	};

	Promise.prototype._rejectPromises = function (len, reason) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._rejectionHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, reason);
	    }
	};

	Promise.prototype._settlePromises = function () {
	    var bitField = this._bitField;
	    var len = (bitField & 65535);

	    if (len > 0) {
	        if (((bitField & 16842752) !== 0)) {
	            var reason = this._fulfillmentHandler0;
	            this._settlePromise0(this._rejectionHandler0, reason, bitField);
	            this._rejectPromises(len, reason);
	        } else {
	            var value = this._rejectionHandler0;
	            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
	            this._fulfillPromises(len, value);
	        }
	        this._setLength(0);
	    }
	    this._clearCancellationData();
	};

	Promise.prototype._settledValue = function() {
	    var bitField = this._bitField;
	    if (((bitField & 33554432) !== 0)) {
	        return this._rejectionHandler0;
	    } else if (((bitField & 16777216) !== 0)) {
	        return this._fulfillmentHandler0;
	    }
	};

	function deferResolve(v) {this.promise._resolveCallback(v);}
	function deferReject(v) {this.promise._rejectCallback(v, false);}

	Promise.defer = Promise.pending = function() {
	    debug.deprecated("Promise.defer", "new Promise");
	    var promise = new Promise(INTERNAL);
	    return {
	        promise: promise,
	        resolve: deferResolve,
	        reject: deferReject
	    };
	};

	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);

	_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
	    debug);
	_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
	_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
	_dereq_("./direct_resolve")(Promise);
	_dereq_("./synchronous_inspection")(Promise);
	_dereq_("./join")(
	    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
	Promise.Promise = Promise;
	Promise.version = "3.4.6";
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
	_dereq_('./timers.js')(Promise, INTERNAL, debug);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	_dereq_('./settle.js')(Promise, PromiseArray, debug);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./filter.js')(Promise, INTERNAL);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    debug.setBounds(Async.firstLineError, util.lastLineError);               
	    return Promise;                                                          

	};

	},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection, Proxyable) {
	var util = _dereq_("./util");
	var isArray = util.isArray;

	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}

	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    if (values instanceof Promise) {
	        promise._propagateFrom(values, 3);
	    }
	    promise._setOnCancel(this);
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	util.inherits(PromiseArray, Proxyable);

	PromiseArray.prototype.length = function () {
	    return this._length;
	};

	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};

	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        var bitField = values._bitField;
	        ;
	        this._values = values;

	        if (((bitField & 50397184) === 0)) {
	            this._promise._setAsyncGuaranteed();
	            return values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	        } else if (((bitField & 33554432) !== 0)) {
	            values = values._value();
	        } else if (((bitField & 16777216) !== 0)) {
	            return this._reject(values._reason());
	        } else {
	            return this._cancel();
	        }
	    }
	    values = util.asArray(values);
	    if (values === null) {
	        var err = apiRejection(
	            "expecting an array or an iterable object but got " + util.classString(values)).reason();
	        this._promise._rejectCallback(err, false);
	        return;
	    }

	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    this._iterate(values);
	};

	PromiseArray.prototype._iterate = function(values) {
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var result = this._promise;
	    var isResolved = false;
	    var bitField = null;
	    for (var i = 0; i < len; ++i) {
	        var maybePromise = tryConvertToPromise(values[i], result);

	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            bitField = maybePromise._bitField;
	        } else {
	            bitField = null;
	        }

	        if (isResolved) {
	            if (bitField !== null) {
	                maybePromise.suppressUnhandledRejections();
	            }
	        } else if (bitField !== null) {
	            if (((bitField & 50397184) === 0)) {
	                maybePromise._proxy(this, i);
	                this._values[i] = maybePromise;
	            } else if (((bitField & 33554432) !== 0)) {
	                isResolved = this._promiseFulfilled(maybePromise._value(), i);
	            } else if (((bitField & 16777216) !== 0)) {
	                isResolved = this._promiseRejected(maybePromise._reason(), i);
	            } else {
	                isResolved = this._promiseCancelled(i);
	            }
	        } else {
	            isResolved = this._promiseFulfilled(maybePromise, i);
	        }
	    }
	    if (!isResolved) result._setAsyncGuaranteed();
	};

	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};

	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};

	PromiseArray.prototype._cancel = function() {
	    if (this._isResolved() || !this._promise._isCancellable()) return;
	    this._values = null;
	    this._promise._cancel();
	};

	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false);
	};

	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};

	PromiseArray.prototype._promiseCancelled = function() {
	    this._cancel();
	    return true;
	};

	PromiseArray.prototype._promiseRejected = function (reason) {
	    this._totalResolved++;
	    this._reject(reason);
	    return true;
	};

	PromiseArray.prototype._resultCancelled = function() {
	    if (this._isResolved()) return;
	    var values = this._values;
	    this._cancel();
	    if (values instanceof Promise) {
	        values.cancel();
	    } else {
	        for (var i = 0; i < values.length; ++i) {
	            if (values[i] instanceof Promise) {
	                values[i].cancel();
	            }
	        }
	    }
	};

	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};

	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};

	return PromiseArray;
	};

	},{"./util":36}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util");
	var nodebackForPromise = _dereq_("./nodeback");
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};

	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}

	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}

	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}

	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}

	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};

	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};

	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};

	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};

	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};

	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn, _, multiArgs) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }

	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }

	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }

	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	    var body = "'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode);
	    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL",
	                        body)(
	                    Promise,
	                    fn,
	                    receiver,
	                    withAppended,
	                    maybeWrapAsError,
	                    nodebackForPromise,
	                    util.tryCatch,
	                    util.errorObj,
	                    util.notEnumerableProp,
	                    INTERNAL);
	};
	}

	function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise, multiArgs);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}

	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;

	function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);

	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key,
	                                           fn, suffix, multiArgs);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}

	function promisify(callback, receiver, multiArgs) {
	    return makeNodePromisified(callback, receiver, undefined,
	                                callback, null, multiArgs);
	}

	Promise.promisify = function (fn, options) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    options = Object(options);
	    var receiver = options.context === undefined ? THIS : options.context;
	    var multiArgs = !!options.multiArgs;
	    var ret = promisify(fn, receiver, multiArgs);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};

	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    options = Object(options);
	    var multiArgs = !!options.multiArgs;
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }

	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier,
	                multiArgs);
	            promisifyAll(value, suffix, filter, promisifier, multiArgs);
	        }
	    }

	    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
	};
	};


	},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5");
	var Es6Map;
	if (typeof Map === "function") Es6Map = Map;

	var mapToEntries = (function() {
	    var index = 0;
	    var size = 0;

	    function extractEntry(value, key) {
	        this[index] = value;
	        this[index + size] = key;
	        index++;
	    }

	    return function mapToEntries(map) {
	        size = map.size;
	        index = 0;
	        var ret = new Array(map.size * 2);
	        map.forEach(extractEntry, ret);
	        return ret;
	    };
	})();

	var entriesToMap = function(entries) {
	    var ret = new Es6Map();
	    var length = entries.length / 2 | 0;
	    for (var i = 0; i < length; ++i) {
	        var key = entries[length + i];
	        var value = entries[i];
	        ret.set(key, value);
	    }
	    return ret;
	};

	function PropertiesPromiseArray(obj) {
	    var isMap = false;
	    var entries;
	    if (Es6Map !== undefined && obj instanceof Es6Map) {
	        entries = mapToEntries(obj);
	        isMap = true;
	    } else {
	        var keys = es5.keys(obj);
	        var len = keys.length;
	        entries = new Array(len * 2);
	        for (var i = 0; i < len; ++i) {
	            var key = keys[i];
	            entries[i] = obj[key];
	            entries[i + len] = key;
	        }
	    }
	    this.constructor$(entries);
	    this._isMap = isMap;
	    this._init$(undefined, -3);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);

	PropertiesPromiseArray.prototype._init = function () {};

	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val;
	        if (this._isMap) {
	            val = entriesToMap(this._values);
	        } else {
	            val = {};
	            var keyOffset = this.length();
	            for (var i = 0, len = this.length(); i < len; ++i) {
	                val[this._values[i + keyOffset]] = this._values[i];
	            }
	        }
	        this._resolve(val);
	        return true;
	    }
	    return false;
	};

	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};

	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);

	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }

	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 2);
	    }
	    return ret;
	}

	Promise.prototype.props = function () {
	    return props(this);
	};

	Promise.props = function (promises) {
	    return props(promises);
	};
	};

	},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}

	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}

	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};

	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};

	Queue.prototype._unshiftOne = function(value) {
	    var capacity = this._capacity;
	    this._checkCapacity(this.length() + 1);
	    var front = this._front;
	    var i = (((( front - 1 ) &
	                    ( capacity - 1) ) ^ capacity ) - capacity );
	    this[i] = value;
	    this._front = i;
	    this._length = this.length() + 1;
	};

	Queue.prototype.unshift = function(fn, receiver, arg) {
	    this._unshiftOne(arg);
	    this._unshiftOne(receiver);
	    this._unshiftOne(fn);
	};

	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};

	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];

	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};

	Queue.prototype.length = function () {
	    return this._length;
	};

	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};

	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};

	module.exports = Queue;

	},{}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util");

	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};

	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);

	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else {
	        promises = util.asArray(promises);
	        if (promises === null)
	            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
	    }

	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 3);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];

	        if (val === undefined && !(i in promises)) {
	            continue;
	        }

	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}

	Promise.race = function (promises) {
	    return race(promises, undefined);
	};

	Promise.prototype.race = function () {
	    return race(this, undefined);
	};

	};

	},{"./util":36}],28:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;

	function ReductionPromiseArray(promises, fn, initialValue, _each) {
	    this.constructor$(promises);
	    var domain = getDomain();
	    this._fn = domain === null ? fn : util.domainBind(domain, fn);
	    if (initialValue !== undefined) {
	        initialValue = Promise.resolve(initialValue);
	        initialValue._attachCancellationCallback(this);
	    }
	    this._initialValue = initialValue;
	    this._currentCancellable = null;
	    if(_each === INTERNAL) {
	        this._eachValues = Array(this._length);
	    } else if (_each === 0) {
	        this._eachValues = null;
	    } else {
	        this._eachValues = undefined;
	    }
	    this._promise._captureStackTrace();
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);

	ReductionPromiseArray.prototype._gotAccum = function(accum) {
	    if (this._eachValues !== undefined && 
	        this._eachValues !== null && 
	        accum !== INTERNAL) {
	        this._eachValues.push(accum);
	    }
	};

	ReductionPromiseArray.prototype._eachComplete = function(value) {
	    if (this._eachValues !== null) {
	        this._eachValues.push(value);
	    }
	    return this._eachValues;
	};

	ReductionPromiseArray.prototype._init = function() {};

	ReductionPromiseArray.prototype._resolveEmptyArray = function() {
	    this._resolve(this._eachValues !== undefined ? this._eachValues
	                                                 : this._initialValue);
	};

	ReductionPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	ReductionPromiseArray.prototype._resolve = function(value) {
	    this._promise._resolveCallback(value);
	    this._values = null;
	};

	ReductionPromiseArray.prototype._resultCancelled = function(sender) {
	    if (sender === this._initialValue) return this._cancel();
	    if (this._isResolved()) return;
	    this._resultCancelled$();
	    if (this._currentCancellable instanceof Promise) {
	        this._currentCancellable.cancel();
	    }
	    if (this._initialValue instanceof Promise) {
	        this._initialValue.cancel();
	    }
	};

	ReductionPromiseArray.prototype._iterate = function (values) {
	    this._values = values;
	    var value;
	    var i;
	    var length = values.length;
	    if (this._initialValue !== undefined) {
	        value = this._initialValue;
	        i = 0;
	    } else {
	        value = Promise.resolve(values[0]);
	        i = 1;
	    }

	    this._currentCancellable = value;

	    if (!value.isRejected()) {
	        for (; i < length; ++i) {
	            var ctx = {
	                accum: null,
	                value: values[i],
	                index: i,
	                length: length,
	                array: this
	            };
	            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
	        }
	    }

	    if (this._eachValues !== undefined) {
	        value = value
	            ._then(this._eachComplete, undefined, undefined, this, undefined);
	    }
	    value._then(completed, completed, undefined, value, this);
	};

	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};

	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};

	function completed(valueOrReason, array) {
	    if (this.isFulfilled()) {
	        array._resolve(valueOrReason);
	    } else {
	        array._reject(valueOrReason);
	    }
	}

	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}

	function gotAccum(accum) {
	    this.accum = accum;
	    this.array._gotAccum(accum);
	    var value = tryConvertToPromise(this.value, this.array._promise);
	    if (value instanceof Promise) {
	        this.array._currentCancellable = value;
	        return value._then(gotValue, undefined, undefined, this, undefined);
	    } else {
	        return gotValue.call(this, value);
	    }
	}

	function gotValue(value) {
	    var array = this.array;
	    var promise = array._promise;
	    var fn = tryCatch(array._fn);
	    promise._pushContext();
	    var ret;
	    if (array._eachValues !== undefined) {
	        ret = fn.call(promise._boundValue(), value, this.index, this.length);
	    } else {
	        ret = fn.call(promise._boundValue(),
	                              this.accum, value, this.index, this.length);
	    }
	    if (ret instanceof Promise) {
	        array._currentCancellable = ret;
	    }
	    var promiseCreated = promise._popContext();
	    debug.checkForgottenReturns(
	        ret,
	        promiseCreated,
	        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
	        promise
	    );
	    return ret;
	}
	};

	},{"./util":36}],29:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util");
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var NativePromise = util.getNativePromise();
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if (typeof NativePromise === "function" &&
	           typeof NativePromise.resolve === "function") {
	    var nativePromise = NativePromise.resolve();
	    schedule = function(fn) {
	        nativePromise.then(fn);
	    };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            (window.navigator.standalone || window.cordova))) {
	    schedule = (function() {
	        var div = document.createElement("div");
	        var opts = {attributes: true};
	        var toggleScheduled = false;
	        var div2 = document.createElement("div");
	        var o2 = new MutationObserver(function() {
	            div.classList.toggle("foo");
	            toggleScheduled = false;
	        });
	        o2.observe(div2, opts);

	        var scheduleToggle = function() {
	            if (toggleScheduled) return;
	                toggleScheduled = true;
	                div2.classList.toggle("foo");
	            };

	            return function schedule(fn) {
	            var o = new MutationObserver(function() {
	                o.disconnect();
	                fn();
	            });
	            o.observe(div, opts);
	            scheduleToggle();
	        };
	    })();
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;

	},{"./util":36}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray, debug) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util");

	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);

	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};

	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 33554432;
	    ret._settledValueField = value;
	    return this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 16777216;
	    ret._settledValueField = reason;
	    return this._promiseResolved(index, ret);
	};

	Promise.settle = function (promises) {
	    debug.deprecated(".settle()", ".reflect()");
	    return new SettledPromiseArray(promises).promise();
	};

	Promise.prototype.settle = function () {
	    return Promise.settle(this);
	};
	};

	},{"./util":36}],31:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util");
	var RangeError = _dereq_("./errors").RangeError;
	var AggregateError = _dereq_("./errors").AggregateError;
	var isArray = util.isArray;
	var CANCELLATION = {};


	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);

	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};

	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};

	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};

	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};

	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};

	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	        return true;
	    }
	    return false;

	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    return this._checkOutcome();
	};

	SomePromiseArray.prototype._promiseCancelled = function () {
	    if (this._values instanceof Promise || this._values == null) {
	        return this._cancel();
	    }
	    this._addRejected(CANCELLATION);
	    return this._checkOutcome();
	};

	SomePromiseArray.prototype._checkOutcome = function() {
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            if (this._values[i] !== CANCELLATION) {
	                e.push(this._values[i]);
	            }
	        }
	        if (e.length > 0) {
	            this._reject(e);
	        } else {
	            this._cancel();
	        }
	        return true;
	    }
	    return false;
	};

	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};

	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};

	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};

	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};

	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};

	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};

	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};

	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}

	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};

	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};

	Promise._SomePromiseArray = SomePromiseArray;
	};

	},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValueField = promise._isFateSealed()
	            ? promise._settledValue() : undefined;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValueField = undefined;
	    }
	}

	PromiseInspection.prototype._settledValue = function() {
	    return this._settledValueField;
	};

	var value = PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};

	var reason = PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};

	var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
	    return (this._bitField & 33554432) !== 0;
	};

	var isRejected = PromiseInspection.prototype.isRejected = function () {
	    return (this._bitField & 16777216) !== 0;
	};

	var isPending = PromiseInspection.prototype.isPending = function () {
	    return (this._bitField & 50397184) === 0;
	};

	var isResolved = PromiseInspection.prototype.isResolved = function () {
	    return (this._bitField & 50331648) !== 0;
	};

	PromiseInspection.prototype.isCancelled = function() {
	    return (this._bitField & 8454144) !== 0;
	};

	Promise.prototype.__isCancelled = function() {
	    return (this._bitField & 65536) === 65536;
	};

	Promise.prototype._isCancelled = function() {
	    return this._target().__isCancelled();
	};

	Promise.prototype.isCancelled = function() {
	    return (this._target()._bitField & 8454144) !== 0;
	};

	Promise.prototype.isPending = function() {
	    return isPending.call(this._target());
	};

	Promise.prototype.isRejected = function() {
	    return isRejected.call(this._target());
	};

	Promise.prototype.isFulfilled = function() {
	    return isFulfilled.call(this._target());
	};

	Promise.prototype.isResolved = function() {
	    return isResolved.call(this._target());
	};

	Promise.prototype.value = function() {
	    return value.call(this._target());
	};

	Promise.prototype.reason = function() {
	    var target = this._target();
	    target._unsetRejectionIsUnhandled();
	    return reason.call(target);
	};

	Promise.prototype._value = function() {
	    return this._settledValue();
	};

	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue();
	};

	Promise.PromiseInspection = PromiseInspection;
	};

	},{}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util");
	var errorObj = util.errorObj;
	var isObject = util.isObject;

	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) return obj;
	        var then = getThen(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            if (isAnyBluebirdPromise(obj)) {
	                var ret = new Promise(INTERNAL);
	                obj._then(
	                    ret._fulfill,
	                    ret._reject,
	                    undefined,
	                    ret,
	                    null
	                );
	                return ret;
	            }
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}

	function doGetThen(obj) {
	    return obj.then;
	}

	function getThen(obj) {
	    try {
	        return doGetThen(obj);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    try {
	        return hasProp.call(obj, "_promise0");
	    } catch (e) {
	        return false;
	    }
	}

	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x, resolve, reject);
	    synchronous = false;

	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }

	    function resolve(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }

	    function reject(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	    return ret;
	}

	return tryConvertToPromise;
	};

	},{"./util":36}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, debug) {
	var util = _dereq_("./util");
	var TimeoutError = Promise.TimeoutError;

	function HandleWrapper(handle)  {
	    this.handle = handle;
	}

	HandleWrapper.prototype._resultCancelled = function() {
	    clearTimeout(this.handle);
	};

	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (ms, value) {
	    var ret;
	    var handle;
	    if (value !== undefined) {
	        ret = Promise.resolve(value)
	                ._then(afterValue, null, null, ms, undefined);
	        if (debug.cancellation() && value instanceof Promise) {
	            ret._setOnCancel(value);
	        }
	    } else {
	        ret = new Promise(INTERNAL);
	        handle = setTimeout(function() { ret._fulfill(); }, +ms);
	        if (debug.cancellation()) {
	            ret._setOnCancel(new HandleWrapper(handle));
	        }
	        ret._captureStackTrace();
	    }
	    ret._setAsyncGuaranteed();
	    return ret;
	};

	Promise.prototype.delay = function (ms) {
	    return delay(ms, this);
	};

	var afterTimeout = function (promise, message, parent) {
	    var err;
	    if (typeof message !== "string") {
	        if (message instanceof Error) {
	            err = message;
	        } else {
	            err = new TimeoutError("operation timed out");
	        }
	    } else {
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._reject(err);

	    if (parent != null) {
	        parent.cancel();
	    }
	};

	function successClear(value) {
	    clearTimeout(this.handle);
	    return value;
	}

	function failureClear(reason) {
	    clearTimeout(this.handle);
	    throw reason;
	}

	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret, parent;

	    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
	        if (ret.isPending()) {
	            afterTimeout(ret, message, parent);
	        }
	    }, ms));

	    if (debug.cancellation()) {
	        parent = this.then();
	        ret = parent._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	        ret._setOnCancel(handleWrapper);
	    } else {
	        ret = this._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	    }

	    return ret;
	};

	};

	},{"./util":36}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext, INTERNAL, debug) {
	    var util = _dereq_("./util");
	    var TypeError = _dereq_("./errors").TypeError;
	    var inherits = _dereq_("./util").inherits;
	    var errorObj = util.errorObj;
	    var tryCatch = util.tryCatch;
	    var NULL = {};

	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }

	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = new Promise(INTERNAL);
	        function iterator() {
	            if (i >= len) return ret._fulfill();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret;
	    }

	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }

	    Disposer.prototype.data = function () {
	        return this._data;
	    };

	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };

	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return NULL;
	    };

	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== NULL
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };

	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };

	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);

	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };

	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }

	    function ResourceList(length) {
	        this.length = length;
	        this.promise = null;
	        this[length-1] = null;
	    }

	    ResourceList.prototype._resultCancelled = function() {
	        var len = this.length;
	        for (var i = 0; i < len; ++i) {
	            var item = this[i];
	            if (item instanceof Promise) {
	                item.cancel();
	            }
	        }
	    };

	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") {
	            return apiRejection("expecting a function but got " + util.classString(fn));
	        }
	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new ResourceList(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }

	        var reflectedResources = new Array(resources.length);
	        for (var i = 0; i < reflectedResources.length; ++i) {
	            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
	        }

	        var resultPromise = Promise.all(reflectedResources)
	            .then(function(inspections) {
	                for (var i = 0; i < inspections.length; ++i) {
	                    var inspection = inspections[i];
	                    if (inspection.isRejected()) {
	                        errorObj.e = inspection.error();
	                        return errorObj;
	                    } else if (!inspection.isFulfilled()) {
	                        resultPromise.cancel();
	                        return;
	                    }
	                    inspections[i] = inspection.value();
	                }
	                promise._pushContext();

	                fn = tryCatch(fn);
	                var ret = spreadArgs
	                    ? fn.apply(undefined, inspections) : fn(inspections);
	                var promiseCreated = promise._popContext();
	                debug.checkForgottenReturns(
	                    ret, promiseCreated, "Promise.using", promise);
	                return ret;
	            });

	        var promise = resultPromise.lastly(function() {
	            var inspection = new Promise.PromiseInspection(resultPromise);
	            return dispose(resources, inspection);
	        });
	        resources.promise = promise;
	        promise._setOnCancel(resources);
	        return promise;
	    };

	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 131072;
	        this._disposer = disposer;
	    };

	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 131072) > 0;
	    };

	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };

	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~131072);
	        this._disposer = undefined;
	    };

	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };

	};

	},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5");
	var canEvaluate = typeof navigator == "undefined";

	var errorObj = {e: {}};
	var tryCatchTarget;
	var globalObject = typeof self !== "undefined" ? self :
	    typeof window !== "undefined" ? window :
	    typeof global !== "undefined" ? global :
	    this !== undefined ? this : null;

	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;

	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};


	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";

	}

	function isObject(value) {
	    return typeof value === "function" ||
	           typeof value === "object" && value !== null;
	}

	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;

	    return new Error(safeToString(maybeError));
	}

	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}

	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);

	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}

	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}

	function thrower(r) {
	    throw r;
	}

	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];

	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };

	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];

	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }

	})();

	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);

	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}

	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function FakeConstructor() {}
	    FakeConstructor.prototype = obj;
	    var l = 8;
	    while (l--) new FakeConstructor();
	    return obj;
	    eval(obj);
	}

	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}

	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}

	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}

	function isError(obj) {
	    return obj !== null &&
	           typeof obj === "object" &&
	           typeof obj.message === "string" &&
	           typeof obj.name === "string";
	}

	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}

	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}

	function canAttachTrace(obj) {
	    return isError(obj) && es5.propertyIsWritable(obj, "stack");
	}

	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();

	function classString(obj) {
	    return {}.toString.call(obj);
	}

	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}

	var asArray = function(v) {
	    if (es5.isArray(v)) {
	        return v;
	    }
	    return null;
	};

	if (typeof Symbol !== "undefined" && Symbol.iterator) {
	    var ArrayFrom = typeof Array.from === "function" ? function(v) {
	        return Array.from(v);
	    } : function(v) {
	        var ret = [];
	        var it = v[Symbol.iterator]();
	        var itResult;
	        while (!((itResult = it.next()).done)) {
	            ret.push(itResult.value);
	        }
	        return ret;
	    };

	    asArray = function(v) {
	        if (es5.isArray(v)) {
	            return v;
	        } else if (v != null && typeof v[Symbol.iterator] === "function") {
	            return ArrayFrom(v);
	        }
	        return null;
	    };
	}

	var isNode = typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]";

	function env(key, def) {
	    return isNode ? process.env[key] : def;
	}

	function getNativePromise() {
	    if (typeof Promise === "function") {
	        try {
	            var promise = new Promise(function(){});
	            if ({}.toString.call(promise) === "[object Promise]") {
	                return Promise;
	            }
	        } catch (e) {}
	    }
	}

	function domainBind(self, cb) {
	    return self.bind(cb);
	}

	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    asArray: asArray,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    isError: isError,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: isNode,
	    env: env,
	    global: globalObject,
	    getNativePromise: getNativePromise,
	    domainBind: domainBind
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();

	if (ret.isNode) ret.toFastProperties(process);

	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;

	},{"./es5":13}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(8), (function() { return this; }()), __webpack_require__(9).setImmediate))

/***/ },
/* 8 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(10).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).setImmediate, __webpack_require__(9).clearImmediate))

/***/ },
/* 10 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Browser Class
	 */
	var Browser = (function () {
	    function Browser(app) {
	        this.width = window.innerWidth;
	        this.height = window.innerHeight;
	        this.aspect = this.width / this.height;
	        this.pixelRatio = window.devicePixelRatio;
	        this.window = {
	            half: {
	                x: this.width / 2,
	                y: this.height / 2,
	            }
	        };
	        window.addEventListener('resize', this.resize.bind(this), false);
	    }
	    Browser.prototype.boot = function (_a) {
	        var camera = _a.camera, renderer = _a.renderer, canvas = _a.canvas;
	        this.camera = camera;
	        this.renderer = renderer;
	        this.canvas = canvas;
	        this.width = canvas.offsetWidth;
	        this.height = canvas.offsetHeight;
	        this.resize();
	    };
	    /**
	     * Set Half of the Screen
	     * @param x
	     * @param y
	     */
	    Browser.prototype.updateHalf = function (x, y) {
	        if (x === void 0) { x = (this.width / 2); }
	        if (y === void 0) { y = (this.height / 2); }
	        this.window.half.x = x;
	        this.window.half.y = y;
	    };
	    /**
	     * On Screen Resize
	     */
	    Browser.prototype.resize = function () {
	        this.updateHalf();
	        this.width = this.canvas.offsetWidth;
	        this.height = this.canvas.offsetHeight;
	        this.camera.aspect = this.width / this.height;
	        this.camera.updateProjectionMatrix();
	        this.renderer.setSize(this.width, this.height);
	    };
	    Browser.prototype.update = function (time, delta) { };
	    return Browser;
	}());
	exports.Browser = Browser;
	//# sourceMappingURL=Browser.js.map

/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Camera Class
	 */
	var Camera = (function (_super) {
	    __extends(Camera, _super);
	    function Camera() {
	        _super.apply(this, arguments);
	    }
	    Camera.prototype.boot = function (app) {
	        this.fov = 20;
	        this.aspect = app.browser.aspect;
	        this.near = 1;
	        this.far = 2000;
	        this.position.z = 500;
	        this.updateProjectionMatrix();
	    };
	    Camera.prototype.update = function (time, delta) {
	    };
	    /**
	     * Calculate view port size within a given distance
	     *
	     * @param distance
	     * @returns {width: number, height: number}
	     */
	    Camera.prototype.getViewSize = function (distance) {
	        var fov = this.fov * Math.PI / 180, depth = -(this.far / 2 + ((-(this.position.z / 2) - this.far / 2) / 100) * distance), height = 2 * Math.tan(fov / 2) * (this.position.z - depth), width = height * this.aspect;
	        return {
	            width: width, height: height, depth: depth
	        };
	    };
	    return Camera;
	}(THREE.PerspectiveCamera));
	exports.Camera = Camera;
	//# sourceMappingURL=Camera.js.map

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Helpers_1 = __webpack_require__(2);
	var Promise = __webpack_require__(7);
	/**
	 * Compositions Class
	 */
	var Compositions = (function () {
	    function Compositions() {
	        this.instances = {};
	        this.active = null;
	    }
	    Compositions.prototype.boot = function (application) {
	        this.app = application;
	        application.app.bootstrap(this.instances, Helpers_1.requireAll(__webpack_require__(14)), this.app);
	    };
	    /**
	     * get composition
	     *
	     * @param name
	     * @returns {any}
	     */
	    Compositions.prototype.get = function (name) {
	        for (var index in this.instances) {
	            if (this.instances[index].constructor.name.toLowerCase() === name) {
	                return this.instances[index];
	            }
	        }
	        throw "There is no composition called: " + name;
	    };
	    /**
	     * Start Composition
	     * @param compositionName
	     * @param payload
	     * @returns Promise
	     */
	    Compositions.prototype.start = function (compositionName, payload) {
	        var _this = this;
	        var composition = this.get(compositionName);
	        /**
	         * Setup The scene
	         */
	        if (typeof composition.setup === 'function') {
	            composition.setup.apply(composition, [this.app].concat(payload));
	        }
	        return Promise
	            .map(composition.objects, function (object) {
	            return _this.app.objects.get(object);
	        })
	            .then(function (objects) {
	            var objs = {};
	            objects.forEach(function (b) {
	                objs[b.name] = b;
	            });
	            composition.stage(objs);
	            return objs;
	        })
	            .then(function (objects) {
	            _this.active = { composition: composition, objects: objects };
	        });
	    };
	    /**
	     * Update Loop
	     * @param time
	     * @param delta
	     */
	    Compositions.prototype.update = function (time, delta) {
	        if (!this.active)
	            return;
	        this.active.composition.update(this.active.objects, time, delta);
	    };
	    return Compositions;
	}());
	exports.Compositions = Compositions;
	//# sourceMappingURL=Compositions.js.map

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./Intro.js": 15
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 14;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Composition_1 = __webpack_require__(16);
	var Tween_1 = __webpack_require__(17);
	var Helpers_1 = __webpack_require__(18);
	var Helpers_2 = __webpack_require__(19);
	/**
	 * Intro Composition
	 */
	var Intro = (function (_super) {
	    __extends(Intro, _super);
	    function Intro() {
	        _super.apply(this, arguments);
	        this.parallex = true;
	        this.mouse = false;
	        this.mouseInverse = false;
	        this.debrisCompleted = false;
	        this.queue = {};
	    }
	    Object.defineProperty(Intro.prototype, "objects", {
	        get: function () {
	            return [
	                'main',
	                'hexParticles',
	                'ship',
	                'debris',
	                'star',
	                'tunnel'
	            ];
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Intro.prototype.setup = function () {
	        // console.log('hi')
	    };
	    Intro.prototype.stage = function (objects) {
	        var ship = objects.ship, main = objects.main, hexParticles = objects.hexParticles, star = objects.star, tunnel = objects.tunnel;
	        // setTimeout(() => {
	        //     this.app.loader.load('/models/Actor.json').then(function (a) {
	        //         console.log('what next', a)
	        //     })
	        // }, 5000)
	        // artist3d.position.x = 30;
	        // this.configure(ship.getChildrenByName('background'), {
	        //     scale: 30,
	        //     position: {
	        //         x: 50,
	        //         y: 50,
	        //         z: 30
	        //     }
	        // })
	        this.scene.add(main);
	        this.scene.add(hexParticles);
	        this.scene.add(ship);
	        this.scene.add(star);
	        // this.scene.add(tunnel);
	        // this.camera
	        /**
	         * Queue Update
	         */
	        this.queue['ship'] = ship;
	        this.queue['hexParticles'] = hexParticles;
	        this.queue['star'] = star;
	        this.queue['tunnel'] = tunnel;
	        this.app.mouse.click(this.start.bind(this, objects));
	        // let gui = new dat.GUI();
	        // gui.add(this.camera.position, 'x', -2000, 2000);
	        // gui.add(this.camera.position, 'y', -2000, 2000);
	        // gui.add(this.camera.position, 'z', -2000, 2000);
	        // gui.add(this.camera.rotation, 'x', -Math.PI * 5, Math.PI * 5).step(0.1);
	        // gui.add(this.camera.rotation, 'y', -Math.PI * 5, Math.PI * 5).step(0.1);
	        // gui.add(this.camera.rotation, 'z', -Math.PI * 5, Math.PI * 5).step(0.1);
	        // console.log(hexParticles)
	        // Animator
	        //     .from(actor)
	        //     .play('idle')
	        //     .play('lookAround');
	        //
	        // Animator
	        //     .from(artist3d)
	        //     .play('idle')
	        //     .play('lookAround');
	    };
	    Intro.prototype.start = function (_a) {
	        var _this = this;
	        var ship = _a.ship, main = _a.main, hexParticles = _a.hexParticles, debris = _a.debris, star = _a.star;
	        var original = [
	            ship.position.clone(),
	            main.position.clone()
	        ];
	        var logo = ship.getObjectByName('logo'), camera = this.camera;
	        /**
	         * Animate Camera back to center point
	         */
	        var animation = this.app.tween.animate({
	            origin: this.camera.position,
	            target: {
	                x: 0, y: 0
	            },
	            duration: 1,
	            ease: Tween_1.Tween.SINEINOUT,
	            before: function () {
	                _this.parallex = false;
	            }
	        });
	        /**
	         * Animate spaceship up
	         */
	        animation.then({
	            origin: {
	                ship: logo.position,
	                main: main.position,
	                booster: ship.userData.booster,
	                speed: star.userData.speed,
	                decay: 0
	            },
	            target: {
	                decay: 5,
	                booster: -3,
	                speed: 2.5,
	                ship: { z: 20 },
	                main: {
	                    y: -main.getObjectByName('background').userData.meta.size.height
	                }
	            },
	            duration: 2,
	            ease: Tween_1.Tween.EXPOIN,
	            update: function (_a, completion, elapsed) {
	                var booster = _a.booster, speed = _a.speed, decay = _a.decay;
	                ship.userData.booster = booster.value;
	                star.userData.speed = speed.value;
	                star.material.opacity = speed.value > .8 ? .8 : speed.value < .2 ? .2 : speed.value;
	                hexParticles.userData.decay = decay.value;
	                return !_this.debrisCompleted;
	            },
	            after: function () {
	                _this.mouse = true;
	                _this.initDebris(debris);
	            }
	        });
	        /**
	         * Lets go to tunnel
	         */
	        animation.then({
	            origin: {
	                rotation: ship.rotation,
	                position: ship.position,
	                r: star.rotation,
	            },
	            target: {
	                r: {
	                    x: -Helpers_2.deg2rad(70)
	                },
	                position: {
	                    z: -300
	                },
	                rotation: {
	                    x: -Helpers_2.deg2rad(70)
	                }
	            },
	            ease: Tween_1.Tween.BACKOUT,
	            duration: 5,
	            before: function () {
	                star.userData.vortexEnabled = true;
	            },
	            after: function () {
	                _this.mouseInverse = true;
	            },
	        });
	    };
	    Intro.prototype.update = function (objects, time, delta) {
	        var mouse = this.app.mouse, camera = this.camera;
	        var hexParticles = objects.hexParticles, ship = objects.ship;
	        for (var property in this.queue) {
	            if (this.queue[property].userData.update(time)) {
	                if (Helpers_1.is.Function(this[(property + "Done")])) {
	                    this[(property + "Done")](objects);
	                }
	                delete this.queue[property];
	            }
	        }
	        /**
	        * Parallex
	        */
	        if (this.parallex) {
	            camera.position.set(mouse.normalized.x * 20, mouse.normalized.y * 20, 500);
	        }
	        /**
	        * Logo Follow Mouse
	        */
	        if (this.mouse) {
	            var logo = ship.getObjectByName('logo');
	            logo.position.x = mouse.screen.x * .1;
	            logo.position[this.mouseInverse ? 'z' : 'y'] = -mouse.screen.y * .1;
	        }
	    };
	    Intro.prototype.hexParticlesDone = function (_a) {
	        var hexParticles = _a.hexParticles;
	        this.scene.remove(hexParticles);
	    };
	    Intro.prototype.debrisDone = function (_a) {
	        var debris = _a.debris;
	        this.scene.remove(debris);
	        this.debrisCompleted = true;
	    };
	    Intro.prototype.initDebris = function (debris) {
	        this.scene.add(debris);
	        this.queue['debris'] = debris;
	    };
	    return Intro;
	}(Composition_1.Composition));
	exports.Intro = Intro;
	//# sourceMappingURL=Intro.js.map

/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Composition
	 */
	var Composition = (function () {
	    function Composition() {
	    }
	    /**
	     * This Method is no need to be implemented
	     * but it can be override if needed
	     * @param app
	     */
	    Composition.prototype.boot = function (app) {
	        this.app = app;
	        this.scene = app.scene;
	        this.camera = app.camera;
	        this.renderer = app.renderer;
	    };
	    ;
	    Object.defineProperty(Composition.prototype, "objects", {
	        /**
	         * List of objects to be loaded
	         * @returns {Array}
	         */
	        get: function () { },
	        enumerable: true,
	        configurable: true
	    });
	    return Composition;
	}());
	exports.Composition = Composition;
	//# sourceMappingURL=Composition.js.map

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Helpers_1 = __webpack_require__(18);
	var Helpers_2 = __webpack_require__(2);
	var Promise = __webpack_require__(7);
	/**
	 * Tween Class
	 */
	var Tween = (function () {
	    function Tween() {
	        this.pool = [];
	        this.promises = [];
	    }
	    Tween.prototype.boot = function () { };
	    Object.defineProperty(Tween.prototype, "defaults", {
	        get: function () {
	            return {
	                ease: Tween.LINEAR,
	                duration: 1,
	                begin: 0,
	                //Return false to break the update loop and release the animation
	                update: function (origin, data, completion, elapsed) {
	                    return false;
	                },
	                before: function () { },
	                after: function () { },
	                afterCalled: false
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    Tween.prototype.promise = function (options, defaults) {
	        var _this = this;
	        if (defaults === void 0) { defaults = this.defaults; }
	        return new Promise(function (resolve, reject) {
	            defaults['resolver'] = resolve;
	            defaults['container'] = _this.clone(options['origin'] || defaults['origin'], options.target);
	            defaults['clock'] = new THREE.Clock();
	            defaults['done'] = false;
	            defaults['result'] = null;
	            defaults['update'] = function () { return false; };
	            defaults['before'] = function () { return null; };
	            defaults['after'] = function () { return null; };
	            defaults['afterCalled'] = false;
	            var final = Helpers_2.extend(defaults, options);
	            final.before();
	            _this.pool.push(final);
	        });
	    };
	    Tween.prototype.animate = function (options) {
	        var _this = this;
	        var chain = {
	            running: false,
	            queue: [],
	            promise: this.promise(options),
	            process: function (result) {
	                if (!chain.queue.length) {
	                    return chain.promise;
	                }
	                var options = chain.queue.shift();
	                if (Helpers_1.is.Object(options)) {
	                    chain.promise = _this.promise(options, result);
	                    chain.promise.then(chain.process);
	                }
	                else if (Helpers_1.is.Function(options)) {
	                    /**
	                     * Allow break in a then
	                     */
	                    chain.promise.then(function (result) {
	                        /**
	                         * If return value is trully, stop the animation
	                         */
	                        if (!options(chain.process.bind(result))) {
	                            chain.promise.then(chain.process);
	                        }
	                    });
	                }
	                return chain.promise;
	            },
	            then: function (options, ease) {
	                if (ease) {
	                    options.ease = ease;
	                }
	                chain.queue.push(options);
	                if (!chain.running) {
	                    chain.running = true;
	                    chain.promise.then(chain.process);
	                }
	                return chain;
	            }
	        };
	        return chain;
	    };
	    Tween.prototype.looper = function (origin, target, container, callback, keys) {
	        if (container === void 0) { container = {}; }
	        if (callback === void 0) { callback = function (o, t, c, p) { }; }
	        if (keys === void 0) { keys = {}; }
	        for (var property in target) {
	            if (Helpers_1.is.Object(target[property])) {
	                this.looper(origin[property], target[property], container[property], callback, keys[property] = {});
	                continue;
	            }
	            else {
	                keys[property] = callback(origin, target, container, property) || origin[property];
	            }
	        }
	        return keys;
	    };
	    /**
	     * Copy param from Origin to new Object based on the Target Property
	     * Example: O => {A:1,B:2,C:3}, T => {B:50}, Result => {B:2}
	     */
	    Tween.prototype.clone = function (origin, target) {
	        return this.looper(origin, target);
	    };
	    Tween.prototype.process = function (original, origin, target, container, property) {
	        var clock = original.clock, duration = original.duration, begin = original.begin, ease = original.ease, elapsed = clock.getElapsedTime(), completion = (elapsed / duration) * 100;
	        if (elapsed >= duration) {
	            /**
	             * If time up, set the end position
	             */
	            origin[property] = target[property];
	        }
	        else {
	            origin[property] = container[property] - this[ease](elapsed, begin, container[property] - target[property], duration);
	        }
	        return {
	            complete: completion >= 100 ? true : false,
	            completion: completion,
	            value: origin[property]
	        };
	    };
	    Tween.prototype.analizer = function (data) {
	        var _this = this;
	        if (!data)
	            return false;
	        if (data.hasOwnProperty('complete')) {
	            return data.complete;
	        }
	        return Object.keys(data).map(function (prop) {
	            if (Helpers_1.is.Object(data[prop])) {
	                return _this.analizer(data[prop]);
	            }
	            return data[prop].complete;
	        }).reduce(function (previousValue, currentValue, index, array) {
	            return previousValue || currentValue;
	        });
	    };
	    /**
	     * Update Animations
	     * @param time
	     * @param delta
	     */
	    Tween.prototype.update = function (time, delta) {
	        var _this = this;
	        if (!this.pool.length) {
	            return;
	        }
	        this.pool.forEach(function (item, index) {
	            var elapsed = item.clock.getElapsedTime(), completion = (elapsed / item.duration) * 100;
	            if (!(item.done = _this.analizer(item.result || null)) && completion < 100) {
	                item.result = _this.looper(item.origin, item.target, item.container, function (o, t, c, p) {
	                    return _this.process(item, o, t, c, p);
	                });
	            }
	            var done = item.update(item.result, completion, elapsed);
	            /**
	             * IF its only waiting for the update to finish.. call after meanwhile
	             */
	            if (completion >= 100 && !item.afterCalled || item.done) {
	                item.after();
	                item.afterCalled = true;
	            }
	            if (completion >= 100 && !done || item.done) {
	                item.clock.stop();
	                item.resolver(item);
	                _this.pool.splice(index, 1);
	            }
	        });
	    };
	    Tween.prototype.backIn = function (time, begin, change, duration, overshoot) {
	        if (overshoot == null)
	            overshoot = Tween.OVERSHOOT;
	        return change * (time /= duration) * time * ((overshoot + 1) * time - overshoot) + begin;
	    };
	    Tween.prototype.backOut = function (time, begin, change, duration, overshoot) {
	        if (overshoot == null)
	            overshoot = Tween.OVERSHOOT;
	        return change * ((time = time / duration - 1) * time * ((overshoot + 1) * time + overshoot) + 1) + begin;
	    };
	    Tween.prototype.backInOut = function (time, begin, change, duration, overshoot) {
	        if (overshoot == null)
	            overshoot = Tween.OVERSHOOT;
	        if ((time = time / (duration / 2)) < 1) {
	            return change / 2 * (time * time * (((overshoot *= 1.525) + 1) * time - overshoot)) + begin;
	        }
	        return change / 2 * ((time -= 2) * time * (((overshoot *= 1.525) + 1) * time + overshoot) + 2) + begin;
	    };
	    Tween.prototype.bounceOut = function (time, begin, change, duration) {
	        if ((time /= duration) < 1 / 2.75) {
	            return change * (7.5625 * time * time) + begin;
	        }
	        else if (time < 2 / 2.75) {
	            return change * (7.5625 * (time -= 1.5 / 2.75) * time + 0.75) + begin;
	        }
	        else if (time < 2.5 / 2.75) {
	            return change * (7.5625 * (time -= 2.25 / 2.75) * time + 0.9375) + begin;
	        }
	        return change * (7.5625 * (time -= 2.625 / 2.75) * time + 0.984375) + begin;
	    };
	    Tween.prototype.bounceIn = function (time, begin, change, duration) {
	        return change - this.bounceOut(duration - time, 0, change, duration) + begin;
	    };
	    Tween.prototype.bounceInOut = function (time, begin, change, duration) {
	        if (time < duration / 2) {
	            return this.bounceIn(time * 2, 0, change, duration) * 0.5 + begin;
	        }
	        return this.bounceOut(time * 2 - duration, 0, change, duration) * 0.5 + change * 0.5 + begin;
	    };
	    Tween.prototype.circIn = function (time, begin, change, duration) {
	        return -change * (Math.sqrt(1 - (time = time / duration) * time) - 1) + begin;
	    };
	    Tween.prototype.circOut = function (time, begin, change, duration) {
	        return change * Math.sqrt(1 - (time = time / duration - 1) * time) + begin;
	    };
	    Tween.prototype.circInOut = function (time, begin, change, duration) {
	        if ((time = time / (duration / 2)) < 1) {
	            return -change / 2 * (Math.sqrt(1 - time * time) - 1) + begin;
	        }
	        return change / 2 * (Math.sqrt(1 - (time -= 2) * time) + 1) + begin;
	    };
	    Tween.prototype.cubicIn = function (time, begin, change, duration) {
	        return change * (time /= duration) * time * time + begin;
	    };
	    Tween.prototype.cubicOut = function (time, begin, change, duration) {
	        return change * ((time = time / duration - 1) * time * time + 1) + begin;
	    };
	    Tween.prototype.cubicInOut = function (time, begin, change, duration) {
	        if ((time = time / (duration / 2)) < 1) {
	            return change / 2 * time * time * time + begin;
	        }
	        return change / 2 * ((time -= 2) * time * time + 2) + begin;
	    };
	    Tween.prototype.elasticOut = function (time, begin, change, duration, amplitude, period) {
	        var overshoot;
	        if (time === 0) {
	            return begin;
	        }
	        else if ((time = time / duration) === 1) {
	            return begin + change;
	        }
	        if (!(period != null)) {
	            period = duration * 0.3;
	        }
	        if (!(amplitude != null) || amplitude < Math.abs(change)) {
	            amplitude = change;
	            overshoot = period / 4;
	        }
	        overshoot = period / (2 * Math.PI) * Math.asin(change / amplitude);
	        return (amplitude * Math.pow(2, -10 * time)) * Math.sin((time * duration - overshoot) * (2 * Math.PI) / period) + change + begin;
	    };
	    Tween.prototype.elasticIn = function (time, begin, change, duration, amplitude, period) {
	        var overshoot;
	        if (time === 0) {
	            return begin;
	        }
	        else if ((time = time / duration) === 1) {
	            return begin + change;
	        }
	        if (!(period != null)) {
	            period = duration * 0.3;
	        }
	        if (!(amplitude != null) || amplitude < Math.abs(change)) {
	            amplitude = change;
	            overshoot = period / 4;
	        }
	        overshoot = period / (2 * Math.PI) * Math.asin(change / amplitude);
	        time -= 1;
	        return -(amplitude * Math.pow(2, 10 * time)) * Math.sin((time * duration - overshoot) * (2 * Math.PI) / period) + begin;
	    };
	    Tween.prototype.elasticInOut = function (time, begin, change, duration, amplitude, period) {
	        var overshoot;
	        if (time === 0) {
	            return begin;
	        }
	        else if ((time = time / (duration / 2)) === 2) {
	            return begin + change;
	        }
	        if (!(period != null)) {
	            period = duration * (0.3 * 1.5);
	        }
	        if (!(amplitude != null) || amplitude < Math.abs(change)) {
	            amplitude = change;
	            overshoot = period / 4;
	        }
	        overshoot = period / (2 * Math.PI) * Math.asin(change / amplitude);
	        if (time < 1) {
	            return -0.5 * (amplitude * Math.pow(2, 10 * (time -= 1))) * Math.sin((time * duration - overshoot) * ((2 * Math.PI) / period)) + begin;
	        }
	        return amplitude * Math.pow(2, -10 * (time -= 1)) * Math.sin((time * duration - overshoot) * (2 * Math.PI) / period) + change + begin;
	    };
	    Tween.prototype.expoIn = function (time, begin, change, duration) {
	        if (time === 0) {
	            return begin;
	        }
	        return change * Math.pow(2, 10 * (time / duration - 1)) + begin;
	    };
	    Tween.prototype.expoOut = function (time, begin, change, duration) {
	        if (time === duration) {
	            return begin + change;
	        }
	        return change * (-Math.pow(2, -10 * time / duration) + 1) + begin;
	    };
	    Tween.prototype.expoInOut = function (time, begin, change, duration) {
	        if (time === 0) {
	            return begin;
	        }
	        else if (time === duration) {
	            return begin + change;
	        }
	        else if ((time = time / (duration / 2)) < 1) {
	            return change / 2 * Math.pow(2, 10 * (time - 1)) + begin;
	        }
	        return change / 2 * (-Math.pow(2, -10 * (time - 1)) + 2) + begin;
	    };
	    Tween.prototype.linear = function (time, begin, change, duration) {
	        return change * time / duration + begin;
	    };
	    Tween.prototype.linearIn = function (time, begin, change, duration) {
	        return this.linear(time, begin, change, duration);
	    };
	    Tween.prototype.linearOut = function (time, begin, change, duration) {
	        return this.linear(time, begin, change, duration);
	    };
	    Tween.prototype.linearInOut = function (time, begin, change, duration) {
	        return this.linear(time, begin, change, duration);
	    };
	    Tween.prototype.quadIn = function (time, begin, change, duration) {
	        return change * (time = time / duration) * time + begin;
	    };
	    Tween.prototype.quadOut = function (time, begin, change, duration) {
	        return -change * (time = time / duration) * (time - 2) + begin;
	    };
	    Tween.prototype.quadInOut = function (time, begin, change, duration) {
	        if ((time = time / (duration / 2)) < 1) {
	            return change / 2 * time * time + begin;
	        }
	        return -change / 2 * ((time -= 1) * (time - 2) - 1) + begin;
	    };
	    Tween.prototype.quartIn = function (time, begin, change, duration) {
	        return change * (time = time / duration) * time * time * time + begin;
	    };
	    Tween.prototype.quartOut = function (time, begin, change, duration) {
	        return -change * ((time = time / duration - 1) * time * time * time - 1) + begin;
	    };
	    Tween.prototype.quartInOut = function (time, begin, change, duration) {
	        if ((time = time / (duration / 2)) < 1) {
	            return change / 2 * time * time * time * time + begin;
	        }
	        return -change / 2 * ((time -= 2) * time * time * time - 2) + begin;
	    };
	    Tween.prototype.quintIn = function (time, begin, change, duration) {
	        return change * (time = time / duration) * time * time * time * time + begin;
	    };
	    Tween.prototype.quintOut = function (time, begin, change, duration) {
	        return change * ((time = time / duration - 1) * time * time * time * time + 1) + begin;
	    };
	    Tween.prototype.quintInOut = function (time, begin, change, duration) {
	        if ((time = time / (duration / 2)) < 1) {
	            return change / 2 * time * time * time * time * time + begin;
	        }
	        return change / 2 * ((time -= 2) * time * time * time * time + 2) + begin;
	    };
	    Tween.prototype.sineIn = function (time, begin, change, duration) {
	        return -change * Math.cos(time / duration * (Math.PI / 2)) + change + begin;
	    };
	    Tween.prototype.sineOut = function (time, begin, change, duration) {
	        return change * Math.sin(time / duration * (Math.PI / 2)) + begin;
	    };
	    Tween.prototype.sineInOut = function (time, begin, change, duration) {
	        return -change / 2 * (Math.cos(Math.PI * time / duration) - 1) + begin;
	    };
	    Tween.OVERSHOOT = 1.70158;
	    Tween.BACKIN = 'backIn';
	    Tween.BACKOUT = 'backOut';
	    Tween.BACKINOUT = 'backInOut';
	    Tween.BOUNCEOUT = 'bounceOut';
	    Tween.BOUNCEIN = 'bounceIn';
	    Tween.BOUNCEINOUT = 'bounceInOut';
	    Tween.CIRCIN = 'circIn';
	    Tween.CIRCOUT = 'circOut';
	    Tween.CIRCINOUT = 'circInOut';
	    Tween.CUBICIN = 'cubicIn';
	    Tween.CUBICOUT = 'cubicOut';
	    Tween.CUBICINOUT = 'cubicInOut';
	    Tween.ELASTICOUT = 'elasticOut';
	    Tween.ELASTICIN = 'elasticIn';
	    Tween.ELASTICINOUT = 'elasticInOut';
	    Tween.EXPOIN = 'expoIn';
	    Tween.EXPOOUT = 'expoOut';
	    Tween.EXPOINOUT = 'expoInOut';
	    Tween.LINEAR = 'linear';
	    Tween.LINEARIN = 'linearIn';
	    Tween.LINEAROUT = 'linearOut';
	    Tween.LINEARINOUT = 'linearInOut';
	    Tween.QUADIN = 'quadIn';
	    Tween.QUADOUT = 'quadOut';
	    Tween.QUADINOUT = 'quadInOut';
	    Tween.QUARTIN = 'quartIn';
	    Tween.QUARTOUT = 'quartOut';
	    Tween.QUARTINOUT = 'quartInOut';
	    Tween.QUINTIN = 'quintIn';
	    Tween.QUINTOUT = 'quintOut';
	    Tween.QUINTINOUT = 'quintInOut';
	    Tween.SINEIN = 'sineIn';
	    Tween.SINEOUT = 'sineOut';
	    Tween.SINEINOUT = 'sineInOut';
	    return Tween;
	}());
	exports.Tween = Tween;
	//# sourceMappingURL=Tween.js.map

/***/ },
/* 18 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Get Extension of file thought the path
	 * @param path
	 * @returns {any}
	 */
	exports.extension = function (path) {
	    return path.slice((path.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
	};
	exports.countKeys = function (object) {
	    var count = 0;
	    for (var k in object)
	        if (object.hasOwnProperty(k))
	            ++count;
	    return count;
	};
	// export var map = function (obj: any, callback: (value, property) => any): {} {
	//     var instance = {};
	//     for (let property in obj) {
	//         if (is.Object(obj[property])) {
	//             return map(obj[property], callback)
	//         } else {
	//             instance[property] = callback(obj[property], property);
	//         }
	//     }
	//     return instance;
	// }
	exports.random = function (min, max) {
	    var l_ValueMin = min;
	    var l_ValueMax = max;
	    if (typeof (min) == "string")
	        l_ValueMin = parseInt(min);
	    if (typeof (max) == "string")
	        l_ValueMax = parseInt(max);
	    return Math.floor(Math.random() * (l_ValueMax - l_ValueMin + 1)) + l_ValueMin;
	};
	/**
	 * Zip two arrays to an keyed object
	 *  [1,2,3] [a,b,c] => {a:1, b:2, c:3}
	 * @param values
	 * @param keys
	 * @returns {any}
	 */
	exports.zip = function (values, keys) {
	    return Object.assign.apply(Object, [{}].concat(keys.map(function (n, index) { return ((_a = {}, _a[n] = values[index], _a)); var _a; })));
	};
	/**
	 * Checker if obj is of a X type
	 */
	var is = (function () {
	    function is() {
	    }
	    /**
	     * Check if it's an Array
	     */
	    is.Array = function (item) {
	        return Array.isArray(item);
	    };
	    /**
	     * Check if it's an Object
	     */
	    is.Object = function (item) {
	        return (typeof item === "object" && !Array.isArray(item) && item !== null);
	    };
	    /**
	     * Check if it's Null
	     */
	    is.Null = function (item) {
	        return (item === null || item === undefined || item === 0 || item === '0');
	    };
	    /**
	     * Check if it's a Function
	     */
	    is.Function = function (item) {
	        return !!(item && item.constructor && item.call && item.apply);
	    };
	    return is;
	}());
	exports.is = is;
	//cloud
	//let l_Var = new findSuitObjectByProbability(0,totalValue);
	//push as many as you want
	//l_Var.addProbability()....
	//l_Var.getIndex();
	var findSuitObjectByProbability = (function () {
	    function findSuitObjectByProbability() {
	        this.m_ProbabilityWeightArray = [];
	        this.m_MaxValue = 0;
	    }
	    findSuitObjectByProbability.prototype.addProbability = function (e_Weight) {
	        var l_Weight = e_Weight;
	        if (typeof (e_Weight) == "string")
	            l_Weight = parseInt(e_Weight);
	        this.m_ProbabilityWeightArray.push(l_Weight);
	        this.m_MaxValue += l_Weight;
	    };
	    findSuitObjectByProbability.prototype.getIndex = function () {
	        console.log("max value " + this.m_MaxValue);
	        var l_TargetValue = exports.random(0, this.m_MaxValue);
	        console.log("target value " + l_TargetValue);
	        var l_Length = this.m_ProbabilityWeightArray.length;
	        var l_CurrentValue = 0;
	        for (var i = 0; i < l_Length; ++i) {
	            var l_CurrentWeight = this.m_ProbabilityWeightArray[i];
	            l_CurrentValue += l_CurrentWeight;
	            console.log("current value " + l_CurrentValue);
	            if (l_CurrentValue >= l_TargetValue) {
	                console.log("target index is " + i);
	                return i;
	            }
	        }
	        //it should't happen
	        return -1;
	    };
	    return findSuitObjectByProbability;
	}());
	exports.findSuitObjectByProbability = findSuitObjectByProbability;
	//# sourceMappingURL=Helpers.js.map

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * Configure the material
	 *
	 * @param material
	 * @param x
	 * @param y
	 * @param width
	 * @param height
	 * @param base
	 * @returns {THREE.MeshBasicMaterial}
	 */
	exports.configureMaterial = function (material, _a, base) {
	    var x = _a.x, y = _a.y, width = _a.width, height = _a.height, sprite = _a.sprite;
	    if (base === void 0) { base = 2048; }
	    var tex = material.userData ? material.userData[sprite.name] : material.map;
	    var clone = material.clone(), texture = tex.clone();
	    texture.repeat.set(width / base, height / base);
	    texture.offset.set(x / base, (base - (y + height)) / base);
	    clone.map = texture;
	    texture.needsUpdate = true;
	    return clone;
	};
	exports.sprite = function (name) {
	    return __webpack_require__(20)[name];
	};
	// export var configureTexture = (texture: THREE.Texture, name: string, base: number = 2048) => {
	//     let {x, y, width, height} = sprite(name);
	//     texture.repeat.set(width / base, height / base);
	//     texture.offset.set(x / base, (base - (y + height)) / base);
	//     texture.needsUpdate = true;
	//     return texture;
	// }
	/**
	 * Convert proportionally a given width/height
	 *
	 * @param targetWidth
	 * @param targetHeight
	 * @param currentWidth
	 * @param currentHeight
	 * @returns {width: number, height: number}
	 */
	exports.resize = function (targetWidth, targetHeight, currentWidth, currentHeight, scale) {
	    if (scale === void 0) { scale = 100; }
	    var ratio = Math.min(targetWidth / currentWidth, targetHeight / currentHeight);
	    return {
	        width: (currentWidth * ratio) * (scale * 0.01),
	        height: (currentHeight * ratio) * (scale * 0.01)
	    };
	};
	/**
	 * Convert degrees to radians
	 */
	exports.deg2rad = function (degrees) {
	    return (degrees * Math.PI / 180);
	};
	/**
	 * Generate random elements
	 */
	var random = (function () {
	    function random() {
	    }
	    /**
	     * Generate random number between a given min and max
	     */
	    random.between = function (min, max) {
	        return (Math.random() * ((max + 1) - min)) + min;
	    };
	    /**
	     * Generate Random Vector3 object
	     *
	     * @param x - number
	     * @param y - number
	     * @param z - number
	     * @param distance or radius
	     * @param stick - stick to a surface or get free-style
	     */
	    random.vector3 = function (x, y, z, distance, stick) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (distance === void 0) { distance = 0; }
	        if (stick === void 0) { stick = false; }
	        // Coordinates
	        var u1 = Math.random() * 2 - 1, u2 = Math.random(), radius = Math.sqrt(1 - u1 * u1), theta = 2 * Math.PI * u2;
	        // Stick to surface or disperse inside sphere
	        if (!stick)
	            distance = Math.random() * distance;
	        return new THREE.Vector3(radius * Math.cos(theta) * distance + x, radius * Math.sin(theta) * distance + y, u1 * distance + z);
	    };
	    return random;
	}());
	exports.random = random;
	//# sourceMappingURL=Helpers.js.map

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = {
		"background": {
			"name": "background",
			"width": 2012,
			"height": 1326,
			"sprite": {
				"name": "sprite-1.png",
				"width": 2012,
				"height": 2012
			},
			"x": 0,
			"y": 0
		},
		"platform": {
			"name": "platform",
			"width": 914,
			"height": 561,
			"sprite": {
				"name": "sprite-1.png",
				"width": 914,
				"height": 914
			},
			"x": 0,
			"y": 1326
		},
		"ship": {
			"name": "ship",
			"width": 512,
			"height": 512,
			"sprite": {
				"name": "sprite-1.png",
				"width": 1426,
				"height": 1426
			},
			"x": 914,
			"y": 1326
		},
		"planet": {
			"name": "planet",
			"width": 208,
			"height": 197,
			"sprite": {
				"name": "sprite-1.png",
				"width": 1634,
				"height": 1634
			},
			"x": 1426,
			"y": 1326
		},
		"fast-star": {
			"name": "fast-star",
			"width": 34,
			"height": 121,
			"sprite": {
				"name": "sprite-1.png",
				"width": 2046,
				"height": 2046
			},
			"x": 2012,
			"y": 0
		},
		"hex": {
			"name": "hex",
			"width": 84,
			"height": 91,
			"sprite": {
				"name": "sprite-1.png",
				"width": 1718,
				"height": 1718
			},
			"x": 1634,
			"y": 1326
		},
		"star": {
			"name": "star",
			"width": 55,
			"height": 55,
			"sprite": {
				"name": "sprite-1.png",
				"width": 1773,
				"height": 1773
			},
			"x": 1718,
			"y": 1326
		}
	};

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Stats = __webpack_require__(22);
	/**
	 * Debugger Class
	 */
	var Debugger = (function () {
	    function Debugger() {
	        this.stats = new Stats();
	        this.stats.showPanel(0);
	        document.body.appendChild(this.stats.dom);
	    }
	    Debugger.prototype.boot = function (app) {
	    };
	    Debugger.prototype.update = function (time, delta) {
	        this.stats.update();
	    };
	    return Debugger;
	}());
	exports.Debugger = Debugger;
	//# sourceMappingURL=Debugger.js.map

/***/ },
/* 22 */
/***/ function(module, exports) {

	// stats.js - http://github.com/mrdoob/stats.js
	var Stats=function(){function h(a){c.appendChild(a.dom);return a}function k(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();k(++l%c.children.length)},!1);var g=(performance||Date).now(),e=g,a=0,r=h(new Stats.Panel("FPS","#0ff","#002")),f=h(new Stats.Panel("MS","#0f0","#020"));
	if(self.performance&&self.performance.memory)var t=h(new Stats.Panel("MB","#f08","#201"));k(0);return{REVISION:16,dom:c,addPanel:h,showPanel:k,begin:function(){g=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();f.update(c-g,200);if(c>e+1E3&&(r.update(1E3*a/(c-e),100),e=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){g=this.end()},domElement:c,setMode:k}};
	Stats.Panel=function(h,k,l){var c=Infinity,g=0,e=Math.round,a=e(window.devicePixelRatio||1),r=80*a,f=48*a,t=3*a,u=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=f;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,f);b.fillStyle=k;b.fillText(h,t,u);b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(f,
	v){c=Math.min(c,f);g=Math.max(g,f);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=k;b.fillText(e(f)+" "+h+" ("+e(c)+"-"+e(g)+")",t,u);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,e((1-f/v)*p))}}};"object"===typeof module&&(module.exports=Stats);


/***/ },
/* 23 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Class Light
	 */
	var Light = (function () {
	    function Light() {
	    }
	    Light.prototype.boot = function (app) {
	        this.scene = app.scene;
	        this.camera = app.camera;
	        var light = new THREE.AmbientLight(0xffffff);
	        light.intensity = .9;
	        var hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, 1);
	        var ambientLight = new THREE.AmbientLight(0xf0ecf6, 1);
	        // let hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, .9),
	        //     ambientLight = new THREE.AmbientLight(0xffffff, .3),
	        var shadowLight = new THREE.DirectionalLight(0xffffff, 1);
	        shadowLight.name = 'shadowLight';
	        shadowLight.position.set(0, 100, -350);
	        shadowLight.castShadow = true;
	        // hemisphereLight.position.setZ(-300)
	        // hemisphereLight.position.setZ(-300)
	        var shadow = new THREE.LightShadow(this.camera);
	        shadowLight.position.set(100, 100, -300);
	        var left = shadowLight.clone();
	        left.intensity = 2.5;
	        left.position.set(100, 0, 100);
	        left.color.setHex(0xafe1fe);
	        var right = shadowLight.clone();
	        right.intensity = 3;
	        right.position.set(-100, 0, -100);
	        right.color.setHex(0xfef1af);
	        this.scene.add(ambientLight, shadowLight, left, right);
	    };
	    Light.prototype.update = function (time, delta) { };
	    return Light;
	}());
	exports.Light = Light;
	//# sourceMappingURL=Light.js.map

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Helpers_1 = __webpack_require__(18);
	var Promise = __webpack_require__(7);
	/**
	 * Loader Class
	 */
	var Loader = (function () {
	    function Loader() {
	        /**
	         * Keep Track of all promises made.. its just like a cache..
	         */
	        this.promises = {};
	    }
	    Loader.prototype.boot = function (_a) {
	        var manager = _a.manager;
	        this.json = new THREE.JSONLoader(manager);
	        this.anim = new THREE.XHRLoader(manager);
	        this.obj = new THREE.ObjectLoader(manager);
	        var imageLoader = new THREE.TextureLoader(manager);
	        this.png = imageLoader;
	        this.jpg = imageLoader;
	    };
	    Loader.prototype.load = function (path) {
	        var _this = this;
	        var loader = Helpers_1.extension(path);
	        if (!this.hasOwnProperty(loader))
	            throw "Unknown loader: " + loader;
	        /**
	         * If Promise has already been made... then... just give it back..
	         */
	        if (this.promises.hasOwnProperty(path))
	            return this.promises[path];
	        return this.promises[path] = new Promise(function (accept, reject) {
	            _this[loader].load(path, function (object, material) {
	                /**
	                 * Parse Json if loader is anim
	                 */
	                if (loader === 'anim')
	                    object = JSON.parse(object);
	                accept(object, material);
	            }, _this.progress, reject);
	        });
	    };
	    Loader.prototype.progress = function (event) {
	    };
	    Loader.prototype.update = function (time, delta) {
	    };
	    return Loader;
	}());
	exports.Loader = Loader;
	//# sourceMappingURL=Loader.js.map

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Initializable_1 = __webpack_require__(26);
	var Helpers_1 = __webpack_require__(2);
	/**
	 * Animation Class
	 */
	var Animation = (function (_super) {
	    __extends(Animation, _super);
	    function Animation() {
	        _super.apply(this, arguments);
	        this.instances = {};
	        this.mixers = [];
	    }
	    Object.defineProperty(Animation.prototype, "collection", {
	        get: function () {
	            return function () { };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Animation.prototype.initialize = function (path) {
	        return this.app.loader.load(path);
	    };
	    /**
	     * Create a new Animation
	     *
	     * @param mesh
	     */
	    Animation.prototype.create = function (root, bones, animations) {
	        var mixer = new THREE.AnimationMixer(root), parsed = {};
	        this.mixers.push(mixer);
	        var _loop_1 = function(track) {
	            animations[track].forEach(function (anim) {
	                parsed[Helpers_1.toCamelCase(anim.name)] = mixer.clipAction(THREE.AnimationClip.parseAnimation(anim, bones, track));
	            });
	        };
	        for (var track in animations) {
	            _loop_1(track);
	        }
	        return parsed;
	    };
	    /**
	     * Update Animations
	     *
	     * @param time
	     * @param delta
	     */
	    Animation.prototype.update = function (time, delta) {
	        if (this.mixers.length > 0) {
	            for (var i = 0; i < this.mixers.length; i++) {
	                this.mixers[i].update(delta);
	            }
	        }
	    };
	    return Animation;
	}(Initializable_1.Initializable));
	exports.Animation = Animation;
	//# sourceMappingURL=Animation.js.map

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Helpers_1 = __webpack_require__(2);
	var Helpers_2 = __webpack_require__(18);
	var Promise = __webpack_require__(7);
	/**
	 * Initializable Class
	 */
	var Initializable = (function () {
	    function Initializable() {
	        this.hasCollection = Object.keys(this.collection).length !== 0;
	    }
	    Object.defineProperty(Initializable.prototype, "collection", {
	        /**
	         * Public properties that must to be overridden
	         */
	        get: function () { },
	        enumerable: true,
	        configurable: true
	    });
	    Initializable.prototype.boot = function (app) {
	        var _this = this;
	        this.app = app;
	        /**
	         * If Collection is empty, then don't attempt to load it
	         */
	        if (!this.hasCollection)
	            return;
	        Helpers_1.requireAll(this.collection).forEach(function (object) {
	            for (var name_1 in object) {
	                _this.instances[Helpers_1.toCamelCase(name_1)] = {
	                    loaded: false,
	                    instance: null,
	                    constructor: object[name_1]
	                };
	            }
	        });
	    };
	    /**
	     * Get Object by its name
	     *
	     * @param object
	     * @returns {"bluebird".Bluebird}
	     */
	    Initializable.prototype.get = function (object) {
	        var _this = this;
	        var name = Helpers_1.toCamelCase(object);
	        return new Promise(function (accept, reject) {
	            if (_this.instances.hasOwnProperty(name)) {
	                /**
	                 * If already loaded send it
	                 */
	                if (_this.instances[name].loaded) {
	                    return accept(_this.instances[name].instance);
	                }
	                return _this
	                    .initialize(new _this.instances[name].constructor(_this.app))
	                    .then(function (instance) {
	                    _this.instances[name].instance = instance;
	                    _this.instances[name].loaded = true;
	                    instance.name = name;
	                    accept(instance);
	                });
	            }
	            if (!_this.hasCollection) {
	                return _this
	                    .initialize(object)
	                    .then(function (instance) {
	                    _this.instances[name] = {
	                        instance: instance,
	                        loaded: true,
	                        constructor: null
	                    };
	                    instance.name = name;
	                    accept(instance);
	                });
	            }
	            throw "object doesnt contain own property " + name;
	        });
	    };
	    /**
	     * Load objects
	     *
	     * @param objects
	     * @returns {Bluebird<U>}
	     */
	    Initializable.prototype.load = function (objects) {
	        var _this = this;
	        var keys = Object.keys(objects), items = keys.map(function (key) { return objects[key]; });
	        return Promise
	            .map(items, function (item) { return _this.get(item); })
	            .then(function (resolutions) { return Helpers_2.zip(resolutions, keys); });
	    };
	    return Initializable;
	}());
	exports.Initializable = Initializable;
	//# sourceMappingURL=Initializable.js.map

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Initializable_1 = __webpack_require__(26);
	var Helpers_1 = __webpack_require__(18);
	var Promise = __webpack_require__(7);
	/**
	 * Material Class
	 */
	var Material = (function (_super) {
	    __extends(Material, _super);
	    function Material() {
	        _super.apply(this, arguments);
	        this.instances = {};
	    }
	    Object.defineProperty(Material.prototype, "collection", {
	        get: function () {
	            return __webpack_require__(28);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Material.prototype.initialize = function (instance) {
	        var _this = this;
	        var promises = [], keys = Object.keys(instance.textures);
	        keys.forEach(function (key) { return promises.push(_this.app.loader.load(instance.textures[key])); });
	        return Promise
	            .all(promises)
	            .then(function (resolutions) { return instance.create(Helpers_1.zip(resolutions, keys)); });
	    };
	    Material.prototype.update = function (time, delta) { };
	    return Material;
	}(Initializable_1.Initializable));
	exports.Material = Material;
	//# sourceMappingURL=Material.js.map

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./CharacterDefaultMaterial.js": 29,
		"./IntroDefaultMaterial.js": 30,
		"./PointsMaterial.js": 31,
		"./ShaderMaterial.js": 32
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 28;


/***/ },
/* 29 */
/***/ function(module, exports) {

	"use strict";
	var CharacterDefaultMaterial = (function () {
	    function CharacterDefaultMaterial() {
	    }
	    Object.defineProperty(CharacterDefaultMaterial.prototype, "textures", {
	        get: function () {
	            return {
	                texture: '/models/texture.png',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CharacterDefaultMaterial.prototype.create = function (_a) {
	        var texture = _a.texture;
	        return new THREE.MeshStandardMaterial({
	            skinning: true,
	            shading: THREE.FlatShading,
	            roughness: 1,
	            metalness: 1,
	            map: texture
	        });
	    };
	    return CharacterDefaultMaterial;
	}());
	exports.CharacterDefaultMaterial = CharacterDefaultMaterial;
	//# sourceMappingURL=CharacterDefaultMaterial.js.map

/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";
	var IntroDefaultMaterial = (function () {
	    function IntroDefaultMaterial() {
	    }
	    Object.defineProperty(IntroDefaultMaterial.prototype, "textures", {
	        get: function () {
	            return {
	                'sprite-1.png': '/assets/img/sprite-1.png',
	                'sprite-2.png': '/assets/img/sprite-2.png',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    IntroDefaultMaterial.prototype.create = function (textures) {
	        var material = new THREE.MeshBasicMaterial({
	            // map: textures['sprite-1.png'],
	            transparent: true,
	        });
	        material['userData'] = textures;
	        return material;
	    };
	    return IntroDefaultMaterial;
	}());
	exports.IntroDefaultMaterial = IntroDefaultMaterial;
	//# sourceMappingURL=IntroDefaultMaterial.js.map

/***/ },
/* 31 */
/***/ function(module, exports) {

	"use strict";
	var PointsMaterial = (function () {
	    function PointsMaterial() {
	    }
	    Object.defineProperty(PointsMaterial.prototype, "textures", {
	        get: function () {
	            return {
	                'sprite-1.png': '/assets/img/sprite-1.png',
	                'sprite-2.png': '/assets/img/sprite-2.png',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PointsMaterial.prototype.create = function (textures) {
	        var material = new THREE.PointsMaterial({
	            color: 0x351c41,
	            size: 30,
	            blending: THREE.AdditiveBlending,
	            // map: texture,
	            transparent: true,
	            alphaTest: 0.01,
	            sizeAttenuation: true,
	            vertexColors: THREE.VertexColors,
	        });
	        material['userData'] = textures;
	        return material;
	    };
	    return PointsMaterial;
	}());
	exports.PointsMaterial = PointsMaterial;
	//# sourceMappingURL=PointsMaterial.js.map

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ShaderMaterial = (function () {
	    function ShaderMaterial(app) {
	        this.app = app;
	    }
	    Object.defineProperty(ShaderMaterial.prototype, "textures", {
	        get: function () {
	            return {
	                'rgb': '/assets/img/sky_RGB_half.jpg',
	                'alpha': '/assets/img/paintStreak_02_half.png',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShaderMaterial.prototype.create = function (_a) {
	        // let uniforms = {
	        //     time: { value: 1.0 },
	        //     resolution: { value: new THREE.Vector2() },
	        //     texture: { value: sprite }
	        // };
	        var rgb = _a.rgb, alpha = _a.alpha;
	        // uniforms.texture.value.wrapS = uniforms.texture.value.wrapT = THREE.RepeatWrapping;
	        var uniforms = {
	            offset: { type: "f", value: 1.0 },
	            offsetMult: { type: "f", value: 1.0 },
	            fade: { type: "f", value: 0.0 },
	            power: { type: "f", value: 1.0 },
	            warp: { type: "f", value: 0.0 },
	            warpSpeed: { type: "f", value: 1.0 },
	            repeat: { type: "f", value: 1.0 },
	            camMat: { type: 'm4', value: new THREE.Matrix4() },
	            textureColor: { type: "t", value: null },
	            textureAlpha: { type: "t", value: null },
	            Color1: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	            Color2: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	            Color3: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	        };
	        var shader = new THREE.ShaderMaterial({
	            uniforms: uniforms,
	            vertexShader: __webpack_require__(33),
	            fragmentShader: __webpack_require__(34),
	            blending: THREE.AdditiveBlending,
	            transparent: true,
	            opacity: .5
	        });
	        shader['userData'] = {
	            rgb: rgb, alpha: alpha
	        };
	        return shader;
	    };
	    return ShaderMaterial;
	}());
	exports.ShaderMaterial = ShaderMaterial;
	//# sourceMappingURL=ShaderMaterial.js.map

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = "varying vec2 vUv;\nuniform float switcher;\nuniform float offset;\nuniform float warp;\nuniform float warpSpeed;\n\nvoid main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position+vec3(cos((warpSpeed*.01)*offset+10.*vUv.x)*warp*.01,sin((warpSpeed*.01)*offset+10.*vUv.x)*warp*.01,0), 1.0 );\n}"

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = "precision highp float;\nuniform vec3 Color1;\nuniform vec3 Color2;\nuniform vec3 Color3;\nvarying vec2 vUv;\nuniform sampler2D textureColor;\nuniform sampler2D textureAlpha;\nuniform float offset;\nuniform float fade;\nuniform float power;\nuniform float repeat;\nvoid main(void) {\n    float fader = pow((.5+(cos(   ( max(0.0,min(1.0,(fade+vUv.x))) * 3.1415*2.))  *-.5))*1.0,power)*4.;\n    vec4 texA = texture2D(textureAlpha, vUv);\n    vec4 tex = texture2D(textureColor, vec2(texA.a,0.0)*.1+vec2(vUv.x*(repeat*.01)+offset,vUv.y));\n    vec3 col1 = Color1*tex.r;\n    vec3 col2 = Color2*tex.g;\n    vec3 col3 = Color3*tex.b;\n    vec3 col = col1+col2+col3;\n    gl_FragColor = vec4(col*col*texA.a*fader, 1.0);\n}"

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Initializable_1 = __webpack_require__(26);
	/**
	 * Model Class
	 */
	var Model = (function (_super) {
	    __extends(Model, _super);
	    function Model() {
	        _super.apply(this, arguments);
	        this.instances = {};
	    }
	    Object.defineProperty(Model.prototype, "collection", {
	        get: function () {
	            return function () { };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Model.prototype.initialize = function (path) {
	        return this.app.loader.load(path);
	    };
	    Model.prototype.update = function (time, delta) { };
	    return Model;
	}(Initializable_1.Initializable));
	exports.Model = Model;
	//# sourceMappingURL=Model.js.map

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Initializable_1 = __webpack_require__(26);
	var Helpers_1 = __webpack_require__(18);
	var Promise = __webpack_require__(7);
	/**
	 * Objects Class
	 */
	var Objects = (function (_super) {
	    __extends(Objects, _super);
	    function Objects() {
	        _super.apply(this, arguments);
	        this.instances = {};
	    }
	    Object.defineProperty(Objects.prototype, "collection", {
	        get: function () {
	            return __webpack_require__(37);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Initialize Object
	     */
	    Objects.prototype.initialize = function (instance) {
	        var _this = this;
	        var loaders = {
	            0: this.app.model,
	            1: this.app.material,
	            2: this.app.animation
	        };
	        return Promise
	            .map([instance.models, instance.materials, instance.animations], function (item, index) {
	            return item ? loaders[index].load(item) : null;
	        })
	            .then(function (resolutions) {
	            /**
	             * Parse Animation and store it on userData.animations
	             */
	            var mesh = instance.create.apply(instance, resolutions);
	            /**
	             * If Animation is set
	             */
	            if (instance.hasOwnProperty('animations')) {
	                var actions = _this.app.animation.create(mesh, mesh.geometry.bones, resolutions[2]);
	                /**
	                 * Give a chance for the actions to be configurable
	                 */
	                if (Helpers_1.is.Function(instance.configAnimation))
	                    instance.configAnimation(actions);
	                mesh.userData.animations = actions;
	            }
	            return mesh;
	        });
	    };
	    Objects.prototype.update = function (time, delta) {
	    };
	    return Objects;
	}(Initializable_1.Initializable));
	exports.Objects = Objects;
	//# sourceMappingURL=Objects.js.map

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./Base.js": 38,
		"./Characters/Actor.js": 39,
		"./Characters/Actress.js": 41,
		"./Characters/Animation.js": 42,
		"./Characters/ArtDirector.js": 43,
		"./Characters/Artist3D.js": 44,
		"./Characters/CameraDirector.js": 45,
		"./Characters/ConceptArtist.js": 46,
		"./Characters/CostumeDesigner.js": 47,
		"./Characters/Director.js": 48,
		"./Characters/Editor.js": 49,
		"./Characters/Effects.js": 50,
		"./Characters/ExecutiveProducer.js": 51,
		"./Characters/LightingArtist.js": 52,
		"./Characters/MakeUpArtist.js": 53,
		"./Characters/PackagingDesigner.js": 54,
		"./Characters/PreStageProjectCoordinator.js": 55,
		"./Characters/ProjectCoordinator.js": 56,
		"./Characters/Prop.js": 57,
		"./Characters/RecordingArtist.js": 58,
		"./Characters/RenderAndComposite.js": 59,
		"./Characters/RiggingArtist.js": 60,
		"./Characters/Screenwriter.js": 61,
		"./Characters/ScriptSupervisor.js": 62,
		"./Characters/SetDesigner.js": 63,
		"./Characters/SoundEffect.js": 64,
		"./Characters/StageManager.js": 65,
		"./Characters/StoryboardArtist.js": 66,
		"./Characters/SwingGang.js": 67,
		"./Characters/VoiceArtist.js": 68,
		"./Debris.js": 69,
		"./HexParticles.js": 73,
		"./Main.js": 74,
		"./Ship.js": 75,
		"./Star.js": 76,
		"./Tunnel.js": 77
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 37;


/***/ },
/* 38 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Character: Base
	 */
	var Base = (function () {
	    function Base(app) {
	    }
	    ;
	    Object.defineProperty(Base.prototype, "models", {
	        get: function () {
	            return {
	                base: '/models/Base.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Base.prototype, "materials", {
	        get: function () {
	            return {
	                material: 'CharacterDefaultMaterial'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Base.prototype.create = function (_a, _b) {
	        var base = _a.base;
	        var material = _b.material;
	        material = material.clone();
	        material.skinning = false;
	        return new THREE.Mesh(base, material);
	    };
	    return Base;
	}());
	exports.Base = Base;
	//# sourceMappingURL=Base.js.map

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Actor
	 */
	var Actor = (function (_super) {
	    __extends(Actor, _super);
	    function Actor() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Actor.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Actor.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Actor;
	}(BaseCharacter_1.BaseCharacter));
	exports.Actor = Actor;
	//# sourceMappingURL=Actor.js.map

/***/ },
/* 40 */
/***/ function(module, exports) {

	"use strict";
	var BaseCharacter = (function () {
	    function BaseCharacter(_a) {
	        var animator = _a.animator;
	        this.animator = animator;
	    }
	    ;
	    Object.defineProperty(BaseCharacter.prototype, "materials", {
	        get: function () {
	            return {
	                material: 'CharacterDefaultMaterial'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BaseCharacter.prototype, "animations", {
	        get: function () {
	            return {
	                animation: '/animations/BaseAnimation.anim'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BaseCharacter.prototype.configAnimation = function () { };
	    BaseCharacter.prototype.create = function (_a, _b, _c) {
	        var character = _a.character;
	        var material = _b.material;
	        var animation = _c.animation;
	        var mesh = new THREE.SkinnedMesh(character, material);
	        return mesh;
	    };
	    return BaseCharacter;
	}());
	exports.BaseCharacter = BaseCharacter;
	//# sourceMappingURL=BaseCharacter.js.map

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Actress
	 */
	var Actress = (function (_super) {
	    __extends(Actress, _super);
	    function Actress() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Actress.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Actress.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Actress;
	}(BaseCharacter_1.BaseCharacter));
	exports.Actress = Actress;
	//# sourceMappingURL=Actress.js.map

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Animation
	 */
	var Animation = (function (_super) {
	    __extends(Animation, _super);
	    function Animation() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Animation.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Animation.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Animation;
	}(BaseCharacter_1.BaseCharacter));
	exports.Animation = Animation;
	//# sourceMappingURL=Animation.js.map

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: ArtDirector
	 */
	var ArtDirector = (function (_super) {
	    __extends(ArtDirector, _super);
	    function ArtDirector() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(ArtDirector.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/ArtDirector.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ArtDirector;
	}(BaseCharacter_1.BaseCharacter));
	exports.ArtDirector = ArtDirector;
	//# sourceMappingURL=ArtDirector.js.map

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Artist3d
	 */
	var Artist3d = (function (_super) {
	    __extends(Artist3d, _super);
	    function Artist3d() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Artist3d.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Artist3d.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Artist3d;
	}(BaseCharacter_1.BaseCharacter));
	exports.Artist3d = Artist3d;
	//# sourceMappingURL=Artist3D.js.map

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: CameraDirector
	 */
	var CameraDirector = (function (_super) {
	    __extends(CameraDirector, _super);
	    function CameraDirector() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(CameraDirector.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/CameraDirector.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CameraDirector;
	}(BaseCharacter_1.BaseCharacter));
	exports.CameraDirector = CameraDirector;
	//# sourceMappingURL=CameraDirector.js.map

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: ConceptArtist
	 */
	var ConceptArtist = (function (_super) {
	    __extends(ConceptArtist, _super);
	    function ConceptArtist() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(ConceptArtist.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/ConceptArtist.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ConceptArtist;
	}(BaseCharacter_1.BaseCharacter));
	exports.ConceptArtist = ConceptArtist;
	//# sourceMappingURL=ConceptArtist.js.map

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: CostumeDesigner
	 */
	var CostumeDesigner = (function (_super) {
	    __extends(CostumeDesigner, _super);
	    function CostumeDesigner() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(CostumeDesigner.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/CostumeDesigner.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CostumeDesigner;
	}(BaseCharacter_1.BaseCharacter));
	exports.CostumeDesigner = CostumeDesigner;
	//# sourceMappingURL=CostumeDesigner.js.map

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Director
	 */
	var Director = (function (_super) {
	    __extends(Director, _super);
	    function Director() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Director.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Director.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Director;
	}(BaseCharacter_1.BaseCharacter));
	exports.Director = Director;
	//# sourceMappingURL=Director.js.map

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Editor
	 */
	var Editor = (function (_super) {
	    __extends(Editor, _super);
	    function Editor() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Editor.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Editor.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Editor;
	}(BaseCharacter_1.BaseCharacter));
	exports.Editor = Editor;
	//# sourceMappingURL=Editor.js.map

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Effects
	 */
	var Effects = (function (_super) {
	    __extends(Effects, _super);
	    function Effects() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Effects.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Effects.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Effects;
	}(BaseCharacter_1.BaseCharacter));
	exports.Effects = Effects;
	//# sourceMappingURL=Effects.js.map

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: ExecutiveProducer
	 */
	var ExecutiveProducer = (function (_super) {
	    __extends(ExecutiveProducer, _super);
	    function ExecutiveProducer() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(ExecutiveProducer.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/ExecutiveProducer.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ExecutiveProducer;
	}(BaseCharacter_1.BaseCharacter));
	exports.ExecutiveProducer = ExecutiveProducer;
	//# sourceMappingURL=ExecutiveProducer.js.map

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: LightingArtist
	 */
	var LightingArtist = (function (_super) {
	    __extends(LightingArtist, _super);
	    function LightingArtist() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(LightingArtist.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/LightingArtist.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return LightingArtist;
	}(BaseCharacter_1.BaseCharacter));
	exports.LightingArtist = LightingArtist;
	//# sourceMappingURL=LightingArtist.js.map

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: MakeUpArtist
	 */
	var MakeUpArtist = (function (_super) {
	    __extends(MakeUpArtist, _super);
	    function MakeUpArtist() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(MakeUpArtist.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/MakeUpArtist.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return MakeUpArtist;
	}(BaseCharacter_1.BaseCharacter));
	exports.MakeUpArtist = MakeUpArtist;
	//# sourceMappingURL=MakeUpArtist.js.map

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: PackagingDesigner
	 */
	var PackagingDesigner = (function (_super) {
	    __extends(PackagingDesigner, _super);
	    function PackagingDesigner() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(PackagingDesigner.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/PackagingDesigner.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PackagingDesigner;
	}(BaseCharacter_1.BaseCharacter));
	exports.PackagingDesigner = PackagingDesigner;
	//# sourceMappingURL=PackagingDesigner.js.map

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: PreStageProjectCoordinator
	 */
	var PreStageProjectCoordinator = (function (_super) {
	    __extends(PreStageProjectCoordinator, _super);
	    function PreStageProjectCoordinator() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(PreStageProjectCoordinator.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/PreStageProjectCoordinator.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PreStageProjectCoordinator;
	}(BaseCharacter_1.BaseCharacter));
	exports.PreStageProjectCoordinator = PreStageProjectCoordinator;
	//# sourceMappingURL=PreStageProjectCoordinator.js.map

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: ProjectCoordinator
	 */
	var ProjectCoordinator = (function (_super) {
	    __extends(ProjectCoordinator, _super);
	    function ProjectCoordinator() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(ProjectCoordinator.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/ProjectCoordinator.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ProjectCoordinator;
	}(BaseCharacter_1.BaseCharacter));
	exports.ProjectCoordinator = ProjectCoordinator;
	//# sourceMappingURL=ProjectCoordinator.js.map

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Prop
	 */
	var Prop = (function (_super) {
	    __extends(Prop, _super);
	    function Prop() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Prop.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Prop.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Prop;
	}(BaseCharacter_1.BaseCharacter));
	exports.Prop = Prop;
	//# sourceMappingURL=Prop.js.map

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: RecordingArtist
	 */
	var RecordingArtist = (function (_super) {
	    __extends(RecordingArtist, _super);
	    function RecordingArtist() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(RecordingArtist.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/RecordingArtist.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return RecordingArtist;
	}(BaseCharacter_1.BaseCharacter));
	exports.RecordingArtist = RecordingArtist;
	//# sourceMappingURL=RecordingArtist.js.map

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: RenderAndComposite
	 */
	var RenderAndComposite = (function (_super) {
	    __extends(RenderAndComposite, _super);
	    function RenderAndComposite() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(RenderAndComposite.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/RenderAndComposite.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return RenderAndComposite;
	}(BaseCharacter_1.BaseCharacter));
	exports.RenderAndComposite = RenderAndComposite;
	//# sourceMappingURL=RenderAndComposite.js.map

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: RiggingArtist
	 */
	var RiggingArtist = (function (_super) {
	    __extends(RiggingArtist, _super);
	    function RiggingArtist() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(RiggingArtist.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/RiggingArtist.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return RiggingArtist;
	}(BaseCharacter_1.BaseCharacter));
	exports.RiggingArtist = RiggingArtist;
	//# sourceMappingURL=RiggingArtist.js.map

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: Screenwriter
	 */
	var Screenwriter = (function (_super) {
	    __extends(Screenwriter, _super);
	    function Screenwriter() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Screenwriter.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/Screenwriter.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Screenwriter;
	}(BaseCharacter_1.BaseCharacter));
	exports.Screenwriter = Screenwriter;
	//# sourceMappingURL=Screenwriter.js.map

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: ScriptSupervisor
	 */
	var ScriptSupervisor = (function (_super) {
	    __extends(ScriptSupervisor, _super);
	    function ScriptSupervisor() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(ScriptSupervisor.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/ScriptSupervisor.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ScriptSupervisor;
	}(BaseCharacter_1.BaseCharacter));
	exports.ScriptSupervisor = ScriptSupervisor;
	//# sourceMappingURL=ScriptSupervisor.js.map

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: SetDesigner
	 */
	var SetDesigner = (function (_super) {
	    __extends(SetDesigner, _super);
	    function SetDesigner() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(SetDesigner.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/SetDesigner.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SetDesigner;
	}(BaseCharacter_1.BaseCharacter));
	exports.SetDesigner = SetDesigner;
	//# sourceMappingURL=SetDesigner.js.map

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: SoundEffect
	 */
	var SoundEffect = (function (_super) {
	    __extends(SoundEffect, _super);
	    function SoundEffect() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(SoundEffect.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/SoundEffect.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SoundEffect;
	}(BaseCharacter_1.BaseCharacter));
	exports.SoundEffect = SoundEffect;
	//# sourceMappingURL=SoundEffect.js.map

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: StageManager
	 */
	var StageManager = (function (_super) {
	    __extends(StageManager, _super);
	    function StageManager() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(StageManager.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/StageManager.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return StageManager;
	}(BaseCharacter_1.BaseCharacter));
	exports.StageManager = StageManager;
	//# sourceMappingURL=StageManager.js.map

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: StoryboardArtist
	 */
	var StoryboardArtist = (function (_super) {
	    __extends(StoryboardArtist, _super);
	    function StoryboardArtist() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(StoryboardArtist.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/StoryboardArtist.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return StoryboardArtist;
	}(BaseCharacter_1.BaseCharacter));
	exports.StoryboardArtist = StoryboardArtist;
	//# sourceMappingURL=StoryboardArtist.js.map

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: SwingGang
	 */
	var SwingGang = (function (_super) {
	    __extends(SwingGang, _super);
	    function SwingGang() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(SwingGang.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/SwingGang.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SwingGang;
	}(BaseCharacter_1.BaseCharacter));
	exports.SwingGang = SwingGang;
	//# sourceMappingURL=SwingGang.js.map

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BaseCharacter_1 = __webpack_require__(40);
	/**
	 * Character: VoiceArtist
	 */
	var VoiceArtist = (function (_super) {
	    __extends(VoiceArtist, _super);
	    function VoiceArtist() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(VoiceArtist.prototype, "models", {
	        get: function () {
	            return {
	                character: '/models/VoiceArtist.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return VoiceArtist;
	}(BaseCharacter_1.BaseCharacter));
	exports.VoiceArtist = VoiceArtist;
	//# sourceMappingURL=VoiceArtist.js.map

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Forgable_1 = __webpack_require__(70);
	/**
	 * Character: Base
	 */
	var Debris = (function (_super) {
	    __extends(Debris, _super);
	    function Debris() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Debris.prototype, "materials", {
	        get: function () {
	            return {
	                material: 'IntroDefaultMaterial'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create Object
	     *
	     * @param models
	     * @param material
	     * @returns {THREE.Group}
	     */
	    Debris.prototype.create = function (models, _a) {
	        var material = _a.material;
	        var debris = this.forge('debris', material, {
	            scale: 70,
	            position: {
	                x: -10, y: -220, z: 5
	            }
	        });
	        debris.userData.update = this.update.bind(this, debris);
	        return debris;
	    };
	    Debris.prototype.update = function (debris) {
	        var height = debris.userData.meta.view.height;
	        if (debris.position.y >= -height) {
	            debris.position.y -= 10; //1;
	        }
	        else {
	            return true;
	        }
	    };
	    return Debris;
	}(Forgable_1.Forgable));
	exports.Debris = Debris;
	//# sourceMappingURL=Debris.js.map

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Helpers_1 = __webpack_require__(2);
	var Helpers_2 = __webpack_require__(19);
	var Forgable = (function () {
	    function Forgable(app) {
	        var _this = this;
	        this.sprite = {};
	        this.app = app;
	        this.camera = app.camera;
	        var sprites = Helpers_1.requireAll(__webpack_require__(71));
	        var _loop_1 = function(sprite) {
	            Object
	                .keys(sprites[sprite])
	                .map(function (property) { return _this.sprite[property] = sprites[sprite][property]; });
	        };
	        for (var sprite in sprites) {
	            _loop_1(sprite);
	        }
	    }
	    Object.defineProperty(Forgable.prototype, "defaults", {
	        get: function () {
	            return {
	                scale: 100,
	                widthFactor: 1,
	                heightFactor: 1,
	                mesh: THREE.Mesh,
	                geometry: THREE.PlaneGeometry,
	                position: {
	                    x: 50,
	                    y: 50,
	                    z: 50
	                }
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ;
	    /**
	     * Forge a new asset
	     *
	     * @param name
	     * @param material
	     * @param options
	     * @returns {THREE.Mesh}
	     */
	    Forgable.prototype.forge = function (name, material, options) {
	        if (options === void 0) { options = {}; }
	        return this.setup(name, Helpers_1.extend(this.sprite[name], options), material);
	    };
	    Forgable.prototype.get3DPosition = function (view, size, targetX, targetY) {
	        var x = (view.width - size.width) / 2, y = (view.height - size.height) / 2;
	        return {
	            x: -(x + (((-x - x) / 100) * targetX)),
	            y: (y + (((-y - y) / 100) * targetY)),
	            z: view.depth
	        };
	    };
	    Forgable.prototype.createMesh = function (geometry, material, mesh) {
	        return new mesh(geometry, material);
	    };
	    ;
	    Forgable.prototype.createGeometry = function (width, height, view, geometry) {
	        if (geometry instanceof THREE.Geometry) {
	            return this.computeGeometrySize(geometry, width);
	        }
	        return new geometry(width, height);
	    };
	    /**
	     * @todo the defaults.width is not right..
	     * because if its already a 3D object.. it is not the texture size
	     */
	    Forgable.prototype.getDimentions = function () {
	        var options = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            options[_i - 0] = arguments[_i];
	        }
	        var defaults = Helpers_1.extend.apply(void 0, [this.defaults].concat(options)), view = this.camera.getViewSize(defaults.position.z), size = Helpers_2.resize(view.width * defaults.widthFactor, view.height * defaults.heightFactor, defaults.width, defaults.height, defaults.scale);
	        var position = this.get3DPosition(view, size, defaults.position.x, defaults.position.y);
	        return {
	            view: view, size: size, position: position, defaults: defaults
	        };
	    };
	    Forgable.prototype.computeGeometrySize = function (geometry, width) {
	        geometry.computeBoundingBox();
	        var box = geometry.boundingBox, scale = Math.abs(box.max.x - box.min.x) / width;
	        geometry.vertices.forEach(function (vertice) {
	            vertice.divideScalar(scale);
	        });
	        geometry.verticesNeedUpdate = true;
	        return geometry;
	    };
	    Forgable.prototype.setup = function (object, options, material) {
	        if (options === void 0) { options = {}; }
	        /**
	         * If its an object its necessary to know its width, and height
	         */
	        if (object instanceof THREE.Mesh) {
	            var box = object.geometry.boundingBox, result = box.max.add(box.min.negate());
	            options = Helpers_1.extend(options, {
	                width: result.x,
	                height: result.y,
	            });
	        }
	        var _a = this.getDimentions(options), view = _a.view, size = _a.size, position = _a.position, defaults = _a.defaults;
	        if (object instanceof THREE.Mesh) {
	            object.geometry = this.computeGeometrySize(object.geometry.clone(), size.width);
	        }
	        if (typeof (object) === "string") {
	            var name_1 = object;
	            object = this.createMesh(this.createGeometry(size.width, size.height, view, defaults.geometry), Helpers_2.configureMaterial(material, defaults), defaults.mesh);
	            object.name = name_1;
	        }
	        object.userData.meta = {
	            view: view, size: size, position: position, defaults: defaults
	        };
	        object.position.set(position.x, position.y, position.z);
	        return object;
	    };
	    return Forgable;
	}());
	exports.Forgable = Forgable;
	//# sourceMappingURL=Forgable.js.map

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./sprite-1.json": 20,
		"./sprite-2.json": 72
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 71;


/***/ },
/* 72 */
/***/ function(module, exports) {

	module.exports = {
		"transition": {
			"name": "transition",
			"width": 2012,
			"height": 1044,
			"sprite": {
				"name": "sprite-2.png",
				"width": 2012,
				"height": 2012
			},
			"x": 0,
			"y": 0
		},
		"debris": {
			"name": "debris",
			"width": 864,
			"height": 504,
			"sprite": {
				"name": "sprite-2.png",
				"width": 864,
				"height": 864
			},
			"x": 0,
			"y": 1044
		}
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Forgable_1 = __webpack_require__(70);
	var Helpers_1 = __webpack_require__(19);
	/**
	 * Main Particles
	 */
	var HexParticles = (function (_super) {
	    __extends(HexParticles, _super);
	    function HexParticles() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(HexParticles.prototype, "materials", {
	        get: function () {
	            return {
	                material: 'PointsMaterial'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    HexParticles.prototype.create = function (models, _a) {
	        var material = _a.material;
	        var group = new THREE.Group(), mesh = this.forge('hex', material, {
	            position: {
	                x: 50, y: 50, z: 20
	            }
	        });
	        var pinkMaterial = mesh.material.clone(), pink = this.createMesh(mesh.geometry.clone(), pinkMaterial);
	        var lilasMaterial = mesh.material.clone(), lilas = this.createMesh(mesh.geometry.clone(), lilasMaterial);
	        pinkMaterial.color.setHex(0x7a1762);
	        lilasMaterial.color.setHex(0xb505ce);
	        group.add(pink);
	        group.add(lilas);
	        group.add(mesh);
	        group.userData = mesh.geometry['userData'];
	        group.userData.update = this.update.bind(this, group);
	        group.userData.decay = 0;
	        return group;
	    };
	    HexParticles.prototype.createMesh = function (geometry, material) {
	        return new THREE.Points(geometry, material);
	    };
	    HexParticles.prototype.createGeometry = function (width, height, view) {
	        var maxParticleCount = 100, radius = view.width * 1.5, particles = new THREE.BufferGeometry(), particlePositions = new Float32Array(maxParticleCount * 3), colors = new Float32Array(maxParticleCount * 3);
	        /**
	         * Store Data
	         */
	        particles['userData'] = {
	            velocities: [[], [], []], view: view
	        };
	        /**
	         * Add Vertices to Points
	         */
	        for (var i = 0; i < maxParticleCount; i++) {
	            var vector = Helpers_1.random.vector3(0, 0, 0, radius, false);
	            particlePositions[i * 3] = vector.x + Math.random();
	            particlePositions[i * 3 + 1] = vector.y + Math.random();
	            particlePositions[i * 3 + 2] = Helpers_1.random.between(this.camera.position.z / 4, this.camera.position.z);
	            /**
	             * Randomize Opacity
	             */
	            colors[i * 3] = colors[i * 3 + 1] = colors[i * 3 + 2] = Helpers_1.random.between(1, 100) * 0.01;
	            for (var j = 0; j < 3; j++) {
	                particles['userData'].velocities[j].push([
	                    Helpers_1.random.between(-10, 10), Helpers_1.random.between(-10, 10)
	                ]);
	            }
	        }
	        particles.addAttribute('position', new THREE.BufferAttribute(particlePositions, 3).setDynamic(true));
	        particles.addAttribute('color', new THREE.BufferAttribute(colors, 3).setDynamic(true));
	        return particles;
	    };
	    HexParticles.prototype.update = function (particles) {
	        var userData = particles.userData, distanceX = userData.view.width / 2, distanceY = userData.view.height / 2, speed = 30;
	        if (userData.decay !== 0) {
	            particles.position.y -= userData.decay;
	            if (particles.position.y <= -userData.view.height * 3) {
	                return true;
	            }
	        }
	        particles.children.forEach(function (child, index) {
	            var positions = child.geometry.getAttribute('position'), velocity = userData['velocities'][index];
	            for (var i = 0; i < positions.count; i++) {
	                positions.array[i * 3] += velocity[i][0] / speed;
	                positions.array[i * 3 + 1] += (velocity[i][1] / speed);
	                if (positions.array[i * 3] < -distanceX || positions.array[i * 3] > distanceX)
	                    velocity[i][0] = -velocity[i][0];
	                if (positions.array[i * 3 + 1] < -distanceY || positions.array[i * 3 + 1] > distanceY)
	                    velocity[i][1] = -velocity[i][1];
	            }
	            positions.needsUpdate = true;
	        });
	    };
	    ;
	    return HexParticles;
	}(Forgable_1.Forgable));
	exports.HexParticles = HexParticles;
	//# sourceMappingURL=HexParticles.js.map

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Forgable_1 = __webpack_require__(70);
	/**
	 * Character: Base
	 */
	var Main = (function (_super) {
	    __extends(Main, _super);
	    function Main() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Main.prototype, "materials", {
	        get: function () {
	            return {
	                material: 'IntroDefaultMaterial'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create Object
	     *
	     * @param models
	     * @param material
	     * @returns {THREE.Group}
	     */
	    Main.prototype.create = function (models, _a) {
	        var material = _a.material;
	        var group = new THREE.Group();
	        group.add(this.forge('background', material, {
	            widthFactor: 2.5,
	            heightFactor: 1.5,
	            position: {
	                x: 50, y: 50, z: 0
	            }
	        }));
	        group.add(this.forge('platform', material, {
	            scale: 65, position: {
	                x: 50,
	                y: 75,
	                z: 50
	            }
	        }));
	        group.add(this.forge('planet', material, {
	            scale: 20,
	            position: {
	                x: 10,
	                y: 10,
	                z: 50
	            }
	        }));
	        group.add(this.forge('transition', material, {
	            widthFactor: 2.5,
	            heightFactor: 1.5,
	            position: {
	                x: 50, y: 200 * 1.5, z: 0
	            }
	        }));
	        return group;
	    };
	    return Main;
	}(Forgable_1.Forgable));
	exports.Main = Main;
	//# sourceMappingURL=Main.js.map

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Forgable_1 = __webpack_require__(70);
	var Helpers_1 = __webpack_require__(19);
	/**
	 * Ship
	 */
	var Ship = (function (_super) {
	    __extends(Ship, _super);
	    function Ship() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Ship.prototype, "models", {
	        get: function () {
	            return {
	                geometry: '/assets/models/Ship.json',
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Ship.prototype, "materials", {
	        get: function () {
	            return {
	                material: 'IntroDefaultMaterial'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Ship.prototype.create = function (_a, _b) {
	        var geometry = _a.geometry;
	        var material = _b.material;
	        var group = new THREE.Group(), ship = this.forge('ship', material, {
	            geometry: geometry,
	            scale: 20,
	            position: {
	                x: 50,
	                y: 45,
	                z: 65
	            }
	        }), clones = [];
	        group.add(ship);
	        for (var i = 0; i <= 5; i++) {
	            clones.push(this.clone(ship));
	        }
	        clones.forEach(function (clone) { return group.add(clone); });
	        ship.name = 'logo';
	        group.userData = {
	            booster: 1,
	            update: this.update.bind(this, group)
	        };
	        return group;
	    };
	    Ship.prototype.update = function (object) {
	        var _this = this;
	        object.children.forEach(function (child, i) {
	            if (child.name === 'logo')
	                return;
	            if (child.position.y > child.userData.respawnAt) {
	                _this.respawn(child);
	            }
	            if (child.position.y < -child.userData.respawnAt) {
	                _this.respawn(child, false);
	            }
	            child.position.y += child.userData.velocity * object.userData.booster;
	        });
	    };
	    /**
	     * Respawn Object
	     */
	    Ship.prototype.respawn = function (object, up) {
	        if (up === void 0) { up = true; }
	        var _a = object.userData.meta.size, width = _a.width, height = _a.height, _b = this.getDimentions({
	            width: width,
	            height: height,
	            widthFactor: 2,
	            scale: 15,
	            position: {
	                x: Helpers_1.random.between(0, 100),
	                y: up ? 100 : 0,
	                z: Helpers_1.random.between(10, 40),
	            }
	        }), view = _b.view, size = _b.size, position = _b.position, defaults = _b.defaults;
	        var absHeight = up ? -view.height : view.height;
	        object.position.set(position.x, absHeight, position.z);
	        object.userData.velocity = this.getVelocity();
	        object.userData.respawnAt = view.height;
	        return object;
	    };
	    Ship.prototype.clone = function (object) {
	        var clone = this.setup(object.clone(), {
	            scale: 15,
	            widthFactor: 2,
	            position: {
	                x: Helpers_1.random.between(0, 100),
	                y: Helpers_1.random.between(0, 100),
	                z: Helpers_1.random.between(10, 40),
	            }
	        });
	        var height = clone.userData.meta.view.height;
	        clone.position.y = -height;
	        clone.userData.velocity = this.getVelocity();
	        clone.userData.respawnAt = height;
	        return clone;
	    };
	    Ship.prototype.getVelocity = function () {
	        return Helpers_1.random.between(2, 5);
	    };
	    return Ship;
	}(Forgable_1.Forgable));
	exports.Ship = Ship;
	//# sourceMappingURL=Ship.js.map

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Forgable_1 = __webpack_require__(70);
	var Helpers_1 = __webpack_require__(19);
	/**
	 * Main Particles
	 */
	var Star = (function (_super) {
	    __extends(Star, _super);
	    function Star() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Star.prototype, "materials", {
	        get: function () {
	            return {
	                material: 'PointsMaterial'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Star.prototype.create = function (models, _a) {
	        var material = _a.material;
	        var point = material;
	        point.size = 12;
	        point.color = new THREE.Color('white');
	        point.blending = THREE.NormalBlending;
	        point.vertexColors = false;
	        point.alphaTest = .1;
	        point.needsUpdate = true;
	        point.opacity = .2;
	        var particles = this.forge('star', point, {
	            position: {
	                x: 50, y: 50, z: 5
	            }
	        });
	        particles.userData.update = this.update.bind(this, particles);
	        particles.userData.speed = 0;
	        particles.userData.vortex = this.vortex.bind(this, particles);
	        particles.userData.vortexEnabled = false;
	        particles.userData.circle = new THREE.CircleGeometry(100, 30);
	        return particles;
	    };
	    Star.prototype.createMesh = function (geometry, material) {
	        return new THREE.Points(geometry, material);
	    };
	    Star.prototype.createGeometry = function (width, height, view) {
	        var maxParticleCount = 700, radius = view.width * 1.5, particles = new THREE.BufferGeometry(), particlePositions = new Float32Array(maxParticleCount * 3);
	        /**
	         * Store Data
	         */
	        particles['userData'] = {
	            velocity: []
	        };
	        /**
	         * Add Vertices to Points
	         */
	        for (var i = 0; i < maxParticleCount; i++) {
	            var vector = Helpers_1.random.vector3(0, 0, 0, radius, false);
	            particlePositions[i * 3] = vector.x + Math.random();
	            particlePositions[i * 3 + 1] = vector.y + Math.random();
	            particlePositions[i * 3 + 2] = Helpers_1.random.between(this.camera.position.z / 4, this.camera.position.z / 2);
	            particles['userData'].velocity.push([
	                Helpers_1.random.between(10, 50)
	            ]);
	        }
	        particles.addAttribute('position', new THREE.BufferAttribute(particlePositions, 3).setDynamic(true));
	        return particles;
	    };
	    Star.prototype.update = function (particles, time) {
	        if (particles.userData.vortexEnabled) {
	            return this.vortex(particles, time);
	        }
	        /**
	         * No point if speed is 0
	         */
	        if (particles.userData.speed <= 0)
	            return;
	        var positions = particles.geometry.getAttribute('position'), distanceX = particles.userData.meta.view.width / 2, distanceY = particles.userData.meta.view.height / 2;
	        for (var i = 0; i < positions.count; i++) {
	            var velocity = particles.geometry.userData.velocity[i];
	            positions.array[i * 3 + 1] -= (velocity[0] / 10) * particles.userData.speed;
	            if (positions.array[i * 3 + 1] < -distanceY)
	                positions.array[i * 3 + 1] = distanceY;
	        }
	        positions.needsUpdate = true;
	    };
	    ;
	    Star.prototype.vortex = function (particles, time) {
	        var positions = particles.geometry.getAttribute('position'), distanceX = particles.userData.meta.view.width / 2, distanceY = particles.userData.meta.view.height / 2;
	        for (var i = 0; i < positions.count; i++) {
	            var vector = particles.userData.circle.vertices[Math.floor(Helpers_1.random.between(1, particles.userData.circle.vertices.length - 1))];
	            positions.array[i * 3] = vector.x + Math.random() * 2;
	            positions.array[i * 3 + 1] = vector.y + Math.random() * 2;
	            positions.array[i * 3 + 2] = vector.z + Math.random() * 2;
	        }
	        positions.needsUpdate = true;
	    };
	    return Star;
	}(Forgable_1.Forgable));
	exports.Star = Star;
	//# sourceMappingURL=Star.js.map

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Forgable_1 = __webpack_require__(70);
	var Curves_1 = __webpack_require__(78);
	var v4 = function (x, y, z, w) { return new THREE.Vector4(x, y, z, w); };
	var simpleVert = "\
		varying vec2 vUv;\
		void main() {\
			vUv = uv;\
			gl_Position = projectionMatrix *\
			modelViewMatrix * vec4(position, 1.0 );\
		}\
	";
	var simpleFrag5 = "\
		precision highp float;\
		varying vec3 vecNormal;\
		uniform float offset;\
		varying vec2 vUv;\
		uniform sampler2D map;\
		uniform sampler2D map2;\
		void main(void) {\
			vec4 lgts = vec4(vec3(0.0),1.0);\
			vec4 tex = texture2D(map, vUv*7.);\
			vec4 tex2 = texture2D(map2, vec2(offset,0)+vUv);\
			gl_FragColor = vec4((tex2.b*vec3(.08,.0,.15))+pow(tex2.r,2.)*tex.rgb*9.*vec3(.3,.5,.9), 1.0);\
		}\
	";
	var simpleMat5 = new THREE.ShaderMaterial({
	    uniforms: {
	        offset: { type: 'f', value: 1.0 },
	        map: { type: "t", value: null },
	        map2: { type: "t", value: null },
	    },
	    vertexShader: simpleVert,
	    fragmentShader: simpleFrag5,
	});
	var facingVert2 = "\
		varying vec2 vUv;\
		varying vec3 wNormal;\
		uniform float switcher;\
		uniform float offset;\
		uniform float warp;\
		uniform float warpSpeed;\
		void main() {\
			vUv = uv;\
			wNormal = mat3(modelMatrix[0].xyz,modelMatrix[1].xyz,modelMatrix[2].xyz)*normal;\
			wNormal = normalize(wNormal);\
			gl_Position = projectionMatrix *\
			modelViewMatrix * vec4(position+vec3(cos((warpSpeed*.01)*offset+10.*vUv.x)*warp*.01,sin((warpSpeed*.01)*offset+10.*vUv.x)*warp*.01,0), 1.0 );\
		}\
	";
	var facingVertTunnel = "\
		varying vec2 vUv;\
		uniform float switcher;\
		uniform float offset;\
		uniform float warp;\
		uniform float warpSpeed;\
		void main() {\
			vUv = uv;\
			gl_Position = projectionMatrix *\
			modelViewMatrix * vec4(position+vec3(cos((warpSpeed*.01)*offset+10.*vUv.x)*warp*.01,sin((warpSpeed*.01)*offset+10.*vUv.x)*warp*.01,0), 1.0 );\
		}\
	";
	//gl_Position = projectionMatrix *\
	// modelViewMatrix * vec4(position+vec3(cos(offset*30.*vUv.x)*10.,sin(offset*30.*vUv.x)*10.,0), 1.0 );\
	var facingFrag2 = "\
		precision highp float;\
		uniform mat4 camMat;\
		uniform mat4 camMatInverse;\
		varying vec3 wNormal;\
		varying vec2 vUv;\
		uniform sampler2D textureColor;\
		uniform sampler2D textureAlpha;\
		uniform float offset;\
		uniform float fade;\
		uniform float power;\
		void main(void) {\
			float fader = pow((1.0+(cos(   ( max(0.0,min(1.0,(fade+vUv.x))) * 3.1415*2.))  *-1.0))*.5,power)*2.;\
			vec4 texB = texture2D(textureColor, vUv);\
			vec4 tex = texture2D(textureColor, (texB.rg*.021)+vec2(vUv.x*.4+offset,vUv.y));\
			vec4 texA = texture2D(textureAlpha, vUv+(.05-tex.rg*.1));\
			vec4 camNorm = vec4(vec3(wNormal),0.) * camMat;\
			gl_FragColor = vec4(vec3(min(1.0,max(0.0,pow(camNorm.z,1.5))))*tex.rgb*texA.a*tex.a*fader, 1.0);\
		}\
	";
	var facingMat2 = new THREE.ShaderMaterial({
	    uniforms: {
	        offset: { type: "f", value: 1.0 },
	        fade: { type: "f", value: 0.0 },
	        power: { type: "f", value: 1.0 },
	        camMat: { type: 'm4', value: new THREE.Matrix4() },
	        textureColor: { type: "t", value: null },
	        textureAlpha: { type: "t", value: null }
	    },
	    vertexShader: facingVert2,
	    fragmentShader: facingFrag2,
	    // side: THREE.DoubleSide,
	    blending: THREE.AdditiveBlending,
	    transparent: true
	});
	var facingFrag3 = "\
		precision highp float;\
		uniform mat4 camMat;\
		uniform mat4 camMatInverse;\
		varying vec3 wNormal;\
		uniform vec3 Color1;\
		uniform vec3 Color2;\
		uniform vec3 Color3;\
		varying vec2 vUv;\
		uniform sampler2D textureColor;\
		uniform sampler2D textureAlpha;\
		uniform float offset;\
		uniform float offsetMult;\
		uniform float fade;\
		uniform float power;\
		uniform float repeat;\
		void main(void) {\
			float fader = pow((.5+(cos(   ( max(0.0,min(1.0,(fade+vUv.x))) * 3.1415*2.))  *-.5))*1.0,power)*2.;\
			vec4 texA = texture2D(textureAlpha, vUv);\
			vec4 tex = texture2D(textureColor, vec2(texA.a,0.0)*.1+vec2(vUv.x*(repeat*.01)+offset*(offsetMult*.01),vUv.y));\
			vec3 col1 = Color1*tex.r;\
			vec3 col2 = Color2*tex.g;\
			vec3 col3 = Color3*tex.b;\
			vec3 col = col1+col2+col3;\
			vec4 camNorm = vec4(vec3(wNormal),0.) * viewMatrix;\
			gl_FragColor = vec4(vec3(min(1.0,max(0.0,min(1.0,abs(pow(camNorm.z,3.))))))*col*col*texA.a*fader, 1.0);\
		}\
	";
	//		gl_FragColor = vec4(vec3(min(1.0,max(0.0,min(1.0,camNorm.z*3.))))*col*col*texA.a*fader*10., 1.0);\
	//		gl_FragColor = vec4(vec3(min(1.0,max(0.0,pow(camNorm.z,.1))))*col*col*texA.a*fader, 1.0);\
	//		gl_FragColor = vec4(vec3(min(1.0,max(0.0,pow(camNorm.z,1.5))))*col*tex.a*fader, 1.0);\
	//
	var facingMat3 = new THREE.ShaderMaterial({
	    uniforms: {
	        offset: { type: "f", value: 1.0 },
	        offsetMult: { type: "f", value: 100.0 },
	        fade: { type: "f", value: 0.0 },
	        power: { type: "f", value: 1.0 },
	        warp: { type: "f", value: 0.0 },
	        warpSpeed: { type: "f", value: 100.0 },
	        repeat: { type: "f", value: 100.0 },
	        camMat: { type: 'm4', value: new THREE.Matrix4() },
	        textureColor: { type: "t", value: null },
	        textureAlpha: { type: "t", value: null },
	        Color1: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	        Color2: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	        Color3: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	    },
	    vertexShader: facingVert2,
	    fragmentShader: facingFrag3,
	    // side: THREE.DoubleSide,
	    blending: THREE.AdditiveBlending,
	    transparent: true,
	    opacity: .5
	});
	var facingFragtunnel = "\
		precision highp float;\
		uniform vec3 Color1;\
		uniform vec3 Color2;\
		uniform vec3 Color3;\
		varying vec2 vUv;\
		uniform sampler2D textureColor;\
		uniform sampler2D textureAlpha;\
		uniform float offset;\
		uniform float fade;\
		uniform float power;\
		uniform float repeat;\
		void main(void) {\
			float fader = pow((.5+(cos(   ( max(0.0,min(1.0,(fade+vUv.x))) * 3.1415*2.))  *-.5))*1.0,power)*4.;\
			vec4 texA = texture2D(textureAlpha, vUv);\
			vec4 tex = texture2D(textureColor, vec2(texA.a,0.0)*.1+vec2(vUv.x*(repeat*.01)+offset,vUv.y));\
			vec3 col1 = Color1*tex.r;\
			vec3 col2 = Color2*tex.g;\
			vec3 col3 = Color3*tex.b;\
			vec3 col = col1+col2+col3;\
			gl_FragColor = vec4(col*col*texA.a*fader, 1.0);\
		}\
	";
	var facingMatTunnel = new THREE.ShaderMaterial({
	    uniforms: {
	        offset: { type: "f", value: 1.0 },
	        offsetMult: { type: "f", value: 1.0 },
	        fade: { type: "f", value: 0.0 },
	        power: { type: "f", value: 1.0 },
	        warp: { type: "f", value: 0.0 },
	        warpSpeed: { type: "f", value: 1.0 },
	        repeat: { type: "f", value: 1.0 },
	        camMat: { type: 'm4', value: new THREE.Matrix4() },
	        textureColor: { type: "t", value: null },
	        textureAlpha: { type: "t", value: null },
	        Color1: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	        Color2: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	        Color3: { type: "v3", value: new THREE.Vector3(0, 0, 0) },
	    },
	    vertexShader: facingVertTunnel,
	    fragmentShader: facingFragtunnel,
	    // side: THREE.DoubleSide,
	    blending: THREE.AdditiveBlending,
	    transparent: true,
	    opacity: .5
	});
	/**
	 * Tunnel
	 */
	var Tunnel = (function (_super) {
	    __extends(Tunnel, _super);
	    function Tunnel() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(Tunnel.prototype, "materials", {
	        get: function () {
	            return {
	                material: 'ShaderMaterial'
	            };
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Tunnel.prototype.create = function (models, _a) {
	        var _this = this;
	        var material = _a.material;
	        var tunnel = new THREE.Mesh(new THREE.PlaneBufferGeometry(100, 100), material);
	        // let tunnel = new THREE.Mesh(
	        //     new THREE.TorusGeometry(160, 75, 2, 13), new THREE.MeshNormalMaterial({})
	        // );
	        // let group = new THREE.Group();
	        var curves = (new Curves_1.Anim()).curves;
	        console.log(curves);
	        tunnel.userData.update = this.update.bind(this, tunnel);
	        // var counter = 20;
	        var swirls = [];
	        // for (var i = 0; i < curves.numCurves; i++) {
	        //     let mat = facingMat3.clone();
	        //     if (curves[i + ""].divisions.includes("tunnel"))
	        //         mat = facingMatTunnel.clone();
	        //     if (curves[i + ""].divisions.includes("normal"))
	        //         mat = new THREE.MeshNormalMaterial();
	        //     var swirl = this.makeSurface({
	        //         surface: curves[counter + ""],
	        //         material: mat,
	        //         textureColor: material.userData.rgb,
	        //         textureAlpha: material.userData.alpha
	        //     })
	        //     // swirl.position.set( 0, 0, -5);
	        //     swirl.material.side = THREE.DoubleSide;
	        //     swirls.push(swirl);
	        // }
	        // tunnel.userData.swirls = swirls;
	        // tunnel.userData.curves = curves;
	        var counter = 40;
	        tunnel.userData.swirls = [];
	        tunnel.userData.next = function () {
	            counter += 1;
	            console.log('playing: ' + counter);
	            return _this.makeSurface({
	                surface: curves[counter + ""],
	                material: material,
	                textureColor: material.userData.rgb,
	                textureAlpha: material.userData.alpha
	            });
	        };
	        setInterval(function () {
	            tunnel.userData.swirls.push(tunnel.userData.next());
	        }, 2000);
	        tunnel.userData.timer = new THREE.Clock();
	        return tunnel;
	    };
	    Tunnel.prototype.update = function (tunnel, time) {
	        tunnel.userData.swirls.forEach(function (swirl) {
	            // time = tunnel.userData.timer.getElapsedTime()
	            //     curves = tunnel.userData.curves;
	            // for (var i = 0; i < curves.numCurves; i++) {
	            //     // scope.swirls[i].setCam(MAEVR.camera);
	            //     swirls[i].update(1 * (time / 1000) * 30);
	            //     if (swirls[i].isInScene)
	            //         swirls[i].offset((i * .3) + 2 * .01 * time * -.02);
	            // }
	            // if (swirl.done) {
	            //     tunnel.userData.swirl = swirl = tunnel.userData.next();
	            //     tunnel.userData.timer = new THREE.Clock();
	            //     time = 0;
	            // }
	            if (swirl) {
	                swirl.update(1 * (time / 1000) * 30);
	                if (swirl.isInScene)
	                    swirl.offset((1 * .3) + 1 * .2 * time * -.02);
	            }
	        });
	    };
	    Tunnel.prototype.curve2 = function () {
	        var Curve_v01 = [
	            [v4(-94.2, 115.2, -235.72, 1),
	                v4(-100.55, 107.34, -235.72, 1),
	                v4(-113.24, 91.54, -235.83, 1),
	                v4(-122.73, 61.55, -235.87, 1),
	                v4(-113, 31.66, -235.93, 1),
	                v4(-99.62, 4.94, -235.97, 1),
	                v4(-83.99, -21.31, -236.02, 1),
	                v4(-67.54, -46.64, -236.07, 1),
	                v4(-51.17, -72.21, -236.14, 1),
	                v4(-36.7, -98.86, -236.2, 1),
	                v4(-20.48, -124.44, -236.23, 1),
	                v4(-5.35, -150.78, -236.25, 1),
	                v4(11.2, -176.29, -236.27, 1),
	                v4(45.4, -184.76, -236.3, 1),
	                v4(64.71, -151.89, -236.32, 1),
	                v4(98.72, -160.56, -236.31, 1),
	                v4(106.29, -193.36, -236.31, 1),
	                v4(121.46, -218.57, -236.27, 1),
	                v4(124.26, -250.01, -236.3, 1),
	                v4(146.06, -279.2, -236.18, 1),
	                v4(146.63, -231.33, -236.08, 1),
	                v4(145.6, -209.1, -236.05, 1),
	                v4(145.67, -174.08, -236.01, 1),
	                v4(159.8, -148.4, -236.01, 1),
	                v4(192.14, -137.4, -236.04, 1),
	                v4(219.54, -138.8, -236.07, 1),
	                v4(253.93, -118.94, -236.11, 1),
	                v4(224.22, -92.94, -236.1, 1),
	                v4(197.63, -84.55, -236.09, 1),
	                v4(171.02, -68.72, -236.08, 1),
	                v4(141.48, -57.41, -236.06, 1),
	                v4(118.14, -43.86, -236.04, 1),
	                v4(82.01, -30.53, -236.02, 1),
	                v4(90.93, 1.24, -235.98, 1),
	                v4(90.49, 30.93, -235.92, 1),
	                v4(62.35, 51.31, -235.89, 1),
	                v4(39.02, 67.18, -235.86, 1),
	                v4(13.3, 84.72, -235.81, 1),
	                v4(-11.66, 102.01, -235.77, 1),
	                v4(-39.18, 113.16, -235.74, 1),
	                v4(-69.35, 124.6, -235.73, 1),
	                v4(-88.44, 117.3, -235.72, 1),
	                v4(-96.46, 110.48, -235.72, 1),
	            ], [v4(-54.22, 61.67, -218.02, 1),
	                v4(-61.31, 65.94, -218.02, 1),
	                v4(-73.79, 55.62, -218.11, 1),
	                v4(-75.75, 34.66, -218.16, 1),
	                v4(-72.56, 14.05, -218.23, 1),
	                v4(-65.2, -4.74, -218.29, 1),
	                v4(-56.24, -24.64, -218.36, 1),
	                v4(-63, -44.69, -218.42, 1),
	                v4(-68.34, -64.85, -218.47, 1),
	                v4(-60.79, -84.99, -218.5, 1),
	                v4(-53, -103.74, -218.52, 1),
	                v4(-40.45, -120.43, -218.54, 1),
	                v4(-25.16, -134.42, -218.56, 1),
	                v4(-3.84, -139.91, -218.59, 1),
	                v4(14.7, -131.15, -218.59, 1),
	                v4(30.12, -113.98, -218.6, 1),
	                v4(35.06, -97.83, -218.6, 1),
	                v4(45.92, -70.6, -218.62, 1),
	                v4(61.05, -89.12, -218.59, 1),
	                v4(60.91, -112.59, -218.6, 1),
	                v4(64.87, -127.86, -218.56, 1),
	                v4(68.85, -157.18, -218.59, 1),
	                v4(63.18, -163.52, -218.42, 1),
	                v4(56.37, -130.94, -218.4, 1),
	                v4(53.11, -117.04, -218.35, 1),
	                v4(46.63, -93.91, -218.33, 1),
	                v4(50.49, -73.86, -218.31, 1),
	                v4(60.76, -58.82, -218.31, 1),
	                v4(99.87, -61.61, -218.35, 1),
	                v4(63.81, -61.21, -218.43, 1),
	                v4(66.76, -43.74, -218.36, 1),
	                v4(94, -37.94, -218.35, 1),
	                v4(99.01, -15.15, -218.28, 1),
	                v4(84.52, 0.46, -218.25, 1),
	                v4(68.41, 13.32, -218.21, 1),
	                v4(52.33, 26.09, -218.17, 1),
	                v4(35.6, 38.35, -218.14, 1),
	                v4(19.7, 51.1, -218.11, 1),
	                v4(2.78, 63.62, -218.07, 1),
	                v4(-15.57, 71.79, -218.04, 1),
	                v4(-36.96, 76.69, -218.02, 1),
	                v4(-49.28, 69.54, -218.02, 1),
	                v4(-54.53, 65.03, -218.02, 1),
	            ], [v4(-6.59, -0.77, -227.14, 1),
	                v4(-6.63, -2.16, -227.14, 1),
	                v4(-6.87, -4.93, -227.14, 1),
	                v4(-7.32, -9.08, -227.14, 1),
	                v4(-7.46, -13.24, -227.15, 1),
	                v4(-7.29, -17.41, -227.15, 1),
	                v4(-6.82, -21.56, -227.15, 1),
	                v4(-5.96, -25.64, -227.16, 1),
	                v4(-4.63, -29.6, -227.16, 1),
	                v4(-2.92, -33.4, -227.17, 1),
	                v4(-0.91, -37.06, -227.17, 1),
	                v4(1.52, -40.46, -227.17, 1),
	                v4(4.41, -43.47, -227.17, 1),
	                v4(7.63, -46.13, -227.18, 1),
	                v4(11.07, -48.49, -227.18, 1),
	                v4(14.92, -50.19, -227.18, 1),
	                v4(18.93, -51.19, -227.18, 1),
	                v4(23.3, -50.91, -227.17, 1),
	                v4(26.35, -47.74, -227.17, 1),
	                v4(28.01, -43.95, -227.16, 1),
	                v4(29.44, -40.02, -227.16, 1),
	                v4(30.93, -36.13, -227.16, 1),
	                v4(33.14, -32.57, -227.16, 1),
	                v4(36.01, -29.5, -227.16, 1),
	                v4(39.53, -27.23, -227.16, 1),
	                v4(42.86, -24.74, -227.16, 1),
	                v4(45.25, -21.14, -227.16, 1),
	                v4(44.87, -16.66, -227.16, 1),
	                v4(41.71, -13.72, -227.16, 1),
	                v4(38.44, -11.22, -227.16, 1),
	                v4(35.39, -8.34, -227.16, 1),
	                v4(32.49, -5.36, -227.15, 1),
	                v4(29.22, -2.75, -227.15, 1),
	                v4(25.88, -0.27, -227.15, 1),
	                v4(22.54, 2.23, -227.15, 1),
	                v4(18.97, 4.41, -227.14, 1),
	                v4(15.08, 5.94, -227.14, 1),
	                v4(10.89, 6.48, -227.14, 1),
	                v4(6.78, 5.45, -227.14, 1),
	                v4(3.07, 3.56, -227.14, 1),
	                v4(-0.41, 1.25, -227.14, 1),
	                v4(-2.56, -0.52, -227.14, 1),
	                v4(-3.6, -1.44, -227.14, 1),
	            ]
	        ];
	        var degree1_v01 = 2;
	        var degree2_v01 = 42;
	        var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	        var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	        var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	        return {
	            func: function (u, v) { return nurbsSurface_v01.getPoint(v, u); },
	            animation: [[0, 1], [51, 0.166], [128, -0.377], [170, -1]],
	            divisions: "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v1"
	        };
	    };
	    Tunnel.prototype.curve = function () {
	        var Curve_v01 = [
	            [
	                v4(-13.9, 11.21, 18.99, 1),
	                v4(-21.19, 15.11, 154.25, 1),
	                v4(-54.87, 19.93, 310.89, 1),
	                v4(-88.46, 33.17, 458.79, 1),
	            ], [
	                v4(-8.41, -2.6, 18.99, 1),
	                v4(-14.92, -6.58, 154.25, 1),
	                v4(-41.3, -31.85, 310.89, 1),
	                v4(-66.44, -50.55, 458.79, 1),
	            ]
	        ];
	        var degree1_v01 = 1;
	        var degree2_v01 = 3;
	        var knots1_v01 = [0, 0, 1, 1,];
	        var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	        var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	        return {
	            func: function (u, v) { return nurbsSurface_v01.getPoint(v, u); },
	            animation: [[0, -1], [271, -0.4205202312], [1387, -0.01046996304], [1650, 0.951758792]],
	            divisions: "|MAEmodelsPrevis|tunnel_1000_1_1_99_134_181_100_50_100_100_100_20|_20_5_v327"
	        };
	    };
	    ;
	    Tunnel.prototype.makeSurface = function (params) {
	        //AtomB_5000_1_2_124_202_247_200_100_1000_100_10
	        //name_timeOffset_rampPower_whichTexture_red_green_blue_colorMult_warp_warpSpeed_offsetMult_repeat_saturation
	        var _this = this;
	        var nameSplit = params.surface.divisions.split("|");
	        var divisions = nameSplit[3].split("_");
	        var shaderInfo = nameSplit[2].split("_");
	        var divisionMultiplier = new THREE.Vector2(1, 1); // 3,2 for more detail
	        var geometry = new THREE.ParametricGeometry(params.surface(), parseInt(divisions[1]) * divisionMultiplier.x, parseInt(divisions[2]) * divisionMultiplier.y);
	        var swirl = new THREE.Mesh(geometry, params.material === undefined ? new THREE.MeshNormalMaterial() : params.material);
	        swirl.material.depthTest = false;
	        swirl.material.uniforms['textureColor'].value = params.textureColor;
	        swirl.material.uniforms['textureAlpha'].value = params.textureAlpha;
	        swirl.material.uniforms['fade'].value = 0;
	        swirl.material.uniforms['power'].value = 1;
	        swirl.whichTexture = shaderInfo[3];
	        swirl.rampPower = shaderInfo[2];
	        swirl.colorMult = shaderInfo[7];
	        swirl.warp = shaderInfo[8];
	        swirl.warpSpeed = shaderInfo[9] ? shaderInfo[9] : 100;
	        swirl.offsetMult = shaderInfo[10] ? shaderInfo[10] : 100;
	        swirl.repeat = shaderInfo[11] ? shaderInfo[11] : 100;
	        swirl.saturation = shaderInfo[12] ? shaderInfo[12] : 20;
	        // console.log(swirl.warpSpeed);
	        swirl.objName = shaderInfo[0];
	        swirl.timeOffsetRandom = (((Math.random()) * shaderInfo[1]) / 1000) * 30;
	        swirl.color = new THREE.Vector3(((swirl.colorMult * .01) * shaderInfo[4] / 256) + Math.random() * (swirl.saturation * .01), ((swirl.colorMult * .01) * shaderInfo[5] / 256) + Math.random() * (swirl.saturation * .01), ((swirl.colorMult * .01) * shaderInfo[6] / 256) + Math.random() * (swirl.saturation * .01));
	        swirl.animation = params.surface.animation;
	        for (var i = 0; i < swirl.animation.length; i++) {
	            swirl.animation[i][0] += swirl.timeOffsetRandom;
	        }
	        swirl.inPoint = swirl.animation[0][0];
	        swirl.outPoint = swirl.animation[swirl.animation.length - 1][0];
	        swirl.isInScene = false;
	        swirl.done = false;
	        swirl.update = function (time) {
	            if (time < swirl.inPoint || time > swirl.outPoint && swirl.visible) {
	                if (swirl.isInScene) {
	                    _this.app.scene.remove(swirl);
	                    swirl.isInScene = false;
	                    swirl.done = true;
	                }
	            }
	            else if (time > swirl.inPoint && time < swirl.outPoint) {
	                var getLerp = _this.findInOut(time, swirl.animation);
	                var value = _this.remap(getLerp[0], 0, 1, swirl.animation[getLerp[1]][1], swirl.animation[getLerp[2]][1]);
	                if (value > -1 && value < 1) {
	                    swirl.setFade(value, swirl.rampPower);
	                    if (!swirl.isInScene) {
	                        _this.app.scene.add(swirl);
	                        swirl.isInScene = true;
	                    }
	                }
	                else {
	                    if (swirl.isInScene) {
	                        _this.app.scene.remove(swirl);
	                        swirl.isInScene = false;
	                    }
	                }
	            }
	            _this.isInScene = swirl.isInScene;
	            // console.log(swirl.isInScene);
	        };
	        swirl.next = function (cam) {
	            this.material.uniforms['camMat'].value = cam.matrixWorld;
	        };
	        swirl.setCam = function (cam) {
	            this.material.uniforms['camMat'].value = cam.matrixWorld;
	        };
	        swirl.offset = function (offset) {
	            this.material.uniforms['offset'].value = offset;
	        };
	        swirl.setFade = function (fade, power) {
	            this.material.uniforms['fade'].value = fade;
	            this.material.uniforms['power'].value = power;
	        };
	        swirl.setUniform = function (uniform, value) {
	            swirl.material.uniforms[uniform].value = value;
	        };
	        swirl.setColor = function (value) {
	            var thisTexture = "Color" + swirl.whichTexture;
	            swirl.material.uniforms[thisTexture].value = value;
	        };
	        swirl.checkIfIsInScene = function () {
	            // console.log(swirl.isInScene);
	            if (this.isInScene)
	                return true;
	            else
	                return false;
	        };
	        swirl.setColor(swirl.color);
	        swirl.setUniform("warp", swirl.warp);
	        swirl.setUniform("warpSpeed", swirl.warpSpeed);
	        swirl.setUniform("repeat", swirl.repeat);
	        swirl.setUniform("offsetMult", swirl.offsetMult);
	        return swirl;
	    };
	    Tunnel.prototype.findInOut = function (time, animationArray) {
	        var tween = 0;
	        var inPoint = 0;
	        var outPoint = 0;
	        for (var i = 1; i < animationArray.length; i++) {
	            var b = animationArray[i][0];
	            var bVal = animationArray[i][1];
	            var a = animationArray[i - 1][0];
	            var aVal = animationArray[i - 1][a];
	            if (time < b && time > a) {
	                tween = 1 - ((b - time) / (b - a));
	                inPoint = i - 1;
	                outPoint = i;
	            }
	        }
	        return [tween, inPoint, outPoint];
	    };
	    Tunnel.prototype.remap = function (value, from1, to1, from2, to2) {
	        return (value - from1) / (to1 - from1) * (to2 - from2) + from2;
	    };
	    return Tunnel;
	}(Forgable_1.Forgable));
	exports.Tunnel = Tunnel;
	//# sourceMappingURL=Tunnel.js.map

/***/ },
/* 78 */
/***/ function(module, exports) {

	"use strict";
	var v4 = function (x, y, z, w) { return new THREE.Vector4(x, y, z, w); };
	var Curves = {};
	Curves["0"] = function () {
	    var Curve_v01 = [[v4(-94.2, 115.2, -235.72, 1),
	            v4(-100.55, 107.34, -235.72, 1),
	            v4(-113.24, 91.54, -235.83, 1),
	            v4(-122.73, 61.55, -235.87, 1),
	            v4(-113, 31.66, -235.93, 1),
	            v4(-99.62, 4.94, -235.97, 1),
	            v4(-83.99, -21.31, -236.02, 1),
	            v4(-67.54, -46.64, -236.07, 1),
	            v4(-51.17, -72.21, -236.14, 1),
	            v4(-36.7, -98.86, -236.2, 1),
	            v4(-20.48, -124.44, -236.23, 1),
	            v4(-5.35, -150.78, -236.25, 1),
	            v4(11.2, -176.29, -236.27, 1),
	            v4(45.4, -184.76, -236.3, 1),
	            v4(64.71, -151.89, -236.32, 1),
	            v4(98.72, -160.56, -236.31, 1),
	            v4(106.29, -193.36, -236.31, 1),
	            v4(121.46, -218.57, -236.27, 1),
	            v4(124.26, -250.01, -236.3, 1),
	            v4(146.06, -279.2, -236.18, 1),
	            v4(146.63, -231.33, -236.08, 1),
	            v4(145.6, -209.1, -236.05, 1),
	            v4(145.67, -174.08, -236.01, 1),
	            v4(159.8, -148.4, -236.01, 1),
	            v4(192.14, -137.4, -236.04, 1),
	            v4(219.54, -138.8, -236.07, 1),
	            v4(253.93, -118.94, -236.11, 1),
	            v4(224.22, -92.94, -236.1, 1),
	            v4(197.63, -84.55, -236.09, 1),
	            v4(171.02, -68.72, -236.08, 1),
	            v4(141.48, -57.41, -236.06, 1),
	            v4(118.14, -43.86, -236.04, 1),
	            v4(82.01, -30.53, -236.02, 1),
	            v4(90.93, 1.24, -235.98, 1),
	            v4(90.49, 30.93, -235.92, 1),
	            v4(62.35, 51.31, -235.89, 1),
	            v4(39.02, 67.18, -235.86, 1),
	            v4(13.3, 84.72, -235.81, 1),
	            v4(-11.66, 102.01, -235.77, 1),
	            v4(-39.18, 113.16, -235.74, 1),
	            v4(-69.35, 124.6, -235.73, 1),
	            v4(-88.44, 117.3, -235.72, 1),
	            v4(-96.46, 110.48, -235.72, 1),
	        ], [v4(-54.22, 61.67, -218.02, 1),
	            v4(-61.31, 65.94, -218.02, 1),
	            v4(-73.79, 55.62, -218.11, 1),
	            v4(-75.75, 34.66, -218.16, 1),
	            v4(-72.56, 14.05, -218.23, 1),
	            v4(-65.2, -4.74, -218.29, 1),
	            v4(-56.24, -24.64, -218.36, 1),
	            v4(-63, -44.69, -218.42, 1),
	            v4(-68.34, -64.85, -218.47, 1),
	            v4(-60.79, -84.99, -218.5, 1),
	            v4(-53, -103.74, -218.52, 1),
	            v4(-40.45, -120.43, -218.54, 1),
	            v4(-25.16, -134.42, -218.56, 1),
	            v4(-3.84, -139.91, -218.59, 1),
	            v4(14.7, -131.15, -218.59, 1),
	            v4(30.12, -113.98, -218.6, 1),
	            v4(35.06, -97.83, -218.6, 1),
	            v4(45.92, -70.6, -218.62, 1),
	            v4(61.05, -89.12, -218.59, 1),
	            v4(60.91, -112.59, -218.6, 1),
	            v4(64.87, -127.86, -218.56, 1),
	            v4(68.85, -157.18, -218.59, 1),
	            v4(63.18, -163.52, -218.42, 1),
	            v4(56.37, -130.94, -218.4, 1),
	            v4(53.11, -117.04, -218.35, 1),
	            v4(46.63, -93.91, -218.33, 1),
	            v4(50.49, -73.86, -218.31, 1),
	            v4(60.76, -58.82, -218.31, 1),
	            v4(99.87, -61.61, -218.35, 1),
	            v4(63.81, -61.21, -218.43, 1),
	            v4(66.76, -43.74, -218.36, 1),
	            v4(94, -37.94, -218.35, 1),
	            v4(99.01, -15.15, -218.28, 1),
	            v4(84.52, 0.46, -218.25, 1),
	            v4(68.41, 13.32, -218.21, 1),
	            v4(52.33, 26.09, -218.17, 1),
	            v4(35.6, 38.35, -218.14, 1),
	            v4(19.7, 51.1, -218.11, 1),
	            v4(2.78, 63.62, -218.07, 1),
	            v4(-15.57, 71.79, -218.04, 1),
	            v4(-36.96, 76.69, -218.02, 1),
	            v4(-49.28, 69.54, -218.02, 1),
	            v4(-54.53, 65.03, -218.02, 1),
	        ], [v4(-6.59, -0.77, -227.14, 1),
	            v4(-6.63, -2.16, -227.14, 1),
	            v4(-6.87, -4.93, -227.14, 1),
	            v4(-7.32, -9.08, -227.14, 1),
	            v4(-7.46, -13.24, -227.15, 1),
	            v4(-7.29, -17.41, -227.15, 1),
	            v4(-6.82, -21.56, -227.15, 1),
	            v4(-5.96, -25.64, -227.16, 1),
	            v4(-4.63, -29.6, -227.16, 1),
	            v4(-2.92, -33.4, -227.17, 1),
	            v4(-0.91, -37.06, -227.17, 1),
	            v4(1.52, -40.46, -227.17, 1),
	            v4(4.41, -43.47, -227.17, 1),
	            v4(7.63, -46.13, -227.18, 1),
	            v4(11.07, -48.49, -227.18, 1),
	            v4(14.92, -50.19, -227.18, 1),
	            v4(18.93, -51.19, -227.18, 1),
	            v4(23.3, -50.91, -227.17, 1),
	            v4(26.35, -47.74, -227.17, 1),
	            v4(28.01, -43.95, -227.16, 1),
	            v4(29.44, -40.02, -227.16, 1),
	            v4(30.93, -36.13, -227.16, 1),
	            v4(33.14, -32.57, -227.16, 1),
	            v4(36.01, -29.5, -227.16, 1),
	            v4(39.53, -27.23, -227.16, 1),
	            v4(42.86, -24.74, -227.16, 1),
	            v4(45.25, -21.14, -227.16, 1),
	            v4(44.87, -16.66, -227.16, 1),
	            v4(41.71, -13.72, -227.16, 1),
	            v4(38.44, -11.22, -227.16, 1),
	            v4(35.39, -8.34, -227.16, 1),
	            v4(32.49, -5.36, -227.15, 1),
	            v4(29.22, -2.75, -227.15, 1),
	            v4(25.88, -0.27, -227.15, 1),
	            v4(22.54, 2.23, -227.15, 1),
	            v4(18.97, 4.41, -227.14, 1),
	            v4(15.08, 5.94, -227.14, 1),
	            v4(10.89, 6.48, -227.14, 1),
	            v4(6.78, 5.45, -227.14, 1),
	            v4(3.07, 3.56, -227.14, 1),
	            v4(-0.41, 1.25, -227.14, 1),
	            v4(-2.56, -0.52, -227.14, 1),
	            v4(-3.6, -1.44, -227.14, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["0"].animation = [[0, 1], [51, 0.166], [128, -0.377], [170, -1]];
	Curves["0"].divisions = "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v1";
	Curves["1"] = function () {
	    var Curve_v01 = [[v4(71.06, -68.7, -219.48, 1),
	            v4(78.84, -68.9, -219.48, 1),
	            v4(92.8, -63.71, -219.45, 1),
	            v4(104.91, -41.88, -219.17, 1),
	            v4(97.83, -20.12, -218.85, 1),
	            v4(85.28, -1.63, -218.64, 1),
	            v4(75.01, 18.11, -218.38, 1),
	            v4(64.22, 37.59, -218.15, 1),
	            v4(53.91, 57.32, -217.93, 1),
	            v4(44.12, 77.32, -217.71, 1),
	            v4(34.15, 97.22, -217.49, 1),
	            v4(21.71, 115.77, -217.3, 1),
	            v4(9.35, 134.17, -217.09, 1),
	            v4(-4.8, 151.63, -216.88, 1),
	            v4(-18.12, 169.01, -216.64, 1),
	            v4(-35.52, 184.32, -216.43, 1),
	            v4(-49.6, 199.39, -216.23, 1),
	            v4(-74.34, 210.48, -216.06, 1),
	            v4(-87.15, 187.84, -216.32, 1),
	            v4(-89.82, 166.68, -216.57, 1),
	            v4(-92.4, 144.1, -216.83, 1),
	            v4(-92.79, 122.09, -217, 1),
	            v4(-95.03, 99.67, -217.03, 1),
	            v4(-105.24, 79.25, -216.9, 1),
	            v4(-124.47, 66.84, -216.66, 1),
	            v4(-142.35, 54.18, -216.39, 1),
	            v4(-159.5, 39.41, -216.14, 1),
	            v4(-175.77, 25.03, -215.94, 1),
	            v4(-187.45, 3.56, -215.89, 1),
	            v4(-173.72, -17.2, -216.3, 1),
	            v4(-156.07, -29.56, -216.71, 1),
	            v4(-136.54, -41.07, -217.18, 1),
	            v4(-116.04, -49.34, -217.59, 1),
	            v4(-95.6, -58.42, -217.93, 1),
	            v4(-75, -66.67, -218.22, 1),
	            v4(-54.22, -74.8, -218.48, 1),
	            v4(-33.26, -82.12, -218.7, 1),
	            v4(-12.24, -89.76, -218.88, 1),
	            v4(9.85, -93.12, -219.1, 1),
	            v4(32.25, -90.47, -219.31, 1),
	            v4(53.2, -82.87, -219.45, 1),
	            v4(65.67, -74.42, -219.48, 1),
	            v4(71.42, -69.81, -219.48, 1),
	        ], [v4(42.21, -27.78, -201.78, 1),
	            v4(43.52, -24.4, -201.78, 1),
	            v4(47.04, -16.57, -201.74, 1),
	            v4(45.93, -5.3, -201.55, 1),
	            v4(41.46, 5.79, -201.25, 1),
	            v4(38.97, 17.02, -200.87, 1),
	            v4(34.75, 28.07, -200.47, 1),
	            v4(28.18, 37.7, -200.13, 1),
	            v4(19.14, 45.27, -199.84, 1),
	            v4(10.02, 52.4, -199.55, 1),
	            v4(1.41, 60.34, -199.21, 1),
	            v4(-6.51, 68.82, -198.89, 1),
	            v4(-15.18, 76.75, -198.66, 1),
	            v4(-24.03, 84.09, -198.5, 1),
	            v4(-33.35, 91.58, -198.36, 1),
	            v4(-46.02, 91.9, -198.59, 1),
	            v4(-53.89, 82.19, -199.09, 1),
	            v4(-60.62, 73.09, -199.29, 1),
	            v4(-70.33, 66.08, -199.32, 1),
	            v4(-80.02, 59.89, -199.27, 1),
	            v4(-89.58, 53.08, -199.16, 1),
	            v4(-98.54, 45.68, -199, 1),
	            v4(-106.56, 37.13, -198.8, 1),
	            v4(-112.45, 26.99, -198.58, 1),
	            v4(-116.35, 15.98, -198.37, 1),
	            v4(-117.88, 4.3, -198.21, 1),
	            v4(-114.97, -7.27, -198.23, 1),
	            v4(-108.05, -16.79, -198.45, 1),
	            v4(-99.58, -24.8, -198.76, 1),
	            v4(-90.31, -31.89, -199.12, 1),
	            v4(-80.11, -37.6, -199.52, 1),
	            v4(-69.29, -41.94, -199.9, 1),
	            v4(-58.14, -45.35, -200.25, 1),
	            v4(-46.82, -48.09, -200.57, 1),
	            v4(-35.27, -49.78, -200.85, 1),
	            v4(-23.62, -50.32, -201.09, 1),
	            v4(-11.96, -49.7, -201.3, 1),
	            v4(-0.45, -47.95, -201.46, 1),
	            v4(11.1, -46.15, -201.57, 1),
	            v4(22.1, -42.14, -201.69, 1),
	            v4(32.03, -35.92, -201.76, 1),
	            v4(38.33, -31.43, -201.78, 1),
	            v4(41.45, -29.1, -201.78, 1),
	        ], [v4(-4.6, -3.1, -211.94, 1),
	            v4(-3.45, -3.01, -211.94, 1),
	            v4(-1.19, -2.49, -211.94, 1),
	            v4(1.83, -0.69, -211.93, 1),
	            v4(3.89, 2.15, -211.93, 1),
	            v4(5.06, 5.41, -211.92, 1),
	            v4(5.59, 8.83, -211.91, 1),
	            v4(5.54, 12.29, -211.89, 1),
	            v4(5.06, 15.71, -211.88, 1),
	            v4(4.24, 19.06, -211.86, 1),
	            v4(3.18, 22.35, -211.84, 1),
	            v4(1.79, 25.51, -211.82, 1),
	            v4(0.05, 28.49, -211.8, 1),
	            v4(-1.96, 31.3, -211.78, 1),
	            v4(-4.07, 34.02, -211.76, 1),
	            v4(-6.73, 36.29, -211.74, 1),
	            v4(-9.67, 38.01, -211.73, 1),
	            v4(-13.33, 38.6, -211.72, 1),
	            v4(-16.09, 36.13, -211.73, 1),
	            v4(-17.55, 33.03, -211.75, 1),
	            v4(-18.57, 29.71, -211.77, 1),
	            v4(-19.4, 26.37, -211.78, 1),
	            v4(-20.88, 23.23, -211.78, 1),
	            v4(-22.61, 20.26, -211.77, 1),
	            v4(-24.49, 17.36, -211.76, 1),
	            v4(-26.47, 14.53, -211.75, 1),
	            v4(-28.55, 11.79, -211.73, 1),
	            v4(-30.56, 8.97, -211.72, 1),
	            v4(-32.36, 6.05, -211.71, 1),
	            v4(-33.38, 2.65, -211.71, 1),
	            v4(-32.43, -0.79, -211.73, 1),
	            v4(-30.4, -3.6, -211.76, 1),
	            v4(-27.68, -5.78, -211.79, 1),
	            v4(-24.61, -7.35, -211.83, 1),
	            v4(-21.42, -8.68, -211.86, 1),
	            v4(-18.08, -9.59, -211.89, 1),
	            v4(-14.64, -9.93, -211.91, 1),
	            v4(-11.18, -9.64, -211.92, 1),
	            v4(-7.86, -8.65, -211.93, 1),
	            v4(-4.73, -7.19, -211.94, 1),
	            v4(-1.76, -5.44, -211.94, 1),
	            v4(0.12, -4.11, -211.94, 1),
	            v4(1.04, -3.43, -211.94, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["1"].animation = [[0, 1], [51, 0.166], [128, -0.377], [170, -1]];
	Curves["1"].divisions = "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v2";
	Curves["2"] = function () {
	    var Curve_v01 = [[v4(69.01, 33.2, -194.8, 1),
	            v4(67.85, 41.55, -194.8, 1),
	            v4(48.39, 44.5, -194.14, 1),
	            v4(28.22, 51.19, -192.72, 1),
	            v4(3.36, 53.98, -191.33, 1),
	            v4(-19.1, 54.94, -189.99, 1),
	            v4(-43.91, 53.89, -188.62, 1),
	            v4(-62.34, 36.51, -189.11, 1),
	            v4(-62.6, 11.68, -190.64, 1),
	            v4(-67.51, -10.65, -190.09, 1),
	            v4(-79.21, -23.59, -188.75, 1),
	            v4(-86.48, -30.59, -187.1, 1),
	            v4(-90.69, -34.87, -185.89, 1),
	            v4(-93.89, -37.05, -184.93, 1),
	            v4(-97.29, -40.02, -184.12, 1),
	            v4(-103.21, -45.02, -183.35, 1),
	            v4(-112.36, -54.4, -182.62, 1),
	            v4(-126.51, -68.62, -181.92, 1),
	            v4(-141.57, -86.45, -181.3, 1),
	            v4(-158.48, -103.62, -180.71, 1),
	            v4(-170.9, -122.88, -180.19, 1),
	            v4(-188.73, -140.75, -179.61, 1),
	            v4(-185.65, -167.8, -179.27, 1),
	            v4(-156.87, -168.5, -179.8, 1),
	            v4(-135.76, -165.2, -180.31, 1),
	            v4(-112.26, -157.32, -181, 1),
	            v4(-91.72, -146.87, -181.71, 1),
	            v4(-71.24, -134.59, -182.44, 1),
	            v4(-54.71, -123.62, -183.11, 1),
	            v4(-43.43, -116.65, -183.77, 1),
	            v4(-36.45, -113.02, -184.42, 1),
	            v4(-31.55, -112.02, -185.17, 1),
	            v4(-26.67, -112.25, -186.05, 1),
	            v4(-19.44, -112.6, -187.06, 1),
	            v4(-7.8, -112.27, -188.24, 1),
	            v4(8.58, -108.1, -189.52, 1),
	            v4(28.11, -95.65, -190.85, 1),
	            v4(41.09, -75.57, -191.79, 1),
	            v4(50.75, -54.11, -192.49, 1),
	            v4(60.13, -32.51, -193.14, 1),
	            v4(70.39, -11.12, -193.76, 1),
	            v4(73.01, 4.5, -194.43, 1),
	            v4(73.55, 12.33, -194.8, 1),
	        ], [v4(39.54, 4.98, -177.09, 1),
	            v4(38.65, 10.82, -177.09, 1),
	            v4(32.09, 21.52, -176.6, 1),
	            v4(16.39, 30.32, -175.52, 1),
	            v4(-1.03, 34.02, -174.7, 1),
	            v4(-18.31, 38.48, -173.81, 1),
	            v4(-35.46, 42.03, -173.01, 1),
	            v4(-53.94, 41.95, -172.3, 1),
	            v4(-70.3, 43.93, -171.59, 1),
	            v4(-90.83, 41.04, -170.88, 1),
	            v4(-96.03, 22.71, -171.64, 1),
	            v4(-87.53, 7.08, -172.38, 1),
	            v4(-73.6, -4.04, -172.9, 1),
	            v4(-65.07, -16.11, -171.87, 1),
	            v4(-67.97, -20.49, -170.05, 1),
	            v4(-69.3, -23.68, -168.86, 1),
	            v4(-71.12, -25.94, -167.76, 1),
	            v4(-73.2, -28.89, -166.75, 1),
	            v4(-76.6, -33.17, -165.75, 1),
	            v4(-81.45, -39.87, -164.84, 1),
	            v4(-88.36, -49.51, -163.98, 1),
	            v4(-96.96, -62.69, -163.1, 1),
	            v4(-106.54, -77.71, -162.13, 1),
	            v4(-109.11, -96.27, -161.5, 1),
	            v4(-96.11, -111.18, -162.01, 1),
	            v4(-77.76, -112.74, -162.92, 1),
	            v4(-60.72, -107.41, -163.76, 1),
	            v4(-45.94, -101.95, -164.57, 1),
	            v4(-34.31, -98.83, -165.39, 1),
	            v4(-25.46, -97.87, -166.21, 1),
	            v4(-19.11, -97.9, -167.02, 1),
	            v4(-14.61, -98.26, -167.81, 1),
	            v4(-11.04, -98.45, -168.58, 1),
	            v4(-7.55, -97.69, -169.36, 1),
	            v4(-3.21, -95.48, -170.16, 1),
	            v4(2.79, -91.15, -171.09, 1),
	            v4(12.27, -86.13, -172.29, 1),
	            v4(23.77, -76.64, -173.59, 1),
	            v4(30.49, -59.84, -174.62, 1),
	            v4(35.22, -42.95, -175.47, 1),
	            v4(41.79, -26.22, -176.18, 1),
	            v4(43.06, -14.43, -176.79, 1),
	            v4(43.41, -8.51, -177.09, 1),
	        ], [v4(2.04, -3.43, -188.84, 1),
	            v4(1.84, -2, -188.84, 1),
	            v4(0.93, 0.79, -188.82, 1),
	            v4(-1.76, 4.26, -188.78, 1),
	            v4(-5.1, 7.01, -188.73, 1),
	            v4(-8.8, 9.32, -188.67, 1),
	            v4(-12.62, 11.28, -188.61, 1),
	            v4(-16.88, 12.56, -188.55, 1),
	            v4(-20.99, 13.12, -188.49, 1),
	            v4(-25.76, 13.27, -188.43, 1),
	            v4(-28.1, 8.9, -188.47, 1),
	            v4(-26.64, 4.62, -188.52, 1),
	            v4(-24.85, 0.83, -188.55, 1),
	            v4(-23.63, -3.6, -188.54, 1),
	            v4(-26.03, -7.51, -188.46, 1),
	            v4(-28.92, -10.62, -188.38, 1),
	            v4(-31.96, -13.77, -188.3, 1),
	            v4(-34.98, -16.84, -188.22, 1),
	            v4(-38.02, -19.94, -188.14, 1),
	            v4(-40.95, -23.13, -188.07, 1),
	            v4(-43.59, -26.57, -188, 1),
	            v4(-45.92, -30.24, -187.93, 1),
	            v4(-48.14, -33.91, -187.87, 1),
	            v4(-49.35, -38.29, -187.82, 1),
	            v4(-47.2, -42.37, -187.84, 1),
	            v4(-43.38, -44.65, -187.89, 1),
	            v4(-38.97, -44.97, -187.96, 1),
	            v4(-34.7, -44.31, -188.03, 1),
	            v4(-30.41, -43.7, -188.1, 1),
	            v4(-26.15, -42.91, -188.18, 1),
	            v4(-21.93, -41.94, -188.25, 1),
	            v4(-17.7, -40.98, -188.32, 1),
	            v4(-13.42, -40.32, -188.39, 1),
	            v4(-9.14, -39.59, -188.46, 1),
	            v4(-4.93, -38.65, -188.52, 1),
	            v4(-0.99, -36.51, -188.59, 1),
	            v4(1.04, -32.51, -188.65, 1),
	            v4(1.93, -28.3, -188.69, 1),
	            v4(2.57, -24, -188.73, 1),
	            v4(2.98, -19.69, -188.76, 1),
	            v4(3.37, -15.38, -188.8, 1),
	            v4(3.6, -12.5, -188.82, 1),
	            v4(3.7, -11.06, -188.84, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["2"].animation = [[0, 1], [51, 0.166], [128, -0.377], [170, -1]];
	Curves["2"].divisions = "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v3";
	Curves["3"] = function () {
	    var Curve_v01 = [[v4(-112.59, -132.17, -157.66, 1),
	            v4(-103.94, -139.82, -157.66, 1),
	            v4(-75.79, -121.21, -157.32, 1),
	            v4(-48.41, -107.18, -156.72, 1),
	            v4(-16.17, -85.46, -155.46, 1),
	            v4(16.32, -70.83, -153.23, 1),
	            v4(51.92, -63.75, -150.31, 1),
	            v4(86.34, -48.42, -147.95, 1),
	            v4(112.97, -27.48, -145.75, 1),
	            v4(145.85, -2.94, -144.17, 1),
	            v4(160.43, 23.07, -140.19, 1),
	            v4(210.45, 42.48, -138.11, 1),
	            v4(206.56, 56.61, -127.62, 1),
	            v4(150.32, 42.32, -127.87, 1),
	            v4(127.6, 32.54, -126.46, 1),
	            v4(78.15, 39.73, -125.55, 1),
	            v4(115.01, 77.7, -124.49, 1),
	            v4(143.78, 97.57, -125.06, 1),
	            v4(165.2, 112.27, -124.75, 1),
	            v4(207.9, 156.44, -124.55, 1),
	            v4(176.71, 155.95, -124.66, 1),
	            v4(146.1, 121.98, -124.73, 1),
	            v4(116.22, 111.4, -124.84, 1),
	            v4(87.83, 79.1, -124.85, 1),
	            v4(46.97, 87.33, -125.01, 1),
	            v4(76.55, 137.13, -124.79, 1),
	            v4(62.45, 165.1, -125.24, 1),
	            v4(43.03, 123.59, -125.83, 1),
	            v4(19.56, 79.13, -125.95, 1),
	            v4(1.19, 111.95, -130.52, 1),
	            v4(11.8, 147.06, -130.76, 1),
	            v4(12.9, 197.96, -134.84, 1),
	            v4(-10.26, 154.68, -142.03, 1),
	            v4(-30.73, 129.34, -140.95, 1),
	            v4(-53.93, 99.53, -143.06, 1),
	            v4(-76.4, 71.14, -143.7, 1),
	            v4(-95.31, 41.21, -145.58, 1),
	            v4(-114.93, 7.89, -146.79, 1),
	            v4(-109.5, -28.26, -150.33, 1),
	            v4(-111.15, -65.12, -154.2, 1),
	            v4(-126.17, -97.29, -156.06, 1),
	            v4(-125.48, -125.79, -157.66, 1),
	            v4(-112.99, -130.95, -157.66, 1),
	        ], [v4(-47.8, -56.22, -139.95, 1),
	            v4(-43.24, -60.85, -139.95, 1),
	            v4(-29.21, -55.31, -139.9, 1),
	            v4(-12.71, -51.42, -139.06, 1),
	            v4(2.79, -38.31, -137.57, 1),
	            v4(17.45, -30.7, -135.76, 1),
	            v4(35.53, -18.83, -134.01, 1),
	            v4(51.97, -27.75, -131.4, 1),
	            v4(68, -36.99, -129.08, 1),
	            v4(87.54, -32.98, -126.83, 1),
	            v4(103.76, -26.31, -124.66, 1),
	            v4(119.93, -16.16, -122.34, 1),
	            v4(134.77, -6.67, -119.93, 1),
	            v4(149.73, 5.6, -116.87, 1),
	            v4(161.41, 17.46, -115.18, 1),
	            v4(173.35, 35.83, -112.55, 1),
	            v4(163.75, 52.21, -109.49, 1),
	            v4(143.18, 53.8, -108.93, 1),
	            v4(124.94, 54.21, -107.85, 1),
	            v4(110.16, 66.83, -107.08, 1),
	            v4(131.42, 92.24, -106.87, 1),
	            v4(118.62, 93.23, -106.96, 1),
	            v4(102.06, 75.4, -107.05, 1),
	            v4(89.07, 66.55, -107.12, 1),
	            v4(72.78, 55.14, -107.19, 1),
	            v4(58.64, 44.18, -107.23, 1),
	            v4(36.52, 44.44, -107.25, 1),
	            v4(36.84, 67.61, -107.24, 1),
	            v4(33.24, 83.7, -107.36, 1),
	            v4(21.76, 100.56, -107.49, 1),
	            v4(3.28, 105.57, -108.1, 1),
	            v4(-15.02, 100.63, -109.15, 1),
	            v4(-31.01, 91.41, -111.45, 1),
	            v4(-43.15, 77.68, -115.41, 1),
	            v4(-48.49, 59.7, -120.43, 1),
	            v4(-42.48, 42.45, -124.43, 1),
	            v4(-32.5, 26.26, -128.01, 1),
	            v4(-38.72, 7.53, -131.24, 1),
	            v4(-49.7, -6.58, -133.6, 1),
	            v4(-57.48, -23.97, -136.19, 1),
	            v4(-57.65, -42.01, -139.06, 1),
	            v4(-52.43, -54.67, -139.95, 1),
	            v4(-46.15, -56.61, -139.95, 1),
	        ], [v4(0.71, -2.1, -154.07, 1),
	            v4(1.97, -1.58, -154.07, 1),
	            v4(4.5, -0.59, -154.07, 1),
	            v4(8.35, 0.78, -154.05, 1),
	            v4(12.25, 2.01, -154.01, 1),
	            v4(16.18, 3.1, -153.94, 1),
	            v4(20.16, 4.01, -153.85, 1),
	            v4(24.16, 4.83, -153.73, 1),
	            v4(28.16, 5.64, -153.57, 1),
	            v4(32.14, 6.53, -153.38, 1),
	            v4(36.08, 7.59, -153.16, 1),
	            v4(39.86, 9.14, -152.91, 1),
	            v4(43.26, 11.44, -152.65, 1),
	            v4(45.96, 14.55, -152.4, 1),
	            v4(47.61, 18.32, -152.21, 1),
	            v4(48.35, 22.36, -152.07, 1),
	            v4(48.21, 26.46, -151.98, 1),
	            v4(47.17, 30.44, -151.94, 1),
	            v4(45.3, 34.09, -151.92, 1),
	            v4(42.58, 37.2, -151.92, 1),
	            v4(39.06, 39.34, -151.93, 1),
	            v4(35.23, 40.76, -151.94, 1),
	            v4(31.28, 41.82, -151.94, 1),
	            v4(27.28, 42.62, -151.94, 1),
	            v4(23.26, 43.31, -151.94, 1),
	            v4(19.26, 44.21, -151.96, 1),
	            v4(15.42, 45.58, -151.98, 1),
	            v4(11.45, 46.65, -152.05, 1),
	            v4(7.31, 46.18, -152.24, 1),
	            v4(3.74, 43.91, -152.51, 1),
	            v4(1.87, 40.18, -152.76, 1),
	            v4(0.94, 36.23, -152.97, 1),
	            v4(0.1, 32.23, -153.16, 1),
	            v4(-0.49, 28.19, -153.33, 1),
	            v4(-0.84, 24.12, -153.49, 1),
	            v4(-1.05, 20.05, -153.63, 1),
	            v4(-1.2, 15.97, -153.76, 1),
	            v4(-1.3, 11.89, -153.86, 1),
	            v4(-1.37, 7.81, -153.95, 1),
	            v4(-1.47, 3.73, -154.02, 1),
	            v4(-1.64, -0.35, -154.06, 1),
	            v4(-1.83, -3.07, -154.07, 1),
	            v4(-1.94, -4.42, -154.07, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["3"].animation = [[0, 1], [51, 0.166], [128, -0.377], [170, -1]];
	Curves["3"].divisions = "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v4";
	Curves["4"] = function () {
	    var Curve_v01 = [[v4(108.39, -82.91, -131.3, 1),
	            v4(110.11, -72.76, -131.3, 1),
	            v4(97.13, -57.12, -130.64, 1),
	            v4(73.12, -42.98, -128.68, 1),
	            v4(43.97, -38.06, -126, 1),
	            v4(23.37, -17.24, -120.05, 1),
	            v4(29.81, 13.28, -116.08, 1),
	            v4(27.69, 40.29, -111.7, 1),
	            v4(11.34, 65.02, -108.39, 1),
	            v4(-10.27, 82.46, -105.2, 1),
	            v4(-31.78, 100.77, -103.28, 1),
	            v4(-59.52, 110.87, -99.39, 1),
	            v4(-74.55, 135.81, -97.86, 1),
	            v4(-76.57, 163.98, -90.97, 1),
	            v4(-87.65, 190.06, -88.72, 1),
	            v4(-100.97, 215.01, -88.28, 1),
	            v4(-116.62, 238.54, -87.34, 1),
	            v4(-127.56, 264.81, -86.86, 1),
	            v4(-136.89, 292.31, -86.17, 1),
	            v4(-175.18, 288.43, -85.87, 1),
	            v4(-184.37, 260.41, -85.93, 1),
	            v4(-174.85, 233.22, -86.27, 1),
	            v4(-159.08, 207.73, -86.42, 1),
	            v4(-154.68, 183.2, -86.71, 1),
	            v4(-139.85, 150.15, -86.8, 1),
	            v4(-156.86, 132.46, -87.59, 1),
	            v4(-195.15, 135.6, -88.3, 1),
	            v4(-198.13, 101.76, -92.38, 1),
	            v4(-173.39, 83.94, -94.89, 1),
	            v4(-158.69, 60.26, -95.8, 1),
	            v4(-137.07, 41.17, -97.87, 1),
	            v4(-116.06, 22.73, -99.55, 1),
	            v4(-94.56, 4.47, -102.36, 1),
	            v4(-73.8, -14.74, -105.01, 1),
	            v4(-51.72, -31.65, -107.96, 1),
	            v4(-30.91, -51.97, -110.41, 1),
	            v4(-22.04, -78.97, -110.06, 1),
	            v4(-3.64, -102.26, -114.1, 1),
	            v4(25.25, -104.86, -119.56, 1),
	            v4(53.59, -100.07, -124.83, 1),
	            v4(77.64, -93.29, -128.39, 1),
	            v4(102.48, -91.74, -131.3, 1),
	            v4(104.02, -82.11, -131.3, 1),
	        ], [v4(54.78, -49.82, -113.6, 1),
	            v4(60.77, -48.89, -113.6, 1),
	            v4(62.97, -30.83, -113.11, 1),
	            v4(50.36, -17.55, -110.45, 1),
	            v4(32.53, -11.95, -108.15, 1),
	            v4(11.8, -7.41, -105.27, 1),
	            v4(8.92, 13.04, -100.56, 1),
	            v4(20.06, 29.25, -98.31, 1),
	            v4(24.88, 47.31, -94.96, 1),
	            v4(21.51, 65.97, -89.14, 1),
	            v4(8.63, 79.96, -85.11, 1),
	            v4(-8.01, 89.06, -83.15, 1),
	            v4(-25.25, 96.84, -81.47, 1),
	            v4(-42.63, 104.06, -80.16, 1),
	            v4(-59.69, 112.88, -78.75, 1),
	            v4(-73.23, 125.95, -77.22, 1),
	            v4(-83.13, 142.83, -75.61, 1),
	            v4(-91.41, 158.62, -73.98, 1),
	            v4(-100.29, 177.43, -72.27, 1),
	            v4(-110.01, 189.61, -70.73, 1),
	            v4(-126.56, 209.18, -69.33, 1),
	            v4(-141.76, 197.37, -67.77, 1),
	            v4(-129.43, 175.3, -68.36, 1),
	            v4(-125.39, 159.9, -68.35, 1),
	            v4(-116.97, 140.88, -68.74, 1),
	            v4(-110.36, 124.44, -69.14, 1),
	            v4(-107.27, 103.39, -69.62, 1),
	            v4(-130.62, 95.99, -71.96, 1),
	            v4(-115.8, 73.93, -74.05, 1),
	            v4(-105.49, 62.54, -74.67, 1),
	            v4(-93.27, 45.75, -76.29, 1),
	            v4(-81.84, 31.92, -77.78, 1),
	            v4(-70.9, 15.93, -80.16, 1),
	            v4(-61.03, 0.45, -83.47, 1),
	            v4(-54.01, -17.39, -86.62, 1),
	            v4(-41.05, -30.96, -89.85, 1),
	            v4(-27.04, -43.53, -92.62, 1),
	            v4(-18.02, -60.88, -92.74, 1),
	            v4(-2.38, -71.81, -94.95, 1),
	            v4(16.14, -76.79, -100.91, 1),
	            v4(31.7, -68.21, -108.38, 1),
	            v4(43.85, -64.81, -113.6, 1),
	            v4(45.01, -57.59, -113.6, 1),
	        ], [v4(-10.48, -18.34, -129.41, 1),
	            v4(-10.63, -16.6, -129.41, 1),
	            v4(-12.03, -13.21, -129.39, 1),
	            v4(-15.71, -9.34, -129.35, 1),
	            v4(-18.29, -4.72, -129.24, 1),
	            v4(-20.53, 0.12, -129.02, 1),
	            v4(-24.79, 3.55, -128.79, 1),
	            v4(-27.02, 8.48, -128.5, 1),
	            v4(-30.71, 12.26, -128.23, 1),
	            v4(-36.22, 13.7, -128.09, 1),
	            v4(-38.03, 19.56, -127.76, 1),
	            v4(-43.66, 20.64, -127.62, 1),
	            v4(-48.87, 20.86, -127.52, 1),
	            v4(-54.02, 21.27, -127.42, 1),
	            v4(-59.63, 22.74, -127.28, 1),
	            v4(-61.1, 28.39, -127.06, 1),
	            v4(-59.46, 33.53, -126.9, 1),
	            v4(-57.94, 38.38, -126.75, 1),
	            v4(-54.64, 43.2, -126.61, 1),
	            v4(-56.72, 49.1, -126.41, 1),
	            v4(-62.29, 43.95, -126.49, 1),
	            v4(-65.1, 40.82, -126.54, 1),
	            v4(-68.97, 36.31, -126.61, 1),
	            v4(-70.9, 31.78, -126.7, 1),
	            v4(-73.65, 26.84, -126.8, 1),
	            v4(-73.16, 21.26, -126.95, 1),
	            v4(-66.89, 20.05, -127.05, 1),
	            v4(-62.02, 19.68, -127.12, 1),
	            v4(-56.98, 17.2, -127.24, 1),
	            v4(-55.05, 11.9, -127.4, 1),
	            v4(-50.65, 8.72, -127.52, 1),
	            v4(-47.44, 4.51, -127.64, 1),
	            v4(-44, 0.48, -127.77, 1),
	            v4(-39.77, -2.78, -127.9, 1),
	            v4(-36.88, -7.34, -128.01, 1),
	            v4(-35.55, -12.47, -128.03, 1),
	            v4(-32.89, -17.18, -128.09, 1),
	            v4(-29.68, -21.21, -128.22, 1),
	            v4(-24.73, -24.24, -128.49, 1),
	            v4(-19.58, -22.41, -128.81, 1),
	            v4(-14.32, -21.15, -129.21, 1),
	            v4(-11.72, -18.91, -129.41, 1),
	            v4(-11.86, -16.76, -129.41, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["4"].animation = [[0, 1], [51, 0.166], [128, -0.377], [170, -1]];
	Curves["4"].divisions = "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v5";
	Curves["5"] = function () {
	    var Curve_v01 = [[v4(71.17, -124.14, -101.39, 1),
	            v4(79.66, -117.93, -101.39, 1),
	            v4(93.36, -101.85, -99.91, 1),
	            v4(97.12, -69.98, -97.04, 1),
	            v4(96.76, -39.31, -93.35, 1),
	            v4(104.28, -9.35, -87.72, 1),
	            v4(112.43, 20.29, -84.56, 1),
	            v4(104.22, 52.31, -82.86, 1),
	            v4(97.19, 80.33, -81.09, 1),
	            v4(86.1, 112.67, -79.09, 1),
	            v4(80.19, 137.72, -78.12, 1),
	            v4(74.31, 180, -72.23, 1),
	            v4(44.63, 157.51, -65.53, 1),
	            v4(32.15, 125.57, -65.71, 1),
	            v4(-1.83, 121.33, -62.86, 1),
	            v4(-18.24, 152.03, -66.93, 1),
	            v4(-21.16, 187.51, -65.84, 1),
	            v4(-49.29, 199.15, -75.69, 1),
	            v4(-54.98, 154.26, -77.36, 1),
	            v4(-68.29, 132.43, -79.65, 1),
	            v4(-79.54, 100.76, -78.9, 1),
	            v4(-84.9, 69.95, -73.16, 1),
	            v4(-109.28, 50.99, -64.25, 1),
	            v4(-141.18, 47.52, -60.78, 1),
	            v4(-171.87, 46.9, -57.99, 1),
	            v4(-200.56, 26.98, -52.22, 1),
	            v4(-170.6, -7.74, -49.12, 1),
	            v4(-200.27, -31.57, -45.31, 1),
	            v4(-219.66, -46.02, -44.18, 1),
	            v4(-259.86, -62.14, -40.76, 1),
	            v4(-242.1, -94.52, -47.25, 1),
	            v4(-206.94, -76.18, -52.22, 1),
	            v4(-182.27, -70.83, -63.01, 1),
	            v4(-152.24, -69.35, -76.47, 1),
	            v4(-123.38, -74.04, -86.83, 1),
	            v4(-92.49, -66.5, -88.21, 1),
	            v4(-61.8, -61.79, -90.09, 1),
	            v4(-35.68, -81.53, -102.02, 1),
	            v4(-12.63, -97.75, -106.95, 1),
	            v4(13.95, -118.08, -110.97, 1),
	            v4(39.76, -128.8, -110.31, 1),
	            v4(65.3, -130.01, -102.03, 1),
	            v4(69.41, -120.56, -99.49, 1),
	        ], [v4(21.7, -54.12, -83.69, 1),
	            v4(27.7, -49.62, -83.69, 1),
	            v4(35.94, -37.1, -82.58, 1),
	            v4(46.21, -17.67, -78.83, 1),
	            v4(51.07, 3.4, -72.85, 1),
	            v4(54.22, 25.06, -68.79, 1),
	            v4(56.94, 46.9, -66.32, 1),
	            v4(59.05, 69.21, -64.27, 1),
	            v4(61.22, 90.77, -62.68, 1),
	            v4(61.49, 113.96, -60.11, 1),
	            v4(66.17, 133.69, -59.49, 1),
	            v4(62.47, 162.53, -53.17, 1),
	            v4(42.53, 137.27, -48.42, 1),
	            v4(36.13, 120.5, -49.5, 1),
	            v4(22.03, 99.43, -46.49, 1),
	            v4(11.51, 83.57, -47.82, 1),
	            v4(-1.2, 59.31, -44.87, 1),
	            v4(-26.48, 65.51, -50.14, 1),
	            v4(-21.92, 93.96, -48.47, 1),
	            v4(-37, 112.31, -59.12, 1),
	            v4(-43.76, 80.61, -61.53, 1),
	            v4(-50.88, 64.52, -61.67, 1),
	            v4(-61.81, 42.17, -54.74, 1),
	            v4(-80.14, 35.68, -45.42, 1),
	            v4(-103.38, 29.42, -42.75, 1),
	            v4(-122.49, 29.09, -39.79, 1),
	            v4(-150.26, 22.43, -36.59, 1),
	            v4(-142.07, -0.63, -30.73, 1),
	            v4(-117.14, -11.51, -31.09, 1),
	            v4(-126.28, -37.38, -25.51, 1),
	            v4(-141.29, -48.89, -27.24, 1),
	            v4(-168.35, -59.83, -21.19, 1),
	            v4(-164.65, -79.32, -33.23, 1),
	            v4(-136.49, -80.84, -37.56, 1),
	            v4(-118.25, -81.93, -42.76, 1),
	            v4(-95.57, -75.4, -49.69, 1),
	            v4(-79.23, -64.31, -56.41, 1),
	            v4(-64.16, -46.25, -62.38, 1),
	            v4(-41.67, -46.26, -68.67, 1),
	            v4(-21.41, -52.72, -74.47, 1),
	            v4(0.2, -56.24, -79.72, 1),
	            v4(14.7, -55.77, -82.49, 1),
	            v4(21.99, -54.65, -83.69, 1),
	        ], [v4(-0.28, -4.75, -101.41, 1),
	            v4(0.88, -3.83, -101.41, 1),
	            v4(3.13, -1.85, -101.4, 1),
	            v4(6.16, 1.46, -101.32, 1),
	            v4(8.74, 5.12, -101.19, 1),
	            v4(10.86, 9.07, -101.01, 1),
	            v4(12.5, 13.24, -100.8, 1),
	            v4(13.58, 17.59, -100.55, 1),
	            v4(13.99, 22.05, -100.28, 1),
	            v4(13.78, 26.52, -99.99, 1),
	            v4(13.14, 30.94, -99.7, 1),
	            v4(11.76, 35.24, -99.42, 1),
	            v4(9.56, 39.12, -99.18, 1),
	            v4(6.51, 42.54, -98.98, 1),
	            v4(1.99, 43.78, -98.97, 1),
	            v4(-2.43, 42.64, -99.14, 1),
	            v4(-6.18, 40.08, -99.38, 1),
	            v4(-8.85, 36.46, -99.65, 1),
	            v4(-11.47, 32.84, -99.86, 1),
	            v4(-14.34, 29.4, -99.98, 1),
	            v4(-17.42, 26.15, -99.97, 1),
	            v4(-20.72, 23.12, -99.82, 1),
	            v4(-24.19, 20.31, -99.58, 1),
	            v4(-27.82, 17.68, -99.28, 1),
	            v4(-31.33, 14.95, -98.95, 1),
	            v4(-34.65, 11.92, -98.64, 1),
	            v4(-37.52, 8.51, -98.38, 1),
	            v4(-40.12, 4.83, -98.15, 1),
	            v4(-42.39, 1.06, -97.96, 1),
	            v4(-45.09, -2.7, -97.69, 1),
	            v4(-45.94, -7.02, -97.67, 1),
	            v4(-47.81, -11.37, -97.46, 1),
	            v4(-45.01, -16.16, -97.98, 1),
	            v4(-40.89, -11.81, -98.58, 1),
	            v4(-38.12, -9.26, -98.97, 1),
	            v4(-34.74, -5.83, -99.42, 1),
	            v4(-31.28, -3.31, -99.84, 1),
	            v4(-27.26, -1.1, -100.28, 1),
	            v4(-22.87, -0.29, -100.65, 1),
	            v4(-18.36, -0.56, -100.97, 1),
	            v4(-14.03, -1.68, -101.22, 1),
	            v4(-11.25, -2.79, -101.35, 1),
	            v4(-9.91, -3.43, -101.41, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["5"].animation = [[0, 1], [51, 0.166], [128, -0.377], [170, -1]];
	Curves["5"].divisions = "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v6";
	Curves["6"] = function () {
	    var Curve_v01 = [[v4(-52.09, 80.18, -72.51, 1),
	            v4(-61.61, 73.14, -72.51, 1),
	            v4(-76.91, 52.83, -68.7, 1),
	            v4(-80.15, 14.26, -64.78, 1),
	            v4(-104.09, -11.41, -55.42, 1),
	            v4(-130.12, -34.68, -45.28, 1),
	            v4(-131.37, -75.74, -40.23, 1),
	            v4(-134.79, -107.33, -37.04, 1),
	            v4(-135.97, -149.31, -32.46, 1),
	            v4(-149.79, -174.68, -29.79, 1),
	            v4(-173.74, -222.18, -22.82, 1),
	            v4(-137.5, -202.8, -13.92, 1),
	            v4(-112.8, -161.63, -14.74, 1),
	            v4(-82.75, -181.82, -6.14, 1),
	            v4(-107.53, -229.49, -7.91, 1),
	            v4(-107.97, -250.6, -5.3, 1),
	            v4(-128.61, -310.11, -5.43, 1),
	            v4(-99.89, -277.28, -8.17, 1),
	            v4(-84.83, -243.05, -10.02, 1),
	            v4(-71.62, -212.3, -11.32, 1),
	            v4(-42.88, -178.09, -15.37, 1),
	            v4(-16.03, -204.78, -18.35, 1),
	            v4(6.95, -249.91, -21.54, 1),
	            v4(25.15, -210.25, -26.81, 1),
	            v4(17.92, -172.69, -26.94, 1),
	            v4(23.89, -139.08, -29.3, 1),
	            v4(23.31, -97.54, -31.04, 1),
	            v4(57.75, -78.73, -36.03, 1),
	            v4(94.71, -115.49, -39.53, 1),
	            v4(100.81, -60.56, -43.48, 1),
	            v4(145.37, -92.97, -42.57, 1),
	            v4(176.04, -100.15, -42.13, 1),
	            v4(214.48, -107.39, -46.56, 1),
	            v4(161.4, -65.25, -49.96, 1),
	            v4(153.14, -44.97, -49.8, 1),
	            v4(129.08, -7.9, -51.58, 1),
	            v4(114.22, 20.83, -52.92, 1),
	            v4(87.66, 49.27, -56.09, 1),
	            v4(55.28, 66.11, -51.8, 1),
	            v4(21.98, 75.48, -66.29, 1),
	            v4(-8.57, 91.8, -74.05, 1),
	            v4(-36.63, 85.03, -72.51, 1),
	            v4(-47.09, 82.66, -72.51, 1),
	        ], [v4(-17.5, 33.13, -54.81, 1),
	            v4(-25.5, 32.96, -54.81, 1),
	            v4(-38.9, 24.46, -51.24, 1),
	            v4(-51.93, 6.03, -45.42, 1),
	            v4(-59.61, -15.61, -40.21, 1),
	            v4(-70.77, -35.33, -35.73, 1),
	            v4(-89.38, -50.18, -30.61, 1),
	            v4(-101.5, -68.19, -26.53, 1),
	            v4(-108.66, -92.39, -20.23, 1),
	            v4(-108.24, -111.06, -17.07, 1),
	            v4(-117.36, -141.59, -10.18, 1),
	            v4(-103.63, -143.17, 2.4, 1),
	            v4(-81.48, -113.17, 1.6, 1),
	            v4(-69.54, -129.21, 12.02, 1),
	            v4(-93.08, -163.95, 11.36, 1),
	            v4(-69.41, -155.4, 11.55, 1),
	            v4(-59.65, -130.39, 8.26, 1),
	            v4(-45.33, -114.11, 6.92, 1),
	            v4(-35.95, -91.69, 4.21, 1),
	            v4(-24.21, -72.34, 1.64, 1),
	            v4(-13.97, -51.57, -1.23, 1),
	            v4(5.87, -36.34, -5.97, 1),
	            v4(28.7, -47.93, -10.67, 1),
	            v4(46.39, -60.87, -13.26, 1),
	            v4(66.74, -73.09, -15.95, 1),
	            v4(86.49, -84.5, -18.24, 1),
	            v4(108.31, -92.75, -21.25, 1),
	            v4(130.57, -98.76, -23.42, 1),
	            v4(153.89, -100.95, -24.57, 1),
	            v4(176.95, -100.39, -23.99, 1),
	            v4(199.17, -84.86, -25.84, 1),
	            v4(184.33, -61.08, -33.13, 1),
	            v4(166.27, -49.41, -34.27, 1),
	            v4(149.02, -33.02, -38.53, 1),
	            v4(131.81, -17.88, -40.96, 1),
	            v4(109.11, -11.13, -45.53, 1),
	            v4(91.31, 3.35, -47.57, 1),
	            v4(68.41, 11.64, -49.69, 1),
	            v4(49.21, 20.53, -51.25, 1),
	            v4(24.71, 32.16, -52.83, 1),
	            v4(9.07, 33.61, -53.66, 1),
	            v4(-18.83, 32.41, -54.81, 1),
	            v4(-18.73, 32.8, -54.81, 1),
	        ], [v4(-5.59, -3.43, -74.38, 1),
	            v4(-6.29, -4.62, -74.38, 1),
	            v4(-7.81, -6.93, -74.35, 1),
	            v4(-10.33, -10.21, -74.21, 1),
	            v4(-12.98, -13.4, -74.03, 1),
	            v4(-15.7, -16.51, -73.8, 1),
	            v4(-18.45, -19.6, -73.55, 1),
	            v4(-21.19, -22.69, -73.28, 1),
	            v4(-23.88, -25.83, -72.99, 1),
	            v4(-26.5, -29.02, -72.69, 1),
	            v4(-29.04, -32.28, -72.38, 1),
	            v4(-31.42, -35.66, -72.06, 1),
	            v4(-33.57, -39.18, -71.74, 1),
	            v4(-35.43, -42.87, -71.41, 1),
	            v4(-36.92, -46.74, -71.08, 1),
	            v4(-37.76, -50.79, -70.76, 1),
	            v4(-38.19, -54.91, -70.45, 1),
	            v4(-36.67, -58.99, -70.16, 1),
	            v4(-33, -61.25, -70.02, 1),
	            v4(-28.78, -61.73, -70.01, 1),
	            v4(-24.88, -60.01, -70.14, 1),
	            v4(-21.66, -57.45, -70.32, 1),
	            v4(-18.55, -54.69, -70.51, 1),
	            v4(-15.75, -51.65, -70.71, 1),
	            v4(-13.26, -48.33, -70.94, 1),
	            v4(-10.97, -44.9, -71.16, 1),
	            v4(-8.7, -41.43, -71.39, 1),
	            v4(-6.44, -37.97, -71.6, 1),
	            v4(-4.25, -34.46, -71.81, 1),
	            v4(-1.84, -31.1, -71.99, 1),
	            v4(0.79, -27.9, -72.15, 1),
	            v4(3.8, -25.03, -72.26, 1),
	            v4(6.56, -21.96, -72.4, 1),
	            v4(10.19, -19.73, -72.4, 1),
	            v4(13.37, -17.36, -72.5, 1),
	            v4(18.16, -16.75, -72.28, 1),
	            v4(19.29, -11.96, -72.88, 1),
	            v4(14.17, -10.79, -73.35, 1),
	            v4(10.78, -9.57, -73.66, 1),
	            v4(6.38, -8.94, -73.94, 1),
	            v4(2.6, -7.84, -74.27, 1),
	            v4(-0.27, -7.45, -74.38, 1),
	            v4(-1.61, -7.41, -74.38, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["6"].animation = [[0, 1], [51, 0.166], [128, -0.377], [170, -1]];
	Curves["6"].divisions = "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v7";
	Curves["7"] = function () {
	    var Curve_v01 = [[v4(-80.76, -98.67, -69.03, 1),
	            v4(-72.24, -99.35, -69.03, 1),
	            v4(-56.23, -96.4, -68.84, 1),
	            v4(-32.02, -86.98, -67.24, 1),
	            v4(-13.38, -72.46, -65.14, 1),
	            v4(9.03, -56.81, -58.62, 1),
	            v4(30.51, -74.34, -48.7, 1),
	            v4(51.29, -67.95, -34.77, 1),
	            v4(65.74, -50.68, -22.46, 1),
	            v4(76.07, -30.66, -11.95, 1),
	            v4(82.4, -8.07, -3, 1),
	            v4(85.19, 15.8, 4.79, 1),
	            v4(79, 39.83, 9.74, 1),
	            v4(67.64, 62.09, 12.17, 1),
	            v4(59.58, 85.78, 11.33, 1),
	            v4(60.33, 111.55, 10.04, 1),
	            v4(63.48, 135.11, 10.11, 1),
	            v4(71.49, 161.3, 10.3, 1),
	            v4(74.43, 181.76, 10.53, 1),
	            v4(88.01, 212.8, 10.73, 1),
	            v4(75.86, 224.95, 11, 1),
	            v4(58.73, 181.43, 11.13, 1),
	            v4(36.19, 197.27, 7.42, 1),
	            v4(36.35, 219.01, 3.98, 1),
	            v4(34.46, 256.36, 2.19, 1),
	            v4(22.36, 245.73, -9.26, 1),
	            v4(18.67, 213.82, -9.31, 1),
	            v4(12.68, 193.3, -14.21, 1),
	            v4(-1.99, 171.78, -20.38, 1),
	            v4(-21.94, 159.89, -29.1, 1),
	            v4(-39.5, 142.75, -35.87, 1),
	            v4(-56.17, 126.11, -42.64, 1),
	            v4(-70.87, 105.87, -48.64, 1),
	            v4(-82.16, 85.35, -53.83, 1),
	            v4(-91.06, 60.49, -58.86, 1),
	            v4(-83.99, 36.81, -58.33, 1),
	            v4(-63.29, 17.85, -53.1, 1),
	            v4(-71.68, -7.97, -61.36, 1),
	            v4(-83.94, -26.89, -68.54, 1),
	            v4(-91.6, -51.12, -74.4, 1),
	            v4(-91.3, -76.08, -75.55, 1),
	            v4(-86.06, -92.15, -72.14, 1),
	            v4(-82.33, -98.87, -69.03, 1),
	        ], [v4(-56.59, -45.34, -51.33, 1),
	            v4(-52.04, -50.47, -51.33, 1),
	            v4(-38.15, -48.91, -50.89, 1),
	            v4(-19.9, -46.16, -49, 1),
	            v4(-3.37, -35.89, -44.86, 1),
	            v4(10.03, -24.13, -39.59, 1),
	            v4(26.3, -17.72, -28.57, 1),
	            v4(40.68, -28.22, -18.7, 1),
	            v4(54.77, -27.05, -4.78, 1),
	            v4(64.45, -15.95, 8.07, 1),
	            v4(70.75, -0.37, 18.06, 1),
	            v4(66.5, 17.07, 26.12, 1),
	            v4(59.42, 34.55, 29.25, 1),
	            v4(51.99, 52.06, 29.5, 1),
	            v4(45.3, 70.2, 28.57, 1),
	            v4(45.29, 89.3, 27.97, 1),
	            v4(49.31, 108.4, 27.81, 1),
	            v4(53.98, 126.06, 27.96, 1),
	            v4(56.87, 146.57, 28.38, 1),
	            v4(59.32, 162.13, 28.71, 1),
	            v4(58.86, 190, 28.89, 1),
	            v4(45.3, 169, 28.13, 1),
	            v4(45.97, 146.69, 29.17, 1),
	            v4(25.98, 140.14, 26.57, 1),
	            v4(32.4, 171.28, 25.17, 1),
	            v4(30.83, 181.53, 24.26, 1),
	            v4(34.11, 212.55, 21.72, 1),
	            v4(20.56, 188.36, 15.81, 1),
	            v4(16.18, 173.61, 12.8, 1),
	            v4(6.39, 155.76, 8.17, 1),
	            v4(-3.74, 140.93, 5.19, 1),
	            v4(-14.8, 125.2, 2.04, 1),
	            v4(-26.06, 110.23, -1.18, 1),
	            v4(-31.74, 92.26, -5.78, 1),
	            v4(-31, 73.3, -10.67, 1),
	            v4(-19.33, 58.55, -17.65, 1),
	            v4(-19.95, 39.88, -25.28, 1),
	            v4(-33.84, 26.08, -29.89, 1),
	            v4(-40.42, 9.44, -36.17, 1),
	            v4(-48.89, -6.94, -41.91, 1),
	            v4(-50.47, -25.34, -47.62, 1),
	            v4(-51.8, -37.68, -50.06, 1),
	            v4(-50.47, -43.9, -51.33, 1),
	        ], [v4(-8.91, -6.08, -72.53, 1),
	            v4(-7.67, -5.38, -72.53, 1),
	            v4(-5.17, -4.01, -72.52, 1),
	            v4(-1.35, -2.08, -72.48, 1),
	            v4(2.51, -0.26, -72.4, 1),
	            v4(6.45, 1.42, -72.27, 1),
	            v4(10.44, 2.93, -72.08, 1),
	            v4(14.51, 4.24, -71.83, 1),
	            v4(18.54, 5.58, -71.46, 1),
	            v4(22.63, 6.85, -71, 1),
	            v4(26.47, 8.48, -70.34, 1),
	            v4(30.46, 10.16, -69.53, 1),
	            v4(31.99, 14.64, -68.16, 1),
	            v4(28.62, 17.86, -67.56, 1),
	            v4(25.43, 20.43, -67.31, 1),
	            v4(21.84, 22.9, -67.26, 1),
	            v4(19, 26.16, -67.29, 1),
	            v4(17.92, 30.42, -67.33, 1),
	            v4(17.87, 34.68, -67.36, 1),
	            v4(17.88, 38.97, -67.37, 1),
	            v4(18.08, 43.23, -67.36, 1),
	            v4(18.38, 47.5, -67.34, 1),
	            v4(18.8, 51.75, -67.32, 1),
	            v4(18.12, 56.05, -67.32, 1),
	            v4(17.59, 60.18, -67.29, 1),
	            v4(14.34, 64.01, -67.44, 1),
	            v4(9.97, 61.59, -67.8, 1),
	            v4(7.34, 58.53, -68.08, 1),
	            v4(5.07, 54.75, -68.41, 1),
	            v4(3.64, 50.79, -68.72, 1),
	            v4(1.85, 46.88, -69.06, 1),
	            v4(0.36, 42.9, -69.41, 1),
	            v4(-0.81, 38.79, -69.75, 1),
	            v4(-1.74, 34.64, -70.09, 1),
	            v4(-2.64, 30.47, -70.45, 1),
	            v4(-3.35, 26.27, -70.81, 1),
	            v4(-3.79, 22.03, -71.16, 1),
	            v4(-3.99, 17.77, -71.5, 1),
	            v4(-3.98, 13.5, -71.83, 1),
	            v4(-3.66, 9.25, -72.12, 1),
	            v4(-3.01, 5.02, -72.36, 1),
	            v4(-2.34, 2.25, -72.48, 1),
	            v4(-1.94, 0.89, -72.53, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["7"].animation = [[0, 1], [51, 0.166], [128, -0.377], [170, -1]];
	Curves["7"].divisions = "|MAEmodelsPrevis|powerBallWarp_20000_2_3_8_100_140_200_100_300_100_100_20|_81_9_v8";
	Curves.numCurves = 8;
	Curves["8"] = function () {
	    var Curve_v01 = [[v4(8.94, 26.59, 52.24, 1),
	            v4(19.15, 31.01, 49.64, 1),
	            v4(40.02, 39.18, 47.08, 1),
	            v4(63.1, 54.56, 24.83, 1),
	            v4(65.65, 66.12, -6.13, 1),
	            v4(49.08, 71.25, -33.72, 1),
	            v4(22.94, 77.57, -52.38, 1),
	            v4(-5.37, 92.53, -66.83, 1),
	            v4(-35.85, 113.53, -75.8, 1),
	            v4(-65.31, 133.17, -65.48, 1),
	            v4(-81.01, 147.39, -34.93, 1),
	            v4(-83.08, 159.51, 1.34, 1),
	            v4(-66.86, 168.89, 34.86, 1),
	            v4(-38.24, 173.96, 56.44, 1),
	            v4(-4.27, 176.99, 62.58, 1),
	            v4(27.33, 180.65, 48.86, 1),
	            v4(53.63, 186.06, 24.7, 1),
	            v4(68.12, 197.69, -9.39, 1),
	        ], [v4(15.77, 27.52, 50.19, 1),
	            v4(25.69, 32.17, 47.35, 1),
	            v4(45.59, 41.16, 43.03, 1),
	            v4(64.38, 55.51, 15.99, 1),
	            v4(61.21, 63.66, -15.58, 1),
	            v4(39.83, 63.14, -41.54, 1),
	            v4(9.38, 63.14, -58.63, 1),
	            v4(-20.29, 68.51, -71.88, 1),
	            v4(-50.8, 84.04, -74.49, 1),
	            v4(-74.89, 102.39, -53.92, 1),
	            v4(-76.48, 113.47, -17.44, 1),
	            v4(-69.8, 124.29, 17.14, 1),
	            v4(-52.86, 136.01, 46.81, 1),
	            v4(-27.14, 146.78, 65.95, 1),
	            v4(2.69, 156.29, 72.31, 1),
	            v4(28.82, 164.58, 62.49, 1),
	            v4(51.21, 172.7, 43.3, 1),
	            v4(59.03, 185.15, 7.85, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 17;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["8"].animation = [[3157, 1], [4393, 0.303465765], [5019, 1], [5624, -0.5970732226], [5929, -0.8230134716], [6070, -1], [6406, -1]];
	Curves["8"].divisions = "|MAEmodelsPrevis|backgroundSwirls_6000_1_2_99_134_181_100_50_100_100_100_20|_91_2_v10";
	Curves["9"] = function () {
	    var Curve_v01 = [[v4(70.83, -4.05, -5.08, 1),
	            v4(67.72, -1.25, -20.55, 1),
	            v4(66.28, 4.75, -51.82, 1),
	            v4(33.69, 19.91, -88.99, 1),
	            v4(-15.84, 34.92, -96.9, 1),
	            v4(-62.54, 46.31, -76.02, 1),
	            v4(-95.08, 60.07, -39.79, 1),
	            v4(-118.73, 81.92, 0.23, 1),
	            v4(-131.76, 108.38, 44.2, 1),
	            v4(-115.55, 132.47, 89.22, 1),
	            v4(-69.26, 148.98, 116.57, 1),
	            v4(-13.42, 162.07, 124.47, 1),
	            v4(39.66, 173.51, 104.91, 1),
	            v4(75.78, 181.01, 65.38, 1),
	            v4(89, 186.59, 15.86, 1),
	            v4(71.44, 193.44, -32.78, 1),
	            v4(37.64, 206.7, -74.97, 1),
	        ], [v4(77.16, -39.49, -15.47, 1),
	            v4(74.28, -37.88, -30.55, 1),
	            v4(70.62, -33.61, -60.41, 1),
	            v4(33.35, -26.75, -91.04, 1),
	            v4(-13.75, -6.42, -90.31, 1),
	            v4(-55.33, 16.87, -62.79, 1),
	            v4(-84.9, 35.05, -20.5, 1),
	            v4(-108.5, 56.69, 21.67, 1),
	            v4(-116.44, 79, 66.52, 1),
	            v4(-89.19, 101.17, 104.96, 1),
	            v4(-35.34, 113.72, 112.19, 1),
	            v4(16.79, 125.27, 106.9, 1),
	            v4(61.67, 139.17, 85.58, 1),
	            v4(88.41, 153.28, 49.78, 1),
	            v4(94.53, 168.44, 7.48, 1),
	            v4(75.49, 185.43, -30.88, 1),
	            v4(42.39, 200.63, -67.72, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 16;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["9"].animation = [[3157, 1], [4393, 0.303465765], [5019, 1], [5624, -0.5970732226], [5929, -0.8230134716], [6070, -1], [6406, -1]];
	Curves["9"].divisions = "|MAEmodelsPrevis|backgroundSwirls_6000_1_2_99_134_181_100_50_100_100_100_20|_91_2_v11";
	Curves["10"] = function () {
	    var Curve_v01 = [[v4(0.33, 59.11, 78.64, 1),
	            v4(15.94, 61.91, 77.26, 1),
	            v4(47.2, 67.91, 78.46, 1),
	            v4(86.38, 81.24, 51.27, 1),
	            v4(97.49, 90.85, 6.42, 1),
	            v4(79.71, 94.53, -38.05, 1),
	            v4(45.77, 100.24, -71.65, 1),
	            v4(7.63, 115.69, -99.62, 1),
	            v4(-35, 139.6, -120.04, 1),
	            v4(-80.72, 165.38, -111.87, 1),
	            v4(-111.05, 187.44, -70.75, 1),
	            v4(-122.71, 208.92, -17.98, 1),
	            v4(-106.85, 228.91, 35.1, 1),
	            v4(-69.95, 241.95, 73.61, 1),
	            v4(-21.52, 248.78, 90.69, 1),
	            v4(28.14, 254.76, 78.06, 1),
	            v4(72.51, 261.07, 48.83, 1),
	        ], [v4(10.85, 55.11, 77.26, 1),
	            v4(26.1, 57.79, 75.45, 1),
	            v4(56.35, 61.41, 73.84, 1),
	            v4(90.36, 56.69, 38.59, 1),
	            v4(93.22, 39.82, -8.52, 1),
	            v4(67.98, 32.74, -51.73, 1),
	            v4(27.34, 40.31, -84.06, 1),
	            v4(-13.09, 64.07, -110.57, 1),
	            v4(-57.27, 98.74, -121.65, 1),
	            v4(-97.53, 132.2, -97.18, 1),
	            v4(-108.55, 153.87, -43.98, 1),
	            v4(-106.95, 174.24, 8.39, 1),
	            v4(-88.29, 195.4, 54.5, 1),
	            v4(-54.27, 214.3, 84.6, 1),
	            v4(-13.18, 231.84, 96.32, 1),
	            v4(26.53, 246.18, 82.6, 1),
	            v4(65.78, 255.13, 53.3, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 16;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["10"].animation = [[3157, 1], [4393, 0.303465765], [5019, 1], [5624, -0.5970732226], [5929, -0.8230134716], [6070, -1], [6406, -1]];
	Curves["10"].divisions = "|MAEmodelsPrevis|backgroundSwirls_6000_1_2_99_134_181_100_50_100_100_100_20|_91_2_v12";
	Curves.numCurves = 11;
	Curves["11"] = function () {
	    var Curve_v01 = [[v4(-17.96, 10.95, 103.35, 1),
	            v4(-24.79, 15.01, 96.8, 1),
	            v4(-39.55, 22.89, 84.97, 1),
	            v4(-46.87, 34.4, 53.81, 1),
	            v4(-54.96, 44.88, 13.72, 1),
	            v4(-60.24, 53.53, -33.6, 1),
	            v4(-46.58, 63.02, -84.4, 1),
	            v4(-17.09, 75.37, -125.56, 1),
	            v4(19.9, 90.63, -148.01, 1),
	            v4(55.7, 108.58, -150.83, 1),
	            v4(83.43, 130.65, -145.35, 1),
	            v4(100.65, 157.74, -137.68, 1),
	            v4(111.27, 187.03, -121.42, 1),
	            v4(123.21, 225.31, -95.45, 1),
	            v4(120.83, 262.78, -65.91, 1),
	            v4(98.94, 293.76, -33.54, 1),
	            v4(64.66, 323.49, 1.03, 1),
	        ], [v4(-21.5, 14.82, 100, 1),
	            v4(-28.31, 18.95, 93.47, 1),
	            v4(-42.99, 27.33, 81.71, 1),
	            v4(-49.42, 40.65, 51.24, 1),
	            v4(-55.74, 54.22, 14.5, 1),
	            v4(-64.54, 67.47, -26.44, 1),
	            v4(-63.36, 81.95, -74.73, 1),
	            v4(-49.06, 98.48, -121.56, 1),
	            v4(-22.54, 119.17, -155.35, 1),
	            v4(5.38, 145.06, -171.72, 1),
	            v4(33.99, 174.78, -173.45, 1),
	            v4(59.36, 206.94, -162.49, 1),
	            v4(71.05, 239.66, -142.04, 1),
	            v4(76.02, 270.91, -111.16, 1),
	            v4(70.69, 301.41, -71.59, 1),
	            v4(56.01, 325.9, -27.2, 1),
	            v4(39.28, 336.04, 14.87, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 16;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["11"].animation = [[3157, 1], [4393, 0.303465765], [5019, 1], [5624, -0.5970732226], [5929, -0.8230134716], [6070, -1], [6406, -1]];
	Curves["11"].divisions = "|MAEmodelsPrevis|backgroundSwirlsEnd_6000_1_1_242_256_256_80_100_100_100_100_20|_91_2_v13";
	Curves.numCurves = 12;
	Curves["12"] = function () {
	    var Curve_v01 = [[v4(-13.9, 11.21, 18.99, 1),
	            v4(-21.19, 15.11, 154.25, 1),
	            v4(-54.87, 19.93, 310.89, 1),
	            v4(-88.46, 33.17, 458.79, 1),
	        ], [v4(-8.41, -2.6, 18.99, 1),
	            v4(-14.92, -6.58, 154.25, 1),
	            v4(-41.3, -31.85, 310.89, 1),
	            v4(-66.44, -50.55, 458.79, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["12"].animation = [[0, -1], [271, -0.4205202312], [1387, -0.01046996304], [1650, 0.951758792]];
	Curves["12"].divisions = "|MAEmodelsPrevis|tunnel_1000_1_1_99_134_181_100_50_100_100_100_20|_20_5_v327";
	Curves["13"] = function () {
	    var Curve_v01 = [[v4(5.5, 20.06, 18.99, 1),
	            v4(9.49, 30.35, 154.25, 1),
	            v4(13.64, 61.38, 310.89, 1),
	            v4(23.45, 100.49, 458.79, 1),
	        ], [v4(-17.05, 1.95, 18.99, 1),
	            v4(-26, 1.18, 154.25, 1),
	            v4(-56.89, -13.07, 310.89, 1),
	            v4(-92.29, -20.2, 458.79, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["13"].animation = [[0, -1], [271, -0.4205202312], [1387, -0.01046996304], [1650, 0.951758792]];
	Curves["13"].divisions = "|MAEmodelsPrevis|tunnel_1000_1_1_99_134_181_100_50_100_100_100_20|_20_5_v328";
	Curves["14"] = function () {
	    var Curve_v01 = [[v4(16.17, 0.25, 18.99, 1),
	            v4(25.94, -2.07, 154.25, 1),
	            v4(54.82, -20.07, 310.89, 1),
	            v4(89.05, -31.56, 458.79, 1),
	        ], [v4(16.96, 13.21, 18.99, 1),
	            v4(26.43, 19.75, 154.25, 1),
	            v4(54.71, 33.2, 310.89, 1),
	            v4(88.94, 54.49, 458.79, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["14"].animation = [[0, -1], [271, -0.4205202312], [1387, -0.01046996304], [1650, 0.951758792]];
	Curves["14"].divisions = "|MAEmodelsPrevis|tunnel_1000_1_1_99_134_181_100_50_100_100_100_20|_20_5_v329";
	Curves["15"] = function () {
	    var Curve_v01 = [[v4(2.86, -4.25, 18.99, 1),
	            v4(9.58, -13.19, 154.25, 1),
	            v4(19.67, -48.3, 310.89, 1),
	            v4(31.99, -77.11, 458.79, 1),
	        ], [v4(13.04, 6.97, 18.99, 1),
	            v4(24.8, 7.87, 154.25, 1),
	            v4(58.33, 2.12, 310.89, 1),
	            v4(94.37, 4.4, 458.79, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["15"].animation = [[0, -1], [271, -0.4205202312], [1387, -0.01046996304], [1650, 0.951758792]];
	Curves["15"].divisions = "|MAEmodelsPrevis|tunnel_1000_1_1_99_134_181_100_50_100_100_100_20|_20_5_v330";
	Curves.numCurves = 16;
	Curves["16"] = function () {
	    var Curve_v01 = [[v4(167.76, 537.33, -987.76, 1),
	            v4(22.13, 564.59, -938.9, 1),
	            v4(-283.46, 712.76, -817.84, 1),
	            v4(-391.81, 1124.27, -503.02, 1),
	            v4(-75.92, 1268.73, -294.65, 1),
	            v4(36.8, 1313.13, -218.74, 1),
	        ], [v4(121.43, 292.86, -1283.11, 1),
	            v4(-121.66, 354.17, -1258.95, 1),
	            v4(-629.17, 632.16, -1195.93, 1),
	            v4(-861.99, 1359.72, -812.88, 1),
	            v4(-415.53, 1615.41, -409.23, 1),
	            v4(-257.37, 1695.51, -261.42, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["16"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["16"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_1";
	Curves["17"] = function () {
	    var Curve_v01 = [[v4(523.99, 1257.76, 48.43, 1),
	            v4(711.94, 1150.94, 134.5, 1),
	            v4(1356.1, 623.56, 655.37, 1),
	            v4(127.32, 552.8, 1147.7, 1),
	            v4(-138.41, 998.42, 465.98, 1),
	            v4(-262.47, 1082.9, 262.29, 1),
	        ], [v4(702.01, 1575.34, 38.93, 1),
	            v4(948.36, 1370.95, 197.21, 1),
	            v4(1713.81, 400.93, 1059.93, 1),
	            v4(-267.28, 454.54, 1519.14, 1),
	            v4(-436.57, 1251.53, 487.36, 1),
	            v4(-562.11, 1423.43, 162.61, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["17"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["17"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_2";
	Curves["18"] = function () {
	    var Curve_v01 = [[v4(-157.63, 714.33, 703.06, 1),
	            v4(-117.57, 640.14, 776.31, 1),
	            v4(1.74, 452.43, 952.55, 1),
	            v4(-145.27, 72.63, 1007.78, 1),
	            v4(-464.55, 114.57, 919.07, 1),
	            v4(-557.6, 129.43, 889.97, 1),
	        ], [v4(20.38, 979.17, 778.71, 1),
	            v4(58.92, 855.39, 943.73, 1),
	            v4(192.86, 538.98, 1351.43, 1),
	            v4(-139.09, -146.6, 1478.09, 1),
	            v4(-688.9, -68.86, 1185.69, 1),
	            v4(-847.66, -42.03, 1093.97, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["18"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["18"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_3";
	Curves["19"] = function () {
	    var Curve_v01 = [[v4(-265.14, 1066.7, 280.83, 1),
	            v4(-208.94, 918.75, 479.12, 1),
	            v4(-162.29, 355.06, 1130.64, 1),
	            v4(1153.38, 283.61, 796.22, 1),
	            v4(875.45, -411.87, 537.46, 1),
	            v4(682.62, -629.25, 466.02, 1),
	        ], [v4(-301.04, 1349.1, 131.46, 1),
	            v4(-291.88, 1196.85, 402.69, 1),
	            v4(-432.94, 607.96, 1270.53, 1),
	            v4(1222.09, 416.06, 1207.84, 1),
	            v4(901.62, -457.67, 927.72, 1),
	            v4(671.99, -724.95, 825.15, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["19"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["19"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_4";
	Curves["20"] = function () {
	    var Curve_v01 = [[v4(-287.3, 1081.59, 241.49, 1),
	            v4(-515.02, 832.11, 278.17, 1),
	            v4(-1069.59, 274.77, 604.68, 1),
	            v4(12.18, -198.85, 1160.81, 1),
	            v4(406.42, -624.08, 584.69, 1),
	            v4(671.93, -687.59, 404.95, 1),
	        ], [v4(-1080.76, 1157.2, 847.34, 1),
	            v4(-1273.44, 804.28, 502.5, 1),
	            v4(-1936.26, -204.7, -49.16, 1),
	            v4(-690.86, -1297.15, 1132.74, 1),
	            v4(443.5, -1316.07, 552.28, 1),
	            v4(946.16, -1232.48, 546.85, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["20"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["20"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_5";
	Curves["21"] = function () {
	    var Curve_v01 = [[v4(-920.09, -657.04, 1.63, 1),
	            v4(-808.75, -757.13, 87.5, 1),
	            v4(-575.12, -855.61, 453.57, 1),
	            v4(16.84, -904.88, 326.36, 1),
	            v4(-144.58, -883.48, -221.74, 1),
	            v4(-175.22, -842.18, -340.98, 1),
	        ], [v4(-1141.98, -762.95, -122.39, 1),
	            v4(-1036.11, -876.28, 21.7, 1),
	            v4(-850.92, -950.25, 530.15, 1),
	            v4(-113.09, -1053.9, 532.09, 1),
	            v4(-173.15, -1104.25, -164.81, 1),
	            v4(-178.25, -1070.82, -320.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["21"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["21"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_6";
	Curves["22"] = function () {
	    var Curve_v01 = [[v4(-767.68, 316.88, 622.41, 1),
	            v4(-700.11, 130.52, 790.07, 1),
	            v4(-390.48, -567.1, 1159.74, 1),
	            v4(-813.99, -999.28, -179.25, 1),
	            v4(-1175.69, -228, 31.78, 1),
	            v4(-1232.03, 15.46, 83.75, 1),
	        ], [v4(-615.05, 697.75, 478.89, 1),
	            v4(-578.79, 428.6, 799.24, 1),
	            v4(-271.3, -633.56, 1611.1, 1),
	            v4(-556.23, -1571.42, -554.21, 1),
	            v4(-1124, -272.2, -483.08, 1),
	            v4(-1207.01, 131.84, -464.76, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["22"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["22"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_7";
	Curves["23"] = function () {
	    var Curve_v01 = [[v4(669.66, -671.79, 425.68, 1),
	            v4(783.19, -810.61, 64.45, 1),
	            v4(773.17, -781.03, -716.18, 1),
	            v4(476.19, 825.22, -1007.2, 1),
	            v4(-372.7, 397.31, -908.12, 1),
	            v4(-497.01, -5, -892.86, 1),
	        ], [v4(587.43, -926.52, 492.59, 1),
	            v4(622.85, -1086.6, 185.95, 1),
	            v4(514.46, -1137.53, -501.19, 1),
	            v4(225.29, 269.73, -897.48, 1),
	            v4(-331.09, -101.39, -751.72, 1),
	            v4(-402.31, -459.22, -698.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["23"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["23"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_8";
	Curves["24"] = function () {
	    var Curve_v01 = [[v4(599.92, 98.4, -893.07, 1),
	            v4(590.26, 240.61, -929.56, 1),
	            v4(545.7, 756.39, -1015.52, 1),
	            v4(946.3, 814.66, -446.41, 1),
	            v4(1064.05, 435.68, -290.56, 1),
	            v4(1104.39, 280.11, -240.95, 1),
	        ], [v4(689.56, 104.48, -768.72, 1),
	            v4(693.17, 187.62, -801.34, 1),
	            v4(695.03, 492.82, -893.42, 1),
	            v4(867.26, 562.44, -512, 1),
	            v4(905.37, 343.41, -379.14, 1),
	            v4(917.97, 252.58, -334.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["24"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["24"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_9";
	Curves["25"] = function () {
	    var Curve_v01 = [[v4(676.15, 737.47, -828.43, 1),
	            v4(713.76, 873.63, -680.55, 1),
	            v4(610.65, 1257.12, -393.3, 1),
	            v4(-253.4, 1216.51, -506.46, 1),
	            v4(-176.47, 785, -792.21, 1),
	            v4(-78.86, 645.14, -888.58, 1),
	        ], [v4(969, 698.47, -920.4, 1),
	            v4(999.12, 924.66, -684.37, 1),
	            v4(762.75, 1534.55, -247.12, 1),
	            v4(-602.41, 1368.43, -511.64, 1),
	            v4(-402.67, 678.73, -947.46, 1),
	            v4(-221.41, 463.33, -1087.6, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["25"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["25"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_10";
	Curves["26"] = function () {
	    var Curve_v01 = [[v4(-537.97, 63.52, -911.44, 1),
	            v4(-1079.5, 595.32, -804.64, 1),
	            v4(-689.4, 1381.49, -24.37, 1),
	            v4(1429.23, 1187.19, -180.73, 1),
	            v4(1166.58, -546.61, -66.72, 1),
	            v4(867.44, -801.92, -28.77, 1),
	        ], [v4(-418.42, 211.73, -903.18, 1),
	            v4(-986.73, 822.09, -975.69, 1),
	            v4(-687.76, 1764.6, -158.8, 1),
	            v4(1598.39, 1455.15, 167.18, 1),
	            v4(1183.83, -397.85, 446.73, 1),
	            v4(839.8, -658.28, 452.86, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["26"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["26"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_11";
	Curves["27"] = function () {
	    var Curve_v01 = [[v4(901.25, 109.17, 778.75, 1),
	            v4(1004.43, 107.07, 667.58, 1),
	            v4(1196.91, 230.73, 421.72, 1),
	            v4(1113.98, 754.55, 426.71, 1),
	            v4(965.06, 970.2, 321.87, 1),
	            v4(868.01, 1063.02, 243.71, 1),
	        ], [v4(1074.15, -53.7, 568, 1),
	            v4(1193.14, -72.41, 483.62, 1),
	            v4(1429.58, 10.76, 275.8, 1),
	            v4(1379.25, 517.74, 206.2, 1),
	            v4(1269.99, 717.39, 54.25, 1),
	            v4(1198, 800.44, -48.76, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["27"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["27"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_12";
	Curves["28"] = function () {
	    var Curve_v01 = [[v4(-479.46, 1.09, -897.62, 1),
	            v4(-389.4, -217.9, -835.26, 1),
	            v4(-127.05, -689.44, -655.95, 1),
	            v4(-143.44, -1028.81, 192.64, 1),
	            v4(450.48, -818.79, 345.41, 1),
	            v4(653.62, -706.28, 395.38, 1),
	        ], [v4(-349.51, -116.84, -1178.16, 1),
	            v4(-271.94, -377.49, -1050.73, 1),
	            v4(-33.63, -934.74, -705.66, 1),
	            v4(-282.03, -1218.3, 350.19, 1),
	            v4(408.98, -964.2, 650.27, 1),
	            v4(648.75, -828.16, 744.49, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["28"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["28"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_13";
	Curves["29"] = function () {
	    var Curve_v01 = [[v4(-1047.22, 430.26, 101.16, 1),
	            v4(-1134.61, 258.06, 46.85, 1),
	            v4(-1152.74, -143.4, -344.13, 1),
	            v4(-1209.39, 543.11, -820.59, 1),
	            v4(-1035.95, 825.06, -511.29, 1),
	            v4(-841.19, 945.72, -470.08, 1),
	        ], [v4(-1134.55, 390.79, 450.64, 1),
	            v4(-1283.31, 84.55, 361.5, 1),
	            v4(-1220.2, -697.65, -231.62, 1),
	            v4(-1083.56, 396.96, -1202.44, 1),
	            v4(-863.91, 944.33, -669.66, 1),
	            v4(-531.47, 1151.71, -554.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["29"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["29"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_14";
	Curves["30"] = function () {
	    var Curve_v01 = [[v4(-496.76, -0.02, -894.68, 1),
	            v4(-621.38, -162.52, -729.06, 1),
	            v4(-1267.14, -506.73, 99.42, 1),
	            v4(-1090.45, 712.13, 0.82, 1),
	            v4(-172.32, 1176.27, 223.25, 1),
	            v4(-269.92, 1068.07, 274.72, 1),
	        ], [v4(-398.63, -126.99, -1279.12, 1),
	            v4(-616.8, -308.67, -1073.54, 1),
	            v4(-1701.28, -597.86, -122.46, 1),
	            v4(-1351.67, 986.84, -387.97, 1),
	            v4(-178.25, 1594.92, 76.41, 1),
	            v4(-327.17, 1464.94, 133.24, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["30"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["30"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_15";
	Curves["31"] = function () {
	    var Curve_v01 = [[v4(-777.27, 217.48, 699.95, 1),
	            v4(-852.52, 281.46, 591.43, 1),
	            v4(-1045.02, 289.77, 310.74, 1),
	            v4(-1333.84, -148.56, 235.8, 1),
	            v4(-1190.11, -414.34, 122.04, 1),
	            v4(-1107.02, -515.36, 54, 1),
	        ], [v4(-1077.05, 400.75, 623.51, 1),
	            v4(-1136.68, 465.23, 466.42, 1),
	            v4(-1299.48, 440.76, 82.67, 1),
	            v4(-1659.15, -91.86, -16.9, 1),
	            v4(-1477.98, -438.34, -79.72, 1),
	            v4(-1368.98, -574.96, -126.12, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["31"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["31"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_16";
	Curves["32"] = function () {
	    var Curve_v01 = [[v4(-838.16, 955.88, -437.19, 1),
	            v4(-750.71, 1003.26, -388.99, 1),
	            v4(-569.72, 1090.09, -271.08, 1),
	            v4(-309.53, 1249.73, -152.8, 1),
	            v4(-163.27, 1219.8, 134.52, 1),
	            v4(-322.87, 1148.87, 112.14, 1),
	        ], [v4(-823.59, 1129.15, -851.67, 1),
	            v4(-726.87, 1190.48, -779.13, 1),
	            v4(-531.9, 1306.49, -605.77, 1),
	            v4(-236.78, 1507.86, -422.52, 1),
	            v4(-132.62, 1508.96, -39.29, 1),
	            v4(-323.84, 1425.87, -95.62, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["32"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["32"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_17";
	Curves["33"] = function () {
	    var Curve_v01 = [[v4(-226.57, -121.88, 982.71, 1),
	            v4(-169.27, -222.98, 956.82, 1),
	            v4(-32.04, -490.59, 863.92, 1),
	            v4(-329.47, -772.34, 635.14, 1),
	            v4(-199.54, -864.93, 386.21, 1),
	            v4(-147.45, -897.41, 273.41, 1),
	        ], [v4(-508.18, 8.05, 1144.97, 1),
	            v4(-440.31, -121.22, 1142.46, 1),
	            v4(-272.11, -466.48, 1103.17, 1),
	            v4(-593.93, -831.59, 796, 1),
	            v4(-384.46, -987.3, 544.23, 1),
	            v4(-297.02, -1046.06, 427.13, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["33"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["33"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_18";
	Curves["34"] = function () {
	    var Curve_v01 = [[v4(-26.53, -929.22, 99.02, 1),
	            v4(27.87, -901.65, 218.03, 1),
	            v4(126.18, -821.53, 468.96, 1),
	            v4(42.72, -551.69, 792.99, 1),
	            v4(-101.78, -358.07, 909.93, 1),
	            v4(-159.61, -243.09, 958.04, 1),
	        ], [v4(-112.04, -1116.17, 253.54, 1),
	            v4(-73.49, -1066.85, 405.13, 1),
	            v4(-10.32, -935.42, 717.63, 1),
	            v4(-169.57, -554.64, 1045.66, 1),
	            v4(-357.54, -295.44, 1122.2, 1),
	            v4(-430.44, -145.89, 1149.14, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["34"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["34"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_19";
	Curves["35"] = function () {
	    var Curve_v01 = [[v4(951.07, 36.7, 705.51, 1),
	            v4(969.93, -117.18, 615.2, 1),
	            v4(1138.71, -409.6, 268.72, 1),
	            v4(1184.4, 93.19, -216.14, 1),
	            v4(1093.88, 484.27, -141.47, 1),
	            v4(1068.49, 667.9, -128.17, 1),
	        ], [v4(983.62, 110.33, 1084.06, 1),
	            v4(1017.16, -91.32, 1002.58, 1),
	            v4(1282.65, -506.49, 672.08, 1),
	            v4(1490.05, 29.76, 34.5, 1),
	            v4(1391.05, 520.52, 46.31, 1),
	            v4(1370.36, 746.95, 30.14, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["35"].animation = [[-118, -1], [54, -0.08812329549], [2965, 0.2085208828], [3193, 1]];
	Curves["35"].divisions = "|MAEmodelsPrevis|Gehry_15000_1_3_30_40_100_100_500_100_100_100_20|_40_2_20";
	Curves.numCurves = 36;
	Curves["36"] = function () {
	    var Curve_v01 = [[v4(0.26, 22.16, -1.76, 1),
	            v4(0.43, 21.47, -1.89, 1),
	            v4(3.99, 19.16, -2.71, 1),
	            v4(9.36, 14.89, -2.64, 1),
	            v4(11.08, 13.07, -1.63, 1),
	            v4(12.38, 9.41, 0, 1),
	            v4(10.26, 2.21, 4.42, 1),
	            v4(3.67, -0.94, 5.68, 1),
	            v4(-1.76, 0.07, 5.26, 1),
	            v4(-6.79, 2.87, 3.99, 1),
	            v4(-11.2, 8.43, 0.29, 1),
	            v4(-10.07, 16.4, -6.23, 1),
	            v4(0.85, 16.95, -7.91, 1),
	            v4(3.28, 4.85, -1.12, 1),
	            v4(0.68, 8.19, -2.73, 1),
	            v4(-2.29, 11.48, -5.6, 1),
	            v4(-0.04, 13.63, -5.98, 1),
	            v4(-1.93, 15.61, -6.5, 1),
	            v4(-16.23, 12.8, -5.35, 1),
	            v4(-9.43, -10.49, -2.04, 1),
	            v4(-3.62, -12.09, -3.41, 1),
	            v4(-2.92, -14.95, -4.1, 1),
	            v4(-0.69, -19.76, -2.51, 1),
	            v4(-0.29, -20.86, -1.98, 1),
	            v4(0.32, -22.3, -1.24, 1),
	            v4(0.34, -22.28, -1.24, 1),
	        ], [v4(0.47, 22.66, -2.3, 1),
	            v4(0.73, 22.01, -2.46, 1),
	            v4(3.6, 19.74, -3.22, 1),
	            v4(10.51, 15.06, -3.04, 1),
	            v4(13.66, 11.48, -1, 1),
	            v4(13.91, 5.24, 3.51, 1),
	            v4(3.9, -2.21, 8.09, 1),
	            v4(-3.17, 0.85, 7.45, 1),
	            v4(-5.46, 2.17, 5.76, 1),
	            v4(-7.47, 3.35, 4, 1),
	            v4(-9.13, 5.33, 1.18, 1),
	            v4(-7.43, 8.19, -3.36, 1),
	            v4(0.09, 7.67, -5.77, 1),
	            v4(3.57, 2.49, -0.49, 1),
	            v4(1.75, 4.51, -1.93, 1),
	            v4(0.91, 9.95, -7.46, 1),
	            v4(-0.12, 13.47, -5.72, 1),
	            v4(-2.13, 15.06, -5.45, 1),
	            v4(-12.64, 14.9, -4.25, 1),
	            v4(-11.39, -8.1, -0.45, 1),
	            v4(-4.51, -11.55, -3.25, 1),
	            v4(-2.45, -13.73, -2.65, 1),
	            v4(-0.59, -19.38, -2.18, 1),
	            v4(-0.23, -20.6, -1.77, 1),
	            v4(0.32, -22.3, -1.24, 1),
	            v4(0.34, -22.31, -1.26, 1),
	        ], [v4(0.68, 23.31, -3.24, 1),
	            v4(1, 22.62, -3.56, 1),
	            v4(3.76, 20.01, -4.87, 1),
	            v4(12.23, 12.57, -5.58, 1),
	            v4(15.84, 5.58, -2.41, 1),
	            v4(12.86, -4.87, 5.17, 1),
	            v4(-9.13, -8.05, 8.29, 1),
	            v4(-14.68, 4.32, 5.07, 1),
	            v4(-11.36, 5.58, 3.28, 1),
	            v4(-8.76, 4.83, 2.97, 1),
	            v4(-6.18, 2.17, 3.84, 1),
	            v4(-3.51, -3.35, 5.66, 1),
	            v4(-1.2, -8.69, 6.08, 1),
	            v4(4.41, -1.54, 2.66, 1),
	            v4(4.23, -1.77, 2.88, 1),
	            v4(9.85, 9.39, -5.64, 1),
	            v4(-3.06, 12.8, -5.99, 1),
	            v4(-7.65, 11.84, -4.2, 1),
	            v4(-14.81, 7.5, -0.45, 1),
	            v4(-12.36, -9.07, 2.66, 1),
	            v4(-7.81, -12.66, -0.11, 1),
	            v4(-1.62, -14.4, -1.24, 1),
	            v4(-0.1, -19.28, -2.1, 1),
	            v4(0.11, -20.49, -1.75, 1),
	            v4(0.32, -22.3, -1.24, 1),
	            v4(0.31, -22.32, -1.26, 1),
	        ], [v4(0.69, 23.49, -3.58, 1),
	            v4(0.95, 22.76, -3.99, 1),
	            v4(3.26, 19.95, -5.5, 1),
	            v4(10.97, 12.02, -7.02, 1),
	            v4(14.02, 4.59, -4.71, 1),
	            v4(10.92, -5.89, 2.19, 1),
	            v4(-10.66, -8.12, 5.46, 1),
	            v4(-15.27, 3.43, 2.91, 1),
	            v4(-11.59, 5.09, 2.1, 1),
	            v4(-8.8, 4.85, 2.63, 1),
	            v4(-6.38, 2.76, 4.66, 1),
	            v4(-3.77, -2.51, 7.91, 1),
	            v4(-1.33, -9.49, 8.31, 1),
	            v4(5.37, -0.92, 0.23, 1),
	            v4(5.68, -1.03, 0.62, 1),
	            v4(10.54, 11.03, -3.85, 1),
	            v4(-7.3, 11.49, -5.18, 1),
	            v4(-12.05, 7.56, -2.53, 1),
	            v4(-14.35, -1.99, 1.08, 1),
	            v4(-5.58, -12.26, -1.01, 1),
	            v4(-3.97, -13.24, -1.64, 1),
	            v4(0.08, -15.04, -2.83, 1),
	            v4(0.15, -19.46, -2.38, 1),
	            v4(0.25, -20.64, -1.9, 1),
	            v4(0.32, -22.3, -1.24, 1),
	            v4(0.29, -22.31, -1.25, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 25;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["36"].animation = [[0, -1], [103.75, -0.1974528452], [2394, 0.2868149978], [2429, 1.046393295]];
	Curves["36"].divisions = "|MAEmodelsPrevis|tundnel_500_1_1_40_70_100_300_1000_100_100_100_20|_90_4_1";
	Curves["37"] = function () {
	    var Curve_v01 = [[v4(11.43, -5.4, 0.09, 1),
	            v4(1.41, -9.74, 3.92, 1),
	            v4(-8.58, -4.3, 7.14, 1),
	            v4(-8.55, 4.54, 4.27, 1),
	            v4(-3.79, -1.67, 6.34, 1),
	            v4(-1.71, -7.78, 7.27, 1),
	            v4(-0.67, -14.73, 6.08, 1),
	            v4(-1.38, -11.49, 3.84, 1),
	            v4(1.47, -5.91, 1.69, 1),
	            v4(5.43, -7.31, 2.69, 1),
	            v4(10.14, -10.24, 4.96, 1),
	            v4(25.35, -6.24, 2.34, 1),
	            v4(6.13, 22.72, -7.72, 1),
	            v4(-10.6, 18.25, -10.06, 1),
	            v4(-13.79, 16.47, -8.31, 1),
	            v4(-13.55, -7.65, -2.97, 1),
	            v4(-2.69, -16.17, -4.21, 1),
	            v4(-1.84, -16.81, -3.94, 1),
	            v4(-0.56, -18.07, -3.11, 1),
	            v4(-0.21, -20.08, -2.24, 1),
	            v4(-2.36, -20.02, -2.89, 1),
	            v4(-1.92, -18.45, -3.35, 1),
	            v4(0.04, -21.36, -1.68, 1),
	            v4(0.06, -21.94, -1.46, 1),
	            v4(0.32, -22.35, -1.22, 1),
	        ], [v4(11.44, -4.88, -0.29, 1),
	            v4(1.73, -9.31, 2, 1),
	            v4(-9.63, -3.85, 5.95, 1),
	            v4(-9.75, 8.87, 2.47, 1),
	            v4(-3.65, 5.25, 4.26, 1),
	            v4(-1.61, 1.92, 6.86, 1),
	            v4(-1.44, -0.3, 9.77, 1),
	            v4(-3.03, 2.11, 7.45, 1),
	            v4(0.37, 0.13, 5.7, 1),
	            v4(4.83, -2.53, 6.32, 1),
	            v4(8.37, -4.1, 7.39, 1),
	            v4(17.5, -3.04, 6.24, 1),
	            v4(10.15, 18.44, -3.57, 1),
	            v4(-5.58, 19.19, -9.07, 1),
	            v4(-9.97, 17.64, -6.74, 1),
	            v4(-16.82, -0.95, 0.27, 1),
	            v4(-2.86, -14.83, -2.89, 1),
	            v4(-1.61, -16.09, -3.21, 1),
	            v4(-0.57, -18.11, -3.15, 1),
	            v4(-0.2, -20.05, -2.21, 1),
	            v4(-1.88, -18.25, -1.3, 1),
	            v4(-1.57, -17.46, -2.27, 1),
	            v4(0.05, -21.29, -1.63, 1),
	            v4(0.1, -21.78, -1.34, 1),
	            v4(0.32, -22.34, -1.22, 1),
	        ], [v4(14.5, -6.42, 4.69, 1),
	            v4(2.44, -10.06, 6.48, 1),
	            v4(-8.84, -4.7, 3.43, 1),
	            v4(-11.3, 13.47, -1.52, 1),
	            v4(-2.6, 13.99, -3.15, 1),
	            v4(-0.13, 14.97, -3.45, 1),
	            v4(0.83, 19.63, -3.73, 1),
	            v4(-0.98, 20.54, -4.27, 1),
	            v4(1.31, 10.69, -2.23, 1),
	            v4(3.98, 7.28, -1.27, 1),
	            v4(4.57, 9.22, -2.55, 1),
	            v4(2.86, 13.72, -4.33, 1),
	            v4(-2.23, 16.11, -6.98, 1),
	            v4(-6.42, 16.21, -8.21, 1),
	            v4(-10.83, 13.61, -5.15, 1),
	            v4(-16.85, -0.51, 1.2, 1),
	            v4(-3.92, -14.04, -2.92, 1),
	            v4(-1.72, -15.77, -3.21, 1),
	            v4(-0.63, -18.12, -3.15, 1),
	            v4(-0.15, -20.03, -2.21, 1),
	            v4(0.7, -17.6, -1.14, 1),
	            v4(0.08, -17.09, -2.16, 1),
	            v4(0.14, -21.26, -1.63, 1),
	            v4(0.3, -21.71, -1.33, 1),
	            v4(0.33, -22.34, -1.22, 1),
	        ], [v4(15.37, -5.26, 3.83, 1),
	            v4(3.8, -9.75, 6.12, 1),
	            v4(-7.78, -5.33, 3.06, 1),
	            v4(-11.37, 12.69, -2.34, 1),
	            v4(-2.35, 14.12, -5.34, 1),
	            v4(0.28, 16.04, -6.7, 1),
	            v4(1.41, 21.96, -7.37, 1),
	            v4(-0.31, 21.33, -6.21, 1),
	            v4(2.02, 11.07, -2.79, 1),
	            v4(4.05, 8.81, -3.01, 1),
	            v4(3.58, 11.84, -5.09, 1),
	            v4(-4.19, 17.07, -9.88, 1),
	            v4(-12.28, 14.03, -8.38, 1),
	            v4(-12.89, 12.9, -7.21, 1),
	            v4(-15.75, 8.83, -4.17, 1),
	            v4(-13.69, -8.86, 0.19, 1),
	            v4(-1.6, -15.6, -3.46, 1),
	            v4(-0.63, -16.44, -3.54, 1),
	            v4(-0.65, -18.1, -3.12, 1),
	            v4(-0.13, -20.05, -2.23, 1),
	            v4(1.71, -18.66, -2.27, 1),
	            v4(0.72, -17.76, -2.9, 1),
	            v4(0.17, -21.3, -1.67, 1),
	            v4(0.38, -21.8, -1.41, 1),
	            v4(0.33, -22.34, -1.22, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["37"].animation = [[0, -1], [103.75, -0.1974528452], [2394, 0.2868149978], [2429, 1.046393295]];
	Curves["37"].divisions = "|MAEmodelsPrevis|tundnel_500_1_1_40_70_100_300_1000_100_100_100_20|_90_4_3";
	Curves.numCurves = 38;
	Curves["38"] = function () {
	    var Curve_v01 = [[v4(26.41, 51.5, -107.05, 1),
	            v4(26.78, 52.37, -107.02, 1),
	            v4(27.42, 53.92, -106.98, 1),
	            v4(27.64, 56.32, -106.94, 1),
	            v4(27.59, 60.06, -106.91, 1),
	            v4(27.38, 71.82, -106.97, 1),
	            v4(15.4, 98.92, -118.68, 1),
	            v4(10.5, 106.78, -120.59, 1),
	            v4(33.33, 142.84, -178.71, 1),
	            v4(77.05, 107.92, -126.46, 1),
	            v4(50.74, 156.57, -106.87, 1),
	            v4(55.97, 205.76, -142.83, 1),
	            v4(3.57, 182.89, -148.88, 1),
	            v4(22.78, 231.96, -120.14, 1),
	            v4(32.03, 271.18, -134.47, 1),
	            v4(35.09, 311.61, -99.61, 1),
	            v4(55.19, 322.58, -65.68, 1),
	            v4(64.59, 326.87, -21.18, 1),
	            v4(64, 330.54, 21, 1),
	            v4(52.23, 331.35, 64.87, 1),
	            v4(38.11, 328.91, 90.47, 1),
	            v4(29.1, 328.72, 101.99, 1),
	        ], [v4(25, 51.6, -111.54, 1),
	            v4(24.58, 52.57, -111.48, 1),
	            v4(23.81, 54.32, -111.39, 1),
	            v4(23.64, 57.02, -111.31, 1),
	            v4(23.55, 60.84, -111.27, 1),
	            v4(23.23, 72.48, -111.43, 1),
	            v4(12.27, 99.68, -121.49, 1),
	            v4(13.34, 107.37, -124.2, 1),
	            v4(35.15, 142.64, -181.39, 1),
	            v4(78.93, 108.01, -128.48, 1),
	            v4(52.12, 157.43, -109.72, 1),
	            v4(57.45, 205.74, -146.07, 1),
	            v4(4.83, 182.89, -151.12, 1),
	            v4(24.81, 232.51, -123.05, 1),
	            v4(33.53, 271.36, -137.01, 1),
	            v4(36.88, 311.81, -102.15, 1),
	            v4(56.87, 322.56, -68.18, 1),
	            v4(67.26, 326.91, -23.75, 1),
	            v4(69.39, 330.53, 19, 1),
	            v4(72.57, 331.35, 68.72, 1),
	            v4(82.75, 328.9, 94, 1),
	            v4(84.45, 328.72, 107.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["38"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["38"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v101";
	Curves["39"] = function () {
	    var Curve_v01 = [[v4(27.84, 5.3, -4.98, 1),
	            v4(27.87, 5.6, -4.75, 1),
	            v4(27.88, 6.41, -4.63, 1),
	            v4(27.86, 7.67, -4.62, 1),
	            v4(27.83, 10.22, -4.63, 1),
	            v4(33.71, 30.77, -13.61, 1),
	            v4(29.79, 68.12, -19.34, 1),
	            v4(38.91, 119.19, -23.19, 1),
	            v4(8.55, 142.24, 43.73, 1),
	            v4(1.25, 110.24, -27.4, 1),
	            v4(64.08, 151.62, -7.72, 1),
	            v4(30.04, 200.79, -51.82, 1),
	            v4(110.88, 205.9, -65.77, 1),
	            v4(133.23, 224.32, -88.54, 1),
	            v4(189.06, 280.63, -92.23, 1),
	            v4(127.28, 311.58, -55.81, 1),
	            v4(113.71, 243.47, -89.34, 1),
	            v4(165.31, 254.58, -134.86, 1),
	            v4(190.18, 301.67, -129.9, 1),
	            v4(250.96, 305.56, -159.26, 1),
	            v4(270.28, 288.37, -164.95, 1),
	            v4(280.62, 271.8, -170.75, 1),
	        ], [v4(27.68, 5.57, -5.91, 1),
	            v4(27.59, 6.06, -6.19, 1),
	            v4(27.48, 6.94, -6.34, 1),
	            v4(27.36, 8.34, -6.44, 1),
	            v4(27.19, 10.65, -6.54, 1),
	            v4(25.71, 22.94, -7.89, 1),
	            v4(28.32, 69.57, -22.11, 1),
	            v4(39.87, 118.42, -26.58, 1),
	            v4(8.56, 142.63, 40.64, 1),
	            v4(1.5, 110.06, -30.52, 1),
	            v4(64.28, 151.6, -10.88, 1),
	            v4(30.24, 200.72, -54.92, 1),
	            v4(111.03, 205.92, -68.92, 1),
	            v4(133.43, 224.27, -91.67, 1),
	            v4(189.27, 280.57, -95.42, 1),
	            v4(127.59, 311.62, -58.99, 1),
	            v4(113.9, 243.5, -92.45, 1),
	            v4(165.53, 254.56, -138.02, 1),
	            v4(190.4, 301.66, -133.06, 1),
	            v4(238.62, 304.54, -184.6, 1),
	            v4(248.95, 286.61, -206.17, 1),
	            v4(256.79, 269.84, -216.37, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["39"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["39"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v102";
	Curves["40"] = function () {
	    var Curve_v01 = [[v4(-36.74, 36.28, -80.08, 1),
	            v4(-36.74, 36.77, -80.09, 1),
	            v4(-36.12, 38.99, -80.4, 1),
	            v4(-36.18, 42.58, -80.49, 1),
	            v4(-36.54, 49.73, -80.73, 1),
	            v4(-37.42, 62.31, -81.51, 1),
	            v4(-48.14, 88.2, -84.53, 1),
	            v4(-42.09, 123.91, -92.54, 1),
	            v4(-48.81, 168.02, -98.98, 1),
	            v4(-59.17, 210.64, -106.34, 1),
	            v4(-75.71, 249.78, -122.19, 1),
	            v4(-93.14, 281.09, -149.28, 1),
	            v4(-107.65, 306.62, -183.27, 1),
	            v4(-111.93, 325.17, -224.6, 1),
	            v4(-102.34, 333.69, -267.99, 1),
	            v4(-82.96, 337.09, -308.28, 1),
	            v4(-55.96, 338.46, -344.13, 1),
	            v4(-21.2, 340.07, -372.65, 1),
	            v4(19.15, 343.12, -392.09, 1),
	            v4(61.71, 348.37, -404.7, 1),
	            v4(90.83, 353.79, -409.01, 1),
	            v4(104.94, 358.65, -409.42, 1),
	        ], [v4(-38.58, 36.28, -79.21, 1),
	            v4(-38.58, 36.72, -79.21, 1),
	            v4(-39.22, 39.04, -78.96, 1),
	            v4(-39.39, 42.65, -79.17, 1),
	            v4(-39.91, 49.89, -79.95, 1),
	            v4(-41.35, 62.04, -82.19, 1),
	            v4(-49.51, 87.5, -88.55, 1),
	            v4(-41.23, 123.01, -94.58, 1),
	            v4(-48.73, 167.16, -102.53, 1),
	            v4(-58.52, 209.91, -109.05, 1),
	            v4(-75.28, 249.2, -125.13, 1),
	            v4(-92.61, 280.69, -151.92, 1),
	            v4(-107.32, 306.32, -185.99, 1),
	            v4(-111.72, 325.03, -227.25, 1),
	            v4(-102.27, 333.64, -270.75, 1),
	            v4(-82.91, 337.07, -311.51, 1),
	            v4(-55.93, 338.45, -356.26, 1),
	            v4(-21.16, 340.06, -390.96, 1),
	            v4(20.02, 343.1, -416.05, 1),
	            v4(69.96, 348.36, -459.71, 1),
	            v4(93.53, 353.78, -504.73, 1),
	            v4(105.17, 358.65, -516.13, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["40"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["40"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v103";
	Curves["41"] = function () {
	    var Curve_v01 = [[v4(4.04, 29.9, -56.7, 1),
	            v4(4.04, 30.08, -56.74, 1),
	            v4(4.35, 30.81, -56.67, 1),
	            v4(4.34, 32.17, -56.91, 1),
	            v4(4.14, 34.77, -57.4, 1),
	            v4(2.02, 51.48, -59.74, 1),
	            v4(-10.03, 75.97, -57.92, 1),
	            v4(33.77, 111.55, -66.07, 1),
	            v4(-1.45, 119.82, -125.23, 1),
	            v4(-43.05, 141.51, -114.35, 1),
	            v4(-88.86, 156.41, -93.68, 1),
	            v4(-70.74, 168.09, -32.32, 1),
	            v4(-55.83, 221.83, -53.59, 1),
	            v4(-122.05, 227.09, -83.31, 1),
	            v4(-77.09, 272.52, -112.73, 1),
	            v4(-87.55, 301.67, -56.35, 1),
	            v4(-127.59, 307.03, -35.84, 1),
	            v4(-170.48, 305.49, -11.69, 1),
	            v4(-219.44, 310.18, -3.07, 1),
	            v4(-266.16, 312.63, 15.66, 1),
	            v4(-296.88, 315.68, 24.77, 1),
	            v4(-311.86, 316.89, 29.84, 1),
	        ], [v4(2.85, 29.9, -57.49, 1),
	            v4(2.86, 30.14, -57.55, 1),
	            v4(2.53, 31, -58.01, 1),
	            v4(2.47, 32.35, -58.38, 1),
	            v4(2.38, 34.9, -58.97, 1),
	            v4(1.02, 51.56, -61.72, 1),
	            v4(-10.52, 76.6, -59.54, 1),
	            v4(34.24, 111.34, -69.98, 1),
	            v4(-1.3, 119.91, -127.98, 1),
	            v4(-42.74, 141.45, -117.73, 1),
	            v4(-88.65, 156.43, -96.76, 1),
	            v4(-70.51, 168.06, -35.55, 1),
	            v4(-55.59, 221.83, -56.71, 1),
	            v4(-121.82, 227.08, -86.47, 1),
	            v4(-76.87, 272.51, -115.89, 1),
	            v4(-87.3, 301.67, -59.57, 1),
	            v4(-127.35, 307.03, -41.22, 1),
	            v4(-170.2, 305.49, -21.18, 1),
	            v4(-217.79, 310.18, -25.74, 1),
	            v4(-264.67, 312.63, -31.3, 1),
	            v4(-295.97, 315.68, -36.23, 1),
	            v4(-311.63, 316.89, -34.87, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["41"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["41"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v104";
	Curves["42"] = function () {
	    var Curve_v01 = [[v4(31.21, 34.3, -67.87, 1),
	            v4(31.43, 34.65, -67.79, 1),
	            v4(31.96, 36.04, -67.58, 1),
	            v4(32.08, 38.73, -67.49, 1),
	            v4(32.09, 42.96, -67.47, 1),
	            v4(31.01, 55.48, -68.79, 1),
	            v4(21.39, 87.71, -83.94, 1),
	            v4(41.53, 102.86, -110.53, 1),
	            v4(57.66, 117.6, -156.4, 1),
	            v4(81.29, 118.14, -190.83, 1),
	            v4(95.51, 146.66, -241.84, 1),
	            v4(59.27, 183.32, -216.37, 1),
	            v4(36.07, 194.49, -184.41, 1),
	            v4(3.54, 213.35, -155.38, 1),
	            v4(-27.29, 226.33, -124.43, 1),
	            v4(-62.8, 240.9, -98.64, 1),
	            v4(-103.89, 252.53, -79.39, 1),
	            v4(-150.6, 260.64, -82.19, 1),
	            v4(-191.82, 264.41, -103.98, 1),
	            v4(-225.94, 268.54, -134.69, 1),
	            v4(-244.67, 271.63, -159.09, 1),
	            v4(-253.19, 273.38, -171.67, 1),
	        ], [v4(29.65, 34.3, -68.27, 1),
	            v4(29.44, 34.76, -68.31, 1),
	            v4(29.04, 36.42, -68.4, 1),
	            v4(29.01, 39.33, -68.4, 1),
	            v4(29.01, 43.45, -68.4, 1),
	            v4(28.26, 55.76, -69.95, 1),
	            v4(19.7, 87.59, -85.91, 1),
	            v4(40.91, 102.41, -112.15, 1),
	            v4(57.35, 117.14, -158.24, 1),
	            v4(80.5, 118.2, -192.43, 1),
	            v4(96.28, 145.03, -244.35, 1),
	            v4(60.47, 183.07, -220.87, 1),
	            v4(36.92, 193.99, -188.01, 1),
	            v4(4.47, 213.11, -159.3, 1),
	            v4(-26.51, 226.04, -128.03, 1),
	            v4(-61.99, 240.73, -102.18, 1),
	            v4(-103.13, 252.4, -82.64, 1),
	            v4(-149.55, 260.61, -85.38, 1),
	            v4(-180.17, 264.38, -111.67, 1),
	            v4(-198.22, 268.53, -149.21, 1),
	            v4(-210.29, 271.62, -176.51, 1),
	            v4(-217.93, 273.38, -189.5, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["42"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["42"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v105";
	Curves["43"] = function () {
	    var Curve_v01 = [[v4(-79.7, 51.39, -116, 1),
	            v4(-78.83, 52.2, -116, 1),
	            v4(-78.65, 53.74, -116, 1),
	            v4(-78.6, 56.17, -116, 1),
	            v4(-78.57, 60.7, -115.98, 1),
	            v4(-78.58, 72.64, -115.88, 1),
	            v4(-87.83, 100.35, -103.8, 1),
	            v4(-89.47, 134.06, -95.05, 1),
	            v4(-150.36, 155.85, -100.9, 1),
	            v4(-117.19, 135.2, -155.84, 1),
	            v4(-89.95, 183.86, -137.57, 1),
	            v4(-166.96, 232.63, -119.93, 1),
	            v4(-155.2, 209.77, -68.51, 1),
	            v4(-134.51, 258.84, -96.2, 1),
	            v4(-151.1, 298.05, -100.15, 1),
	            v4(-119.25, 338.48, -114.65, 1),
	            v4(-93.96, 349.46, -144.91, 1),
	            v4(-55.47, 353.75, -169.54, 1),
	            v4(-16.58, 357.41, -186.09, 1),
	            v4(27.61, 358.22, -192.7, 1),
	            v4(56.21, 355.78, -188.6, 1),
	            v4(70.07, 355.6, -183.95, 1),
	        ], [v4(-83.18, 51.39, -114.67, 1),
	            v4(-83.98, 52.13, -114.68, 1),
	            v4(-84.08, 53.61, -114.69, 1),
	            v4(-84.03, 55.99, -114.68, 1),
	            v4(-83.93, 60.42, -114.61, 1),
	            v4(-83.99, 72.42, -114.24, 1),
	            v4(-90.75, 100.46, -104.27, 1),
	            v4(-93.83, 134.66, -96.52, 1),
	            v4(-153.49, 155.65, -101.72, 1),
	            v4(-119.72, 135.29, -156.94, 1),
	            v4(-93.1, 184.71, -137.92, 1),
	            v4(-170.51, 232.61, -120.25, 1),
	            v4(-157.74, 209.77, -68.96, 1),
	            v4(-137.92, 259.38, -97.15, 1),
	            v4(-153.99, 298.24, -100.8, 1),
	            v4(-122.25, 338.69, -118.89, 1),
	            v4(-96.88, 349.43, -152.84, 1),
	            v4(-58.45, 353.79, -181.38, 1),
	            v4(-19.58, 357.4, -210.52, 1),
	            v4(24.55, 358.23, -232.85, 1),
	            v4(53.13, 355.78, -234.9, 1),
	            v4(66.97, 355.6, -230.99, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["43"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["43"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v106";
	Curves["44"] = function () {
	    var Curve_v01 = [[v4(-7.76, 2.72, -4.53, 1),
	            v4(-7.6, 2.88, -4.54, 1),
	            v4(-7.48, 3.48, -4.64, 1),
	            v4(-7.48, 4.73, -4.91, 1),
	            v4(-7.61, 6.61, -5.3, 1),
	            v4(-11.59, 17.91, -7.28, 1),
	            v4(1.07, 48.45, -4.55, 1),
	            v4(13.04, 85.75, -5.55, 1),
	            v4(36.54, 106.74, 49.53, 1),
	            v4(-28.08, 86.39, 45.73, 1),
	            v4(-23.83, 135.8, 13.29, 1),
	            v4(-0.6, 184.11, 41.75, 1),
	            v4(38.64, 161.27, 6.34, 1),
	            v4(4.44, 210.88, 2.13, 1),
	            v4(8.86, 249.74, 17.99, 1),
	            v4(-19.13, 290.19, -3.07, 1),
	            v4(-57.68, 300.93, -11.25, 1),
	            v4(-97.47, 305.29, -33.58, 1),
	            v4(-130.33, 308.9, -60.11, 1),
	            v4(-156.9, 309.73, -95.94, 1),
	            v4(-166.74, 307.28, -123.09, 1),
	            v4(-169.15, 307.1, -137.48, 1),
	        ], [v4(-8.65, 2.72, -4.75, 1),
	            v4(-8.9, 2.89, -4.85, 1),
	            v4(-9.29, 3.52, -5.09, 1),
	            v4(-9.71, 4.99, -5.51, 1),
	            v4(-9.93, 7.25, -6.02, 1),
	            v4(-13.46, 18.69, -8.1, 1),
	            v4(-4.04, 48.56, -7.2, 1),
	            v4(12.29, 85.15, -10.09, 1),
	            v4(35.79, 106.94, 46.38, 1),
	            v4(-28.3, 86.29, 42.98, 1),
	            v4(-25, 134.95, 10.34, 1),
	            v4(-1.99, 184.13, 38.47, 1),
	            v4(37.84, 161.27, 3.89, 1),
	            v4(3.67, 210.34, -1.33, 1),
	            v4(8.03, 249.55, 15.17, 1),
	            v4(-18.79, 289.98, -6.11, 1),
	            v4(-56.35, 300.96, -14.18, 1),
	            v4(-93.94, 305.25, -36.55, 1),
	            v4(-113.1, 308.91, -63.06, 1),
	            v4(-121.27, 309.72, -98.94, 1),
	            v4(-124.38, 307.28, -126.11, 1),
	            v4(-126.1, 307.1, -140.52, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["44"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["44"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v107";
	Curves["45"] = function () {
	    var Curve_v01 = [[v4(10.85, 2.14, -5.25, 1),
	            v4(11.01, 2.75, -5.27, 1),
	            v4(11.19, 4.05, -5.3, 1),
	            v4(11.26, 6.33, -5.33, 1),
	            v4(11.34, 9.61, -5.37, 1),
	            v4(12.99, 21.36, -6.94, 1),
	            v4(22.18, 60.04, -5.02, 1),
	            v4(17.75, 108.25, 6.37, 1),
	            v4(-10.72, 132.47, -62.11, 1),
	            v4(46.55, 99.9, -19.29, 1),
	            v4(-10.32, 141.43, 13.78, 1),
	            v4(45.15, 190.55, 18.4, 1),
	            v4(0.96, 195.75, 87.45, 1),
	            v4(2.62, 214.1, 119.33, 1),
	            v4(-32.31, 270.4, 163.07, 1),
	            v4(-17.55, 301.45, 92.96, 1),
	            v4(16.38, 233.33, 105.45, 1),
	            v4(15.15, 244.39, 174.31, 1),
	            v4(-5.29, 291.49, 189.3, 1),
	            v4(-18.33, 293.66, 256.96, 1),
	            v4(-22.64, 275.23, 277.19, 1),
	            v4(-24.08, 258.31, 289.33, 1),
	        ], [v4(10.36, 2.39, -6.51, 1),
	            v4(10.21, 3.01, -6.52, 1),
	            v4(10.05, 4.28, -6.54, 1),
	            v4(10, 6.18, -6.56, 1),
	            v4(10.06, 8.96, -6.59, 1),
	            v4(11.2, 21.59, -7.88, 1),
	            v4(19.18, 58.45, -5.87, 1),
	            v4(15.89, 109.02, 3.37, 1),
	            v4(-12.99, 132.07, -64.2, 1),
	            v4(44.42, 100.08, -21.57, 1),
	            v4(-12.51, 141.45, 11.5, 1),
	            v4(43.01, 190.63, 16.15, 1),
	            v4(-1.27, 195.74, 85.21, 1),
	            v4(0.44, 214.15, 117.07, 1),
	            v4(-34.51, 270.47, 160.76, 1),
	            v4(-19.69, 301.41, 90.6, 1),
	            v4(13.43, 233.3, 103.21, 1),
	            v4(4.64, 244.42, 172.01, 1),
	            v4(-24.71, 291.5, 187.02, 1),
	            v4(-61.84, 293.66, 254.66, 1),
	            v4(-71.74, 275.22, 274.89, 1),
	            v4(-73.93, 258.31, 287.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["45"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["45"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v108";
	Curves["46"] = function () {
	    var Curve_v01 = [[v4(10.28, 5.93, -10.21, 1),
	            v4(10.2, 6.37, -10.21, 1),
	            v4(10.12, 7.16, -10.21, 1),
	            v4(10.07, 8.43, -10.21, 1),
	            v4(10.07, 10, -10.21, 1),
	            v4(8.83, 23.39, -10.01, 1),
	            v4(18.09, 51.21, -8.87, 1),
	            v4(16.74, 92.84, 3.07, 1),
	            v4(27.67, 136.99, 2.9, 1),
	            v4(39.1, 179.74, 0.08, 1),
	            v4(62.27, 219.03, -1.44, 1),
	            v4(93.73, 250.52, 3.85, 1),
	            v4(128.8, 276.15, 16, 1),
	            v4(162.21, 294.86, 40.6, 1),
	            v4(187.93, 303.47, 76.94, 1),
	            v4(204.66, 306.9, 118.47, 1),
	            v4(212.98, 308.28, 162.65, 1),
	            v4(211.65, 309.89, 211.45, 1),
	            v4(203.07, 312.93, 270.4, 1),
	            v4(187.89, 318.19, 326.23, 1),
	            v4(172.4, 323.61, 354.42, 1),
	            v4(163.17, 328.48, 365.13, 1),
	        ], [v4(10.62, 5.93, -8.94, 1),
	            v4(10.69, 6.36, -8.94, 1),
	            v4(10.77, 7.17, -8.94, 1),
	            v4(10.83, 8.45, -8.94, 1),
	            v4(10.84, 10.02, -8.94, 1),
	            v4(9.05, 23.81, -9.03, 1),
	            v4(13.69, 52.07, -10.47, 1),
	            v4(15.82, 93.74, 1.05, 1),
	            v4(25.11, 137.84, 0.44, 1),
	            v4(37.54, 180.47, -2.23, 1),
	            v4(60.39, 219.61, -3.74, 1),
	            v4(92.14, 250.91, 1.69, 1),
	            v4(127.02, 276.45, 13.92, 1),
	            v4(160.4, 295, 38.66, 1),
	            v4(185.55, 303.52, 74.9, 1),
	            v4(197.74, 306.91, 115.05, 1),
	            v4(199.89, 308.29, 157.33, 1),
	            v4(193.82, 309.9, 200.44, 1),
	            v4(171.52, 312.95, 232.15, 1),
	            v4(141.76, 318.2, 257.47, 1),
	            v4(122.49, 323.62, 276.37, 1),
	            v4(113.67, 328.48, 286.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["46"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["46"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v109";
	Curves["47"] = function () {
	    var Curve_v01 = [[v4(-0.9, 15.99, -30.47, 1),
	            v4(-0.76, 16.46, -30.47, 1),
	            v4(-0.59, 17.42, -30.47, 1),
	            v4(-0.51, 19, -30.46, 1),
	            v4(-0.47, 21.81, -30.45, 1),
	            v4(-0.88, 37.67, -29.47, 1),
	            v4(10.88, 50.57, -16.43, 1),
	            v4(-11.44, 85.04, 23.32, 1),
	            v4(55.34, 93.61, 36.24, 1),
	            v4(75.75, 115.15, -1.24, 1),
	            v4(91.26, 130.13, -49.28, 1),
	            v4(33.86, 141.76, -77.21, 1),
	            v4(39.4, 195.53, -51.91, 1),
	            v4(106.06, 200.78, -80.69, 1),
	            v4(97.43, 246.21, -27.68, 1),
	            v4(65.18, 275.37, -71.8, 1),
	            v4(80.39, 280.73, -112.87, 1),
	            v4(94.13, 279.19, -157.86, 1),
	            v4(129.8, 283.88, -183.46, 1),
	            v4(165.33, 286.33, -207.41, 1),
	            v4(189.63, 289.38, -225.62, 1),
	            v4(199.32, 290.59, -237.86, 1),
	        ], [v4(-2.39, 15.86, -30.08, 1),
	            v4(-2.52, 16.28, -30.07, 1),
	            v4(-2.7, 17.36, -30.07, 1),
	            v4(-2.75, 19.03, -30.06, 1),
	            v4(-2.75, 22.01, -30.06, 1),
	            v4(-2.94, 37.8, -30.17, 1),
	            v4(9.25, 50.11, -17.02, 1),
	            v4(-14.01, 85.25, 20.33, 1),
	            v4(53.41, 93.52, 34.28, 1),
	            v4(73.47, 115.21, -3.75, 1),
	            v4(89.14, 130.11, -51.51, 1),
	            v4(31.63, 141.79, -79.55, 1),
	            v4(37.26, 195.53, -54.2, 1),
	            v4(103.89, 200.79, -83, 1),
	            v4(95.25, 246.22, -29.97, 1),
	            v4(60.7, 275.37, -75.74, 1),
	            v4(72.6, 280.73, -119.12, 1),
	            v4(83.13, 279.19, -168.01, 1),
	            v4(109.88, 283.88, -211.08, 1),
	            v4(137.44, 286.33, -252.68, 1),
	            v4(160.88, 289.38, -274.48, 1),
	            v4(171.1, 290.59, -286.35, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["47"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["47"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v110";
	Curves["48"] = function () {
	    var Curve_v01 = [[v4(-16.79, 4.66, -6.5, 1),
	            v4(-16.62, 4.96, -6.62, 1),
	            v4(-16.44, 5.86, -6.76, 1),
	            v4(-16.38, 7.52, -6.82, 1),
	            v4(-16.39, 10.21, -6.84, 1),
	            v4(-16.09, 22.61, -7.2, 1),
	            v4(3.5, 57.85, -3.83, 1),
	            v4(8.76, 73.32, 30.99, 1),
	            v4(31.67, 88.05, 74.23, 1),
	            v4(41.27, 89.11, 114.37, 1),
	            v4(68.93, 115.94, 161.07, 1),
	            v4(75.78, 153.98, 118.79, 1),
	            v4(70.1, 164.9, 76.32, 1),
	            v4(70.82, 184.02, 33, 1),
	            v4(68.65, 196.95, -10.96, 1),
	            v4(73.6, 211.64, -54.43, 1),
	            v4(88.11, 223.31, -95.44, 1),
	            v4(123.1, 231.52, -124.38, 1),
	            v4(164.66, 235.29, -129.19, 1),
	            v4(205.24, 239.44, -120.53, 1),
	            v4(233.08, 242.53, -114.03, 1),
	            v4(247.36, 244.29, -112.2, 1),
	        ], [v4(-17.89, 4.69, -5.79, 1),
	            v4(-18.09, 4.99, -5.67, 1),
	            v4(-18.35, 5.89, -5.53, 1),
	            v4(-18.5, 7.43, -5.47, 1),
	            v4(-18.58, 10.01, -5.45, 1),
	            v4(-18.89, 22.15, -5.77, 1),
	            v4(0.84, 57.91, -4, 1),
	            v4(7.15, 73.77, 30.34, 1),
	            v4(30.11, 88.51, 73.2, 1),
	            v4(39.56, 89.05, 113.88, 1),
	            v4(67.6, 117.57, 158.8, 1),
	            v4(73.27, 154.23, 114.87, 1),
	            v4(68.01, 165.4, 73.26, 1),
	            v4(68.55, 184.26, 29.67, 1),
	            v4(66.53, 197.24, -13.97, 1),
	            v4(71.46, 211.81, -57.58, 1),
	            v4(85, 223.44, -100.89, 1),
	            v4(118.66, 231.55, -133.77, 1),
	            v4(163.95, 235.32, -156.83, 1),
	            v4(211.72, 239.45, -172.22, 1),
	            v4(243.24, 242.54, -174.11, 1),
	            v4(258.38, 244.29, -172.5, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["48"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["48"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v111";
	Curves["49"] = function () {
	    var Curve_v01 = [[v4(18.61, 6.17, -5.69, 1),
	            v4(18.79, 6.5, -5.61, 1),
	            v4(19.07, 7.56, -5.52, 1),
	            v4(19.28, 9.37, -5.5, 1),
	            v4(19.44, 11.8, -5.5, 1),
	            v4(23.73, 29.24, -8.84, 1),
	            v4(22.16, 96.07, 3.77, 1),
	            v4(121.57, 93.38, -1.21, 1),
	            v4(114.3, 175.26, -71.96, 1),
	            v4(121.7, 195.92, 32.67, 1),
	            v4(193.82, 202.21, 56.08, 1),
	            v4(259.64, 215.57, 87.96, 1),
	            v4(335.89, 221.68, 80.91, 1),
	            v4(401.7, 230.53, 64.53, 1),
	            v4(455.42, 236.94, 28.38, 1),
	            v4(497.25, 244.2, -20.55, 1),
	            v4(529.73, 250.69, -82.71, 1),
	            v4(532.82, 257.51, -141.91, 1),
	            v4(500.82, 264.24, -189.64, 1),
	            v4(452.57, 271.13, -237.49, 1),
	            v4(399.5, 277.21, -252.24, 1),
	            v4(381.67, 279.85, -264.88, 1),
	        ], [v4(17.71, 6.17, -6.28, 1),
	            v4(17.6, 6.46, -6.37, 1),
	            v4(17.47, 7.42, -6.49, 1),
	            v4(17.45, 9.17, -6.54, 1),
	            v4(17.49, 11.58, -6.55, 1),
	            v4(22.56, 28.6, -9.12, 1),
	            v4(19.8, 96.34, 0.82, 1),
	            v4(119.41, 93.2, -3.13, 1),
	            v4(112.13, 175.26, -74.44, 1),
	            v4(119.49, 195.9, 30.36, 1),
	            v4(191.58, 202.21, 53.73, 1),
	            v4(257.41, 215.55, 85.66, 1),
	            v4(333.67, 221.68, 78.61, 1),
	            v4(403.85, 230.53, 60.9, 1),
	            v4(467.94, 236.94, 21.54, 1),
	            v4(519.84, 244.19, -30.49, 1),
	            v4(557.37, 250.69, -94.65, 1),
	            v4(576.12, 257.5, -166.84, 1),
	            v4(573.22, 264.23, -240.1, 1),
	            v4(550.15, 271.13, -313.42, 1),
	            v4(501.61, 277.21, -336.5, 1),
	            v4(482.14, 279.85, -349.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["49"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["49"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v112";
	Curves["50"] = function () {
	    var Curve_v01 = [[v4(-19.62, 2.48, -0.82, 1),
	            v4(-19.73, 2.84, -0.7, 1),
	            v4(-19.83, 3.9, -0.5, 1),
	            v4(-19.85, 5.75, -0.25, 1),
	            v4(-19.82, 8.58, 0.11, 1),
	            v4(-12.8, 20.5, 1.73, 1),
	            v4(-24.01, 49.63, 6.85, 1),
	            v4(-30.49, 85.75, 12.81, 1),
	            v4(-82, 106.74, -17.73, 1),
	            v4(-27.63, 86.39, -52.86, 1),
	            v4(-11.89, 135.8, -24.18, 1),
	            v4(-47.45, 184.11, -33.41, 1),
	            v4(-58.17, 161.27, 18.35, 1),
	            v4(-28.09, 210.88, 1.53, 1),
	            v4(-41.04, 249.74, -8.7, 1),
	            v4(-6.31, 290.19, -10.21, 1),
	            v4(29.3, 300.93, -28.6, 1),
	            v4(75.03, 305.29, -36.69, 1),
	            v4(122.23, 308.9, -44.46, 1),
	            v4(171.86, 309.73, -43.7, 1),
	            v4(198.56, 307.28, -32.3, 1),
	            v4(209.41, 307.1, -22.63, 1),
	        ], [v4(-18.67, 2.48, -1.32, 1),
	            v4(-18.48, 2.82, -1.36, 1),
	            v4(-18.21, 3.9, -1.34, 1),
	            v4(-18.12, 5.68, -1.15, 1),
	            v4(-17.61, 8.43, -0.77, 1),
	            v4(-10.42, 20.25, 1.2, 1),
	            v4(-21.58, 49.24, 8.39, 1),
	            v4(-27.2, 85.15, 16.03, 1),
	            v4(-79.54, 106.94, -15.63, 1),
	            v4(-25.83, 86.29, -50.77, 1),
	            v4(-9.2, 134.95, -22.5, 1),
	            v4(-44.39, 184.13, -31.58, 1),
	            v4(-56.07, 161.27, 19.85, 1),
	            v4(-25.43, 210.34, 3.86, 1),
	            v4(-38.67, 249.55, -6.88, 1),
	            v4(-3.68, 289.98, -6.15, 1),
	            v4(32.23, 300.96, -22.46, 1),
	            v4(77.59, 305.25, -27.97, 1),
	            v4(119.81, 308.91, -26.04, 1),
	            v4(162.5, 309.72, -12.84, 1),
	            v4(186.5, 307.28, 3.25, 1),
	            v4(196.97, 307.1, 13.45, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["50"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["50"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v113";
	Curves["51"] = function () {
	    var Curve_v01 = [[v4(-6.39, 4.96, -12.25, 1),
	            v4(-6.46, 5.09, -12.27, 1),
	            v4(-6.59, 5.53, -12.3, 1),
	            v4(-6.74, 6.49, -12.33, 1),
	            v4(-6.81, 8.09, -12.33, 1),
	            v4(-5.79, 20.42, -7.68, 1),
	            v4(-16.85, 61.45, -5.48, 1),
	            v4(-20.15, 111.93, -17.84, 1),
	            v4(43.29, 136.15, 20.56, 1),
	            v4(-28.22, 103.58, 19.88, 1),
	            v4(-1.89, 145.12, -40.41, 1),
	            v4(-49.36, 194.24, -11.34, 1),
	            v4(-54.53, 199.43, -93.16, 1),
	            v4(-74.72, 217.79, -117.9, 1),
	            v4(-72.4, 274.08, -173.82, 1),
	            v4(-42.86, 305.13, -108.55, 1),
	            v4(-77.61, 237.01, -98.57, 1),
	            v4(-117.33, 248.07, -154.83, 1),
	            v4(-109.7, 295.18, -179.01, 1),
	            v4(-139.17, 297.34, -241.29, 1),
	            v4(-147.66, 278.91, -260.16, 1),
	            v4(-153.67, 262, -270.8, 1),
	        ], [v4(-5.2, 4.96, -11.86, 1),
	            v4(-5.08, 5.23, -11.81, 1),
	            v4(-4.97, 5.85, -11.75, 1),
	            v4(-4.89, 6.95, -11.68, 1),
	            v4(-4.88, 8.41, -11.63, 1),
	            v4(-4.02, 21.86, -7.85, 1),
	            v4(-13.95, 59.93, -6.72, 1),
	            v4(-16.87, 112.71, -16.52, 1),
	            v4(46.36, 135.76, 20.91, 1),
	            v4(-25.14, 103.76, 20.46, 1),
	            v4(1.23, 145.13, -39.87, 1),
	            v4(-46.3, 194.31, -10.8, 1),
	            v4(-51.41, 199.42, -92.68, 1),
	            v4(-71.63, 217.83, -117.36, 1),
	            v4(-69.26, 274.15, -173.26, 1),
	            v4(-39.74, 305.1, -107.91, 1),
	            v4(-73.65, 236.99, -97.96, 1),
	            v4(-105.36, 248.1, -153.38, 1),
	            v4(-87.86, 295.18, -178.69, 1),
	            v4(-84.06, 297.34, -250.55, 1),
	            v4(-84.56, 278.91, -272.46, 1),
	            v4(-84.47, 262, -283.98, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["51"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["51"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v114";
	Curves["52"] = function () {
	    var Curve_v01 = [[v4(4.77, 4.29, -10.61, 1),
	            v4(4.89, 4.62, -10.58, 1),
	            v4(5.01, 5.37, -10.55, 1),
	            v4(5.06, 6.56, -10.52, 1),
	            v4(5.01, 8.45, -10.48, 1),
	            v4(5.25, 22.39, -11.71, 1),
	            v4(-2.71, 50.7, -7.26, 1),
	            v4(-8.64, 92.04, -17.61, 1),
	            v4(-17.35, 136.19, -11.01, 1),
	            v4(-24.9, 178.94, -1.98, 1),
	            v4(-42.7, 218.23, 12.94, 1),
	            v4(-71.2, 249.71, 27.26, 1),
	            v4(-106.66, 275.35, 38.2, 1),
	            v4(-148.16, 294.05, 38.11, 1),
	            v4(-190.64, 302.67, 24.06, 1),
	            v4(-232.29, 306.09, 1.29, 1),
	            v4(-270.28, 307.48, -28.21, 1),
	            v4(-298.6, 309.08, -65.48, 1),
	            v4(-325.51, 312.13, -110.85, 1),
	            v4(-348.21, 317.39, -159.28, 1),
	            v4(-356, 322.81, -190.49, 1),
	            v4(-355.94, 327.67, -204.78, 1),
	        ], [v4(3.56, 4.29, -10.95, 1),
	            v4(3.43, 4.66, -10.98, 1),
	            v4(3.27, 5.57, -11.03, 1),
	            v4(3.19, 7.04, -11.03, 1),
	            v4(3.14, 9.09, -11, 1),
	            v4(4.49, 23.33, -12.3, 1),
	            v4(1.72, 51.75, -8.59, 1),
	            v4(-6.7, 92.94, -16.53, 1),
	            v4(-13.83, 137.04, -10.55, 1),
	            v4(-22.28, 179.66, -1.04, 1),
	            v4(-39.82, 218.8, 13.68, 1),
	            v4(-68.64, 250.11, 28.07, 1),
	            v4(-104, 275.64, 38.82, 1),
	            v4(-145.55, 294.2, 38.6, 1),
	            v4(-187.42, 302.72, 24.37, 1),
	            v4(-222.69, 306.11, 0.7, 1),
	            v4(-251.73, 307.49, -30.07, 1),
	            v4(-273.94, 309.09, -67.45, 1),
	            v4(-281.45, 312.14, -106.21, 1),
	            v4(-280.43, 317.4, -145.13, 1),
	            v4(-278.9, 322.81, -172.6, 1),
	            v4(-277.99, 327.67, -186.4, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["52"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["52"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v115";
	Curves["53"] = function () {
	    var Curve_v01 = [[v4(6.21, 15.75, -29.62, 1),
	            v4(6.05, 15.98, -29.62, 1),
	            v4(5.85, 16.66, -29.62, 1),
	            v4(5.69, 17.85, -29.63, 1),
	            v4(5.62, 19.5, -29.63, 1),
	            v4(2.3, 34.57, -29.15, 1),
	            v4(-0.51, 49.54, 0.61, 1),
	            v4(-6.17, 85.04, -46.01, 1),
	            v4(-67.67, 93.61, -16.96, 1),
	            v4(-61.97, 115.15, 25.34, 1),
	            v4(-46.09, 130.13, 73.25, 1),
	            v4(16.72, 141.76, 61.85, 1),
	            v4(-2.7, 195.53, 44.72, 1),
	            v4(-39.46, 200.78, 107.34, 1),
	            v4(-63.83, 246.21, 59.48, 1),
	            v4(-8.93, 275.37, 75.94, 1),
	            v4(7.13, 280.73, 117.98, 1),
	            v4(26.23, 279.19, 163.19, 1),
	            v4(13.89, 283.88, 210.82, 1),
	            v4(-5.66, 286.33, 257.62, 1),
	            v4(-19.57, 289.38, 288.35, 1),
	            v4(-21.57, 290.59, 303.99, 1),
	        ], [v4(7.04, 15.63, -29.63, 1),
	            v4(7.21, 15.88, -29.63, 1),
	            v4(7.41, 16.69, -29.64, 1),
	            v4(7.49, 17.99, -29.63, 1),
	            v4(7.5, 19.74, -29.63, 1),
	            v4(4.4, 34.83, -29.76, 1),
	            v4(1.08, 49.1, 0.01, 1),
	            v4(-2.33, 85.25, -45.12, 1),
	            v4(-64.95, 93.52, -16.52, 1),
	            v4(-58.64, 115.21, 26.02, 1),
	            v4(-43.06, 130.11, 73.8, 1),
	            v4(19.91, 141.79, 62.42, 1),
	            v4(0.37, 195.53, 45.3, 1),
	            v4(-36.34, 200.79, 107.92, 1),
	            v4(-60.72, 246.22, 60.03, 1),
	            v4(-5.8, 275.37, 76.53, 1),
	            v4(10.25, 280.73, 118.56, 1),
	            v4(29.7, 279.19, 163.83, 1),
	            v4(33.13, 283.88, 214.18, 1),
	            v4(38.72, 286.33, 265.3, 1),
	            v4(35.55, 289.38, 297.87, 1),
	            v4(34.97, 290.59, 313.75, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["53"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["53"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v116";
	Curves["54"] = function () {
	    var Curve_v01 = [[v4(9.68, 11.78, -22.61, 1),
	            v4(9.52, 12.01, -22.47, 1),
	            v4(9.33, 12.69, -22.31, 1),
	            v4(9.21, 14.24, -22.2, 1),
	            v4(9.2, 16.54, -22.17, 1),
	            v4(9.59, 28.32, -22.47, 1),
	            v4(-10.55, 64.15, -21.07, 1),
	            v4(-23.3, 79.83, -54.41, 1),
	            v4(-54.92, 94.56, -91.75, 1),
	            v4(-72.88, 95.62, -128.92, 1),
	            v4(-109.88, 122.45, -168.62, 1),
	            v4(-107.53, 160.49, -125.87, 1),
	            v4(-92.91, 171.4, -85.59, 1),
	            v4(-84.35, 190.53, -43.12, 1),
	            v4(-72.9, 203.46, -0.7, 1),
	            v4(-69.96, 218.15, 40.93, 1),
	            v4(-76.31, 229.82, 83.07, 1),
	            v4(-103.22, 238.02, 121.09, 1),
	            v4(-141.97, 241.8, 136.91, 1),
	            v4(-183.09, 245.95, 134.45, 1),
	            v4(-211.73, 249.04, 129.73, 1),
	            v4(-226.41, 250.8, 128.63, 1),
	        ], [v4(11.25, 12.18, -23.86, 1),
	            v4(11.42, 12.46, -23.99, 1),
	            v4(11.64, 13.2, -24.16, 1),
	            v4(11.85, 14.82, -24.3, 1),
	            v4(11.93, 17.58, -24.34, 1),
	            v4(11.41, 28.96, -24.39, 1),
	            v4(-8.11, 64.46, -22, 1),
	            v4(-21.59, 80.28, -54.13, 1),
	            v4(-53.17, 95.02, -91.09, 1),
	            v4(-71.1, 95.56, -128.81, 1),
	            v4(-108.09, 124.08, -166.7, 1),
	            v4(-104.25, 160.73, -122.57, 1),
	            v4(-90.22, 171.91, -83.05, 1),
	            v4(-81.43, 190.77, -40.34, 1),
	            v4(-70.12, 203.75, 1.85, 1),
	            v4(-65.62, 218.32, 45.52, 1),
	            v4(-68.32, 229.95, 92.34, 1),
	            v4(-91.77, 238.06, 134.79, 1),
	            v4(-129.52, 241.83, 170.01, 1),
	            v4(-173.82, 245.96, 195.58, 1),
	            v4(-205.65, 249.05, 202.91, 1),
	            v4(-221.52, 250.8, 203.72, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["54"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["54"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v117";
	Curves["55"] = function () {
	    var Curve_v01 = [[v4(-16.62, 9.37, -17.17, 1),
	            v4(-16.77, 9.53, -17.14, 1),
	            v4(-16.94, 10.07, -17.07, 1),
	            v4(-17.07, 11.42, -16.95, 1),
	            v4(-17.06, 14.68, -16.8, 1),
	            v4(-13.94, 26.09, -3, 1),
	            v4(-18.12, 89.43, -14.96, 1),
	            v4(-95.69, 86.74, 62.75, 1),
	            v4(-48.01, 168.62, 115.52, 1),
	            v4(-115.82, 189.28, 35.5, 1),
	            v4(-187.84, 195.56, 59.25, 1),
	            v4(-259.77, 208.92, 72.45, 1),
	            v4(-317.11, 215.04, 123.21, 1),
	            v4(-359.69, 223.89, 175.19, 1),
	            v4(-379.7, 230.3, 235.8, 1),
	            v4(-382.63, 237.55, 299.7, 1),
	            v4(-371.56, 244.04, 369.97, 1),
	            v4(-342.92, 250.86, 429.77, 1),
	            v4(-294.06, 257.59, 462.51, 1),
	            v4(-230.6, 264.48, 483.48, 1),
	            v4(-178.82, 270.57, 465.72, 1),
	            v4(-155.9, 273.21, 464.06, 1),
	        ], [v4(-15.35, 9.37, -17.26, 1),
	            v4(-15.35, 9.46, -17.26, 1),
	            v4(-15.13, 9.74, -17.27, 1),
	            v4(-14.86, 10.61, -17.26, 1),
	            v4(-14.66, 14.42, -17.22, 1),
	            v4(-12.92, 24.48, -3.34, 1),
	            v4(-14.4, 89.71, -14.02, 1),
	            v4(-92.82, 86.55, 63.03, 1),
	            v4(-44.79, 168.61, 116.24, 1),
	            v4(-112.67, 189.25, 36.06, 1),
	            v4(-184.64, 195.56, 59.82, 1),
	            v4(-256.61, 208.91, 72.99, 1),
	            v4(-313.95, 215.04, 123.75, 1),
	            v4(-360.09, 223.88, 179.52, 1),
	            v4(-388.52, 230.3, 249.15, 1),
	            v4(-399.62, 237.55, 321.8, 1),
	            v4(-391.97, 244.04, 395.73, 1),
	            v4(-364.42, 250.86, 465.04, 1),
	            v4(-318.78, 257.59, 522.41, 1),
	            v4(-256.83, 264.48, 567.92, 1),
	            v4(-204.03, 270.57, 557.84, 1),
	            v4(-180.72, 273.21, 556.7, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["55"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["55"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v118";
	Curves["56"] = function () {
	    var Curve_v01 = [[v4(11.04, -1.54, 7.85, 1),
	            v4(11.12, -1.29, 7.91, 1),
	            v4(11.32, -0.49, 7.84, 1),
	            v4(11.56, 0.95, 7.56, 1),
	            v4(11.66, 3.74, 7.07, 1),
	            v4(12.66, 15.49, 6.56, 1),
	            v4(15.96, 45.4, 14.99, 1),
	            v4(22.14, 81.68, 21.32, 1),
	            v4(-6.89, 102.67, 73.7, 1),
	            v4(-43.59, 82.31, 20.38, 1),
	            v4(-15.38, 131.73, 3.8, 1),
	            v4(-23.57, 180.04, 39.62, 1),
	            v4(28.48, 157.2, 48.83, 1),
	            v4(10.79, 206.81, 19.25, 1),
	            v4(0.76, 245.66, 32.5, 1),
	            v4(-2.6, 286.11, -2.33, 1),
	            v4(-22.54, 296.86, -37.59, 1),
	            v4(-32.43, 301.22, -82.87, 1),
	            v4(-37.82, 304.83, -126.35, 1),
	            v4(-31.97, 305.65, -170.96, 1),
	            v4(-18.22, 303.21, -196.04, 1),
	            v4(-8.15, 303.02, -206.91, 1),
	        ], [v4(10.96, -1.65, 6.88, 1),
	            v4(11.02, -1.37, 6.61, 1),
	            v4(11.21, -0.43, 6.08, 1),
	            v4(11.47, 1.26, 5.58, 1),
	            v4(11.61, 4.04, 5.11, 1),
	            v4(12.38, 15.72, 4.45, 1),
	            v4(17.46, 45.18, 12.55, 1),
	            v4(25.25, 81.08, 17.94, 1),
	            v4(-4.87, 102.87, 71.18, 1),
	            v4(-41.56, 82.22, 18.52, 1),
	            v4(-13.77, 130.88, 1.07, 1),
	            v4(-21.84, 180.06, 36.51, 1),
	            v4(29.92, 157.2, 46.69, 1),
	            v4(13.04, 206.27, 16.52, 1),
	            v4(2.69, 245.48, 30.07, 1),
	            v4(2.4, 285.91, -4.93, 1),
	            v4(-14.94, 296.89, -40.34, 1),
	            v4(-18.87, 302.81, -85.53, 1),
	            v4(-5.29, 313.73, -127.79, 1),
	            v4(22.38, 323.4, -170.84, 1),
	            v4(43.62, 324.26, -195.3, 1),
	            v4(54.3, 324.52, -206.06, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["56"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["56"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v119";
	Curves["57"] = function () {
	    var Curve_v01 = [[v4(-12, -0.91, 4.32, 1),
	            v4(-11.97, -0.65, 4.56, 1),
	            v4(-11.79, 0.19, 5.07, 1),
	            v4(-11.49, 1.58, 5.65, 1),
	            v4(-10.98, 3.51, 6.3, 1),
	            v4(-4.3, 14.63, 10.39, 1),
	            v4(1.8, 53.8, 18.18, 1),
	            v4(-8.39, 103.47, 21.78, 1),
	            v4(28.15, 127.69, -42.75, 1),
	            v4(29.55, 95.12, 28.75, 1),
	            v4(-31.48, 136.66, 4.18, 1),
	            v4(-1.04, 185.78, 50.79, 1),
	            v4(-82.68, 190.98, 58.33, 1),
	            v4(-106.82, 209.33, 79.24, 1),
	            v4(-162.78, 265.63, 78.54, 1),
	            v4(-98.4, 296.68, 47.12, 1),
	            v4(-87.41, 228.56, 81.57, 1),
	            v4(-142.5, 239.61, 122.9, 1),
	            v4(-168.23, 286.72, 117.62, 1),
	            v4(-220.62, 288.88, 170.37, 1),
	            v4(-231.89, 270.45, 189.26, 1),
	            v4(-238.37, 253.54, 200.02, 1),
	        ], [v4(-11.65, -0.91, 3.84, 1),
	            v4(-11.54, -0.62, 3.81, 1),
	            v4(-11.19, 0.37, 3.97, 1),
	            v4(-10.86, 2.05, 4.39, 1),
	            v4(-10.4, 4.1, 4.91, 1),
	            v4(-4.55, 16.2, 8.65, 1),
	            v4(0.3, 52.36, 15.31, 1),
	            v4(-7.17, 104.25, 18.47, 1),
	            v4(28.41, 127.3, -45.83, 1),
	            v4(30.04, 95.3, 25.66, 1),
	            v4(-31.03, 136.68, 1.05, 1),
	            v4(-0.59, 185.85, 47.72, 1),
	            v4(-82.29, 190.96, 55.21, 1),
	            v4(-106.38, 209.38, 76.13, 1),
	            v4(-162.32, 265.69, 75.38, 1),
	            v4(-97.85, 296.64, 43.98, 1),
	            v4(-86.98, 228.53, 78.48, 1),
	            v4(-142.02, 239.64, 119.76, 1),
	            v4(-166.43, 286.72, 112.85, 1),
	            v4(-227.81, 288.88, 144.12, 1),
	            v4(-246.42, 270.45, 153.15, 1),
	            v4(-256.88, 253.54, 159.46, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["57"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["57"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v120";
	Curves["58"] = function () {
	    var Curve_v01 = [[v4(-11.34, 11.35, -22.61, 1),
	            v4(-11.24, 11.64, -22.69, 1),
	            v4(-11.13, 12.31, -22.76, 1),
	            v4(-11.02, 13.48, -22.81, 1),
	            v4(-10.96, 15.27, -22.76, 1),
	            v4(-11.47, 26.64, -21.85, 1),
	            v4(-3.89, 54.63, -13.81, 1),
	            v4(-14.11, 96.16, -7.55, 1),
	            v4(-7.26, 140.3, 0.97, 1),
	            v4(1.99, 183.06, 8.25, 1),
	            v4(17.42, 222.35, 25.61, 1),
	            v4(32.57, 253.83, 53.68, 1),
	            v4(44.52, 279.47, 88.81, 1),
	            v4(45.64, 298.17, 130.29, 1),
	            v4(32.76, 306.79, 172.91, 1),
	            v4(10.27, 310.21, 211.62, 1),
	            v4(-19.48, 311.6, 245.33, 1),
	            v4(-56.42, 313.2, 271.09, 1),
	            v4(-98.24, 316.25, 287.33, 1),
	            v4(-141.74, 321.51, 296.54, 1),
	            v4(-171.16, 326.92, 298.54, 1),
	            v4(-185.27, 331.79, 297.83, 1),
	        ], [v4(-12.53, 10.99, -21.71, 1),
	            v4(-12.65, 11.28, -21.62, 1),
	            v4(-12.78, 11.97, -21.52, 1),
	            v4(-12.85, 13.11, -21.44, 1),
	            v4(-12.86, 14.72, -21.4, 1),
	            v4(-12.11, 27.01, -21.06, 1),
	            v4(-5.31, 55.44, -18.26, 1),
	            v4(-13.08, 97.05, -9.52, 1),
	            v4(-6.9, 141.16, -2.57, 1),
	            v4(2.85, 183.78, 5.6, 1),
	            v4(18.07, 222.92, 22.71, 1),
	            v4(33.3, 254.23, 51.1, 1),
	            v4(45.07, 279.76, 86.14, 1),
	            v4(46.01, 298.31, 126.89, 1),
	            v4(32.71, 306.83, 164.49, 1),
	            v4(9.83, 310.23, 197.21, 1),
	            v4(-20.08, 311.6, 228.19, 1),
	            v4(-56.25, 313.21, 253.74, 1),
	            v4(-94.18, 316.26, 259.78, 1),
	            v4(-133.03, 321.52, 255.76, 1),
	            v4(-160.63, 326.93, 252.34, 1),
	            v4(-174.49, 331.79, 250.78, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["58"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["58"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v121";
	Curves["59"] = function () {
	    var Curve_v01 = [[v4(-18.92, -0.44, 7.09, 1),
	            v4(-18.91, -0.26, 7.25, 1),
	            v4(-18.97, 0.34, 7.55, 1),
	            v4(-19.11, 1.53, 7.94, 1),
	            v4(-19.42, 4.21, 8.53, 1),
	            v4(-24.58, 20.37, 6.3, 1),
	            v4(-13.9, 45.54, 11.41, 1),
	            v4(-56.18, 80.3, -6.66, 1),
	            v4(-61.85, 88.87, 61.12, 1),
	            v4(-22.38, 110.41, 77.37, 1),
	            v4(27.04, 125.4, 87.63, 1),
	            v4(48.64, 137.02, 27.56, 1),
	            v4(24.08, 190.79, 35.78, 1),
	            v4(59.87, 196.04, 98.97, 1),
	            v4(6.23, 241.47, 96.09, 1),
	            v4(47.99, 270.63, 56.82, 1),
	            v4(92.41, 275.99, 63.97, 1),
	            v4(140.6, 274.45, 70.79, 1),
	            v4(172.58, 279.14, 108.33, 1),
	            v4(200.17, 281.59, 150.88, 1),
	            v4(218.64, 284.64, 178.99, 1),
	            v4(231.02, 285.85, 188.65, 1),
	        ], [v4(-18.98, -0.31, 5.4, 1),
	            v4(-19.04, -0.09, 5.3, 1),
	            v4(-19.16, 0.55, 5.25, 1),
	            v4(-19.32, 1.88, 5.36, 1),
	            v4(-19.48, 4.76, 5.9, 1),
	            v4(-23.78, 20.58, 4.18, 1),
	            v4(-13.58, 45.13, 9.7, 1),
	            v4(-53.49, 80.51, -9.54, 1),
	            v4(-60.1, 88.78, 58.99, 1),
	            v4(-20.13, 110.47, 74.84, 1),
	            v4(29.03, 125.37, 85.28, 1),
	            v4(50.73, 137.05, 25.09, 1),
	            v4(26.13, 190.79, 33.42, 1),
	            v4(61.93, 196.05, 96.56, 1),
	            v4(8.28, 241.48, 93.67, 1),
	            v4(50.06, 270.64, 54.4, 1),
	            v4(94.47, 275.99, 61.56, 1),
	            v4(143.92, 274.45, 66.73, 1),
	            v4(191.14, 279.14, 84.26, 1),
	            v4(239.27, 281.59, 99.85, 1),
	            v4(266.15, 284.64, 116.92, 1),
	            v4(279.64, 285.85, 125.11, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["59"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["59"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v122";
	Curves["60"] = function () {
	    var Curve_v01 = [[v4(-31.45, 7.11, -6.53, 1),
	            v4(-31.35, 7.24, -6.63, 1),
	            v4(-31.16, 7.86, -6.81, 1),
	            v4(-30.99, 9.5, -6.98, 1),
	            v4(-30.95, 12.85, -7.02, 1),
	            v4(-31.07, 25.31, -6.83, 1),
	            v4(-9.96, 55.23, -7.96, 1),
	            v4(1.55, 70.54, 24.92, 1),
	            v4(32.09, 85.26, 63.16, 1),
	            v4(48.97, 86.32, 100.83, 1),
	            v4(84.82, 113.16, 141.57, 1),
	            v4(83.7, 151.19, 98.77, 1),
	            v4(70.23, 162.11, 58.09, 1),
	            v4(62.9, 181.23, 15.39, 1),
	            v4(52.78, 194.16, -27.16, 1),
	            v4(50.97, 208.85, -68.62, 1),
	            v4(58.02, 220.52, -110.8, 1),
	            v4(85.4, 228.73, -146.46, 1),
	            v4(121.93, 232.5, -157.89, 1),
	            v4(160.44, 236.65, -156.2, 1),
	            v4(188.28, 239.75, -154.39, 1),
	            v4(202.78, 241.51, -154.89, 1),
	        ], [v4(-32.59, 7.11, -5.44, 1),
	            v4(-32.76, 7.38, -5.28, 1),
	            v4(-33.04, 8.42, -5.05, 1),
	            v4(-33.17, 10.44, -4.95, 1),
	            v4(-33.23, 13.68, -4.92, 1),
	            v4(-33.06, 25.74, -4.98, 1),
	            v4(-12.56, 55.34, -7.54, 1),
	            v4(-0.15, 70.99, 24.59, 1),
	            v4(30.36, 85.73, 62.44, 1),
	            v4(47.2, 86.26, 100.66, 1),
	            v4(83.09, 114.78, 139.6, 1),
	            v4(80.51, 151.44, 95.38, 1),
	            v4(67.62, 162.61, 55.47, 1),
	            v4(60.05, 181.47, 12.53, 1),
	            v4(49.96, 194.45, -29.97, 1),
	            v4(46.72, 209.02, -73.74, 1),
	            v4(51.98, 220.65, -118.81, 1),
	            v4(79.91, 228.76, -156.74, 1),
	            v4(125.51, 232.53, -182.09, 1),
	            v4(171.21, 236.67, -206.97, 1),
	            v4(200.44, 239.75, -221.26, 1),
	            v4(214.84, 241.51, -226.62, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["60"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["60"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v123";
	Curves["61"] = function () {
	    var Curve_v01 = [[v4(18.69, 11.7, -20.64, 1),
	            v4(18.69, 11.77, -20.54, 1),
	            v4(18.71, 12.08, -20.3, 1),
	            v4(18.76, 12.8, -19.97, 1),
	            v4(18.9, 14.57, -19.68, 1),
	            v4(21.93, 30.64, -16.25, 1),
	            v4(8.65, 101.35, -17.35, 1),
	            v4(74.76, 98.62, 59.33, 1),
	            v4(126.12, 180.5, 10.13, 1),
	            v4(48.11, 201.16, 80.24, 1),
	            v4(73.93, 207.44, 151.53, 1),
	            v4(89.21, 220.8, 223.05, 1),
	            v4(141.62, 226.92, 278.89, 1),
	            v4(194.98, 235.77, 321.03, 1),
	            v4(256.54, 242.18, 341.85, 1),
	            v4(320.88, 249.43, 345.42, 1),
	            v4(389.76, 255.92, 333.35, 1),
	            v4(440.06, 262.74, 303.92, 1),
	            v4(456.92, 269.47, 256.46, 1),
	            v4(460.7, 276.36, 194.61, 1),
	            v4(435.85, 282.45, 144.4, 1),
	            v4(415.22, 285.09, 119.59, 1),
	        ], [v4(19.22, 12.94, -24.48, 1),
	            v4(19.27, 13.23, -24.65, 1),
	            v4(19.34, 13.87, -24.82, 1),
	            v4(19.43, 15.03, -24.96, 1),
	            v4(19.52, 16.86, -24.94, 1),
	            v4(21.19, 30.96, -17.26, 1),
	            v4(9.79, 101.62, -20.74, 1),
	            v4(74.95, 98.44, 56.45, 1),
	            v4(126.75, 180.49, 6.89, 1),
	            v4(48.57, 201.14, 77.08, 1),
	            v4(74.41, 207.44, 148.32, 1),
	            v4(89.67, 220.79, 219.88, 1),
	            v4(142.07, 226.92, 275.73, 1),
	            v4(199.16, 235.76, 320.22, 1),
	            v4(269.58, 242.18, 346.62, 1),
	            v4(342.52, 249.43, 355.61, 1),
	            v4(416.21, 255.92, 345.8, 1),
	            v4(484.69, 262.74, 316.25, 1),
	            v4(540.71, 269.47, 268.96, 1),
	            v4(584.4, 276.36, 205.72, 1),
	            v4(572.78, 282.45, 153.24, 1),
	            v4(570.97, 285.09, 129.97, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["61"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["61"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v124";
	Curves["62"] = function () {
	    var Curve_v01 = [[v4(16.84, 1.32, -1.26, 1),
	            v4(17.2, 1.63, -1.31, 1),
	            v4(17.45, 2.66, -1.39, 1),
	            v4(17.76, 4.82, -1.6, 1),
	            v4(18.01, 8.68, -1.41, 1),
	            v4(23.39, 21.12, 1.25, 1),
	            v4(5.7, 84.54, 19.16, 1),
	            v4(102.69, 81.92, 15.69, 1),
	            v4(96.43, 163.8, -55.16, 1),
	            v4(102.34, 184.46, 49.57, 1),
	            v4(174.12, 190.75, 74, 1),
	            v4(239.49, 204.11, 106.8, 1),
	            v4(315.83, 210.23, 100.83, 1),
	            v4(378.92, 219.07, 85.02, 1),
	            v4(426.15, 225.49, 48.75, 1),
	            v4(461.89, 232.74, -0.44, 1),
	            v4(493.25, 239.23, -63.18, 1),
	            v4(503.66, 246.05, -123.22, 1),
	            v4(477.52, 252.78, -166.31, 1),
	            v4(435.04, 259.67, -208.01, 1),
	            v4(383.88, 265.75, -220.15, 1),
	            v4(365.2, 268.39, -232.17, 1),
	        ], [v4(15.95, 1.32, -1.72, 1),
	            v4(15.95, 1.66, -2.21, 1),
	            v4(15.93, 2.8, -2.45, 1),
	            v4(16.2, 4.86, -2.56, 1),
	            v4(16.47, 8.68, -2.18, 1),
	            v4(22.08, 20.53, 0.86, 1),
	            v4(3.59, 84.8, 16.2, 1),
	            v4(100.56, 81.74, 13.74, 1),
	            v4(94.29, 163.8, -57.67, 1),
	            v4(100.16, 184.44, 47.22, 1),
	            v4(171.91, 190.75, 71.61, 1),
	            v4(237.3, 204.1, 104.47, 1),
	            v4(313.65, 210.22, 98.5, 1),
	            v4(384.06, 219.07, 81.78, 1),
	            v4(448.71, 225.48, 43.34, 1),
	            v4(501.34, 232.73, -7.96, 1),
	            v4(539.77, 239.23, -71.58, 1),
	            v4(559.54, 246.04, -143.5, 1),
	            v4(557.68, 252.78, -216.79, 1),
	            v4(535.65, 259.67, -290.43, 1),
	            v4(487.43, 265.75, -314.19, 1),
	            v4(468.15, 268.39, -327.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["62"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["62"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v125";
	Curves["63"] = function () {
	    var Curve_v01 = [[v4(-12.13, -2.74, 9.38, 1),
	            v4(-12.18, -2.55, 9.19, 1),
	            v4(-12.27, -1.58, 8.88, 1),
	            v4(-12.32, 0.45, 8.74, 1),
	            v4(-12.91, 4.32, 8.3, 1),
	            v4(-13.9, 14.81, 8.22, 1),
	            v4(0.11, 48.45, -4.1, 1),
	            v4(32.49, 63.54, 7.32, 1),
	            v4(81.42, 78.26, 7.4, 1),
	            v4(121.38, 79.32, 17.78, 1),
	            v4(175.59, 106.16, 15.3, 1),
	            v4(141.49, 144.19, -10.6, 1),
	            v4(101.32, 155.11, -25.53, 1),
	            v4(63.42, 174.23, -46.52, 1),
	            v4(23.66, 187.16, -65.27, 1),
	            v4(-10.37, 201.86, -90.32, 1),
	            v4(-39.03, 213.52, -122.98, 1),
	            v4(-50.21, 221.73, -167.71, 1),
	            v4(-34.49, 225.5, -201.55, 1),
	            v4(-4.6, 229.66, -225.28, 1),
	            v4(16.42, 232.75, -243.25, 1),
	            v4(25.54, 234.51, -254.4, 1),
	        ], [v4(-12.38, -2.72, 10.26, 1),
	            v4(-12.32, -2.46, 10.48, 1),
	            v4(-12.25, -1.16, 10.81, 1),
	            v4(-12.24, 1.38, 11.57, 1),
	            v4(-13.11, 5.48, 11.28, 1),
	            v4(-13.9, 15.84, 10.65, 1),
	            v4(-0.96, 48.68, -1.75, 1),
	            v4(31.17, 63.99, 8.44, 1),
	            v4(79.78, 78.73, 8.31, 1),
	            v4(120.14, 79.27, 19.06, 1),
	            v4(172.97, 107.78, 15.41, 1),
	            v4(136.85, 144.44, -10.23, 1),
	            v4(97.64, 155.61, -25.13, 1),
	            v4(59.41, 174.47, -46.08, 1),
	            v4(19.93, 187.45, -64.79, 1),
	            v4(-16.25, 202.02, -89.64, 1),
	            v4(-48.13, 213.65, -121.92, 1),
	            v4(-61.1, 221.76, -166.89, 1),
	            v4(-54.35, 225.53, -213.02, 1),
	            v4(-36.82, 229.67, -255.44, 1),
	            v4(-20.08, 232.75, -281.26, 1),
	            v4(-11.07, 234.51, -293.49, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["63"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["63"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v126";
	Curves["64"] = function () {
	    var Curve_v01 = [[v4(-43.15, 0.72, 31.7, 1),
	            v4(-42.96, 1.07, 31.95, 1),
	            v4(-42.76, 2.14, 32.39, 1),
	            v4(-42.68, 3.91, 32.88, 1),
	            v4(-42.54, 6.88, 33.55, 1),
	            v4(-41, 21.18, 36.09, 1),
	            v4(-30.24, 45.87, 34.59, 1),
	            v4(-74.93, 80.23, 42.87, 1),
	            v4(-42.11, 88.8, 102.44, 1),
	            v4(-0.25, 110.34, 94.12, 1),
	            v4(46.58, 125.32, 75.29, 1),
	            v4(31.29, 136.95, 13.31, 1),
	            v4(15.41, 190.72, 33.76, 1),
	            v4(80.19, 195.97, 66.55, 1),
	            v4(33.94, 241.4, 93.86, 1),
	            v4(47.12, 270.56, 39.93, 1),
	            v4(88.32, 275.92, 24.13, 1),
	            v4(132.3, 274.38, 3.81, 1),
	            v4(176.78, 279.07, 13.95, 1),
	            v4(218.54, 281.52, 31.06, 1),
	            v4(247.41, 284.57, 42.92, 1),
	            v4(262.77, 285.78, 43.79, 1),
	        ], [v4(-44, 0.72, 31.08, 1),
	            v4(-44.18, 0.98, 31, 1),
	            v4(-44.4, 1.99, 31.05, 1),
	            v4(-44.4, 3.72, 31.34, 1),
	            v4(-44.15, 6.7, 31.87, 1),
	            v4(-41.93, 21.02, 34.08, 1),
	            v4(-30.62, 45.24, 32.93, 1),
	            v4(-74.28, 80.44, 38.98, 1),
	            v4(-41.84, 88.71, 99.7, 1),
	            v4(0.22, 110.4, 90.76, 1),
	            v4(46.94, 125.3, 72.23, 1),
	            v4(31.67, 136.98, 10.09, 1),
	            v4(15.8, 190.72, 30.66, 1),
	            v4(80.58, 195.98, 63.4, 1),
	            v4(34.3, 241.41, 90.71, 1),
	            v4(47.35, 270.56, 34.87, 1),
	            v4(88.29, 275.92, 16.24, 1),
	            v4(132.21, 274.38, -5.83, 1),
	            v4(179.81, 279.07, -5.08, 1),
	            v4(226.61, 281.52, -2.18, 1),
	            v4(257.66, 284.57, 3.94, 1),
	            v4(273.33, 285.78, 4.18, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["64"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["64"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v127";
	Curves["65"] = function () {
	    var Curve_v01 = [[v4(18.59, -0.87, 3.91, 1),
	            v4(18.83, -0.65, 4, 1),
	            v4(19.51, 0.16, 3.96, 1),
	            v4(20.48, 1.61, 3.72, 1),
	            v4(21.78, 3.95, 3.36, 1),
	            v4(26.91, 15.76, 2.13, 1),
	            v4(32.27, 55.66, 4.01, 1),
	            v4(27.58, 104.81, 15.55, 1),
	            v4(0.09, 129.03, -53.32, 1),
	            v4(56.75, 96.46, -9.7, 1),
	            v4(-0.58, 137.99, 22.56, 1),
	            v4(54.82, 187.11, 27.96, 1),
	            v4(9.65, 192.31, 96.38, 1),
	            v4(10.86, 210.66, 128.29, 1),
	            v4(-24.68, 266.96, 171.52, 1),
	            v4(-8.93, 298.01, 101.63, 1),
	            v4(29.82, 229.89, 114.45, 1),
	            v4(32.65, 240.95, 186.16, 1),
	            v4(12.13, 288.05, 202.82, 1),
	            v4(3.83, 290.22, 269.76, 1),
	            v4(1.5, 271.79, 288.89, 1),
	            v4(0.47, 254.87, 300.22, 1),
	        ], [v4(18.45, -0.87, 3.38, 1),
	            v4(18.55, -0.64, 3.19, 1),
	            v4(18.98, 0.26, 2.83, 1),
	            v4(19.69, 1.75, 2.55, 1),
	            v4(20.78, 4.27, 2.22, 1),
	            v4(25.29, 16.92, 1.2, 1),
	            v4(29.24, 54.26, 3.2, 1),
	            v4(25.77, 105.58, 12.52, 1),
	            v4(-2.15, 128.63, -55.45, 1),
	            v4(54.65, 96.64, -12.02, 1),
	            v4(-2.75, 138.01, 20.25, 1),
	            v4(52.7, 187.19, 25.69, 1),
	            v4(7.45, 192.3, 94.11, 1),
	            v4(8.71, 210.71, 126, 1),
	            v4(-26.85, 267.03, 169.18, 1),
	            v4(-11.04, 297.97, 99.24, 1),
	            v4(22.68, 229.86, 112.33, 1),
	            v4(20.47, 240.98, 181.1, 1),
	            v4(-3.96, 288.06, 196.26, 1),
	            v4(-39.96, 290.22, 266.25, 1),
	            v4(-50.97, 271.78, 287.17, 1),
	            v4(-54.18, 254.87, 299.46, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["65"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["65"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v128";
	Curves["66"] = function () {
	    var Curve_v01 = [[v4(14.08, -3.81, 12.97, 1),
	            v4(14.24, -3.45, 12.92, 1),
	            v4(14.27, -2.24, 12.66, 1),
	            v4(14.14, -0.26, 12.23, 1),
	            v4(14.09, 3.57, 11.58, 1),
	            v4(15.53, 15.56, 10.55, 1),
	            v4(27.24, 44.33, 13.06, 1),
	            v4(35.76, 79.45, 12.23, 1),
	            v4(58.48, 100.45, 67.64, 1),
	            v4(-6.08, 80.09, 62.93, 1),
	            v4(-1.37, 129.51, 30.55, 1),
	            v4(21.45, 177.82, 59.34, 1),
	            v4(61.19, 154.97, 24.48, 1),
	            v4(27.05, 204.59, 19.79, 1),
	            v4(31.24, 243.44, 35.71, 1),
	            v4(3.56, 283.89, 14.26, 1),
	            v4(-34.87, 294.64, 5.54, 1),
	            v4(-74.34, 298.99, -17.35, 1),
	            v4(-106.82, 302.61, -44.35, 1),
	            v4(-132.89, 303.43, -80.55, 1),
	            v4(-142.34, 300.98, -107.83, 1),
	            v4(-144.55, 300.8, -122.26, 1),
	        ], [v4(12.95, -3.81, 12.69, 1),
	            v4(12.63, -3.45, 12.52, 1),
	            v4(12.13, -2.19, 12.1, 1),
	            v4(11.86, -0.21, 11.62, 1),
	            v4(11.79, 3.3, 10.93, 1),
	            v4(13.29, 15.13, 9.45, 1),
	            v4(26.18, 43.71, 10.33, 1),
	            v4(35.07, 78.86, 7.68, 1),
	            v4(57.77, 100.65, 64.48, 1),
	            v4(-6.26, 80, 60.18, 1),
	            v4(-2.5, 128.65, 27.58, 1),
	            v4(20.11, 177.84, 56.04, 1),
	            v4(60.42, 154.97, 22.02, 1),
	            v4(26.33, 204.04, 16.32, 1),
	            v4(30.49, 243.26, 32.84, 1),
	            v4(4.66, 283.69, 10.26, 1),
	            v4(-32.04, 294.67, 0.65, 1),
	            v4(-69.14, 298.95, -22.61, 1),
	            v4(-89.83, 302.62, -48.04, 1),
	            v4(-100.38, 303.43, -81.77, 1),
	            v4(-104.49, 300.99, -107.72, 1),
	            v4(-106.37, 300.8, -121.77, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["66"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["66"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v129";
	Curves["67"] = function () {
	    var Curve_v01 = [[v4(5, -2.33, 26.56, 1),
	            v4(4.99, -2.23, 26.75, 1),
	            v4(4.97, -1.43, 27.12, 1),
	            v4(4.97, 0.5, 27.39, 1),
	            v4(4.87, 4.29, 27.57, 1),
	            v4(4.74, 22.99, 35.65, 1),
	            v4(-3.83, 87.44, 30.66, 1),
	            v4(-3.16, 84.8, 128.28, 1),
	            v4(67.84, 166.68, 124.08, 1),
	            v4(-37.01, 187.34, 126.95, 1),
	            v4(-63.52, 193.63, 197.99, 1),
	            v4(-98.21, 206.99, 262.38, 1),
	            v4(-94.46, 213.1, 338.87, 1),
	            v4(-79.78, 221.95, 409.73, 1),
	            v4(-43.23, 228.36, 475.46, 1),
	            v4(6.52, 235.62, 529.54, 1),
	            v4(69, 242.11, 569.8, 1),
	            v4(140.31, 248.93, 591.64, 1),
	            v4(213.61, 255.66, 591.9, 1),
	            v4(287.86, 262.55, 572.02, 1),
	            v4(313.01, 268.63, 524.52, 1),
	            v4(326.69, 271.27, 505.62, 1),
	        ], [v4(5.05, -2.17, 25.83, 1),
	            v4(5.07, -1.87, 25.62, 1),
	            v4(5.06, -0.73, 25.46, 1),
	            v4(4.99, 1.43, 25.58, 1),
	            v4(6.2, 4.59, 28.21, 1),
	            v4(5.14, 22.71, 34.43, 1),
	            v4(-0.8, 87.7, 28.32, 1),
	            v4(-1.15, 84.62, 126.21, 1),
	            v4(70.41, 166.68, 122.01, 1),
	            v4(-34.61, 187.32, 124.84, 1),
	            v4(-61.08, 193.63, 195.85, 1),
	            v4(-95.81, 206.98, 260.25, 1),
	            v4(-92.06, 213.1, 336.74, 1),
	            v4(-77.43, 221.95, 407.49, 1),
	            v4(-42.35, 228.36, 465.98, 1),
	            v4(4.56, 235.61, 506.1, 1),
	            v4(63.72, 242.11, 532.49, 1),
	            v4(122.77, 248.92, 534.92, 1),
	            v4(172.32, 255.65, 506.54, 1),
	            v4(222.84, 262.55, 464.08, 1),
	            v4(240.31, 268.63, 415.23, 1),
	            v4(253.76, 271.27, 398.99, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["67"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["67"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v130";
	Curves["68"] = function () {
	    var Curve_v01 = [[v4(21.35, -5.42, 28.18, 1),
	            v4(21.39, -4.97, 28.56, 1),
	            v4(21.44, -3.56, 28.91, 1),
	            v4(21.47, -0.56, 28.99, 1),
	            v4(21.47, 4.45, 29.03, 1),
	            v4(19.85, 17.48, 30.91, 1),
	            v4(7.77, 48.29, 43.81, 1),
	            v4(-23.63, 62.78, 33.74, 1),
	            v4(-72.55, 77.51, 35.06, 1),
	            v4(-112.79, 78.57, 25.83, 1),
	            v4(-166.9, 105.4, 29.87, 1),
	            v4(-132.07, 143.44, 54.78, 1),
	            v4(-91.5, 154.36, 68.55, 1),
	            v4(-53.01, 173.48, 88.44, 1),
	            v4(-12.74, 186.41, 106.03, 1),
	            v4(21.67, 201.1, 129.64, 1),
	            v4(50.72, 212.77, 160.73, 1),
	            v4(62.97, 220.98, 204.88, 1),
	            v4(50.2, 224.75, 242.25, 1),
	            v4(24.08, 228.9, 271.7, 1),
	            v4(4.89, 231.99, 292.47, 1),
	            v4(-7.88, 233.75, 299.75, 1),
	        ], [v4(21.22, -5.42, 26.88, 1),
	            v4(21.19, -5.04, 26.52, 1),
	            v4(21.15, -3.65, 26.11, 1),
	            v4(21.15, -0.61, 25.99, 1),
	            v4(21.14, 4.36, 25.95, 1),
	            v4(19.95, 17.25, 27.96, 1),
	            v4(9.17, 48.35, 41.59, 1),
	            v4(-22.34, 63.23, 32.58, 1),
	            v4(-70.94, 77.97, 34.11, 1),
	            v4(-111.58, 78.51, 24.51, 1),
	            v4(-164.28, 107.03, 29.67, 1),
	            v4(-127.45, 143.69, 54.27, 1),
	            v4(-87.83, 154.86, 68.04, 1),
	            v4(-49.01, 173.72, 87.89, 1),
	            v4(-9.02, 186.7, 105.46, 1),
	            v4(27.86, 201.27, 129.26, 1),
	            v4(60.65, 212.9, 160.62, 1),
	            v4(74.91, 221.01, 205.19, 1),
	            v4(69.48, 224.78, 251.5, 1),
	            v4(53.18, 228.91, 294.41, 1),
	            v4(37.18, 232, 320.69, 1),
	            v4(28.53, 233.75, 333.17, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["68"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["68"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v131";
	Curves["69"] = function () {
	    var Curve_v01 = [[v4(34.64, -4.71, 16.74, 1),
	            v4(34.25, -3.96, 16.92, 1),
	            v4(33.63, -2.01, 16.73, 1),
	            v4(33.07, 0.48, 16.38, 1),
	            v4(32.36, 4.3, 15.96, 1),
	            v4(30.67, 17.68, 15.36, 1),
	            v4(32.7, 42.92, 18.54, 1),
	            v4(20.26, 66.51, -29.91, 1),
	            v4(-35.64, 83.12, 6.14, 1),
	            v4(-23.07, 112.84, 41.42, 1),
	            v4(0.46, 136.97, 81.87, 1),
	            v4(60.55, 143.75, 58.33, 1),
	            v4(38.58, 193.38, 33.51, 1),
	            v4(12.6, 212.92, 98.65, 1),
	            v4(-19.3, 248.12, 46.77, 1),
	            v4(37.56, 278.16, 47.64, 1),
	            v4(60.31, 291.65, 84.43, 1),
	            v4(86.56, 298.95, 125.22, 1),
	            v4(81.7, 313.61, 169.64, 1),
	            v4(69.27, 325.96, 213.4, 1),
	            v4(60.25, 335.64, 242.92, 1),
	            v4(60.79, 340.14, 257.83, 1),
	        ], [v4(35.14, -4.89, 15.9, 1),
	            v4(35.2, -4.34, 15.46, 1),
	            v4(34.93, -2.53, 14.95, 1),
	            v4(34.49, 0.12, 14.63, 1),
	            v4(33.86, 4.42, 14.34, 1),
	            v4(32.61, 17.85, 14.47, 1),
	            v4(34.26, 42.5, 17.59, 1),
	            v4(24.19, 66.77, -29.71, 1),
	            v4(-32.88, 83.03, 6.15, 1),
	            v4(-19.68, 112.93, 41.53, 1),
	            v4(3.54, 136.95, 81.91, 1),
	            v4(63.79, 143.79, 58.37, 1),
	            v4(41.71, 193.39, 33.58, 1),
	            v4(15.77, 212.94, 98.7, 1),
	            v4(-16.14, 248.14, 46.81, 1),
	            v4(40.75, 278.17, 47.7, 1),
	            v4(63.48, 291.66, 84.49, 1),
	            v4(90.05, 298.96, 125.33, 1),
	            v4(99.77, 313.62, 171.89, 1),
	            v4(110.59, 325.97, 219.09, 1),
	            v4(111.49, 335.65, 250.07, 1),
	            v4(113.35, 340.15, 265.18, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["69"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["69"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v132";
	Curves["70"] = function () {
	    var Curve_v01 = [[v4(-15.61, -4.48, 17.27, 1),
	            v4(-15.47, -4.23, 17.03, 1),
	            v4(-15.32, -3.42, 16.76, 1),
	            v4(-15.25, -1.71, 16.66, 1),
	            v4(-15.26, 1.71, 17.12, 1),
	            v4(-15.56, 15.13, 19.85, 1),
	            v4(-17.49, 42.58, 28.25, 1),
	            v4(-28.85, 82.43, 26.47, 1),
	            v4(-29.16, 126.58, 37.39, 1),
	            v4(-26.83, 169.33, 48.93, 1),
	            v4(-26.32, 208.62, 72.15, 1),
	            v4(-32.97, 240.11, 103.35, 1),
	            v4(-46.62, 265.74, 137.86, 1),
	            v4(-72.63, 284.44, 170.18, 1),
	            v4(-110.06, 293.06, 194.31, 1),
	            v4(-152.27, 296.49, 209.22, 1),
	            v4(-196.77, 297.87, 215.63, 1),
	            v4(-241.59, 299.47, 211.33, 1),
	            v4(-283.97, 302.52, 196.61, 1),
	            v4(-323.08, 307.78, 175.45, 1),
	            v4(-346.79, 313.2, 157.91, 1),
	            v4(-357.08, 318.06, 148.23, 1),
	        ], [v4(-16.06, -4.48, 18.02, 1),
	            v4(-16.24, -4.09, 18.32, 1),
	            v4(-16.43, -2.75, 18.64, 1),
	            v4(-16.48, -0.66, 18.76, 1),
	            v4(-16.49, 2.52, 18.92, 1),
	            v4(-16.33, 15.83, 19.71, 1),
	            v4(-15.66, 43.3, 24.07, 1),
	            v4(-26.8, 83.33, 25.63, 1),
	            v4(-26.59, 127.43, 34.94, 1),
	            v4(-24.46, 170.05, 47.47, 1),
	            v4(-23.94, 209.19, 70.37, 1),
	            v4(-30.73, 240.5, 101.86, 1),
	            v4(-44.46, 266.03, 136.18, 1),
	            v4(-70.62, 284.59, 168.46, 1),
	            v4(-107.57, 293.11, 191.91, 1),
	            v4(-144.33, 296.5, 201.19, 1),
	            v4(-181.41, 297.88, 199.95, 1),
	            v4(-221.79, 299.48, 191.61, 1),
	            v4(-252.59, 302.54, 171.43, 1),
	            v4(-278.54, 307.79, 145.58, 1),
	            v4(-299.04, 313.2, 128.35, 1),
	            v4(-310.18, 318.06, 120.04, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["70"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["70"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v133";
	Curves["71"] = function () {
	    var Curve_v01 = [[v4(-19.24, -2.93, 33.67, 1),
	            v4(-19.2, -2.55, 34, 1),
	            v4(-19.15, -1.48, 34.41, 1),
	            v4(-19.13, 0.58, 34.57, 1),
	            v4(-19.11, 4.23, 34.66, 1),
	            v4(-17.86, 16, 37.1, 1),
	            v4(-20.16, 54.44, 45.94, 1),
	            v4(-31.13, 101.77, 41.1, 1),
	            v4(38.51, 125.99, 15.62, 1),
	            v4(-6.75, 93.42, 70.99, 1),
	            v4(-37.33, 134.96, 12.74, 1),
	            v4(-44.33, 184.07, 67.97, 1),
	            v4(-111.41, 189.27, 20.83, 1),
	            v4(-143.34, 207.62, 21.11, 1),
	            v4(-185.52, 263.92, -15.67, 1),
	            v4(-116.12, 294.97, 2.1, 1),
	            v4(-130.06, 226.85, 35.46, 1),
	            v4(-198.81, 237.91, 31.26, 1),
	            v4(-213.5, 283.81, 14.56, 1),
	            v4(-278.94, 286.03, 25.74, 1),
	            v4(-299.53, 268.45, 29, 1),
	            v4(-312.46, 252.13, 30.46, 1),
	        ], [v4(-19.49, -3.21, 31.52, 1),
	            v4(-19.53, -2.9, 31.19, 1),
	            v4(-19.58, -1.93, 30.8, 1),
	            v4(-19.59, 0.22, 30.66, 1),
	            v4(-19.59, 4.29, 30.62, 1),
	            v4(-16.91, 17.29, 33.74, 1),
	            v4(-19.23, 53.39, 42.96, 1),
	            v4(-28.06, 102.55, 39.38, 1),
	            v4(40.7, 125.59, 13.45, 1),
	            v4(-4.37, 93.6, 68.96, 1),
	            v4(-34.96, 134.97, 10.65, 1),
	            v4(-42, 184.15, 65.92, 1),
	            v4(-109.08, 189.26, 18.7, 1),
	            v4(-140.99, 207.67, 19.03, 1),
	            v4(-183.12, 263.99, -17.77, 1),
	            v4(-113.67, 294.93, 0.07, 1),
	            v4(-127.74, 226.83, 33.39, 1),
	            v4(-196.41, 237.94, 29.18, 1),
	            v4(-210.53, 285.02, 5.36, 1),
	            v4(-277.54, 287.18, -26.58, 1),
	            v4(-297.57, 268.74, -36.43, 1),
	            v4(-309.63, 251.83, -39.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["71"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["71"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v134";
	Curves["72"] = function () {
	    var Curve_v01 = [[v4(2.84, -5.76, 30.23, 1),
	            v4(2.61, -5.31, 30.5, 1),
	            v4(2.42, -3.29, 30.76, 1),
	            v4(2.41, -0.26, 30.81, 1),
	            v4(2.89, 4.94, 31.46, 1),
	            v4(0.75, 16.58, 33.75, 1),
	            v4(-7.23, 43.84, 42.42, 1),
	            v4(-10.21, 77.51, 50.07, 1),
	            v4(-69.9, 98.5, 45.33, 1),
	            v4(-36.56, 78.15, -10.15, 1),
	            v4(-9.79, 127.56, 8.67, 1),
	            v4(-45.78, 175.87, 16.04, 1),
	            v4(-32.62, 153.03, 67.23, 1),
	            v4(-13.02, 202.64, 38.89, 1),
	            v4(-29.12, 241.5, 35.44, 1),
	            v4(2.51, 281.95, 20.42, 1),
	            v4(27.65, 292.69, -9.94, 1),
	            v4(65.89, 297.05, -34.83, 1),
	            v4(104.63, 300.66, -51.63, 1),
	            v4(148.71, 301.49, -58.55, 1),
	            v4(177.32, 299.04, -54.67, 1),
	            v4(191.19, 298.86, -50.13, 1),
	        ], [v4(3.41, -5.76, 29.62, 1),
	            v4(3.68, -5.23, 29.33, 1),
	            v4(3.92, -3.25, 29.08, 1),
	            v4(3.97, -0.09, 29.04, 1),
	            v4(4.61, 4.86, 29.81, 1),
	            v4(2.76, 16.5, 32.57, 1),
	            v4(-4.27, 43.4, 42.8, 1),
	            v4(-5.84, 76.91, 51.51, 1),
	            v4(-66.77, 98.7, 46.13, 1),
	            v4(-34.02, 78.05, -9.07, 1),
	            v4(-6.64, 126.71, 8.99, 1),
	            v4(-42.24, 175.89, 16.33, 1),
	            v4(-30.08, 153.03, 67.65, 1),
	            v4(-9.6, 202.1, 39.8, 1),
	            v4(-26.22, 241.31, 35.99, 1),
	            v4(5.51, 281.74, 21.24, 1),
	            v4(30.58, 292.72, -9.21, 1),
	            v4(68.19, 297.01, -32.74, 1),
	            v4(101.44, 300.67, -38.4, 1),
	            v4(138.01, 301.48, -29.95, 1),
	            v4(163.71, 299.04, -20.13, 1),
	            v4(177.21, 298.86, -14.77, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["72"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["72"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v135";
	Curves["73"] = function () {
	    var Curve_v01 = [[v4(-8.42, -0.87, 46.39, 1),
	            v4(-8.29, -0.67, 46.38, 1),
	            v4(-8.14, -0.34, 46.29, 1),
	            v4(-8.01, 0.42, 46.17, 1),
	            v4(-7.93, 1.54, 46.05, 1),
	            v4(-7.86, 3.45, 45.95, 1),
	            v4(-6.98, 26.91, 44.93, 1),
	            v4(2.47, 89.02, 45.87, 1),
	            v4(59.83, 86.41, -32.46, 1),
	            v4(0.08, 168.3, -71.04, 1),
	            v4(86.35, 188.96, -11.38, 1),
	            v4(149.72, 195.24, -53.01, 1),
	            v4(215.76, 208.6, -84.44, 1),
	            v4(257.95, 214.72, -148.35, 1),
	            v4(288, 223.57, -214.18, 1),
	            v4(297.37, 229.98, -288.81, 1),
	            v4(289.21, 237.23, -361.84, 1),
	            v4(262.61, 243.72, -431.24, 1),
	            v4(218.01, 250.54, -491.01, 1),
	            v4(159.04, 257.27, -534.55, 1),
	            v4(87.4, 264.16, -562.4, 1),
	            v4(39.04, 270.24, -538.95, 1),
	            v4(16.83, 272.89, -531.81, 1),
	        ], [v4(-8.7, -0.87, 46.65, 1),
	            v4(-8.83, -0.68, 46.65, 1),
	            v4(-8.9, -0.37, 46.57, 1),
	            v4(-8.84, 0.38, 46.39, 1),
	            v4(-8.72, 1.48, 46.23, 1),
	            v4(-8.59, 3.17, 46.08, 1),
	            v4(-7.6, 26.14, 45.01, 1),
	            v4(-1.11, 89.29, 46.01, 1),
	            v4(56.98, 86.23, -31.99, 1),
	            v4(-3.22, 168.29, -70.9, 1),
	            v4(83.16, 188.93, -11.1, 1),
	            v4(146.48, 195.24, -52.73, 1),
	            v4(212.57, 208.59, -84.14, 1),
	            v4(254.76, 214.72, -148.05, 1),
	            v4(284.68, 226.3, -212.81, 1),
	            v4(293.7, 239.25, -284.88, 1),
	            v4(285.2, 252.83, -355.43, 1),
	            v4(258.46, 261.97, -423.81, 1),
	            v4(213.8, 273.13, -481.85, 1),
	            v4(154.68, 291.18, -520.9, 1),
	            v4(82.86, 310.34, -543.88, 1),
	            v4(34.42, 321.32, -518.48, 1),
	            v4(12.2, 324.61, -511.08, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["73"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["73"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v136";
	Curves["74"] = function () {
	    var Curve_v01 = [[v4(2.49, -2.01, 48.99, 1),
	            v4(2.65, -1.52, 48.69, 1),
	            v4(2.8, -0.14, 48.42, 1),
	            v4(2.83, 2.07, 48.36, 1),
	            v4(2.85, 5.24, 48.32, 1),
	            v4(6.29, 17.14, 48.21, 1),
	            v4(20.97, 50.96, 35.95, 1),
	            v4(50.95, 66.19, 53.34, 1),
	            v4(99.01, 80.92, 62.51, 1),
	            v4(136.35, 81.98, 80.12, 1),
	            v4(190.08, 108.81, 87.74, 1),
	            v4(161.38, 146.84, 55.96, 1),
	            v4(124.68, 157.76, 33.84, 1),
	            v4(91.33, 176.88, 6.18, 1),
	            v4(55.74, 189.8, -19.63, 1),
	            v4(26.45, 204.31, -50.72, 1),
	            v4(3.43, 215.68, -88.37, 1),
	            v4(1.86, 223.75, -132.57, 1),
	            v4(27.05, 227.64, -162.16, 1),
	            v4(61.67, 232.07, -184.32, 1),
	            v4(84.72, 235.33, -201.75, 1),
	            v4(97.23, 237.14, -207.39, 1),
	        ], [v4(1.6, -2.01, 50.59, 1),
	            v4(1.45, -1.59, 50.87, 1),
	            v4(1.29, -0.31, 51.17, 1),
	            v4(1.23, 1.94, 51.26, 1),
	            v4(1.83, 5.43, 52.18, 1),
	            v4(5.92, 17.55, 50.89, 1),
	            v4(19.49, 51.19, 38.08, 1),
	            v4(49.44, 66.64, 54.2, 1),
	            v4(97.23, 81.38, 63.09, 1),
	            v4(134.89, 81.92, 81.15, 1),
	            v4(187.48, 110.44, 87.37, 1),
	            v4(156.75, 147.09, 55.47, 1),
	            v4(120.99, 158.27, 33.55, 1),
	            v4(87.31, 177.13, 5.86, 1),
	            v4(51.99, 190.1, -19.85, 1),
	            v4(21.05, 204.68, -50.98, 1),
	            v4(-4.28, 216.3, -88.62, 1),
	            v4(-8.68, 224.41, -135.21, 1),
	            v4(6.52, 228.18, -179.28, 1),
	            v4(31.62, 232.32, -217.72, 1),
	            v4(52.85, 235.4, -239.98, 1),
	            v4(63.98, 237.16, -250.32, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["74"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["74"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v137";
	Curves["75"] = function () {
	    var Curve_v01 = [[v4(36.7, -1.63, 55.92, 1),
	            v4(37.08, -1.11, 55.44, 1),
	            v4(37.46, 1.01, 55.04, 1),
	            v4(37.59, 3.96, 54.94, 1),
	            v4(37.73, 9.92, 54.81, 1),
	            v4(38.48, 22.62, 52.26, 1),
	            v4(29.06, 45.72, 53.81, 1),
	            v4(44.75, 77.41, 92.7, 1),
	            v4(96.6, 85.98, 48.67, 1),
	            v4(80.11, 107.52, 9.3, 1),
	            v4(52.33, 122.51, -32.84, 1),
	            v4(-5.37, 134.13, -5.52, 1),
	            v4(17.84, 187.9, 5.97, 1),
	            v4(37.07, 193.16, -64.04, 1),
	            v4(73.04, 238.58, -24.15, 1),
	            v4(18.6, 267.75, -26.39, 1),
	            v4(-3.53, 273.1, -63.7, 1),
	            v4(-31.42, 271.57, -102.74, 1),
	            v4(-31.29, 276.25, -145.75, 1),
	            v4(-20.96, 278.7, -184.53, 1),
	            v4(-12.05, 281.75, -211.76, 1),
	            v4(-12.68, 282.96, -226.69, 1),
	        ], [v4(35.97, -1.63, 56.86, 1),
	            v4(35.66, -1.21, 57.28, 1),
	            v4(35.37, 0.66, 57.7, 1),
	            v4(35.36, 3.39, 57.74, 1),
	            v4(35.41, 9.25, 57.67, 1),
	            v4(36.77, 22.11, 53.59, 1),
	            v4(27.26, 45, 54.29, 1),
	            v4(40.81, 77.63, 92.83, 1),
	            v4(93.86, 85.9, 48.95, 1),
	            v4(76.72, 107.59, 9.51, 1),
	            v4(49.26, 122.48, -32.58, 1),
	            v4(-8.59, 134.17, -5.25, 1),
	            v4(14.72, 187.9, 6.21, 1),
	            v4(33.91, 193.16, -63.79, 1),
	            v4(69.89, 238.59, -23.88, 1),
	            v4(12.57, 267.75, -25.55, 1),
	            v4(-13.84, 273.1, -61.97, 1),
	            v4(-44.21, 271.57, -100.61, 1),
	            v4(-52.95, 276.25, -147.41, 1),
	            v4(-59.42, 278.7, -193.84, 1),
	            v4(-59.61, 281.75, -225.5, 1),
	            v4(-62.49, 282.96, -240.9, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["75"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["75"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v138";
	Curves["76"] = function () {
	    var Curve_v01 = [[v4(-31.27, 5.93, 56.81, 1),
	            v4(-31.53, 6.22, 56.73, 1),
	            v4(-31.85, 7.36, 56.62, 1),
	            v4(-31.89, 9.2, 56.54, 1),
	            v4(-31.77, 12.51, 56.37, 1),
	            v4(-29.78, 25.62, 55.9, 1),
	            v4(-23.29, 52.93, 50.26, 1),
	            v4(-15.17, 92.84, 58.43, 1),
	            v4(-8.46, 136.99, 49.79, 1),
	            v4(-3.52, 179.74, 39.11, 1),
	            v4(9.79, 219.03, 20.08, 1),
	            v4(33.6, 250.52, -1.15, 1),
	            v4(65.01, 276.15, -20.92, 1),
	            v4(105.1, 294.86, -31.61, 1),
	            v4(149.54, 303.47, -28.95, 1),
	            v4(192.41, 306.9, -16.03, 1),
	            v4(232.09, 308.28, 5.11, 1),
	            v4(265.7, 309.89, 35.08, 1),
	            v4(291.18, 312.93, 72, 1),
	            v4(310.22, 318.19, 112.19, 1),
	            v4(318.98, 323.61, 140.34, 1),
	            v4(321.55, 328.48, 154.24, 1),
	        ], [v4(-30.44, 5.93, 57.09, 1),
	            v4(-30.09, 6.41, 57.21, 1),
	            v4(-29.78, 7.95, 57.31, 1),
	            v4(-29.68, 10.21, 57.28, 1),
	            v4(-29.58, 13.64, 57.18, 1),
	            v4(-29.22, 26.8, 56.39, 1),
	            v4(-27.13, 54.08, 52.61, 1),
	            v4(-17.31, 93.74, 57.89, 1),
	            v4(-11.98, 137.84, 50.26, 1),
	            v4(-6.29, 180.47, 38.89, 1),
	            v4(6.82, 219.61, 20.12, 1),
	            v4(30.91, 250.91, -1.27, 1),
	            v4(62.28, 276.45, -20.84, 1),
	            v4(102.45, 295, -31.41, 1),
	            v4(146.38, 303.52, -28.39, 1),
	            v4(184.36, 306.91, -12.97, 1),
	            v4(217.36, 308.29, 11.56, 1),
	            v4(246.72, 309.9, 43.15, 1),
	            v4(259.64, 312.95, 80.32, 1),
	            v4(264.19, 318.2, 119.44, 1),
	            v4(268.6, 323.62, 146.37, 1),
	            v4(271.42, 328.48, 159.66, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["76"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["76"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v139";
	Curves["77"] = function () {
	    var Curve_v01 = [[v4(2.6, 12.39, -25.71, 1),
	            v4(2.94, 12.7, -25.73, 1),
	            v4(3.35, 13.92, -25.79, 1),
	            v4(3.51, 16.36, -25.87, 1),
	            v4(3.61, 20.53, -25.98, 1),
	            v4(5.62, 23.81, -17.94, 1),
	            v4(10.15, 61.5, -20.13, 1),
	            v4(16.07, 108.25, -9.86, 1),
	            v4(-55.16, 132.47, -30.48, 1),
	            v4(14.06, 99.9, -48.39, 1),
	            v4(4.3, 141.43, 16.67, 1),
	            v4(42.6, 190.55, -23.73, 1),
	            v4(68.83, 195.75, 53.94, 1),
	            v4(94.76, 214.1, 72.59, 1),
	            v4(107.04, 270.4, 127.19, 1),
	            v4(61.56, 301.45, 71.84, 1),
	            v4(92.53, 233.33, 53.17, 1),
	            v4(145.49, 244.39, 97.19, 1),
	            v4(146.31, 291.49, 120.32, 1),
	            v4(202.11, 293.66, 159.9, 1),
	            v4(218.47, 275.23, 172.15, 1),
	            v4(227.84, 258.31, 179.94, 1),
	        ], [v4(1.73, 12.39, -25.71, 1),
	            v4(1.41, 12.68, -25.72, 1),
	            v4(1.04, 13.85, -25.78, 1),
	            v4(0.95, 16.03, -25.89, 1),
	            v4(0.96, 20.21, -26.05, 1),
	            v4(3.71, 23.78, -17.05, 1),
	            v4(7.57, 59.92, -18.39, 1),
	            v4(12.57, 109.02, -10.29, 1),
	            v4(-58.22, 132.07, -30.02, 1),
	            v4(10.95, 100.08, -48.15, 1),
	            v4(1.15, 141.45, 16.96, 1),
	            v4(39.5, 190.63, -23.46, 1),
	            v4(65.7, 195.74, 54.28, 1),
	            v4(91.63, 214.15, 72.87, 1),
	            v4(103.85, 270.47, 127.47, 1),
	            v4(58.38, 301.41, 72.02, 1),
	            v4(89.42, 233.3, 53.46, 1),
	            v4(142.33, 244.42, 97.45, 1),
	            v4(140.03, 291.5, 124.53, 1),
	            v4(177.5, 293.66, 187.14, 1),
	            v4(188.5, 275.22, 206.12, 1),
	            v4(196.55, 258.31, 215.56, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["77"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["77"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v140";
	Curves["78"] = function () {
	    var Curve_v01 = [[v4(-46.29, 14.44, -31.6, 1),
	            v4(-46.17, 14.85, -31.82, 1),
	            v4(-46.5, 16.7, -32.08, 1),
	            v4(-47.05, 19.83, -32.34, 1),
	            v4(-47.32, 24.67, -32.95, 1),
	            v4(-46.36, 36.42, -35.03, 1),
	            v4(-37.89, 63.62, -42.23, 1),
	            v4(-33.45, 97.7, -49.25, 1),
	            v4(24.23, 118.7, -33.14, 1),
	            v4(-19.15, 98.34, 14.91, 1),
	            v4(-41.8, 147.76, -8.7, 1),
	            v4(-5.06, 196.07, -9.02, 1),
	            v4(-8.16, 173.22, -61.79, 1),
	            v4(-32.83, 222.84, -37.74, 1),
	            v4(-17.68, 261.74, -31.2, 1),
	            v4(-51.1, 303.73, -20.33, 1),
	            v4(-81.03, 316.18, 7.08, 1),
	            v4(-123.04, 321.43, 25.44, 1),
	            v4(-164.54, 324.27, 33.38, 1),
	            v4(-209.74, 323.26, 29.07, 1),
	            v4(-237.42, 319.74, 18.25, 1),
	            v4(-250.28, 319.22, 10.65, 1),
	        ], [v4(-46.98, 14.44, -31.06, 1),
	            v4(-47.42, 14.87, -30.85, 1),
	            v4(-48.26, 16.61, -30.68, 1),
	            v4(-48.91, 19.55, -30.9, 1),
	            v4(-49.32, 24.16, -31.56, 1),
	            v4(-48.66, 35.93, -34.1, 1),
	            v4(-40.71, 63.13, -43.15, 1),
	            v4(-37.46, 97.1, -51.5, 1),
	            v4(21.31, 118.9, -34.52, 1),
	            v4(-21.43, 98.25, 13.36, 1),
	            v4(-44.83, 146.9, -9.63, 1),
	            v4(-8.49, 196.09, -9.99, 1),
	            v4(-10.57, 173.22, -62.7, 1),
	            v4(-36.01, 222.29, -39.3, 1),
	            v4(-20.43, 261.51, -32.36, 1),
	            v4(-54.41, 301.94, -23.98, 1),
	            v4(-84.85, 312.91, 1.09, 1),
	            v4(-126.25, 317.2, 16.35, 1),
	            v4(-159.67, 320.87, 10.6, 1),
	            v4(-193.54, 321.68, -11.46, 1),
	            v4(-216.72, 319.24, -28.65, 1),
	            v4(-228.92, 319.05, -36.85, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["78"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["78"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v141";
	Curves["79"] = function () {
	    var Curve_v01 = [[v4(149.27, -3.15, -6.03, 1),
	            v4(149.44, -2.84, -5.49, 1),
	            v4(149.8, -1.26, -4.86, 1),
	            v4(150.09, 1.47, -4.92, 1),
	            v4(150.53, 7.06, -5.06, 1),
	            v4(151.08, 19.93, -4.62, 1),
	            v4(150.26, 47.18, -6.71, 1),
	            v4(144.61, 84.82, -13.85, 1),
	            v4(147.04, 129.98, -5.08, 1),
	            v4(151.72, 173.63, 1.11, 1),
	            v4(151.67, 215.8, 18.58, 1),
	            v4(142.03, 252.08, 43.07, 1),
	            v4(124.2, 283.68, 69.86, 1),
	            v4(94.07, 309.17, 92.54, 1),
	            v4(53.53, 324.43, 105.94, 1),
	            v4(9.75, 333.59, 110.01, 1),
	            v4(-34.6, 339.65, 105.61, 1),
	            v4(-76.88, 344.32, 90.77, 1),
	            v4(-114.35, 348.65, 66.29, 1),
	            v4(-146.98, 353.9, 36.08, 1),
	            v4(-165.46, 358.58, 12.94, 1),
	            v4(-172.75, 362.77, 0.58, 1),
	        ], [v4(148.58, -3.04, -9.02, 1),
	            v4(148.46, -2.49, -9.86, 1),
	            v4(148.5, -0.63, -10.79, 1),
	            v4(148.8, 2.3, -11.22, 1),
	            v4(149.41, 7.7, -11.7, 1),
	            v4(150.87, 20.51, -12.21, 1),
	            v4(152.99, 47.27, -11.85, 1),
	            v4(146.89, 85.4, -17.7, 1),
	            v4(150.16, 130.23, -6.96, 1),
	            v4(154.42, 173.93, 0.17, 1),
	            v4(154.43, 215.9, 17.35, 1),
	            v4(144.57, 252.06, 42.11, 1),
	            v4(126.7, 283.54, 68.71, 1),
	            v4(96.42, 308.88, 91.33, 1),
	            v4(56.14, 324.02, 104.29, 1),
	            v4(15.24, 333.13, 105.07, 1),
	            v4(-25.18, 339.16, 96.2, 1),
	            v4(-64.94, 343.83, 79.01, 1),
	            v4(-90.7, 348.15, 49.13, 1),
	            v4(-107.36, 353.4, 12.77, 1),
	            v4(-119.35, 358.07, -12.3, 1),
	            v4(-125.75, 362.25, -24.63, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["79"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["79"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v142";
	Curves["80"] = function () {
	    var Curve_v01 = [[v4(6.44, 3.17, -4.85, 1),
	            v4(6.44, 3.57, -5.17, 1),
	            v4(6.54, 4.84, -5.78, 1),
	            v4(6.82, 6.99, -6.3, 1),
	            v4(7.41, 10.76, -6.73, 1),
	            v4(8.04, 21.24, -6.26, 1),
	            v4(14.79, 49.54, 4.69, 1),
	            v4(21.96, 84.43, 10.47, 1),
	            v4(-11.98, 106.23, 61.36, 1),
	            v4(-44.72, 85.57, 6.16, 1),
	            v4(-15.73, 134.23, -9.21, 1),
	            v4(-26.36, 183.41, 25.55, 1),
	            v4(24.51, 160.55, 39.49, 1),
	            v4(9.89, 209.62, 8.17, 1),
	            v4(-1.32, 248.83, 20.93, 1),
	            v4(4.44, 289.26, -13.63, 1),
	            v4(-6.47, 300.24, -49.83, 1),
	            v4(-6.86, 304.53, -94.33, 1),
	            v4(5.24, 308.19, -129.6, 1),
	            v4(29.78, 309, -162.49, 1),
	            v4(49.47, 306.56, -182.32, 1),
	            v4(59.93, 306.38, -191.92, 1),
	        ], [v4(6.73, 2.97, -3.61, 1),
	            v4(6.82, 3.31, -3.55, 1),
	            v4(7.01, 4.42, -3.7, 1),
	            v4(7.27, 6.41, -4.06, 1),
	            v4(7.73, 9.78, -4.43, 1),
	            v4(8.19, 20.59, -4.22, 1),
	            v4(13.01, 49.42, 6.97, 1),
	            v4(18.6, 85.03, 13.62, 1),
	            v4(-14.18, 106.02, 63.73, 1),
	            v4(-46.88, 85.67, 7.87, 1),
	            v4(-17.53, 135.08, -6.6, 1),
	            v4(-28.32, 183.39, 28.52, 1),
	            v4(22.92, 160.55, 41.51, 1),
	            v4(7.44, 210.16, 10.73, 1),
	            v4(-3.3, 249.02, 23.2, 1),
	            v4(-1.32, 289.47, -11.76, 1),
	            v4(-15.91, 300.21, -48.38, 1),
	            v4(-19.41, 304.57, -93.87, 1),
	            v4(-15.57, 308.18, -135.92, 1),
	            v4(-0.51, 309.01, -177.92, 1),
	            v4(16.62, 306.56, -201.16, 1),
	            v4(27.25, 306.38, -211.16, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["80"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["80"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v143";
	Curves["81"] = function () {
	    var Curve_v01 = [[v4(-9.25, 0.76, -0.14, 1),
	            v4(-8.96, 1.25, 0.05, 1),
	            v4(-8.54, 2.47, 0.61, 1),
	            v4(-8.13, 4.44, 1.46, 1),
	            v4(-7.69, 7.18, 2.5, 1),
	            v4(-4.79, 19.89, 6.53, 1),
	            v4(-6.3, 56.45, 10.54, 1),
	            v4(-15.9, 107.22, 8.35, 1),
	            v4(47.79, 130.27, -28.3, 1),
	            v4(12.24, 98.28, 33.74, 1),
	            v4(-27.32, 139.65, -18.89, 1),
	            v4(-25.38, 188.83, 36.79, 1),
	            v4(-99.19, 193.93, 0.98, 1),
	            v4(-130.63, 212.35, 6.44, 1),
	            v4(-178.13, 268.67, -23.11, 1),
	            v4(-106.71, 299.61, -16.68, 1),
	            v4(-115.24, 231.5, 15.71, 1),
	            v4(-183.7, 242.62, 20.39, 1),
	            v4(-201.41, 289.7, 0.69, 1),
	            v4(-272.39, 291.86, -16.27, 1),
	            v4(-293.66, 273.42, -22.37, 1),
	            v4(-306.04, 256.51, -23.48, 1),
	        ], [v4(-9.93, 0.76, 0.14, 1),
	            v4(-9.92, 1.14, 0.5, 1),
	            v4(-9.67, 2.23, 1.33, 1),
	            v4(-9.2, 4.12, 2.44, 1),
	            v4(-8.68, 6.72, 3.7, 1),
	            v4(-5.48, 18.68, 8.29, 1),
	            v4(-6.69, 57.7, 13.65, 1),
	            v4(-18.65, 106.45, 10.55, 1),
	            v4(45.98, 130.67, -25.8, 1),
	            v4(10.23, 98.1, 36.13, 1),
	            v4(-29.33, 139.63, -16.44, 1),
	            v4(-27.36, 188.75, 39.19, 1),
	            v4(-101.15, 193.95, 3.45, 1),
	            v4(-132.61, 212.3, 8.87, 1),
	            v4(-180.17, 268.6, -20.65, 1),
	            v4(-108.81, 299.65, -14.27, 1),
	            v4(-117.2, 231.53, 20.9, 1),
	            v4(-185.72, 242.59, 27.81, 1),
	            v4(-204.02, 289.69, 11.82, 1),
	            v4(-273.42, 291.86, 35.54, 1),
	            v4(-292.14, 273.43, 46.36, 1),
	            v4(-303.34, 256.51, 51.62, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["81"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["81"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v144";
	Curves["82"] = function () {
	    var Curve_v01 = [[v4(16.13, 7.06, -12.8, 1),
	            v4(15.95, 7.29, -12.72, 1),
	            v4(15.74, 8.05, -12.62, 1),
	            v4(15.61, 9.42, -12.57, 1),
	            v4(15.57, 11.75, -12.55, 1),
	            v4(16.85, 28.66, -13.2, 1),
	            v4(3.14, 49.95, -1.29, 1),
	            v4(-7.85, 90.91, 2.12, 1),
	            v4(-6.15, 135.01, 11.27, 1),
	            v4(-2.02, 177.63, 23.3, 1),
	            v4(2.17, 216.77, 45.81, 1),
	            v4(0.53, 248.08, 77.99, 1),
	            v4(-7.5, 273.61, 114.07, 1),
	            v4(-28.12, 292.17, 150.13, 1),
	            v4(-61.13, 300.69, 179.41, 1),
	            v4(-99.46, 304.08, 196.5, 1),
	            v4(-141.06, 305.46, 203.97, 1),
	            v4(-184.45, 307.06, 203.26, 1),
	            v4(-217.61, 310.12, 185.37, 1),
	            v4(-244.99, 315.37, 159.26, 1),
	            v4(-265.57, 320.78, 142.61, 1),
	            v4(-276.7, 325.64, 135.14, 1),
	        ], [v4(17.1, 7.2, -13.23, 1),
	            v4(17.27, 7.45, -13.3, 1),
	            v4(17.47, 8.17, -13.39, 1),
	            v4(17.62, 9.62, -13.45, 1),
	            v4(17.65, 12.06, -13.47, 1),
	            v4(17.74, 28.34, -13.36, 1),
	            v4(2.05, 49.16, 3.2, 1),
	            v4(-9.74, 90.01, 3.28, 1),
	            v4(-8.28, 134.16, 14.11, 1),
	            v4(-4.13, 176.91, 25.12, 1),
	            v4(0.11, 216.2, 47.96, 1),
	            v4(-1.43, 247.69, 79.82, 1),
	            v4(-9.35, 273.32, 116.08, 1),
	            v4(-29.83, 292.02, 152.16, 1),
	            v4(-62.88, 300.64, 181.99, 1),
	            v4(-102.15, 304.07, 203.51, 1),
	            v4(-145.04, 305.45, 216.99, 1),
	            v4(-189.97, 307.05, 219.95, 1),
	            v4(-234.16, 310.1, 212.24, 1),
	            v4(-276.17, 315.36, 197.65, 1),
	            v4(-302.39, 320.78, 184.16, 1),
	            v4(-314.11, 325.64, 176.25, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["82"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["82"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v145";
	Curves["83"] = function () {
	    var Curve_v01 = [[v4(11.56, 0.79, -0.89, 1),
	            v4(11.51, 1.11, -1.08, 1),
	            v4(11.45, 2.08, -1.3, 1),
	            v4(11.41, 3.69, -1.36, 1),
	            v4(11.36, 6.62, -1.34, 1),
	            v4(8.01, 20.97, 1.29, 1),
	            v4(16.97, 50.69, 4.07, 1),
	            v4(-28.31, 83.72, -5.01, 1),
	            v4(-23.16, 89.28, 61.7, 1),
	            v4(15.32, 113.28, 73.03, 1),
	            v4(65.75, 124.38, 80.72, 1),
	            v4(79.75, 140.58, 18.45, 1),
	            v4(61.04, 194.75, 36.8, 1),
	            v4(92.35, 195.93, 95.4, 1),
	            v4(40.39, 247.05, 87.7, 1),
	            v4(85.82, 270.03, 50.59, 1),
	            v4(128.61, 276.42, 58.72, 1),
	            v4(177.72, 274.17, 63.62, 1),
	            v4(222.22, 278.72, 79.32, 1),
	            v4(265.71, 281.46, 103.11, 1),
	            v4(291.07, 284.58, 121.16, 1),
	            v4(302.44, 286.52, 136.92, 1),
	        ], [v4(11.79, 0.76, 0.15, 1),
	            v4(11.83, 1, 0.33, 1),
	            v4(11.87, 1.66, 0.53, 1),
	            v4(11.89, 2.95, 0.69, 1),
	            v4(11.89, 5.37, 0.75, 1),
	            v4(7.47, 20.06, 3.42, 1),
	            v4(16.84, 50.59, 6.17, 1),
	            v4(-30.37, 83.04, -2.76, 1),
	            v4(-25.36, 89.36, 63.34, 1),
	            v4(12.78, 112.91, 75.54, 1),
	            v4(63.3, 124.47, 83.38, 1),
	            v4(77.96, 140.08, 21.31, 1),
	            v4(58.79, 194.64, 38.68, 1),
	            v4(90.47, 195.76, 97.67, 1),
	            v4(38.43, 246.77, 90.37, 1),
	            v4(83.47, 270.02, 53.07, 1),
	            v4(126.46, 276.4, 61.11, 1),
	            v4(175.15, 274.18, 66.41, 1),
	            v4(204.52, 279.32, 101.28, 1),
	            v4(224.66, 281.46, 142.44, 1),
	            v4(237.09, 284.58, 171.33, 1),
	            v4(239.63, 285.78, 185.68, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["83"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["83"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v146";
	Curves["84"] = function () {
	    var Curve_v01 = [[v4(-1.37, 5.15, -12.08, 1),
	            v4(-1.59, 5.46, -12.33, 1),
	            v4(-1.86, 6.44, -12.96, 1),
	            v4(-1.99, 8.32, -13.66, 1),
	            v4(-2.05, 11.73, -14.2, 1),
	            v4(-3.42, 22.35, -9.92, 1),
	            v4(-3.65, 56.61, 9.08, 1),
	            v4(-36.28, 72.13, 19.19, 1),
	            v4(-76.13, 86.87, 47.04, 1),
	            v4(-115.4, 87.41, 61.24, 1),
	            v4(-156.7, 115.93, 94.38, 1),
	            v4(-112.41, 152.58, 94.83, 1),
	            v4(-71.71, 163.76, 84.69, 1),
	            v4(-28.35, 182.61, 80.08, 1),
	            v4(14.73, 195.59, 72.91, 1),
	            v4(58.63, 210.17, 72.66, 1),
	            v4(103.23, 221.79, 80.99, 1),
	            v4(139.55, 229.9, 110.51, 1),
	            v4(160.32, 233.67, 152.24, 1),
	            v4(170.14, 237.81, 197.08, 1),
	            v4(171.12, 240.89, 227.83, 1),
	            v4(170.71, 242.65, 243.02, 1),
	        ], [v4(-0.37, 5.16, -12.08, 1),
	            v4(-0.19, 5.56, -12.39, 1),
	            v4(-0.06, 6.61, -13.03, 1),
	            v4(-0.07, 8.48, -13.7, 1),
	            v4(-0.1, 11.58, -14.21, 1),
	            v4(-1.75, 22.67, -7.74, 1),
	            v4(-3.19, 56.39, 11.64, 1),
	            v4(-36.73, 71.68, 20.86, 1),
	            v4(-76.96, 86.41, 48.72, 1),
	            v4(-115.69, 87.47, 62.99, 1),
	            v4(-158.79, 114.3, 95.97, 1),
	            v4(-116.01, 152.33, 97.78, 1),
	            v4(-74.5, 163.25, 87.12, 1),
	            v4(-31.4, 182.37, 82.72, 1),
	            v4(12, 195.3, 75.38, 1),
	            v4(55.9, 210, 75.07, 1),
	            v4(100.72, 221.66, 83.18, 1),
	            v4(136.69, 229.87, 112.36, 1),
	            v4(142.76, 233.64, 148.38, 1),
	            v4(130.32, 237.8, 184.61, 1),
	            v4(122.04, 240.89, 211.84, 1),
	            v4(120.38, 242.65, 226.58, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["84"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["84"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v147";
	Curves["85"] = function () {
	    var Curve_v01 = [[v4(-5, 11.03, -25.23, 1),
	            v4(-4.91, 11.35, -25.29, 1),
	            v4(-4.82, 12.08, -25.35, 1),
	            v4(-4.74, 13.47, -25.36, 1),
	            v4(-4.71, 15.45, -25.32, 1),
	            v4(-3.04, 31.02, -10.79, 1),
	            v4(-11.08, 92.36, 1.48, 1),
	            v4(4.73, 89.19, 100.73, 1),
	            v4(74.68, 171.25, 85.07, 1),
	            v4(-28.52, 191.89, 104.76, 1),
	            v4(-43.22, 198.2, 179.1, 1),
	            v4(-67.14, 211.55, 248.25, 1),
	            v4(-51.14, 217.68, 323.13, 1),
	            v4(-27.48, 226.52, 384.32, 1),
	            v4(13.89, 232.94, 428.04, 1),
	            v4(66.57, 240.19, 458.62, 1),
	            v4(132.58, 246.68, 482.12, 1),
	            v4(195.21, 253.5, 482.18, 1),
	            v4(240.29, 260.23, 448.92, 1),
	            v4(283.87, 267.12, 402.68, 1),
	            v4(293.89, 273.21, 354.74, 1),
	            v4(304.67, 275.85, 337.3, 1),
	        ], [v4(-6.31, 10.79, -23.82, 1),
	            v4(-6.39, 11.06, -23.74, 1),
	            v4(-6.48, 11.77, -23.64, 1),
	            v4(-6.55, 13.05, -23.56, 1),
	            v4(-6.56, 14.93, -23.54, 1),
	            v4(-3.02, 31.02, -9.56, 1),
	            v4(-13.81, 92.09, 3.81, 1),
	            v4(3.08, 89.38, 103.09, 1),
	            v4(72.47, 171.26, 87.53, 1),
	            v4(-30.55, 191.92, 107.23, 1),
	            v4(-45.29, 198.2, 181.61, 1),
	            v4(-69.17, 211.56, 250.73, 1),
	            v4(-53.16, 217.68, 325.63, 1),
	            v4(-27.27, 226.53, 393.2, 1),
	            v4(19.38, 232.94, 452.19, 1),
	            v4(77.18, 240.19, 497.57, 1),
	            v4(145.32, 246.68, 527.25, 1),
	            v4(219.21, 253.5, 537.34, 1),
	            v4(291.61, 260.23, 525.8, 1),
	            v4(361.69, 267.12, 494.24, 1),
	            v4(378.87, 273.21, 443.31, 1),
	            v4(389.34, 275.85, 422.46, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["85"].animation = [[902, 1], [1161, 0.4813325041], [1232, 0.475], [1562, 0.475], [1596, 0.3982702091], [1690, 0.07022845857], [1891, -1]];
	Curves["85"].divisions = "|MAEmodelsPrevis|ShootingStars_30000_300_2_124_202_247_1000_50_100_100_100_20|_60_1_v148";
	Curves.numCurves = 86;
	Curves["86"] = function () {
	    var Curve_v01 = [[v4(0.72, 2.96, 0.12, 1),
	            v4(0.68, 3.06, 0.17, 1),
	            v4(0.55, 3.3, 0.32, 1),
	            v4(0.22, 3.57, 0.58, 1),
	            v4(-0.16, 3.64, 0.74, 1),
	            v4(-0.33, 3.4, 0.78, 1),
	            v4(-0.14, 3.06, 0.71, 1),
	            v4(0.22, 2.83, 0.5, 1),
	            v4(0.47, 2.74, 0.34, 1),
	            v4(0.58, 2.7, 0.27, 1),
	        ], [v4(1.24, 2.97, 0, 1),
	            v4(1.37, 3.65, 0, 1),
	            v4(1.03, 4.95, 0, 1),
	            v4(-0.35, 6.55, 0.73, 1),
	            v4(-2.45, 6.82, 3.48, 1),
	            v4(-3.92, 5.4, 3.48, 1),
	            v4(-3.55, 3.34, 0.73, 1),
	            v4(-1.75, 2.36, 0, 1),
	            v4(-0.39, 2.32, 0, 1),
	            v4(0.27, 2.27, 0, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["86"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["86"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v261";
	Curves["87"] = function () {
	    var Curve_v01 = [[v4(0.86, 2.95, 0.27, 1),
	            v4(0.91, 3.31, 0.26, 1),
	            v4(0.67, 4.05, 0.46, 1),
	            v4(-0.06, 4.87, 1.65, 1),
	            v4(-1.1, 5.1, 2.51, 1),
	            v4(-1.81, 4.47, 2.68, 1),
	            v4(-1.52, 3.47, 2.14, 1),
	            v4(-0.68, 2.8, 0.94, 1),
	            v4(0.03, 2.67, 0.59, 1),
	            v4(0.4, 2.68, 0.52, 1),
	        ], [v4(0.73, 3, 0.41, 1),
	            v4(0.71, 3.14, 0.48, 1),
	            v4(0.59, 3.46, 0.74, 1),
	            v4(0.26, 3.83, 1.18, 1),
	            v4(-0.2, 3.91, 1.63, 1),
	            v4(-0.42, 3.59, 1.7, 1),
	            v4(-0.21, 3.14, 1.33, 1),
	            v4(0.17, 2.84, 0.89, 1),
	            v4(0.44, 2.71, 0.61, 1),
	            v4(0.56, 2.66, 0.51, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["87"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["87"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v262";
	Curves["88"] = function () {
	    var Curve_v01 = [[v4(1.04, 2.98, 0, 1),
	            v4(1.14, 3.53, 0.27, 1),
	            v4(0.86, 4.56, 0.46, 1),
	            v4(-0.15, 5.84, 1.43, 1),
	            v4(-1.81, 6.06, 3.48, 1),
	            v4(-2.98, 4.93, 3.48, 1),
	            v4(-2.68, 3.29, 1.76, 1),
	            v4(-1.25, 2.5, 0.33, 1),
	            v4(-0.16, 2.47, 0.33, 1),
	            v4(0.36, 2.43, 0.33, 1),
	        ], [v4(0.81, 2.89, 0.02, 1),
	            v4(0.85, 3.17, 0.12, 1),
	            v4(0.65, 3.74, 0.52, 1),
	            v4(-0.08, 4.37, 1.35, 1),
	            v4(-0.99, 4.54, 1.73, 1),
	            v4(-1.54, 4.06, 1.73, 1),
	            v4(-1.24, 3.29, 1.43, 1),
	            v4(-0.43, 2.78, 0.61, 1),
	            v4(0.17, 2.68, 0.56, 1),
	            v4(0.45, 2.68, 0.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["88"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["88"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v263";
	Curves["89"] = function () {
	    var Curve_v01 = [[v4(0.53, 3.15, -0.59, 1),
	            v4(0.6, 3.47, -0.68, 1),
	            v4(0.65, 4.22, -0.9, 1),
	            v4(1.01, 5.37, -1.56, 1),
	            v4(1.63, 6.1, -1.97, 1),
	            v4(1.96, 5.97, -2.16, 1),
	            v4(1.52, 5.12, -1.88, 1),
	            v4(0.92, 3.91, -1.02, 1),
	            v4(0.66, 3.28, -0.52, 1),
	            v4(0.55, 3.07, -0.38, 1),
	        ], [v4(0.2, 2.97, 0.17, 1),
	            v4(0.26, 3.57, -0.05, 1),
	            v4(0.2, 5.08, -0.66, 1),
	            v4(1.31, 7.36, -2.37, 1),
	            v4(2.88, 8.87, -3.4, 1),
	            v4(3.75, 8.6, -3.84, 1),
	            v4(3.17, 6.87, -3.45, 1),
	            v4(1.78, 4.36, -2.12, 1),
	            v4(1.02, 3.32, -0.74, 1),
	            v4(0.8, 2.96, -0.34, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["89"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["89"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v264";
	Curves["90"] = function () {
	    var Curve_v01 = [[v4(0.41, 3.14, -0.09, 1),
	            v4(0.51, 3.52, -0.19, 1),
	            v4(0.6, 4.5, -0.42, 1),
	            v4(1.16, 5.85, -1.14, 1),
	            v4(1.88, 6.78, -1.6, 1),
	            v4(2.32, 6.64, -1.83, 1),
	            v4(1.89, 5.62, -1.56, 1),
	            v4(1.12, 4.01, -0.99, 1),
	            v4(0.79, 3.3, -0.14, 1),
	            v4(0.67, 3.06, 0.06, 1),
	        ], [v4(0.34, 2.95, 0.24, 1),
	            v4(0.38, 3.44, 0.09, 1),
	            v4(0.4, 4.61, -0.44, 1),
	            v4(1.02, 6.48, -1.7, 1),
	            v4(2.28, 7.7, -2.53, 1),
	            v4(2.99, 7.49, -2.88, 1),
	            v4(2.48, 6.04, -2.52, 1),
	            v4(1.41, 4.21, -1.12, 1),
	            v4(0.88, 3.3, -0.26, 1),
	            v4(0.66, 2.99, -0.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["90"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["90"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v265";
	Curves["91"] = function () {
	    var Curve_v01 = [[v4(0.63, 3.16, 0, 1),
	            v4(-0.17, 3.08, 0, 1),
	            v4(-1.62, 2.67, 0, 1),
	            v4(-2.63, 1.68, 0, 1),
	            v4(-2.11, 0.8, 0, 1),
	            v4(-0.4, 0.51, 0, 1),
	            v4(1.48, 1.03, 0, 1),
	            v4(2.42, 2.15, 0, 1),
	            v4(1.95, 2.88, 0, 1),
	            v4(1.39, 3.12, 0, 1),
	        ], [v4(0.68, 2.76, 0, 1),
	            v4(0.57, 2.75, 0, 1),
	            v4(0.38, 2.7, 0, 1),
	            v4(0.24, 2.56, 0, 1),
	            v4(0.31, 2.45, 0, 1),
	            v4(0.54, 2.41, 0, 1),
	            v4(0.79, 2.48, 0, 1),
	            v4(0.91, 2.63, 0, 1),
	            v4(0.85, 2.72, 0, 1),
	            v4(0.78, 2.76, 0, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["91"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["91"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v266";
	Curves["92"] = function () {
	    var Curve_v01 = [[v4(0.67, 2.91, 0.07, 1),
	            v4(0.26, 2.87, 0.07, 1),
	            v4(-0.5, 2.65, 0.26, 1),
	            v4(-1.03, 2.13, 1.36, 1),
	            v4(-0.75, 1.68, 1.53, 1),
	            v4(0.14, 1.53, 1.68, 1),
	            v4(1.12, 1.8, 1.5, 1),
	            v4(1.61, 2.38, 0.33, 1),
	            v4(1.36, 2.76, 0.1, 1),
	            v4(1.07, 2.89, 0.07, 1),
	        ], [v4(0.71, 2.8, 0.19, 1),
	            v4(0.55, 2.79, 0.38, 1),
	            v4(0.25, 2.7, 0.59, 1),
	            v4(0.04, 2.5, 0.78, 1),
	            v4(0.14, 2.32, 0.99, 1),
	            v4(0.5, 2.26, 0.99, 1),
	            v4(0.89, 2.36, 0.67, 1),
	            v4(1.08, 2.59, 0.26, 1),
	            v4(0.98, 2.75, 0.1, 1),
	            v4(0.87, 2.8, 0.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["92"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["92"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v267";
	Curves["93"] = function () {
	    var Curve_v01 = [[v4(0.63, 3, 0.12, 1),
	            v4(-0.01, 2.94, 0.12, 1),
	            v4(-1.18, 2.6, 0.12, 1),
	            v4(-2, 1.81, 0.22, 1),
	            v4(-1.58, 1.16, 0.65, 1),
	            v4(-0.2, 1.11, 1.15, 1),
	            v4(1.32, 1.32, 0.53, 1),
	            v4(2.08, 2.18, 0.13, 1),
	            v4(1.7, 2.78, 0.12, 1),
	            v4(1.24, 2.97, 0.12, 1),
	        ], [v4(0.64, 2.85, 0.15, 1),
	            v4(0.36, 2.82, 0.17, 1),
	            v4(-0.15, 2.69, 0.26, 1),
	            v4(-0.51, 2.39, 0.44, 1),
	            v4(-0.32, 2.13, 0.61, 1),
	            v4(0.28, 2.06, 0.7, 1),
	            v4(0.94, 2.2, 0.57, 1),
	            v4(1.27, 2.53, 0.35, 1),
	            v4(1.1, 2.76, 0.24, 1),
	            v4(0.91, 2.84, 0.2, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["93"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["93"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v268";
	Curves["94"] = function () {
	    var Curve_v01 = [[v4(0.68, 3.43, -5.11, 1),
	            v4(0.24, 3.32, -5.11, 1),
	            v4(-0.77, 3.07, -4.94, 1),
	            v4(-2.27, 2.67, -4.22, 1),
	            v4(-3.6, 2.33, -3.11, 1),
	            v4(-4.59, 2.26, -1.73, 1),
	            v4(-5.07, 2.52, -0.21, 1),
	            v4(-4.95, 2.97, 1.29, 1),
	            v4(-4.31, 3.34, 2.58, 1),
	            v4(-3.38, 3.44, 3.59, 1),
	            v4(-2.3, 3.25, 4.42, 1),
	            v4(-1.07, 2.74, 5, 1),
	            v4(0.25, 2.05, 5.21, 1),
	            v4(1.57, 1.41, 4.87, 1),
	            v4(2.71, 1.11, 4.05, 1),
	            v4(3.58, 1.2, 3.03, 1),
	            v4(4.18, 1.57, 1.91, 1),
	            v4(4.5, 2.15, 0.78, 1),
	            v4(4.53, 2.79, -0.37, 1),
	            v4(4.26, 3.37, -1.52, 1),
	            v4(3.65, 3.73, -2.64, 1),
	            v4(2.79, 3.79, -3.63, 1),
	            v4(1.8, 3.69, -4.47, 1),
	            v4(1.06, 3.53, -4.92, 1),
	            v4(0.68, 3.43, -5.11, 1),
	        ], [v4(0.13, 2.1, -1.42, 1),
	            v4(-0.02, 2.08, -1.41, 1),
	            v4(-0.33, 2.08, -1.37, 1),
	            v4(-0.75, 2.18, -1.18, 1),
	            v4(-1.11, 2.34, -0.92, 1),
	            v4(-1.41, 2.52, -0.6, 1),
	            v4(-1.63, 2.72, -0.23, 1),
	            v4(-1.75, 2.9, 0.21, 1),
	            v4(-1.73, 3.04, 0.68, 1),
	            v4(-1.57, 3.12, 1.13, 1),
	            v4(-1.31, 3.15, 1.55, 1),
	            v4(-0.97, 3.14, 1.9, 1),
	            v4(-0.54, 3.08, 2.16, 1),
	            v4(-0.05, 2.95, 2.24, 1),
	            v4(0.44, 2.78, 2.12, 1),
	            v4(0.86, 2.6, 1.82, 1),
	            v4(1.17, 2.45, 1.4, 1),
	            v4(1.37, 2.37, 0.89, 1),
	            v4(1.42, 2.34, 0.35, 1),
	            v4(1.33, 2.33, -0.19, 1),
	            v4(1.1, 2.31, -0.68, 1),
	            v4(0.78, 2.29, -1.08, 1),
	            v4(0.41, 2.27, -1.41, 1),
	            v4(0.15, 2.26, -1.59, 1),
	            v4(0.01, 2.25, -1.66, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["94"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["94"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v269";
	Curves["95"] = function () {
	    var Curve_v01 = [[v4(0.43, 3.32, -3.45, 1),
	            v4(0.13, 3.19, -3.42, 1),
	            v4(-0.5, 2.98, -3.27, 1),
	            v4(-1.41, 2.82, -2.78, 1),
	            v4(-2.23, 2.8, -2.09, 1),
	            v4(-2.89, 2.91, -1.28, 1),
	            v4(-3.33, 3.13, -0.35, 1),
	            v4(-3.46, 3.38, 0.64, 1),
	            v4(-3.2, 3.57, 1.61, 1),
	            v4(-2.63, 3.64, 2.45, 1),
	            v4(-1.87, 3.59, 3.12, 1),
	            v4(-0.99, 3.42, 3.59, 1),
	            v4(-0.07, 3.13, 3.82, 1),
	            v4(0.86, 2.77, 3.68, 1),
	            v4(1.69, 2.46, 3.16, 1),
	            v4(2.33, 2.32, 2.39, 1),
	            v4(2.77, 2.39, 1.51, 1),
	            v4(3, 2.69, 0.63, 1),
	            v4(3.03, 3.09, -0.22, 1),
	            v4(2.83, 3.46, -1.03, 1),
	            v4(2.41, 3.67, -1.81, 1),
	            v4(1.81, 3.71, -2.5, 1),
	            v4(1.12, 3.64, -3.08, 1),
	            v4(0.61, 3.55, -3.39, 1),
	            v4(0.35, 3.49, -3.52, 1),
	        ], [v4(0.19, 2.81, -1.89, 1),
	            v4(0.01, 2.77, -1.88, 1),
	            v4(-0.36, 2.75, -1.8, 1),
	            v4(-0.86, 2.83, -1.57, 1),
	            v4(-1.31, 2.98, -1.23, 1),
	            v4(-1.67, 3.16, -0.82, 1),
	            v4(-1.95, 3.36, -0.35, 1),
	            v4(-2.08, 3.55, 0.2, 1),
	            v4(-2.04, 3.68, 0.78, 1),
	            v4(-1.83, 3.74, 1.33, 1),
	            v4(-1.49, 3.74, 1.83, 1),
	            v4(-1.03, 3.68, 2.23, 1),
	            v4(-0.49, 3.56, 2.51, 1),
	            v4(0.13, 3.36, 2.55, 1),
	            v4(0.7, 3.12, 2.34, 1),
	            v4(1.17, 2.9, 1.92, 1),
	            v4(1.51, 2.75, 1.38, 1),
	            v4(1.7, 2.71, 0.76, 1),
	            v4(1.72, 2.76, 0.13, 1),
	            v4(1.6, 2.86, -0.47, 1),
	            v4(1.33, 2.94, -1, 1),
	            v4(0.97, 2.99, -1.44, 1),
	            v4(0.54, 3.02, -1.81, 1),
	            v4(0.23, 3.02, -2.01, 1),
	            v4(0.06, 3.02, -2.1, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["95"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["95"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v270";
	Curves["96"] = function () {
	    var Curve_v01 = [[v4(0.53, 3.5, -4.21, 1),
	            v4(0.17, 3.35, -4.19, 1),
	            v4(-0.62, 3.07, -4.03, 1),
	            v4(-1.77, 2.77, -3.42, 1),
	            v4(-2.8, 2.62, -2.54, 1),
	            v4(-3.62, 2.67, -1.49, 1),
	            v4(-4.1, 2.91, -0.31, 1),
	            v4(-4.15, 3.24, 0.91, 1),
	            v4(-3.7, 3.49, 2.06, 1),
	            v4(-2.92, 3.55, 3.02, 1),
	            v4(-1.99, 3.43, 3.74, 1),
	            v4(-0.99, 3.11, 4.23, 1),
	            v4(0.1, 2.63, 4.44, 1),
	            v4(1.21, 2.12, 4.19, 1),
	            v4(2.17, 1.79, 3.5, 1),
	            v4(2.91, 1.76, 2.59, 1),
	            v4(3.41, 2.03, 1.62, 1),
	            v4(3.67, 2.51, 0.67, 1),
	            v4(3.69, 3.04, -0.29, 1),
	            v4(3.47, 3.53, -1.24, 1),
	            v4(2.97, 3.82, -2.17, 1),
	            v4(2.25, 3.87, -3, 1),
	            v4(1.42, 3.78, -3.7, 1),
	            v4(0.81, 3.65, -4.07, 1),
	            v4(0.5, 3.57, -4.23, 1),
	        ], [v4(0.34, 3.05, -2.78, 1),
	            v4(0.09, 2.95, -2.76, 1),
	            v4(-0.43, 2.82, -2.64, 1),
	            v4(-1.17, 2.78, -2.25, 1),
	            v4(-1.81, 2.84, -1.72, 1),
	            v4(-2.34, 2.99, -1.09, 1),
	            v4(-2.72, 3.19, -0.36, 1),
	            v4(-2.86, 3.39, 0.44, 1),
	            v4(-2.71, 3.52, 1.26, 1),
	            v4(-2.3, 3.55, 1.99, 1),
	            v4(-1.72, 3.49, 2.6, 1),
	            v4(-1.01, 3.34, 3.04, 1),
	            v4(-0.21, 3.11, 3.27, 1),
	            v4(0.61, 2.82, 3.19, 1),
	            v4(1.32, 2.54, 2.78, 1),
	            v4(1.86, 2.38, 2.16, 1),
	            v4(2.23, 2.36, 1.42, 1),
	            v4(2.43, 2.53, 0.64, 1),
	            v4(2.45, 2.81, -0.13, 1),
	            v4(2.29, 3.12, -0.84, 1),
	            v4(1.93, 3.35, -1.5, 1),
	            v4(1.43, 3.43, -2.06, 1),
	            v4(0.86, 3.4, -2.54, 1),
	            v4(0.44, 3.32, -2.8, 1),
	            v4(0.22, 3.27, -2.91, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["96"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["96"].divisions = "|MAEmodelsPrevis|AtomB_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v271";
	Curves.numCurves = 97;
	Curves["97"] = function () {
	    var Curve_v01 = [[v4(0.45, 2.54, -3.86, 1),
	            v4(0.12, 2.42, -3.85, 1),
	            v4(-0.6, 2.21, -3.7, 1),
	            v4(-1.66, 2, -3.14, 1),
	            v4(-2.61, 1.88, -2.33, 1),
	            v4(-3.36, 1.92, -1.36, 1),
	            v4(-3.81, 2.1, -0.28, 1),
	            v4(-3.85, 2.34, 0.85, 1),
	            v4(-3.44, 2.53, 1.91, 1),
	            v4(-2.72, 2.57, 2.79, 1),
	            v4(-1.86, 2.48, 3.45, 1),
	            v4(-0.94, 2.25, 3.9, 1),
	            v4(0.06, 1.89, 4.1, 1),
	            v4(1.08, 1.51, 3.87, 1),
	            v4(1.96, 1.27, 3.23, 1),
	            v4(2.64, 1.24, 2.39, 1),
	            v4(3.1, 1.44, 1.5, 1),
	            v4(3.34, 1.8, 0.62, 1),
	            v4(3.36, 2.19, -0.25, 1),
	            v4(3.16, 2.56, -1.13, 1),
	            v4(2.69, 2.77, -1.99, 1),
	            v4(2.04, 2.81, -2.75, 1),
	            v4(1.27, 2.75, -3.39, 1),
	            v4(0.72, 2.65, -3.74, 1),
	            v4(0.42, 2.59, -3.88, 1),
	        ], [v4(0.45, 3.75, -3.86, 1),
	            v4(0.12, 3.63, -3.85, 1),
	            v4(-0.6, 3.42, -3.7, 1),
	            v4(-1.66, 3.2, -3.14, 1),
	            v4(-2.61, 3.09, -2.33, 1),
	            v4(-3.36, 3.13, -1.36, 1),
	            v4(-3.81, 3.3, -0.28, 1),
	            v4(-3.85, 3.55, 0.85, 1),
	            v4(-3.44, 3.73, 1.91, 1),
	            v4(-2.72, 3.78, 2.79, 1),
	            v4(-1.86, 3.69, 3.45, 1),
	            v4(-0.94, 3.45, 3.9, 1),
	            v4(0.06, 3.1, 4.1, 1),
	            v4(1.08, 2.72, 3.87, 1),
	            v4(1.96, 2.48, 3.23, 1),
	            v4(2.64, 2.45, 2.39, 1),
	            v4(3.1, 2.65, 1.5, 1),
	            v4(3.34, 3.01, 0.62, 1),
	            v4(3.36, 3.4, -0.25, 1),
	            v4(3.16, 3.76, -1.13, 1),
	            v4(2.69, 3.98, -1.99, 1),
	            v4(2.04, 4.02, -2.75, 1),
	            v4(1.27, 3.96, -3.39, 1),
	            v4(0.72, 3.86, -3.74, 1),
	            v4(0.42, 3.8, -3.88, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["97"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["97"].divisions = "|MAEmodelsPrevis|AtomPerp_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v272";
	Curves["98"] = function () {
	    var Curve_v01 = [[v4(0.18, 1.87, -2.38, 1),
	            v4(-0.03, 1.79, -2.37, 1),
	            v4(-0.48, 1.67, -2.26, 1),
	            v4(-1.12, 1.58, -1.91, 1),
	            v4(-1.69, 1.56, -1.43, 1),
	            v4(-2.15, 1.63, -0.86, 1),
	            v4(-2.46, 1.75, -0.21, 1),
	            v4(-2.55, 1.9, 0.48, 1),
	            v4(-2.37, 2.01, 1.16, 1),
	            v4(-1.97, 2.05, 1.75, 1),
	            v4(-1.43, 2.02, 2.22, 1),
	            v4(-0.82, 1.92, 2.55, 1),
	            v4(-0.17, 1.76, 2.71, 1),
	            v4(0.48, 1.55, 2.61, 1),
	            v4(1.06, 1.37, 2.25, 1),
	            v4(1.5, 1.28, 1.71, 1),
	            v4(1.81, 1.33, 1.09, 1),
	            v4(1.98, 1.5, 0.48, 1),
	            v4(2, 1.73, -0.12, 1),
	            v4(1.86, 1.95, -0.69, 1),
	            v4(1.56, 2.07, -1.23, 1),
	            v4(1.14, 2.09, -1.72, 1),
	            v4(0.66, 2.05, -2.12, 1),
	            v4(0.31, 2, -2.34, 1),
	            v4(0.12, 1.96, -2.43, 1),
	        ], [v4(0.18, 3.72, -2.38, 1),
	            v4(-0.03, 3.65, -2.37, 1),
	            v4(-0.48, 3.53, -2.26, 1),
	            v4(-1.12, 3.43, -1.91, 1),
	            v4(-1.69, 3.42, -1.43, 1),
	            v4(-2.15, 3.49, -0.86, 1),
	            v4(-2.46, 3.61, -0.21, 1),
	            v4(-2.55, 3.76, 0.48, 1),
	            v4(-2.37, 3.87, 1.16, 1),
	            v4(-1.97, 3.91, 1.75, 1),
	            v4(-1.43, 3.88, 2.22, 1),
	            v4(-0.82, 3.78, 2.55, 1),
	            v4(-0.17, 3.61, 2.71, 1),
	            v4(0.48, 3.41, 2.61, 1),
	            v4(1.06, 3.23, 2.25, 1),
	            v4(1.5, 3.14, 1.71, 1),
	            v4(1.81, 3.18, 1.09, 1),
	            v4(1.98, 3.36, 0.48, 1),
	            v4(2, 3.59, -0.12, 1),
	            v4(1.86, 3.8, -0.69, 1),
	            v4(1.56, 3.93, -1.23, 1),
	            v4(1.14, 3.95, -1.72, 1),
	            v4(0.66, 3.91, -2.12, 1),
	            v4(0.31, 3.85, -2.34, 1),
	            v4(0.12, 3.82, -2.43, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["98"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["98"].divisions = "|MAEmodelsPrevis|AtomPerp_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v273";
	Curves["99"] = function () {
	    var Curve_v01 = [[v4(0.18, 3.18, -1, 1),
	            v4(0.33, 3.61, -1.13, 1),
	            v4(0.49, 4.72, -1.45, 1),
	            v4(1.08, 6.21, -2.45, 1),
	            v4(1.82, 7.21, -3.11, 1),
	            v4(2.35, 7.01, -3.36, 1),
	            v4(1.95, 5.87, -2.93, 1),
	            v4(1.12, 4.1, -2.07, 1),
	            v4(0.67, 3.34, -1.06, 1),
	            v4(0.51, 3.08, -0.82, 1),
	        ], [v4(0.41, 3.18, -0.11, 1),
	            v4(0.57, 3.61, -0.23, 1),
	            v4(0.76, 4.71, -0.53, 1),
	            v4(1.58, 6.19, -1.38, 1),
	            v4(2.55, 7.18, -1.92, 1),
	            v4(3.09, 6.98, -2.17, 1),
	            v4(2.48, 5.85, -1.85, 1),
	            v4(1.39, 4.09, -1.16, 1),
	            v4(0.9, 3.34, -0.16, 1),
	            v4(0.74, 3.07, 0.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["99"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["99"].divisions = "|MAEmodelsPrevis|AtomPerp_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v274";
	Curves["100"] = function () {
	    var Curve_v01 = [[v4(0.26, 2.86, 0.19, 1),
	            v4(0.3, 3.42, 0.06, 1),
	            v4(0.34, 4.77, -0.48, 1),
	            v4(1.08, 6.95, -1.74, 1),
	            v4(2.53, 8.39, -2.5, 1),
	            v4(3.35, 8.18, -2.86, 1),
	            v4(2.78, 6.53, -2.57, 1),
	            v4(1.53, 4.37, -1.19, 1),
	            v4(0.88, 3.29, -0.31, 1),
	            v4(0.64, 2.92, -0.07, 1),
	        ], [v4(0.12, 2.84, -0.46, 1),
	            v4(0.14, 3.39, -0.63, 1),
	            v4(0.09, 4.69, -1.27, 1),
	            v4(0.71, 6.81, -2.7, 1),
	            v4(2.06, 8.26, -3.59, 1),
	            v4(2.9, 8.07, -3.94, 1),
	            v4(2.42, 6.41, -3.53, 1),
	            v4(1.3, 4.3, -1.96, 1),
	            v4(0.72, 3.26, -0.99, 1),
	            v4(0.5, 2.9, -0.73, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["100"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["100"].divisions = "|MAEmodelsPrevis|AtomPerp_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v275";
	Curves["101"] = function () {
	    var Curve_v01 = [[v4(0.83, 2.92, 0.33, 1),
	            v4(0.87, 3.21, 0.42, 1),
	            v4(0.68, 3.77, 0.78, 1),
	            v4(0.09, 4.12, 1.99, 1),
	            v4(-0.79, 4.08, 2.79, 1),
	            v4(-1.39, 3.52, 2.78, 1),
	            v4(-1.16, 2.84, 2.07, 1),
	            v4(-0.48, 2.61, 0.89, 1),
	            v4(0.13, 2.6, 0.55, 1),
	            v4(0.44, 2.63, 0.48, 1),
	        ], [v4(0.44, 2.94, 0.19, 1),
	            v4(0.44, 3.24, 0.1, 1),
	            v4(0.11, 3.83, 0.01, 1),
	            v4(-0.9, 4.62, 0.56, 1),
	            v4(-2, 4.8, 0.96, 1),
	            v4(-2.54, 4.19, 1.1, 1),
	            v4(-2.05, 3.31, 1, 1),
	            v4(-0.97, 2.67, 0.42, 1),
	            v4(-0.28, 2.62, 0.34, 1),
	            v4(0.03, 2.68, 0.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["101"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["101"].divisions = "|MAEmodelsPrevis|AtomPerp_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v276";
	Curves["102"] = function () {
	    var Curve_v01 = [[v4(1, 2.94, -0.03, 1),
	            v4(1.19, 3.48, 0.28, 1),
	            v4(1.12, 4.61, 0.59, 1),
	            v4(0.46, 6, 1.71, 1),
	            v4(-0.88, 6.21, 3.73, 1),
	            v4(-2.12, 5.13, 3.68, 1),
	            v4(-2.22, 3.53, 1.89, 1),
	            v4(-1.13, 2.67, 0.38, 1),
	            v4(-0.15, 2.5, 0.3, 1),
	            v4(0.32, 2.39, 0.25, 1),
	        ], [v4(0.99, 2.98, 0.12, 1),
	            v4(1.01, 3.61, 0.29, 1),
	            v4(0.78, 4.75, 0.15, 1),
	            v4(-0.35, 6.28, 0.35, 1),
	            v4(-2.46, 6.83, 1.41, 1),
	            v4(-3.52, 5.59, 1.2, 1),
	            v4(-2.77, 3.55, 0.18, 1),
	            v4(-1.09, 2.49, -0.34, 1),
	            v4(-0.18, 2.46, 0.05, 1),
	            v4(0.26, 2.43, 0.25, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["102"].animation = [[727, 1], [930, 0], [2207, 0], [2252, -0.1528552739], [2281, -0.4980758778], [2311, -0.4489353351], [2340, -0.2743187648], [2353, -0.2419646222], [2369, -0.3506542954], [2415, -1], [7191, -1], [7285, -1]];
	Curves["102"].divisions = "|MAEmodelsPrevis|AtomPerp_1000_1_1_124_202_247_800_100_1000_100_10_20|_50_5_v277";
	Curves.numCurves = 103;
	Curves["103"] = function () {
	    var Curve_v01 = [[v4(-2.57, 2.58, -8.26, 1),
	            v4(-2.72, 9.43, -8.26, 1),
	            v4(-2.99, 23.12, -8.26, 1),
	            v4(-3.31, 43.67, -8.26, 1),
	            v4(-3.55, 64.22, -8.26, 1),
	            v4(-3.73, 84.78, -8.26, 1),
	            v4(-3.85, 105.33, -8.26, 1),
	            v4(-3.91, 125.88, -8.26, 1),
	            v4(-3.92, 146.43, -8.26, 1),
	            v4(-3.89, 166.99, -8.26, 1),
	            v4(-3.81, 187.54, -8.26, 1),
	            v4(-3.71, 208.09, -8.26, 1),
	            v4(-3.57, 228.64, -8.26, 1),
	            v4(-3.41, 249.19, -8.26, 1),
	            v4(-3.24, 269.75, -8.26, 1),
	            v4(-3.06, 290.3, -8.26, 1),
	            v4(-2.93, 304, -8.26, 1),
	            v4(-2.86, 310.85, -8.26, 1),
	        ], [v4(-1.16, 2.58, -9.23, 1),
	            v4(-0.99, 9.43, -9.23, 1),
	            v4(-0.66, 23.12, -9.23, 1),
	            v4(-0.22, 43.67, -9.23, 1),
	            v4(0.19, 64.22, -9.23, 1),
	            v4(0.57, 84.77, -9.23, 1),
	            v4(0.91, 105.32, -9.23, 1),
	            v4(1.23, 125.88, -9.23, 1),
	            v4(1.52, 146.43, -9.23, 1),
	            v4(1.79, 166.98, -9.23, 1),
	            v4(2.04, 187.53, -9.23, 1),
	            v4(2.27, 208.08, -9.23, 1),
	            v4(2.49, 228.64, -9.23, 1),
	            v4(2.7, 249.19, -9.23, 1),
	            v4(2.9, 269.74, -9.23, 1),
	            v4(3.09, 290.3, -9.23, 1),
	            v4(3.21, 304, -9.23, 1),
	            v4(3.28, 310.85, -9.23, 1),
	        ], [v4(0.34, 2.58, -8.26, 1),
	            v4(0.51, 9.43, -8.26, 1),
	            v4(0.84, 23.12, -8.26, 1),
	            v4(1.29, 43.67, -8.26, 1),
	            v4(1.7, 64.22, -8.26, 1),
	            v4(2.07, 84.77, -8.26, 1),
	            v4(2.42, 105.32, -8.26, 1),
	            v4(2.73, 125.88, -8.26, 1),
	            v4(3.02, 146.43, -8.26, 1),
	            v4(3.29, 166.98, -8.26, 1),
	            v4(3.54, 187.53, -8.26, 1),
	            v4(3.77, 208.08, -8.26, 1),
	            v4(3.99, 228.64, -8.26, 1),
	            v4(4.2, 249.19, -8.26, 1),
	            v4(4.4, 269.74, -8.26, 1),
	            v4(4.59, 290.3, -8.26, 1),
	            v4(4.72, 304, -8.26, 1),
	            v4(4.78, 310.85, -8.26, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 17;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["103"].animation = [[2393, 1], [2468, -1]];
	Curves["103"].divisions = "|MAEmodelsPrevis|tunnelTower_500_1_3_124_202_247_500_200_1000_500_10_20|_60_5_v1";
	Curves["104"] = function () {
	    var Curve_v01 = [[v4(1.32, 2.58, -1.16, 1),
	            v4(1.6, 9.42, -1.16, 1),
	            v4(2.12, 23.12, -1.16, 1),
	            v4(2.83, 43.66, -1.16, 1),
	            v4(3.46, 64.21, -1.16, 1),
	            v4(4.02, 84.76, -1.16, 1),
	            v4(4.52, 105.31, -1.16, 1),
	            v4(4.97, 125.86, -1.16, 1),
	            v4(5.36, 146.41, -1.16, 1),
	            v4(5.7, 166.96, -1.16, 1),
	            v4(6.01, 187.52, -1.16, 1),
	            v4(6.29, 208.07, -1.16, 1),
	            v4(6.53, 228.63, -1.16, 1),
	            v4(6.76, 249.18, -1.16, 1),
	            v4(6.96, 269.74, -1.16, 1),
	            v4(7.16, 290.29, -1.16, 1),
	            v4(7.29, 304, -1.16, 1),
	            v4(7.35, 310.85, -1.16, 1),
	        ], [v4(0.11, 2.58, -2.13, 1),
	            v4(0.13, 9.43, -2.13, 1),
	            v4(0.18, 23.13, -2.13, 1),
	            v4(0.28, 43.68, -2.13, 1),
	            v4(0.38, 64.23, -2.13, 1),
	            v4(0.5, 84.78, -2.13, 1),
	            v4(0.63, 105.33, -2.13, 1),
	            v4(0.78, 125.89, -2.13, 1),
	            v4(0.93, 146.44, -2.13, 1),
	            v4(1.09, 166.99, -2.13, 1),
	            v4(1.26, 187.54, -2.13, 1),
	            v4(1.43, 208.09, -2.13, 1),
	            v4(1.61, 228.64, -2.13, 1),
	            v4(1.79, 249.2, -2.13, 1),
	            v4(1.98, 269.75, -2.13, 1),
	            v4(2.17, 290.3, -2.13, 1),
	            v4(2.3, 304, -2.13, 1),
	            v4(2.36, 310.85, -2.13, 1),
	        ], [v4(-1, 2.58, -1.16, 1),
	            v4(-0.98, 9.43, -1.16, 1),
	            v4(-0.92, 23.13, -1.16, 1),
	            v4(-0.83, 43.68, -1.16, 1),
	            v4(-0.72, 64.23, -1.16, 1),
	            v4(-0.61, 84.78, -1.16, 1),
	            v4(-0.47, 105.33, -1.16, 1),
	            v4(-0.33, 125.89, -1.16, 1),
	            v4(-0.18, 146.44, -1.16, 1),
	            v4(-0.02, 166.99, -1.16, 1),
	            v4(0.15, 187.54, -1.16, 1),
	            v4(0.32, 208.09, -1.16, 1),
	            v4(0.5, 228.64, -1.16, 1),
	            v4(0.69, 249.2, -1.16, 1),
	            v4(0.87, 269.75, -1.16, 1),
	            v4(1.06, 290.3, -1.16, 1),
	            v4(1.19, 304, -1.16, 1),
	            v4(1.25, 310.85, -1.16, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 17;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["104"].animation = [[2393, 1], [2468, -1]];
	Curves["104"].divisions = "|MAEmodelsPrevis|tunnelTower_500_1_3_124_202_247_500_200_1000_500_10_20|_60_5_v2";
	Curves.numCurves = 105;
	Curves["105"] = function () {
	    var Curve_v01 = [[v4(-0.59, 5.72, -4.13, 1),
	            v4(-0.42, 7.56, -4.62, 1),
	            v4(-0.66, 13.03, -5.96, 1),
	            v4(-9.72, 21.67, -9.2, 1),
	            v4(-23.43, 19.34, -11.74, 1),
	            v4(-30.91, 12.02, -14.33, 1),
	            v4(-42.23, 9.91, -18.17, 1),
	            v4(-42.77, 13.54, -18.1, 1),
	            v4(-43.12, 15.36, -18.07, 1),
	        ], [v4(-0.85, 1.9, -4.13, 1),
	            v4(-3.69, 3.07, -4.62, 1),
	            v4(-7.73, 6.41, -5.96, 1),
	            v4(-13.81, 17.98, -9.2, 1),
	            v4(-23.19, 17.88, -11.74, 1),
	            v4(-30.67, 10.57, -14.33, 1),
	            v4(-41.98, 8.45, -18.17, 1),
	            v4(-42.9, 12.09, -18.1, 1),
	            v4(-43.37, 13.91, -18.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["105"].animation = [[2388, 1], [2442, -1]];
	Curves["105"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v5";
	Curves["106"] = function () {
	    var Curve_v01 = [[v4(0.85, 2.47, 0.02, 1),
	            v4(2.82, 2.62, 0.55, 1),
	            v4(6.13, 6.14, 2.23, 1),
	            v4(16.7, 12.13, 6.99, 1),
	            v4(19.22, 18.08, 8.42, 1),
	            v4(20.57, 22.45, 8.06, 1),
	            v4(18.88, 29.47, 4.84, 1),
	            v4(14.72, 29.05, 3.56, 1),
	            v4(14.31, 27.9, 3.52, 1),
	            v4(14.1, 27.32, 3.52, 1),
	        ], [v4(0.21, 3.12, 1.06, 1),
	            v4(1.77, 3.98, 1.38, 1),
	            v4(4.96, 7.16, 2.17, 1),
	            v4(12.17, 16.1, 4.53, 1),
	            v4(17.63, 19.71, 8.09, 1),
	            v4(19.04, 23.03, 7.57, 1),
	            v4(18.31, 28.47, 5.18, 1),
	            v4(14.75, 28.56, 3.76, 1),
	            v4(14.34, 27.42, 3.64, 1),
	            v4(14.14, 26.84, 3.64, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["106"].animation = [[2388, 1], [2442, -1]];
	Curves["106"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v6";
	Curves["107"] = function () {
	    var Curve_v01 = [[v4(-1.04, 3.76, 0.25, 1),
	            v4(-3.66, 4.45, 4.16, 1),
	            v4(-7.69, 11.22, 15.97, 1),
	            v4(-12.88, 18.54, 19.21, 1),
	            v4(-14.75, 23.93, 20.44, 1),
	            v4(-11.36, 32.26, 18.12, 1),
	            v4(-2.98, 34.52, 11.66, 1),
	            v4(0.31, 42.56, -0.33, 1),
	            v4(-1.24, 47.94, -4.31, 1),
	            v4(0.7, 51.15, -5.19, 1),
	            v4(2.21, 52.86, -5.64, 1),
	        ], [v4(-1.27, 2.38, 0.2, 1),
	            v4(-4.88, 2.8, 4.07, 1),
	            v4(-10.61, 9.06, 15.79, 1),
	            v4(-15.54, 16.96, 19.9, 1),
	            v4(-15.79, 23.46, 21.78, 1),
	            v4(-11.94, 32.28, 19.52, 1),
	            v4(-3.5, 34.6, 13.07, 1),
	            v4(-0.2, 42.64, 1.09, 1),
	            v4(-1.76, 48.03, -2.9, 1),
	            v4(0.19, 51.24, -3.78, 1),
	            v4(2.28, 52.84, -4.23, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["107"].animation = [[2388, 1], [2442, -1]];
	Curves["107"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v7";
	Curves["108"] = function () {
	    var Curve_v01 = [[v4(-2.39, 2.2, -4.67, 1),
	            v4(-1.92, 0.94, -3.85, 1),
	            v4(-1.12, -1.51, -1.59, 1),
	            v4(-0.09, -4.47, 5.74, 1),
	            v4(-0.06, -4.98, 18.87, 1),
	            v4(1.65, -2.09, 35.64, 1),
	            v4(-4.3, 4.7, 39.29, 1),
	            v4(-9.9, 12.94, 32.53, 1),
	            v4(-10, 20.75, 2.33, 1),
	            v4(-7.67, 20.97, -7.27, 1),
	            v4(0.69, 18.17, -6.89, 1),
	            v4(4.44, 15.18, -5.68, 1),
	            v4(5.7, 14.21, -5.27, 1),
	        ], [v4(-0.82, 3.64, -4.45, 1),
	            v4(-0.28, 2.44, -3.63, 1),
	            v4(0.9, 0.22, -1.28, 1),
	            v4(2.73, -2.46, 6.19, 1),
	            v4(3.12, -3.12, 19.28, 1),
	            v4(3.88, -0.82, 35.65, 1),
	            v4(-3.25, 5.91, 39.33, 1),
	            v4(-6.18, 15.84, 34.25, 1),
	            v4(-7.74, 23.98, 6.62, 1),
	            v4(-7.34, 23.79, -3.81, 1),
	            v4(-0.44, 19.72, -4.26, 1),
	            v4(2.77, 16.19, -3.35, 1),
	            v4(3.92, 15.05, -3.04, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["108"].animation = [[2388, 1], [2442, -1]];
	Curves["108"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v8";
	Curves["109"] = function () {
	    var Curve_v01 = [[v4(0.91, 2.18, -1.63, 1),
	            v4(2.38, 4.33, -1.4, 1),
	            v4(5.03, 9.62, -2.04, 1),
	            v4(10.37, 13.38, -5.47, 1),
	            v4(17, 13.48, -7.81, 1),
	            v4(23.28, 9.45, -7.7, 1),
	            v4(36.78, 10.74, -11.36, 1),
	            v4(37.44, 17.35, -11.1, 1),
	            v4(35.94, 18.49, -10.13, 1),
	            v4(35.19, 19.06, -9.64, 1),
	        ], [v4(0.67, 2.53, -1.63, 1),
	            v4(1.32, 6.44, -1.4, 1),
	            v4(2.36, 14.11, -2.04, 1),
	            v4(7.71, 17.9, -5.47, 1),
	            v4(16.46, 18.04, -7.81, 1),
	            v4(23.11, 10.47, -7.7, 1),
	            v4(36.59, 11.54, -11.36, 1),
	            v4(37.25, 19.21, -11.79, 1),
	            v4(35.75, 20.36, -10.82, 1),
	            v4(35, 20.93, -10.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["109"].animation = [[2388, 1], [2442, -1]];
	Curves["109"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v9";
	Curves["110"] = function () {
	    var Curve_v01 = [[v4(0.28, 3.5, -0.24, 1),
	            v4(-0.24, 3.88, 1.22, 1),
	            v4(-0.32, 5.02, 4.03, 1),
	            v4(0.36, 7.76, 6.24, 1),
	            v4(0.97, 12.06, 7.48, 1),
	            v4(1.91, 14.89, 6.15, 1),
	            v4(2.48, 16.89, 4.75, 1),
	            v4(2.98, 18.76, 3.26, 1),
	            v4(2.99, 24.96, 1.59, 1),
	            v4(1.98, 31.39, 1.48, 1),
	            v4(1.68, 44.57, -1.16, 1),
	            v4(2.47, 48.2, -2.96, 1),
	            v4(2.91, 49.83, -3.86, 1),
	        ], [v4(-1.25, 3.86, -1.51, 1),
	            v4(-2.42, 4.25, -1.02, 1),
	            v4(-4.15, 5.43, 1.07, 1),
	            v4(-5.29, 8.14, 3.17, 1),
	            v4(-5.65, 12.42, 4.54, 1),
	            v4(-4.26, 15.26, 4.07, 1),
	            v4(-3.06, 17.25, 3.12, 1),
	            v4(-1.86, 19.12, 2.5, 1),
	            v4(-0.78, 25.36, 1.42, 1),
	            v4(-1.03, 31.76, 0.44, 1),
	            v4(0.44, 45.02, -1.46, 1),
	            v4(1.76, 48.65, -1.92, 1),
	            v4(2.4, 50.3, -2.09, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["110"].animation = [[2388, 1], [2442, -1]];
	Curves["110"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v10";
	Curves["111"] = function () {
	    var Curve_v01 = [[v4(1.02, 4.6, 1.25, 1),
	            v4(1.54, 5.4, 2.72, 1),
	            v4(3.1, 6.71, 4.56, 1),
	            v4(4.8, 8.54, 5.22, 1),
	            v4(5.89, 12.06, 5.36, 1),
	            v4(5.72, 14.89, 3.54, 1),
	            v4(5.27, 16.89, 2.05, 1),
	            v4(4.93, 19.32, 0.6, 1),
	            v4(3.94, 24.86, -0.45, 1),
	            v4(2.72, 31.32, 0.53, 1),
	            v4(2.13, 47.55, -2.3, 1),
	            v4(1.79, 51.42, -4.24, 1),
	            v4(1.69, 53.39, -5.26, 1),
	        ], [v4(-1.47, 3.86, -0.38, 1),
	            v4(-2.02, 4.25, 1.09, 1),
	            v4(-2.11, 5.43, 4.23, 1),
	            v4(-1.78, 8.14, 6.81, 1),
	            v4(-1.24, 12.42, 8.14, 1),
	            v4(-0.1, 15.26, 6.71, 1),
	            v4(0.42, 17.25, 4.99, 1),
	            v4(0.93, 19.12, 3.38, 1),
	            v4(0.68, 25.39, 1.22, 1),
	            v4(0.18, 31.82, 0.67, 1),
	            v4(0.33, 48.08, -2.47, 1),
	            v4(1.16, 51.87, -3.98, 1),
	            v4(1.63, 53.81, -4.65, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["111"].animation = [[2388, 1], [2442, -1]];
	Curves["111"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v11";
	Curves["112"] = function () {
	    var Curve_v01 = [[v4(0.36, 4.6, -1.97, 1),
	            v4(0.33, 5.38, -1.34, 1),
	            v4(1.7, 6.56, 0.14, 1),
	            v4(4.48, 8.18, 1.48, 1),
	            v4(6.75, 11.54, 2.01, 1),
	            v4(6.77, 14.5, 0.45, 1),
	            v4(5.99, 16.7, -1.15, 1),
	            v4(5.15, 19.29, -1.89, 1),
	            v4(3.52, 24.84, -1.21, 1),
	            v4(2.08, 31.27, -1.85, 1),
	            v4(2.46, 51.27, -4.75, 1),
	            v4(3.27, 54.69, -5.84, 1),
	            v4(3.8, 56.54, -6.36, 1),
	        ], [v4(-0.51, 3.86, -1.09, 1),
	            v4(-0.88, 4.25, -0.17, 1),
	            v4(-1.39, 5.46, 2.18, 1),
	            v4(-3.25, 8.34, 3.18, 1),
	            v4(-4.86, 12.84, 3.06, 1),
	            v4(-3.17, 15.77, 1.95, 1),
	            v4(-1.28, 17.7, 0.51, 1),
	            v4(0.4, 19.42, -0.37, 1),
	            v4(0.92, 25.37, -0.3, 1),
	            v4(0.48, 31.79, -1.16, 1),
	            v4(1.61, 52.06, -4.53, 1),
	            v4(2.73, 55.34, -5.34, 1),
	            v4(3.38, 57.12, -5.66, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["112"].animation = [[2388, 1], [2442, -1]];
	Curves["112"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v12";
	Curves["113"] = function () {
	    var Curve_v01 = [[v4(0.01, 2, -4.1, 1),
	            v4(0.64, 2.36, -4.78, 1),
	            v4(1.65, 3.48, -6.78, 1),
	            v4(2.7, 6.19, -8.45, 1),
	            v4(3.42, 10.61, -8.82, 1),
	            v4(3.25, 13.63, -8.42, 1),
	            v4(4.47, 16.77, -9.73, 1),
	            v4(5.92, 19.65, -9.44, 1),
	            v4(6.23, 24.7, -7.69, 1),
	            v4(4.7, 31.63, -8.2, 1),
	            v4(2.66, 52.06, -5.58, 1),
	            v4(2.55, 55.34, -4.18, 1),
	            v4(2.19, 57.12, -3.79, 1),
	        ], [v4(-4.03, 3.04, -2.87, 1),
	            v4(-4.63, 3.83, -3.47, 1),
	            v4(-5.86, 5.14, -3.81, 1),
	            v4(-6.86, 7.03, -3.22, 1),
	            v4(-6.94, 10.71, -2.38, 1),
	            v4(-5.53, 13.74, -1.22, 1),
	            v4(-4.13, 15.93, -2.76, 1),
	            v4(-1.03, 19.41, -6.12, 1),
	            v4(0.54, 24.46, -6.25, 1),
	            v4(0.37, 31.21, -7.55, 1),
	            v4(0.31, 51.27, -5.68, 1),
	            v4(0.61, 54.69, -5.94, 1),
	            v4(0.69, 56.54, -5.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["113"].animation = [[2388, 1], [2442, -1]];
	Curves["113"].divisions = "|MAEmodelsPrevis|ExplosionAfastNarrow_500_1_1_124_202_247_800_100_100_100_10_20|_41_4_v13";
	Curves.numCurves = 114;
	Curves["114"] = function () {
	    var Curve_v01 = [[v4(0.8, 3.38, 1.2, 1),
	            v4(0.38, 3.63, 1.83, 1),
	            v4(0.13, 4.46, 3.05, 1),
	            v4(1.14, 6.59, 4.43, 1),
	            v4(2.78, 9.17, 5.08, 1),
	            v4(3.74, 11.47, 4.86, 1),
	            v4(4.58, 13.17, 4.09, 1),
	            v4(5.31, 14.5, 3.14, 1),
	            v4(5.33, 16.06, 2.34, 1),
	            v4(4.26, 18.05, 1.66, 1),
	            v4(3.13, 20.17, 0.69, 1),
	            v4(4.08, 22.6, -1.15, 1),
	            v4(8.6, 26.04, -4.09, 1),
	            v4(16.87, 30.96, -7.9, 1),
	            v4(21.64, 35.52, -10.99, 1),
	            v4(20.91, 39.9, -14.06, 1),
	            v4(18.1, 43.15, -16.01, 1),
	            v4(16.07, 44.76, -16.88, 1),
	        ], [v4(-4.11, 3.86, 0.89, 1),
	            v4(-5.51, 4.14, 1.23, 1),
	            v4(-8.17, 5.21, 2.33, 1),
	            v4(-12.62, 7.88, 3.63, 1),
	            v4(-15.52, 11.1, 3.95, 1),
	            v4(-16.11, 14.27, 3.7, 1),
	            v4(-14.97, 17.07, 3.08, 1),
	            v4(-12.99, 19.47, 2.13, 1),
	            v4(-10.97, 21.45, 0.89, 1),
	            v4(-9.19, 23.08, -0.49, 1),
	            v4(-7.3, 24.72, -1.9, 1),
	            v4(-4.65, 26.86, -3.49, 1),
	            v4(-0.22, 29.76, -5.63, 1),
	            v4(7.54, 33.31, -8.75, 1),
	            v4(16.98, 38.06, -11.48, 1),
	            v4(18.44, 41.7, -13.34, 1),
	            v4(16.57, 44.69, -13.99, 1),
	            v4(14.76, 46.39, -14.16, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 17;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["114"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2589, 0.3576251504], [2643, 0.4615941673], [2747, 0.1398264592], [2845, 0.4614093976], [3034, 0.1224669942], [3205, 0.3966634489], [3354, -1]];
	Curves["114"].divisions = "|MAEmodelsPrevis|ExplosionAfirst_500_1_2_124_202_247_100_100_100_100_100_20|_41_4_v1";
	Curves["115"] = function () {
	    var Curve_v01 = [[v4(1.89, 4.42, 2.02, 1),
	            v4(2.43, 4.91, 2.56, 1),
	            v4(4.1, 5.93, 3.44, 1),
	            v4(7.14, 8.03, 4.08, 1),
	            v4(9.72, 10.65, 3.95, 1),
	            v4(11.12, 13.14, 3.16, 1),
	            v4(10.73, 14.48, 2.15, 1),
	            v4(8.5, 15.72, 1.34, 1),
	            v4(5.49, 17.44, 0.62, 1),
	            v4(2.86, 19.47, -0.28, 1),
	            v4(2.03, 21.74, -1.72, 1),
	            v4(4.45, 24.85, -3.97, 1),
	            v4(10.43, 29.18, -6.94, 1),
	            v4(18.83, 34.23, -10.26, 1),
	            v4(20.48, 37.68, -13.35, 1),
	            v4(16.72, 41.01, -16.5, 1),
	            v4(12.76, 44.26, -18.31, 1),
	            v4(11, 46.27, -19.02, 1),
	        ], [v4(-2.89, 3.86, 1.16, 1),
	            v4(-3.89, 4.15, 1.85, 1),
	            v4(-6.31, 5.15, 3.21, 1),
	            v4(-10.56, 7.71, 4.71, 1),
	            v4(-12.49, 10.81, 5.35, 1),
	            v4(-12.42, 13.71, 5.03, 1),
	            v4(-11.33, 15.9, 4.05, 1),
	            v4(-9.75, 17.5, 2.9, 1),
	            v4(-8.67, 19.18, 1.85, 1),
	            v4(-8.99, 21.73, 0.7, 1),
	            v4(-9.2, 25.39, -1.09, 1),
	            v4(-5.63, 29.36, -3.84, 1),
	            v4(3.2, 32.08, -7.52, 1),
	            v4(13.83, 36.73, -11.26, 1),
	            v4(14.12, 40.56, -14.18, 1),
	            v4(10.15, 44.84, -16.49, 1),
	            v4(7.24, 48.58, -17.61, 1),
	            v4(6.03, 50.65, -18.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 17;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["115"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2589, 0.3576251504], [2643, 0.4615941673], [2747, 0.1398264592], [2845, 0.4614093976], [3034, 0.1224669942], [3205, 0.3966634489], [3354, -1]];
	Curves["115"].divisions = "|MAEmodelsPrevis|ExplosionAfirst_500_1_2_124_202_247_100_100_100_100_100_20|_41_4_v2";
	Curves["116"] = function () {
	    var Curve_v01 = [[v4(1.08, 4.35, 0.43, 1),
	            v4(1.11, 5.38, 1.29, 1),
	            v4(2.81, 6.68, 2.74, 1),
	            v4(6.96, 8.22, 3.87, 1),
	            v4(10.66, 10.34, 3.75, 1),
	            v4(13.13, 13.02, 2.71, 1),
	            v4(13.94, 15.78, 1.51, 1),
	            v4(12.44, 18.1, 0.57, 1),
	            v4(8.85, 19.79, -0.38, 1),
	            v4(5.8, 21.47, -1.92, 1),
	            v4(6.79, 24.06, -4.39, 1),
	            v4(12.39, 27.82, -7.69, 1),
	            v4(19.61, 32.26, -11.37, 1),
	            v4(20.75, 36.11, -14.48, 1),
	            v4(19.86, 41.02, -17.24, 1),
	            v4(14.66, 46.21, -19.18, 1),
	            v4(9.99, 50.55, -20.22, 1),
	            v4(8.07, 52.72, -20.71, 1),
	        ], [v4(-0.83, 3.86, 1.3, 1),
	            v4(-1.42, 4.32, 2.38, 1),
	            v4(-3.45, 5.81, 4.2, 1),
	            v4(-7.21, 8.92, 5.45, 1),
	            v4(-9.23, 12.04, 5.22, 1),
	            v4(-9.33, 14.66, 4.05, 1),
	            v4(-8.23, 16.78, 2.67, 1),
	            v4(-7.39, 18.85, 1.46, 1),
	            v4(-7.59, 21.37, 0.28, 1),
	            v4(-8.49, 24.57, -1.38, 1),
	            v4(-6.03, 28.05, -4, 1),
	            v4(3.35, 30.82, -7.85, 1),
	            v4(16.85, 33.16, -12.41, 1),
	            v4(21.25, 38.1, -15.39, 1),
	            v4(18.6, 42.71, -17.25, 1),
	            v4(10.29, 48.85, -18.56, 1),
	            v4(5.1, 54, -19.35, 1),
	            v4(3.33, 56.02, -19.63, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 17;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["116"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2589, 0.3576251504], [2643, 0.4615941673], [2747, 0.1398264592], [2845, 0.4614093976], [3034, 0.1224669942], [3205, 0.3966634489], [3354, -1]];
	Curves["116"].divisions = "|MAEmodelsPrevis|ExplosionAfirst_500_1_2_124_202_247_100_100_100_100_100_20|_41_4_v3";
	Curves["117"] = function () {
	    var Curve_v01 = [[v4(0.5, 2, -1.7, 1),
	            v4(1.77, 2.43, -2.52, 1),
	            v4(4.26, 3.83, -4.32, 1),
	            v4(8.58, 7.14, -5.98, 1),
	            v4(12.32, 10.53, -6.63, 1),
	            v4(13.59, 12.89, -6.79, 1),
	            v4(12.03, 14.61, -6.79, 1),
	            v4(8.92, 17.02, -6.89, 1),
	            v4(6.37, 20.42, -7.52, 1),
	            v4(7.09, 23.96, -9.16, 1),
	            v4(12.61, 27.38, -11.96, 1),
	            v4(20.29, 31.14, -15.29, 1),
	            v4(24.75, 35.71, -18.13, 1),
	            v4(21.55, 41.41, -19.55, 1),
	            v4(15.07, 46.24, -19.14, 1),
	            v4(7.11, 52.04, -17.79, 1),
	            v4(2.19, 55.59, -17.02, 1),
	            v4(-0.15, 56.97, -16.76, 1),
	        ], [v4(-5.49, 3.86, -0.47, 1),
	            v4(-6.94, 4.39, -1.09, 1),
	            v4(-9.92, 5.87, -1.55, 1),
	            v4(-15.7, 8.97, -1.18, 1),
	            v4(-19.65, 12.5, -0.84, 1),
	            v4(-19.6, 15.96, -1.12, 1),
	            v4(-17.21, 18.97, -2.08, 1),
	            v4(-14.48, 21.49, -3.51, 1),
	            v4(-11.56, 23.72, -5.2, 1),
	            v4(-7.74, 25.99, -7.12, 1),
	            v4(-3.66, 28.71, -9.43, 1),
	            v4(3.49, 32.35, -12.31, 1),
	            v4(12.78, 33.88, -15.4, 1),
	            v4(18.33, 37.04, -18.11, 1),
	            v4(17.64, 42.04, -19.85, 1),
	            v4(10.81, 48.48, -20.23, 1),
	            v4(5, 52.76, -19.42, 1),
	            v4(2.6, 54.44, -18.72, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 17;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["117"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2589, 0.3576251504], [2643, 0.4615941673], [2747, 0.1398264592], [2845, 0.4614093976], [3034, 0.1224669942], [3205, 0.3966634489], [3354, -1]];
	Curves["117"].divisions = "|MAEmodelsPrevis|ExplosionAfirst_500_1_2_124_202_247_100_100_100_100_100_20|_41_4_v69";
	Curves.numCurves = 118;
	Curves["118"] = function () {
	    var Curve_v01 = [[v4(11.11, 4.51, 8.64, 1),
	            v4(11.23, 5.02, 8.64, 1),
	            v4(14.54, 7.93, 8.72, 1),
	            v4(21.63, 15.64, 9.19, 1),
	            v4(15.9, 30.08, 12.1, 1),
	            v4(17.24, 37.45, 12.1, 1),
	            v4(26.33, 42.16, 9.96, 1),
	            v4(37.71, 42.95, 6.63, 1),
	            v4(46.84, 40.29, 4.75, 1),
	            v4(57.98, 43.06, 4.05, 1),
	        ], [v4(5.06, 2.41, 8.64, 1),
	            v4(4.87, 2.93, 8.64, 1),
	            v4(2.41, 6.05, 8.64, 1),
	            v4(4.13, 17.8, 8.29, 1),
	            v4(6.33, 31.83, 12.1, 1),
	            v4(10.97, 41.33, 12.1, 1),
	            v4(22.06, 45.94, 9.74, 1),
	            v4(35.13, 44, 6.31, 1),
	            v4(44.6, 41.24, 4.4, 1),
	            v4(55.93, 43.99, 4.05, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["118"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["118"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v2";
	Curves["119"] = function () {
	    var Curve_v01 = [[v4(-6.86, 17.11, 4.05, 1),
	            v4(-5.05, 20.9, 4.05, 1),
	            v4(-3.23, 28.46, 4.05, 1),
	            v4(-5.97, 34.9, 4.05, 1),
	            v4(-12.34, 43.46, 4.05, 1),
	            v4(-19.97, 54.55, 4.05, 1),
	            v4(-34.48, 61.87, 4.05, 1),
	            v4(-46.33, 65.12, 9.53, 1),
	            v4(-53.01, 65.76, 15.74, 1),
	            v4(-60.21, 65.32, 33.38, 1),
	            v4(-54.47, 63.31, 54.92, 1),
	            v4(-40.23, 57.2, 75.37, 1),
	            v4(-22.49, 57.54, 80.61, 1),
	            v4(-9.53, 60.25, 75.24, 1),
	            v4(4.91, 66.5, 61.67, 1),
	            v4(17.53, 74, 36.25, 1),
	            v4(18.87, 79.57, 21.66, 1),
	            v4(14.18, 83.25, 10.87, 1),
	            v4(10.65, 84.88, 0.21, 1),
	            v4(-0.06, 82.29, -9.49, 1),
	            v4(-7.22, 76.8, -12.35, 1),
	            v4(-9, 68.84, -12.35, 1),
	            v4(-3.96, 60.49, -12.35, 1),
	            v4(9.99, 55.22, -6.79, 1),
	            v4(19.97, 54.54, -0.67, 1),
	            v4(30.77, 54.74, 3.66, 1),
	            v4(36.11, 51.72, 4.05, 1),
	            v4(37.25, 48.62, 4.05, 1),
	            v4(37.81, 47.08, 4.05, 1),
	        ], [v4(-7.23, 7.77, 2.93, 1),
	            v4(-5.09, 12.31, 2.93, 1),
	            v4(-2.13, 23.83, 2.93, 1),
	            v4(-5.12, 31.85, 2.94, 1),
	            v4(-17.26, 40.9, 3.14, 1),
	            v4(-33.07, 50.18, 6.07, 1),
	            v4(-41.34, 53.5, 10.62, 1),
	            v4(-45.36, 54.89, 17.65, 1),
	            v4(-47.82, 55.46, 28.45, 1),
	            v4(-46.06, 54.21, 41.02, 1),
	            v4(-43.6, 51.97, 54.16, 1),
	            v4(-30.54, 49.58, 66.49, 1),
	            v4(-14.21, 49.59, 71.95, 1),
	            v4(3.7, 58.25, 55.63, 1),
	            v4(10.3, 65.57, 40.7, 1),
	            v4(19.6, 71.34, 21.01, 1),
	            v4(16.21, 75.92, 13.52, 1),
	            v4(12.24, 78.25, 5.57, 1),
	            v4(8.14, 78.27, -2.68, 1),
	            v4(3.02, 74.26, -9.07, 1),
	            v4(3.14, 70.8, -10.23, 1),
	            v4(5.09, 65.41, -11.82, 1),
	            v4(11.58, 60.35, -8.78, 1),
	            v4(18.3, 59.54, -6.52, 1),
	            v4(27.12, 58.5, -2.18, 1),
	            v4(32.42, 56.6, 0.19, 1),
	            v4(36.89, 54.87, 2.22, 1),
	            v4(40.34, 51.95, 2.22, 1),
	            v4(41.2, 49.67, 2.22, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 28;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["119"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["119"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_100_4_v3";
	Curves["120"] = function () {
	    var Curve_v01 = [[v4(-1.05, 2.31, -8.72, 1),
	            v4(-1.81, 4.24, -8.67, 1),
	            v4(-3.91, 6.2, -7.37, 1),
	            v4(-7.19, 8.29, -4.2, 1),
	            v4(-13.15, 9.99, 1.17, 1),
	            v4(-18.26, 14.96, 7.49, 1),
	            v4(-17.93, 24.06, 15.62, 1),
	            v4(-19.08, 27.92, 25.84, 1),
	            v4(-19.08, 28.72, 37.63, 1),
	            v4(-17.29, 29.53, 48.34, 1),
	            v4(-13.94, 30.57, 56.84, 1),
	            v4(-7.18, 32.64, 64.12, 1),
	            v4(-1.04, 34.98, 68.88, 1),
	            v4(7.43, 38.43, 70.69, 1),
	            v4(11.14, 44.32, 64.28, 1),
	            v4(10.07, 48.34, 54.24, 1),
	            v4(9.1, 50.54, 47.74, 1),
	            v4(4.8, 51.56, 43.03, 1),
	            v4(-0.26, 52.6, 41.46, 1),
	            v4(-6.21, 53.61, 41.91, 1),
	            v4(-12.39, 56.91, 40.51, 1),
	            v4(-17.95, 60.88, 35.24, 1),
	            v4(-19.99, 64.69, 28.24, 1),
	            v4(-18.97, 68.18, 22.93, 1),
	            v4(-17.39, 71.49, 18.93, 1),
	            v4(-12.84, 74.68, 11.87, 1),
	            v4(-4.93, 78.35, 4.67, 1),
	            v4(-3.33, 83.52, 2, 1),
	            v4(-9.02, 89.04, -0.5, 1),
	            v4(-13.3, 94.17, -4.16, 1),
	            v4(-15.84, 99.16, -3.91, 1),
	            v4(-20.79, 103.66, -1.71, 1),
	            v4(-25.09, 107.78, 0.49, 1),
	            v4(-44.85, 109.23, -0.06, 1),
	            v4(-38.74, 99.66, -3.7, 1),
	            v4(-28.33, 107.8, -14.21, 1),
	            v4(-38.77, 112.03, -16.69, 1),
	            v4(-45.71, 111.22, -11.59, 1),
	            v4(-51.04, 114.94, -12.1, 1),
	            v4(-44.28, 118.55, -8.52, 1),
	            v4(-50.2, 123.89, -16.31, 1),
	            v4(-51.84, 124.34, -9.1, 1),
	            v4(-52.37, 124.49, -6.58, 1),
	        ], [v4(-5.9, 1.34, -8.72, 1),
	            v4(-6.72, 3.27, -8.67, 1),
	            v4(-8.96, 6.2, -7.37, 1),
	            v4(-12.33, 8.29, -4.2, 1),
	            v4(-18.28, 9.99, 1.17, 1),
	            v4(-22.65, 14.5, 7.49, 1),
	            v4(-21.75, 21.62, 15.62, 1),
	            v4(-20.3, 25.26, 25.84, 1),
	            v4(-20.23, 26.06, 37.63, 1),
	            v4(-18.43, 26.87, 48.34, 1),
	            v4(-15.94, 27.58, 56.84, 1),
	            v4(-10.99, 29.06, 64.12, 1),
	            v4(-5.33, 31.02, 68.88, 1),
	            v4(5.19, 33.06, 70.69, 1),
	            v4(9.91, 38, 64.28, 1),
	            v4(8.84, 42.44, 54.09, 1),
	            v4(7.87, 46.43, 46.77, 1),
	            v4(2.66, 48.54, 41.36, 1),
	            v4(-4.06, 51.13, 39.62, 1),
	            v4(-11.76, 53.5, 40.07, 1),
	            v4(-18.85, 56.91, 38.67, 1),
	            v4(-25.44, 60.88, 33.89, 1),
	            v4(-28.45, 64.69, 27.77, 1),
	            v4(-28.2, 68.18, 22.91, 1),
	            v4(-27.23, 71.49, 18.93, 1),
	            v4(-23.32, 74.68, 11.87, 1),
	            v4(-15.72, 78.35, 4.67, 1),
	            v4(-14.12, 83.52, 2, 1),
	            v4(-19.57, 89.04, -0.5, 1),
	            v4(-23.25, 94.17, -4.16, 1),
	            v4(-25.06, 99.16, -3.91, 1),
	            v4(-29.07, 103.66, -1.71, 1),
	            v4(-32.46, 107.78, 0.49, 1),
	            v4(-43.83, 108.12, -0.19, 1),
	            v4(-40.25, 101.31, -4.5, 1),
	            v4(-33.18, 107.8, -14.21, 1),
	            v4(-43.62, 110.13, -16.69, 1),
	            v4(-48.73, 110.21, -11.59, 1),
	            v4(-55.27, 114.96, -9.25, 1),
	            v4(-47.7, 118.78, -8.43, 1),
	            v4(-51.72, 123.7, -13.65, 1),
	            v4(-54.76, 124.04, -6.7, 1),
	            v4(-55.29, 124.18, -4.18, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["120"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["120"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_100_4_v4";
	Curves["121"] = function () {
	    var Curve_v01 = [[v4(-0.36, 3.42, -12.81, 1),
	            v4(-0.2, 4.85, -12.81, 1),
	            v4(0.95, 6.14, -9.42, 1),
	            v4(3.01, 9.84, -6.51, 1),
	            v4(7.15, 18.94, -6.42, 1),
	            v4(8.49, 31.88, -9.88, 1),
	            v4(4.44, 40.3, -16.28, 1),
	            v4(-4.31, 47.39, -20.86, 1),
	            v4(-19.51, 53.32, -22.87, 1),
	            v4(-32.05, 52.37, -20.31, 1),
	            v4(-42.4, 49.68, -13.17, 1),
	            v4(-47.91, 40.49, -8.2, 1),
	            v4(-49.21, 32.13, 4.05, 1),
	            v4(-32.5, 28.41, 17.21, 1),
	            v4(-19.29, 30.03, 37.64, 1),
	            v4(-6.51, 33.11, 47.73, 1),
	            v4(6.64, 37.39, 42.16, 1),
	            v4(13.45, 39.33, 33.82, 1),
	            v4(19.19, 39.06, 28.27, 1),
	            v4(22.05, 37.44, 22.97, 1),
	            v4(23.42, 35.1, 19.04, 1),
	            v4(22.81, 32.91, 16.67, 1),
	            v4(22.32, 31.73, 16.07, 1),
	        ], [v4(-12.44, 3.69, -12.81, 1),
	            v4(-14.77, 7.82, -12.81, 1),
	            v4(-15.23, 11.8, -9.42, 1),
	            v4(-14.22, 16.81, -6.51, 1),
	            v4(-6.49, 26.46, -6.42, 1),
	            v4(-6.02, 34.1, -9.88, 1),
	            v4(-10.89, 39.4, -16.28, 1),
	            v4(-13.55, 42.08, -20.86, 1),
	            v4(-19.66, 43.97, -22.87, 1),
	            v4(-28.63, 44.7, -20.31, 1),
	            v4(-34.23, 43.08, -13.17, 1),
	            v4(-39.65, 39.23, -8.2, 1),
	            v4(-37.86, 35.06, 4.05, 1),
	            v4(-28.23, 32.04, 17.21, 1),
	            v4(-15.02, 33.66, 37.64, 1),
	            v4(-2.24, 36.75, 47.73, 1),
	            v4(10.06, 40.57, 42.16, 1),
	            v4(18.32, 40.9, 33.25, 1),
	            v4(22.36, 39.48, 28.7, 1),
	            v4(25.21, 37.86, 23.34, 1),
	            v4(26.14, 35.52, 19.36, 1),
	            v4(25.54, 33.33, 16.78, 1),
	            v4(25.05, 32.15, 16.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["121"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["121"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_81_4_v5";
	Curves["122"] = function () {
	    var Curve_v01 = [[v4(7.5, 3.43, 2.4, 1),
	            v4(7.77, 8.61, 1.88, 1),
	            v4(7.85, 22.72, 1.06, 1),
	            v4(4.19, 34.52, 0.78, 1),
	            v4(1.8, 40.66, -1.54, 1),
	            v4(1.07, 44.86, -4.18, 1),
	            v4(1.41, 49.57, -3.76, 1),
	            v4(6.07, 53.27, 3.43, 1),
	            v4(11.55, 52.77, 17.8, 1),
	            v4(10.02, 48.17, 34.41, 1),
	            v4(3.48, 45.97, 37.57, 1),
	            v4(-16.54, 42.9, 39.69, 1),
	            v4(-60.34, 48.06, 5.38, 1),
	            v4(-94.9, 58.27, -30.43, 1),
	            v4(-105.54, 68.61, -64.22, 1),
	            v4(-97.78, 74.99, -78.91, 1),
	            v4(-92.07, 84.54, -87.88, 1),
	            v4(-95.69, 91.96, -79.29, 1),
	            v4(-102.86, 94.13, -64.26, 1),
	            v4(-108.39, 84.45, -53.6, 1),
	            v4(-97.03, 77.26, -58.69, 1),
	            v4(-84.34, 78.12, -63.8, 1),
	            v4(-80.54, 84.11, -68.39, 1),
	            v4(-74.37, 86.94, -67.7, 1),
	            v4(-67.25, 82.82, -64.42, 1),
	            v4(-66.27, 80.08, -62.8, 1),
	            v4(-68.81, 79.31, -61.68, 1),
	            v4(-69.43, 79.94, -61.52, 1),
	            v4(-69.74, 80.26, -61.44, 1),
	        ], [v4(-2.38, 2.45, 2.4, 1),
	            v4(-4.02, 6.59, 1.88, 1),
	            v4(-7.3, 20.94, 1.06, 1),
	            v4(-8.69, 33.9, 0.78, 1),
	            v4(-8.61, 40.56, -1.54, 1),
	            v4(-9.04, 51.6, -4.18, 1),
	            v4(-2.85, 56.61, -3.76, 1),
	            v4(5.3, 60.33, 3.43, 1),
	            v4(15.48, 58.67, 18.32, 1),
	            v4(13.13, 48.56, 35.55, 1),
	            v4(3.71, 44.47, 39.4, 1),
	            v4(-16.79, 39.7, 41.96, 1),
	            v4(-65.91, 45.12, 7.44, 1),
	            v4(-103.75, 62.06, -30.96, 1),
	            v4(-108.93, 75.16, -62.97, 1),
	            v4(-102.75, 78.64, -73.2, 1),
	            v4(-97.26, 84.17, -80.23, 1),
	            v4(-97.34, 88.09, -76.15, 1),
	            v4(-99.27, 89.99, -67.31, 1),
	            v4(-99.9, 85.32, -61.26, 1),
	            v4(-92.93, 82.77, -62.82, 1),
	            v4(-86.23, 83.38, -64.22, 1),
	            v4(-82.07, 87.01, -67.33, 1),
	            v4(-75.17, 89.98, -66.75, 1),
	            v4(-67.42, 86.34, -66.73, 1),
	            v4(-65.93, 80.58, -64.23, 1),
	            v4(-69.54, 78.6, -62.29, 1),
	            v4(-70.37, 79.4, -61.94, 1),
	            v4(-70.8, 79.82, -61.76, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 28;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["122"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["122"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_100_4_v6";
	Curves["123"] = function () {
	    var Curve_v01 = [[v4(0.83, 2.17, -0.61, 1),
	            v4(3.07, 2.84, -0.54, 1),
	            v4(6.58, 4.14, -0.7, 1),
	            v4(9.75, 6.04, -0.4, 1),
	            v4(11.76, 8.27, 2.29, 1),
	            v4(13.25, 11.37, 9.55, 1),
	            v4(14.3, 15.22, 22.67, 1),
	            v4(14.8, 18.61, 40.36, 1),
	            v4(14.65, 20.25, 59.47, 1),
	            v4(13.35, 20.15, 77.72, 1),
	            v4(9.72, 19.79, 93.5, 1),
	            v4(3.01, 21.07, 105.07, 1),
	            v4(-5.32, 25.26, 112.04, 1),
	            v4(-11.55, 32.23, 114.35, 1),
	            v4(-12.39, 40.56, 111.45, 1),
	            v4(-7.95, 48.78, 104.4, 1),
	            v4(-1.46, 56.38, 92.1, 1),
	            v4(3.64, 63.26, 74.59, 1),
	            v4(5.97, 68.8, 55.97, 1),
	            v4(5.76, 72.36, 38.74, 1),
	            v4(4.2, 74.5, 24.09, 1),
	            v4(3.42, 76.77, 13.96, 1),
	            v4(5.52, 80.32, 9.68, 1),
	            v4(10.98, 84.8, 10.15, 1),
	            v4(18.93, 88.84, 12.14, 1),
	            v4(28.18, 92.04, 12.72, 1),
	            v4(33.78, 95.17, 12.93, 1),
	            v4(35.76, 97.83, 13.93, 1),
	        ], [v4(-3.51, 1.63, 0.23, 1),
	            v4(-3.35, 2.3, 0.3, 1),
	            v4(-2.84, 4.42, 0.47, 1),
	            v4(-1.51, 6.33, 0.31, 1),
	            v4(0.02, 7.34, 1.12, 1),
	            v4(2.28, 10.17, 5.65, 1),
	            v4(4.95, 14, 16.6, 1),
	            v4(8.36, 22.34, 35.45, 1),
	            v4(11.14, 24.64, 54.01, 1),
	            v4(12.59, 24.14, 71.62, 1),
	            v4(12.32, 22.15, 88.05, 1),
	            v4(9.61, 21.26, 100.76, 1),
	            v4(4.29, 22.42, 112.15, 1),
	            v4(-6.86, 30.6, 116.32, 1),
	            v4(-10.02, 40.44, 110.59, 1),
	            v4(-6.19, 48.78, 102.45, 1),
	            v4(0.69, 52.01, 90.1, 1),
	            v4(3.21, 62.27, 71.56, 1),
	            v4(3.44, 67.72, 52.65, 1),
	            v4(1.52, 71.23, 36.27, 1),
	            v4(-0.76, 74.55, 23.12, 1),
	            v4(-3.23, 74.56, 14.88, 1),
	            v4(-5.32, 81.79, 6.9, 1),
	            v4(9.38, 86.05, 8.67, 1),
	            v4(16.48, 89.38, 16.75, 1),
	            v4(18.13, 97.1, 13.83, 1),
	            v4(27.96, 95.63, 13.8, 1),
	            v4(32.61, 97.24, 13.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 27;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["123"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["123"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_100_4_v7";
	Curves["124"] = function () {
	    var Curve_v01 = [[v4(-1.01, 5.03, 3.2, 1),
	            v4(-0.9, 8.14, 3.2, 1),
	            v4(0.26, 15.97, 3.2, 1),
	            v4(4.86, 26.91, 2.44, 1),
	            v4(8.07, 29.36, 2.44, 1),
	            v4(22.22, 35.35, 0.12, 1),
	            v4(36.55, 36.84, -6.42, 1),
	            v4(51.01, 42.38, -10.36, 1),
	            v4(57.25, 50.31, -10.26, 1),
	            v4(55.41, 63.61, -5.36, 1),
	            v4(43.09, 68.17, 3.39, 1),
	            v4(29.72, 65.39, 6.69, 1),
	            v4(26.88, 57.14, 7.27, 1),
	            v4(22.3, 57.75, 7.27, 1),
	            v4(19.78, 58.01, 7.27, 1),
	        ], [v4(-4.27, 5.83, 2.22, 1),
	            v4(-4.16, 8.94, 2.22, 1),
	            v4(-3.09, 16.92, 2.22, 1),
	            v4(1.13, 32.19, 1.45, 1),
	            v4(4.15, 36.24, 1.45, 1),
	            v4(17.82, 44.42, -0.86, 1),
	            v4(31.91, 45.92, -7.41, 1),
	            v4(46.34, 49.83, -11.35, 1),
	            v4(51.67, 55, -11.25, 1),
	            v4(51.25, 63.39, -6.35, 1),
	            v4(39.16, 66.14, 2.4, 1),
	            v4(29.53, 64.11, 6.72, 1),
	            v4(26.24, 56.72, 7.29, 1),
	            v4(21.21, 57.23, 7.29, 1),
	            v4(18.7, 57.49, 7.29, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 14;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["124"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["124"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_49_4_v8";
	Curves["125"] = function () {
	    var Curve_v01 = [[v4(-0.81, 5.21, -5.71, 1),
	            v4(-0.28, 6.72, -5.71, 1),
	            v4(0.81, 8.73, -5.51, 1),
	            v4(2.64, 10.4, -5, 1),
	            v4(5.59, 13.76, -4.04, 1),
	            v4(10.8, 20.92, -2.93, 1),
	            v4(15.57, 27.47, -2.74, 1),
	            v4(18.94, 32.44, -3.86, 1),
	            v4(21.52, 37.37, -4.2, 1),
	            v4(23.69, 42.35, -2.86, 1),
	            v4(25.57, 47.43, -0.65, 1),
	            v4(26.53, 52.72, -0.39, 1),
	            v4(26.44, 57.59, -2.34, 1),
	            v4(25.87, 62.08, -5.27, 1),
	            v4(25.93, 66.58, -9.15, 1),
	            v4(25.93, 71.06, -13.88, 1),
	            v4(22.11, 75.34, -17.56, 1),
	            v4(14.7, 79.63, -18.76, 1),
	            v4(5.77, 82.75, -19.13, 1),
	            v4(-4.54, 83.88, -19.76, 1),
	            v4(-15.77, 83.6, -20.37, 1),
	            v4(-26.33, 82.69, -20.89, 1),
	            v4(-36.64, 77.76, -22.44, 1),
	            v4(-45.05, 69.69, -24.95, 1),
	            v4(-36.81, 58.49, -29.66, 1),
	            v4(-11.98, 67.81, -36.03, 1),
	            v4(-29.16, 71.3, -39.74, 1),
	            v4(-22.75, 63.48, -41.46, 1),
	            v4(-12.58, 63.1, -33.23, 1),
	            v4(-22.92, 57.11, -29.78, 1),
	            v4(-32.81, 58.38, -24.86, 1),
	            v4(-33.05, 53.97, -21.56, 1),
	            v4(-31.79, 52.45, -20.31, 1),
	        ], [v4(-11.15, 5.31, -5.71, 1),
	            v4(-12.41, 6.87, -5.71, 1),
	            v4(-16.22, 8.63, -6.2, 1),
	            v4(-16.73, 12.06, -5, 1),
	            v4(-16.55, 15.71, -4.04, 1),
	            v4(-10.77, 23.6, -2.93, 1),
	            v4(-3.12, 30.19, -3.26, 1),
	            v4(1.42, 34.59, -4.13, 1),
	            v4(4.87, 39.55, -4.2, 1),
	            v4(7.39, 44.47, -2.86, 1),
	            v4(9.76, 49.46, -0.65, 1),
	            v4(11.62, 54.42, -0.39, 1),
	            v4(12.96, 58.7, -2.34, 1),
	            v4(13.91, 62.45, -5.27, 1),
	            v4(14.06, 65.87, -9.15, 1),
	            v4(13.23, 69.14, -13.88, 1),
	            v4(9.45, 72.49, -17.56, 1),
	            v4(2.83, 75.3, -18.76, 1),
	            v4(-4.58, 77.21, -19.13, 1),
	            v4(-12.4, 77.33, -19.81, 1),
	            v4(-19.57, 77.02, -20.55, 1),
	            v4(-26.1, 75.77, -21.25, 1),
	            v4(-31.12, 73.77, -23.08, 1),
	            v4(-35.3, 70.44, -25.45, 1),
	            v4(-34.23, 64.24, -29.64, 1),
	            v4(-24.17, 67.97, -36.03, 1),
	            v4(-34.24, 68.26, -39.74, 1),
	            v4(-29.69, 62.7, -41.46, 1),
	            v4(-19.53, 62.32, -33.23, 1),
	            v4(-25.6, 58.43, -29.78, 1),
	            v4(-34.91, 59.9, -24.86, 1),
	            v4(-35.64, 55.78, -21.56, 1),
	            v4(-34.37, 54.26, -20.31, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["125"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["125"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_91_4_v9";
	Curves["126"] = function () {
	    var Curve_v01 = [[v4(0.87, 3.02, 8.6, 1),
	            v4(-5.68, 3.92, 8.61, 1),
	            v4(-21.92, 6.64, 11.56, 1),
	            v4(-45.58, 26.49, 33.16, 1),
	            v4(-41.32, 37.35, 32.45, 1),
	            v4(-28.5, 46.39, 30.88, 1),
	            v4(-12.82, 52.52, 28.79, 1),
	            v4(-4.64, 60.31, 31.08, 1),
	            v4(-10.49, 70.91, 31.08, 1),
	            v4(-20.68, 75.15, 37.35, 1),
	            v4(-33.62, 76.31, 41.86, 1),
	            v4(-39.23, 73.41, 45.83, 1),
	            v4(-42.4, 71.89, 47.44, 1),
	        ], [v4(-3.72, 1.82, 8.01, 1),
	            v4(-10.68, 1.92, 8, 1),
	            v4(-29.18, 5.39, 13.55, 1),
	            v4(-55.06, 24.97, 40.07, 1),
	            v4(-53.65, 38.01, 40.63, 1),
	            v4(-40.65, 47.16, 35.38, 1),
	            v4(-24.37, 53.49, 31.95, 1),
	            v4(-13.25, 59.22, 30.77, 1),
	            v4(-15.2, 70.05, 30.29, 1),
	            v4(-26.39, 74.52, 34.35, 1),
	            v4(-34.11, 75.8, 41.81, 1),
	            v4(-39.57, 73.68, 45.41, 1),
	            v4(-43.53, 72.75, 45.95, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["126"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["126"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_41_4_v11";
	Curves["127"] = function () {
	    var Curve_v01 = [[v4(1.82, 4.19, 4.05, 1),
	            v4(17.73, 4.36, 7.67, 1),
	            v4(50.81, 21.39, 13.44, 1),
	            v4(68.29, 37.13, 5.35, 1),
	            v4(82.48, 47.55, 4.05, 1),
	            v4(113.34, 45.57, 4.05, 1),
	            v4(141.92, 43.23, 4.05, 1),
	            v4(148.3, 52.48, 4.05, 1),
	            v4(151.49, 57.11, 4.05, 1),
	        ], [v4(-0.67, 4.95, 4.05, 1),
	            v4(15.23, 5.13, 4.05, 1),
	            v4(48.31, 22.16, 4.05, 1),
	            v4(65.8, 37.89, 4.05, 1),
	            v4(79.98, 49.9, 4.05, 1),
	            v4(110.85, 48.26, 4.05, 1),
	            v4(139.43, 44, 4.05, 1),
	            v4(145.81, 53.25, 4.05, 1),
	            v4(149, 57.87, 4.05, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["127"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["127"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_25_4_v14";
	Curves["128"] = function () {
	    var Curve_v01 = [[v4(-1.91, 8.44, -7.51, 1),
	            v4(-1.43, 11.69, -8.9, 1),
	            v4(-2.1, 21.37, -12.66, 1),
	            v4(-27.48, 36.63, -21.71, 1),
	            v4(-65.87, 32.51, -28.83, 1),
	            v4(-86.83, 19.58, -36.08, 1),
	            v4(-118.51, 15.84, -46.83, 1),
	            v4(-120.03, 22.27, -46.65, 1),
	            v4(-121.01, 25.48, -46.55, 1),
	        ], [v4(-2.38, 1.68, -7.51, 1),
	            v4(-10.34, 3.75, -8.9, 1),
	            v4(-21.65, 9.66, -12.66, 1),
	            v4(-38.67, 30.11, -21.71, 1),
	            v4(-64.94, 29.93, -28.83, 1),
	            v4(-85.88, 17.02, -36.08, 1),
	            v4(-117.56, 13.27, -46.83, 1),
	            v4(-120.15, 19.7, -46.65, 1),
	            v4(-121.45, 22.91, -46.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["128"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["128"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_25_4_v15";
	Curves["129"] = function () {
	    var Curve_v01 = [[v4(-1.74, 8.4, -7, 1),
	            v4(-3.56, 11.06, -5.48, 1),
	            v4(-8.92, 21.46, -12.58, 1),
	            v4(-20.84, 29.18, 17.48, 1),
	            v4(-34.71, 24.44, 38.49, 1),
	            v4(-41.09, 6.59, 47.01, 1),
	            v4(-38.58, 0.28, 44.44, 1),
	            v4(-36.48, -1.8, 43.32, 1),
	        ], [v4(-2.69, 4.58, -7, 1),
	            v4(-6.23, 6.14, -5.48, 1),
	            v4(-18.57, 12.04, -12.58, 1),
	            v4(-23.44, 23.14, 17.48, 1),
	            v4(-34.32, 19.89, 38.49, 1),
	            v4(-40.45, 2.24, 44.02, 1),
	            v4(-37.52, -3.83, 41.5, 1),
	            v4(-36.31, -5.78, 40.37, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["129"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["129"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_21_4_v16";
	Curves["130"] = function () {
	    var Curve_v01 = [[v4(-0.7, 4.39, -6.41, 1),
	            v4(-9.06, 3.67, -14.31, 1),
	            v4(-29.03, 6.38, -13.32, 1),
	            v4(-66.81, 17.96, -10.87, 1),
	            v4(-121.92, 25.42, 5.32, 1),
	            v4(-157.92, 33.45, -4, 1),
	            v4(-182.64, 41.21, -8.79, 1),
	            v4(-192.85, 39.1, -8.79, 1),
	            v4(-201.11, 37.38, -8.79, 1),
	        ], [v4(-4.51, 2.43, -6.41, 1),
	            v4(-19.66, 2.06, -14.37, 1),
	            v4(-75.93, 5.17, -16.21, 1),
	            v4(-96.32, 9.88, -12.73, 1),
	            v4(-144.75, 18.73, 2.15, 1),
	            v4(-171.46, 27.74, -3.96, 1),
	            v4(-185.97, 37.04, -9.19, 1),
	            v4(-192.95, 37.65, -8.72, 1),
	            v4(-197.75, 37.13, -8.72, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["130"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["130"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_25_4_v18";
	Curves["131"] = function () {
	    var Curve_v01 = [[v4(0.73, 9.93, 4.52, 1),
	            v4(4.12, 17.64, 6.73, 1),
	            v4(15.95, 31.04, 16.71, 1),
	            v4(36.65, 36.11, 35.08, 1),
	            v4(55.68, 34.52, 45.77, 1),
	            v4(69.23, 30.79, 52.02, 1),
	            v4(83.22, 24.35, 58.71, 1),
	            v4(89.18, 18.69, 60.45, 1),
	            v4(92.35, 14.4, 62.52, 1),
	        ], [v4(-1.01, 7.5, 4.52, 1),
	            v4(-3.45, 21.69, 6.73, 1),
	            v4(6.2, 34.02, 16.71, 1),
	            v4(34.28, 37.85, 35.08, 1),
	            v4(53.31, 36.26, 47.66, 1),
	            v4(66.85, 32.53, 53.7, 1),
	            v4(79.96, 26.92, 58.78, 1),
	            v4(85.42, 21.73, 61.17, 1),
	            v4(88.59, 17.44, 62.23, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["131"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["131"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_25_4_v21";
	Curves["132"] = function () {
	    var Curve_v01 = [[v4(-4.53, 2.37, -7.43, 1),
	            v4(-10.66, 3.66, -4.24, 1),
	            v4(-22.46, 7.21, 2.18, 1),
	            v4(-39.78, 14.26, 12.03, 1),
	            v4(-55.91, 23.23, 21.63, 1),
	            v4(-71.61, 34.17, 31.04, 1),
	            v4(-82.88, 50.87, 37.6, 1),
	            v4(-89.54, 71.84, 35.3, 1),
	            v4(-102.29, 87.22, 35.02, 1),
	            v4(-109.89, 101.76, 34.38, 1),
	            v4(-102.86, 106.1, 31.24, 1),
	        ], [v4(-13.19, 2.06, -4.04, 1),
	            v4(-19.42, 3.24, -0.32, 1),
	            v4(-31.36, 6.49, 7.83, 1),
	            v4(-47.48, 13.78, 21.06, 1),
	            v4(-62.6, 23.75, 33.96, 1),
	            v4(-77.01, 36.69, 44.58, 1),
	            v4(-92.6, 52.96, 48.51, 1),
	            v4(-106.39, 69.04, 46.25, 1),
	            v4(-119.98, 88.19, 40.54, 1),
	            v4(-115.04, 101.46, 34.09, 1),
	            v4(-108.67, 105.39, 31.24, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["132"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["132"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_33_4_v22";
	Curves["133"] = function () {
	    var Curve_v01 = [[v4(0.78, 7.02, -14.27, 1),
	            v4(-2.86, 15.49, -13.6, 1),
	            v4(-10.99, 25.61, -22.25, 1),
	            v4(-24.23, 30.45, -49.58, 1),
	            v4(-36.44, 33.23, -77.94, 1),
	            v4(-45.09, 38.66, -99.06, 1),
	            v4(-47.88, 47.16, -111.44, 1),
	            v4(-43.93, 56.85, -118.43, 1),
	            v4(-34.25, 66.55, -123.81, 1),
	            v4(-21.76, 77.46, -129.1, 1),
	            v4(-11.29, 92.32, -135.37, 1),
	            v4(-10.04, 106.51, -142.7, 1),
	            v4(-12.15, 114.95, -148.32, 1),
	        ], [v4(-3.5, 5.59, -14.27, 1),
	            v4(-6.94, 13.62, -13.63, 1),
	            v4(-16.04, 22.87, -23.49, 1),
	            v4(-33.25, 27.03, -53.98, 1),
	            v4(-50.35, 30.26, -84.68, 1),
	            v4(-62.97, 37.43, -105.01, 1),
	            v4(-67.32, 48.65, -112.09, 1),
	            v4(-62.32, 61.31, -111, 1),
	            v4(-50.55, 73.45, -110.94, 1),
	            v4(-36.67, 85.51, -118.64, 1),
	            v4(-24.93, 99.09, -133.86, 1),
	            v4(-20.33, 109.52, -144.72, 1),
	            v4(-19.13, 114.91, -148.8, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["133"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["133"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_41_4_v23";
	Curves["134"] = function () {
	    var Curve_v01 = [[v4(-8.39, 7.69, -10.04, 1),
	            v4(-16.21, 2.49, -11.34, 1),
	            v4(-31.59, -19.07, -15.98, 1),
	            v4(-35.86, -38.48, -18.65, 1),
	            v4(-35.07, -49.55, -20.49, 1),
	            v4(-31.58, -53.96, -19.61, 1),
	            v4(-29.93, -55.9, -18.95, 1),
	        ], [v4(-4.8, 5.24, -8.89, 1),
	            v4(-8.74, 1.09, -8.99, 1),
	            v4(-16.11, -12.8, -10.71, 1),
	            v4(-22, -31.76, -12.12, 1),
	            v4(-24.85, -47.3, -16.06, 1),
	            v4(-23.9, -51.82, -16.83, 1),
	            v4(-23.48, -53.73, -16.97, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["134"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["134"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_17_4_v27";
	Curves["135"] = function () {
	    var Curve_v01 = [[v4(-2.3, 5.43, 15.07, 1),
	            v4(-1.77, 7.78, 15.07, 1),
	            v4(4.03, 11.11, 13.99, 1),
	            v4(12.66, 13.33, 6.01, 1),
	            v4(13.66, 16.55, -2.13, 1),
	            v4(10.33, 18.59, -12.06, 1),
	            v4(-3.49, 22.29, -16.79, 1),
	            v4(-18.67, 24.88, -9.22, 1),
	            v4(-25.7, 29.1, 1.09, 1),
	            v4(-21.16, 33.96, 12.88, 1),
	            v4(-6.13, 36.07, 21.44, 1),
	            v4(9.6, 38.39, 17.61, 1),
	            v4(20.54, 40.03, 4.2, 1),
	            v4(20.63, 43.65, -9.01, 1),
	            v4(8.16, 51.43, -16.69, 1),
	            v4(-2.76, 57.56, -18.64, 1),
	            v4(-13.75, 63.82, -14.83, 1),
	            v4(-18.89, 70, -2.57, 1),
	            v4(-21.33, 73.8, 9.02, 1),
	            v4(-13.4, 78.28, 19.2, 1),
	            v4(-8.57, 83.57, 4.13, 1),
	            v4(1.29, 88.25, -2.09, 1),
	            v4(5.49, 94.21, -4.49, 1),
	        ], [v4(-1.95, 4.83, 15.07, 1),
	            v4(-1.83, 7.58, 15.07, 1),
	            v4(1.18, 13.59, 13.99, 1),
	            v4(7.38, 18.61, 6.01, 1),
	            v4(10.89, 24.15, -2.13, 1),
	            v4(11.58, 29.9, -12.06, 1),
	            v4(-0.72, 34.55, -16.79, 1),
	            v4(-12.67, 37.17, -9.22, 1),
	            v4(-17, 41.24, 1.09, 1),
	            v4(-15.64, 43.98, 12.88, 1),
	            v4(-3.35, 46.4, 21.44, 1),
	            v4(12.7, 49.15, 17.61, 1),
	            v4(23.91, 51.17, 4.2, 1),
	            v4(24.19, 55.04, -9.01, 1),
	            v4(11.89, 60.35, -16.69, 1),
	            v4(1.1, 65.11, -18.64, 1),
	            v4(-9.56, 71.16, -14.83, 1),
	            v4(-14.15, 76.88, -2.57, 1),
	            v4(-16.15, 80.2, 9.02, 1),
	            v4(-7.88, 84.16, 19.2, 1),
	            v4(-3.03, 88.99, 4.13, 1),
	            v4(6.63, 93.4, -2.09, 1),
	            v4(10.57, 99.19, -4.49, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["135"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["135"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_81_4_v29";
	Curves["136"] = function () {
	    var Curve_v01 = [[v4(0.32, 3.16, 3.07, 1),
	            v4(2.17, 3.7, 3.62, 1),
	            v4(3.39, 6.1, 5.14, 1),
	            v4(8.44, 8.28, 12.7, 1),
	            v4(15.67, 9.42, 23.65, 1),
	            v4(27.38, 14.04, 36.54, 1),
	            v4(66.21, 33.62, 49.08, 1),
	            v4(128.63, 75.34, 62.39, 1),
	            v4(142.88, 96.81, 87.84, 1),
	            v4(139.01, 103.6, 109.71, 1),
	        ], [v4(0.34, 3.31, 0.47, 1),
	            v4(0.94, 4.51, 1.23, 1),
	            v4(2.13, 6.93, 2.75, 1),
	            v4(8.02, 13, 10.2, 1),
	            v4(16.49, 14.64, 20.98, 1),
	            v4(28.21, 17.28, 33.86, 1),
	            v4(67.04, 33.62, 46.41, 1),
	            v4(129.46, 75.34, 59.71, 1),
	            v4(143.71, 96.81, 85.17, 1),
	            v4(139.83, 103.6, 107.03, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["136"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["136"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v39";
	Curves["137"] = function () {
	    var Curve_v01 = [[v4(-121.99, 21.78, 142.06, 1),
	            v4(-123.98, 30.75, 145.73, 1),
	            v4(-127.55, 53.08, 155.58, 1),
	            v4(-123.53, 66.62, 172.5, 1),
	            v4(-119.5, 68.29, 185.45, 1),
	            v4(-117.83, 65.8, 191.48, 1),
	        ], [v4(-120.25, 20.14, 145.53, 1),
	            v4(-121.94, 27.67, 150.29, 1),
	            v4(-125.62, 42.02, 161.62, 1),
	            v4(-124.42, 59.36, 173.68, 1),
	            v4(-120.03, 63.5, 185.77, 1),
	            v4(-118.42, 61.86, 191.39, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["137"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["137"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_13_4_v41";
	Curves["138"] = function () {
	    var Curve_v01 = [[v4(-2.93, 4.81, 0.12, 1),
	            v4(-3.71, 6.27, 1.31, 1),
	            v4(-4.41, 8.57, 3.42, 1),
	            v4(-11.55, 15.55, 12.88, 1),
	            v4(-11.78, 15.76, 24.88, 1),
	            v4(7.05, 11.17, 56.86, 1),
	            v4(65.88, 17.82, 113.79, 1),
	            v4(185.6, 83.3, 124.18, 1),
	            v4(360.97, 106.25, 93.54, 1),
	            v4(431.72, 125.15, 29.87, 1),
	        ], [v4(-3.25, 2.75, 0.58, 1),
	            v4(-4.06, 4.16, 1.82, 1),
	            v4(-5.13, 6.58, 4.13, 1),
	            v4(-11.09, 12.28, 12.83, 1),
	            v4(-10.6, 9.89, 25.14, 1),
	            v4(10.86, 5.05, 56.94, 1),
	            v4(68.95, 9.41, 112.76, 1),
	            v4(187.21, 76.86, 122.54, 1),
	            v4(367.79, 101.58, 91.7, 1),
	            v4(428.33, 121.46, 34.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["138"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["138"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v43";
	Curves["139"] = function () {
	    var Curve_v01 = [[v4(-0.28, 3.96, -5.71, 1),
	            v4(5.58, 0.97, 0.44, 1),
	            v4(15.4, 14.05, 7.7, 1),
	            v4(35.39, 22.15, 16.6, 1),
	            v4(53.85, 16.71, 22.93, 1),
	            v4(76.24, 17.07, 26.39, 1),
	            v4(99.02, 17.19, 25.15, 1),
	            v4(120.64, 20.99, 18.59, 1),
	            v4(141.32, 25.38, 10.11, 1),
	            v4(161.66, 30.79, 0.96, 1),
	            v4(181.85, 36.26, -8.38, 1),
	            v4(201.83, 42.23, -18.08, 1),
	            v4(221.54, 48.51, -28.19, 1),
	            v4(240.92, 55.25, -38.77, 1),
	            v4(259.92, 62.43, -49.89, 1),
	            v4(278.44, 70.14, -61.59, 1),
	            v4(296.43, 78.38, -73.96, 1),
	            v4(313.72, 87.25, -87, 1),
	            v4(330.62, 96.6, -100.5, 1),
	            v4(346.86, 106.59, -114.32, 1),
	            v4(363.24, 117.1, -128.32, 1),
	            v4(378.93, 129.06, -142.33, 1),
	            v4(396.2, 141.95, -156.08, 1),
	            v4(411.18, 157.23, -169.11, 1),
	            v4(430.49, 173.82, -180.19, 1),
	            v4(442.58, 195.54, -187.7, 1),
	            v4(461.47, 209.16, -186.49, 1),
	            v4(459.01, 201.35, -177.51, 1),
	        ], [v4(0.69, 4.83, -4.71, 1),
	            v4(6.68, 2.78, 1.21, 1),
	            v4(16.3, 18.33, 7.84, 1),
	            v4(36.78, 23.48, 18.72, 1),
	            v4(57.84, 17.69, 26.23, 1),
	            v4(79.65, 16.15, 29.86, 1),
	            v4(102.26, 13.81, 28.15, 1),
	            v4(123.87, 16.63, 21.58, 1),
	            v4(144.55, 21.02, 13.1, 1),
	            v4(164.89, 26.43, 3.95, 1),
	            v4(185.08, 31.9, -5.39, 1),
	            v4(205.06, 37.87, -15.09, 1),
	            v4(224.77, 44.15, -25.19, 1),
	            v4(244.15, 50.9, -35.78, 1),
	            v4(263.15, 58.04, -46.94, 1),
	            v4(281.67, 64.85, -59.91, 1),
	            v4(299.66, 71.7, -74.26, 1),
	            v4(316.95, 79.9, -88.23, 1),
	            v4(333.85, 89.26, -101.72, 1),
	            v4(350.09, 99.24, -115.55, 1),
	            v4(366.41, 109.68, -129.55, 1),
	            v4(381.67, 121.07, -143.57, 1),
	            v4(398.16, 133.15, -157.39, 1),
	            v4(412.11, 152.01, -171.2, 1),
	            v4(430.26, 175.39, -183.56, 1),
	            v4(441.72, 200.91, -190.77, 1),
	            v4(460.42, 217.48, -187.69, 1),
	            v4(457.96, 211.17, -177.87, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 27;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["139"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["139"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_100_4_v44";
	Curves["140"] = function () {
	    var Curve_v01 = [[v4(0.29, 3.31, -0.58, 1),
	            v4(0.43, 4.51, -1.55, 1),
	            v4(0.75, 6.93, -3.48, 1),
	            v4(2.09, 13, -12.95, 1),
	            v4(3.73, 14.64, -26.63, 1),
	            v4(3.25, 17.28, -43.89, 1),
	            v4(-25.95, 33.62, -76.26, 1),
	            v4(-72.66, 75.34, -122.66, 1),
	            v4(-69.94, 96.81, -151.7, 1),
	            v4(-54.33, 103.6, -167.5, 1),
	        ], [v4(-1.19, 2.61, 2.09, 1),
	            v4(-1.28, 3.7, 1.13, 1),
	            v4(-1.47, 5.9, -0.8, 1),
	            v4(-2.34, 10.98, -10.28, 1),
	            v4(-3.5, 11.42, -23.96, 1),
	            v4(-5.98, 13.28, -41.22, 1),
	            v4(-30.09, 32.08, -73.59, 1),
	            v4(-73.48, 75.59, -119.99, 1),
	            v4(-70.76, 98.34, -149.03, 1),
	            v4(-55.16, 105.57, -164.83, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["140"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["140"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v45";
	Curves["141"] = function () {
	    var Curve_v01 = [[v4(-1.01, 4.22, -6.41, 1),
	            v4(-7.29, 6.47, -6.41, 1),
	            v4(-26.88, 15.59, -7.92, 1),
	            v4(-24.27, 39.21, 9.91, 1),
	            v4(-39.46, 59.47, -1.57, 1),
	            v4(-18.44, 66.13, -23.05, 1),
	            v4(-0.75, 72.44, -33.84, 1),
	            v4(15.78, 84.91, -50.62, 1),
	            v4(21.49, 88.56, -73, 1),
	            v4(31.38, 94.03, -97.93, 1),
	            v4(34.44, 99.83, -115.47, 1),
	            v4(39.6, 107.97, -138.42, 1),
	            v4(35.49, 113.46, -138.44, 1),
	        ], [v4(-8.87, 2.66, -6.41, 1),
	            v4(-14.44, 3.15, -6.41, 1),
	            v4(-40.66, 8.04, -8.33, 1),
	            v4(-33.37, 32.8, 7.06, 1),
	            v4(-47.53, 56.9, 3.54, 1),
	            v4(-31.39, 68.33, -20.05, 1),
	            v4(-13.36, 74.43, -32.93, 1),
	            v4(-0.62, 80.69, -56.31, 1),
	            v4(7.32, 84.54, -78.38, 1),
	            v4(17.16, 90.75, -102.21, 1),
	            v4(25.4, 94.27, -123.81, 1),
	            v4(34.26, 106.76, -138.41, 1),
	            v4(28.74, 114.51, -138.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["141"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["141"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_41_4_v20";
	Curves["142"] = function () {
	    var Curve_v01 = [[v4(-0.66, 4.32, 5.56, 1),
	            v4(-6.59, 6.5, 11.9, 1),
	            v4(-10.51, 6.93, 18.49, 1),
	            v4(-15.04, 6.53, 28.49, 1),
	            v4(-18.01, 3.91, 36.16, 1),
	            v4(-18.9, 1.72, 38.21, 1),
	            v4(-18.96, 0.25, 38.35, 1),
	        ], [v4(4.06, 3.07, 10.45, 1),
	            v4(3.55, 5.25, 24.02, 1),
	            v4(1.56, 5.68, 33.18, 1),
	            v4(-2.96, 5.28, 43.18, 1),
	            v4(-8.95, 3.23, 47.45, 1),
	            v4(-12.51, 0.67, 45.93, 1),
	            v4(-13.84, -1, 43.77, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["142"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["142"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_17_4_v24";
	Curves["143"] = function () {
	    var Curve_v01 = [[v4(-0.94, 2.14, 5.71, 1),
	            v4(3.16, 3.18, 8.76, 1),
	            v4(8.32, -0.03, 13.87, 1),
	            v4(22.45, -10.03, 18.34, 1),
	            v4(23.91, -21.9, 21.2, 1),
	            v4(23.63, -24.98, 21.94, 1),
	            v4(22.75, -26.68, 21.89, 1),
	        ], [v4(2.88, 3.09, 4.54, 1),
	            v4(9.95, 4.13, 3.36, 1),
	            v4(20.21, 3.94, 2.87, 1),
	            v4(37.09, -3.78, 3.96, 1),
	            v4(34.43, -20.29, 9.21, 1),
	            v4(31.81, -24.98, 11.79, 1),
	            v4(30.19, -26.57, 13.47, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["143"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["143"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_17_4_v25";
	Curves["144"] = function () {
	    var Curve_v01 = [[v4(-2.1, 4.06, -3.18, 1),
	            v4(-13.73, 6.15, 0.76, 1),
	            v4(-27.95, 7.94, 3.25, 1),
	            v4(-43.11, 5.28, 4.05, 1),
	            v4(-126.55, 9.29, 4.05, 1),
	            v4(-170.89, 16.44, 4.05, 1),
	            v4(-171.61, 19.19, 4.05, 1),
	            v4(-171.97, 20.4, 4.05, 1),
	        ], [v4(-2.58, 2.83, -3.18, 1),
	            v4(-14.21, 4.04, 0.76, 1),
	            v4(-29.78, 3.67, 2.62, 1),
	            v4(-46.7, -2.48, 2.59, 1),
	            v4(-117.04, 2.87, 2.66, 1),
	            v4(-173.26, 12.24, 3.23, 1),
	            v4(-173.22, 15.68, 3.59, 1),
	            v4(-173.27, 17.16, 3.74, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["144"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["144"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_21_4_v28";
	Curves["145"] = function () {
	    var Curve_v01 = [[v4(-1.18, 3.7, -1.66, 1),
	            v4(-1.83, 5.3, -0.84, 1),
	            v4(-2.97, 7.95, 0.7, 1),
	            v4(-11.27, 15.55, 9.66, 1),
	            v4(-19.1, 15.97, 18.49, 1),
	            v4(-22.56, 19.84, 39.37, 1),
	            v4(-15.02, 26.32, 80.52, 1),
	            v4(17.06, 57.94, 146.53, 1),
	            v4(17.89, 96.39, 169.39, 1),
	            v4(11.37, 117.14, 173.58, 1),
	        ], [v4(-0.19, 3.31, -1.6, 1),
	            v4(-0.85, 4.51, -0.9, 1),
	            v4(-2.17, 6.93, 0.51, 1),
	            v4(-8.4, 12.84, 8.76, 1),
	            v4(-16.12, 10.16, 18.97, 1),
	            v4(-19.58, 13.96, 39.55, 1),
	            v4(-12.25, 20.57, 80.13, 1),
	            v4(19.2, 55.92, 146.14, 1),
	            v4(22.06, 96.64, 169.23, 1),
	            v4(10.95, 122.82, 175, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["145"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["145"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v40";
	Curves["146"] = function () {
	    var Curve_v01 = [[v4(-0.58, 2.28, 0.42, 1),
	            v4(-0.35, 2.58, 0.8, 1),
	            v4(0.45, 2.35, 1.3, 1),
	            v4(2.51, 2.58, 4.89, 1),
	            v4(5.49, 5.36, 7.01, 1),
	            v4(16, 8.1, 7.88, 1),
	            v4(38.24, 12.26, -2.22, 1),
	            v4(88.64, 27.16, -67.6, 1),
	            v4(143.21, 36.4, -149.8, 1),
	            v4(135.06, 39.75, -177.25, 1),
	        ], [v4(2.47, 3.75, -0.56, 1),
	            v4(2.71, 4.17, -0.18, 1),
	            v4(3.2, 4.9, 0.42, 1),
	            v4(4.85, 6.23, 3.23, 1),
	            v4(8.13, 6.56, 4.9, 1),
	            v4(17.76, 7.5, 4.77, 1),
	            v4(40.08, 8.65, -5.32, 1),
	            v4(87.55, 20.81, -62.32, 1),
	            v4(146.11, 32.66, -151.47, 1),
	            v4(138.36, 38.64, -175.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["146"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["146"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v46";
	Curves["147"] = function () {
	    var Curve_v01 = [[v4(1.92, 2.94, -10.19, 1),
	            v4(14.96, 6.86, -31.01, 1),
	            v4(33.75, 23.13, -96.05, 1),
	            v4(41.38, 39.78, -104.64, 1),
	            v4(28.35, 55.8, -101.31, 1),
	            v4(24.25, 70.93, -85.73, 1),
	            v4(31.94, 76.38, -45.33, 1),
	            v4(76.81, 90.98, -12.4, 1),
	            v4(93.64, 108.38, -91.75, 1),
	            v4(82.29, 115.68, -119.31, 1),
	            v4(81.8, 125.12, -120.58, 1),
	            v4(90.94, 130.77, -110.13, 1),
	            v4(99.4, 134.37, -97.15, 1),
	            v4(99.11, 138.5, -96.38, 1),
	        ], [v4(-2.1, 3.49, -9.23, 1),
	            v4(10.95, 7.41, -13.53, 1),
	            v4(5.65, 23.68, -73.68, 1),
	            v4(13.26, 40.44, -104.64, 1),
	            v4(15.35, 58.73, -101.31, 1),
	            v4(17.38, 77.64, -55.02, 1),
	            v4(28.23, 85.71, -6.77, 1),
	            v4(70.61, 95.48, -19.66, 1),
	            v4(86.18, 107.31, -95.87, 1),
	            v4(78.61, 114.16, -120.58, 1),
	            v4(77.79, 125.67, -120.58, 1),
	            v4(86.92, 131.32, -110.13, 1),
	            v4(97.51, 134.92, -97.15, 1),
	            v4(97.22, 139.05, -96.38, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 13;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["147"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["147"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_45_4_v12";
	Curves["148"] = function () {
	    var Curve_v01 = [[v4(10.75, 1.17, -5.53, 1),
	            v4(21.89, -2.78, -8.89, 1),
	            v4(32.29, -13.71, -12.88, 1),
	            v4(43.88, -36.04, -17.88, 1),
	            v4(46.88, -51.16, -21.62, 1),
	            v4(46.09, -55.86, -22.32, 1),
	            v4(45.61, -59.78, -22.02, 1),
	        ], [v4(0.41, 2.2, -5.86, 1),
	            v4(9.31, 4.63, -10.87, 1),
	            v4(19.98, 0.65, -19.3, 1),
	            v4(38.77, -18.88, -28.81, 1),
	            v4(39.85, -39.69, -29.89, 1),
	            v4(37.9, -50.55, -27.96, 1),
	            v4(40.02, -57.5, -24.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["148"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["148"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_17_4_v26";
	Curves["149"] = function () {
	    var Curve_v01 = [[v4(-3.77, 2.06, -4.18, 1),
	            v4(-3.27, 2.86, -4.18, 1),
	            v4(-2.12, 8.05, -4.18, 1),
	            v4(-4.75, 22.21, -4.18, 1),
	            v4(-13.15, 34.25, -4.35, 1),
	            v4(-25.95, 39.53, -3.7, 1),
	            v4(-39.07, 46.19, -2.25, 1),
	            v4(-52.17, 49.09, -2.13, 1),
	            v4(-55, 56.25, -4.31, 1),
	            v4(-48.89, 61.79, -16.8, 1),
	            v4(-39.36, 63.27, -28.32, 1),
	            v4(-36.38, 62.31, -28.32, 1),
	            v4(-34.89, 61.83, -28.32, 1),
	        ], [v4(-9.87, 1.15, -4.18, 1),
	            v4(-12.28, 3.18, -4.18, 1),
	            v4(-18.69, 7.95, -8.48, 1),
	            v4(-29.9, 19.42, -4.18, 1),
	            v4(-40.94, 30.71, -3.96, 1),
	            v4(-44.82, 39.99, -2.36, 1),
	            v4(-57.57, 44.57, -1.24, 1),
	            v4(-65.14, 50.1, -1.98, 1),
	            v4(-65.76, 58.35, -3.96, 1),
	            v4(-59.46, 63.99, -16.78, 1),
	            v4(-49.82, 65.51, -28.32, 1),
	            v4(-46.86, 64.54, -28.32, 1),
	            v4(-45.38, 64.06, -28.32, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["149"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["149"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_41_4_v1";
	Curves["150"] = function () {
	    var Curve_v01 = [[v4(2.69, 2.19, -0.51, 1),
	            v4(6.79, 5.99, 0.13, 1),
	            v4(14.41, 15.34, -1.75, 1),
	            v4(39.27, 21.98, -15.22, 1),
	            v4(80.3, 22.16, -30.52, 1),
	            v4(123.51, 15.03, -40.19, 1),
	            v4(190.46, 17.31, -61.8, 1),
	            v4(192.31, 28.99, -61.07, 1),
	            v4(188.11, 31.01, -58.34, 1),
	            v4(186.01, 32.02, -56.97, 1),
	        ], [v4(1.8, 2.8, -0.51, 1),
	            v4(3.62, 9.71, 0.13, 1),
	            v4(6.55, 23.27, -1.67, 1),
	            v4(24.85, 29.97, -12.58, 1),
	            v4(73.46, 30.22, -28.53, 1),
	            v4(122.88, 16.83, -40.21, 1),
	            v4(189.74, 18.73, -61.8, 1),
	            v4(191.59, 32.29, -63.01, 1),
	            v4(187.39, 34.31, -60.27, 1),
	            v4(185.29, 35.32, -58.91, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["150"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["150"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v19";
	Curves["151"] = function () {
	    var Curve_v01 = [[v4(-2.9, 4.98, 4.74, 1),
	            v4(-10.26, 6.2, 15.7, 1),
	            v4(-21.53, 18.16, 48.78, 1),
	            v4(-36.08, 31.1, 57.84, 1),
	            v4(-41.31, 40.62, 61.29, 1),
	            v4(-31.83, 55.34, 54.78, 1),
	            v4(-8.36, 59.33, 36.69, 1),
	            v4(0.88, 73.54, 3.13, 1),
	            v4(-3.49, 83.06, -8.04, 1),
	            v4(1.96, 88.73, -10.5, 1),
	            v4(6.18, 91.75, -11.74, 1),
	        ], [v4(-5.33, 2.54, 4.61, 1),
	            v4(-15.43, 3.29, 15.43, 1),
	            v4(-31.48, 14.35, 48.28, 1),
	            v4(-45.28, 28.3, 59.77, 1),
	            v4(-46, 39.79, 65.03, 1),
	            v4(-35.21, 55.38, 58.71, 1),
	            v4(-11.57, 59.49, 40.64, 1),
	            v4(-2.33, 73.7, 7.09, 1),
	            v4(-6.7, 83.21, -4.08, 1),
	            v4(-1.25, 88.88, -6.55, 1),
	            v4(4.61, 91.71, -7.79, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["151"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["151"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_33_4_v13";
	Curves["152"] = function () {
	    var Curve_v01 = [[v4(2.78, 2.7, 4.1, 1),
	            v4(8.3, 2.95, 5.59, 1),
	            v4(17.55, 9.18, 10.29, 1),
	            v4(96.15, 19.76, 31.86, 1),
	            v4(130.61, 30.28, 40.48, 1),
	            v4(140.35, 38.01, 40.47, 1),
	            v4(135.59, 50.41, 31.46, 1),
	            v4(123.95, 49.66, 27.89, 1),
	            v4(122.8, 47.64, 27.76, 1),
	            v4(122.23, 46.62, 27.76, 1),
	        ], [v4(0.07, 3.84, 7, 1),
	            v4(4.45, 5.36, 7.92, 1),
	            v4(13.36, 10.99, 10.12, 1),
	            v4(70.69, 26.78, 22.98, 1),
	            v4(127.03, 33.17, 39.86, 1),
	            v4(135.13, 39.03, 39.11, 1),
	            v4(133.1, 48.64, 32.4, 1),
	            v4(123.13, 48.81, 28.45, 1),
	            v4(121.99, 46.79, 28.1, 1),
	            v4(121.42, 45.77, 28.1, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["152"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["152"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v17";
	Curves["153"] = function () {
	    var Curve_v01 = [[v4(-2.57, 4.62, -1.23, 1),
	            v4(-3.51, 5.91, -1.43, 1),
	            v4(-5.36, 8.57, -1.88, 1),
	            v4(-14.63, 15.55, -3.81, 1),
	            v4(-25.8, 15.76, -7.27, 1),
	            v4(-46.3, 18.5, -0.69, 1),
	            v4(-81.77, 28.23, 27.04, 1),
	            v4(-129.44, 49.91, 75.56, 1),
	            v4(-149.56, 94.05, 100.6, 1),
	            v4(-155.47, 124.8, 99.84, 1),
	        ], [v4(-0.58, 3.31, -0.06, 1),
	            v4(-1.54, 4.51, -0.13, 1),
	            v4(-3.47, 6.93, -0.25, 1),
	            v4(-12.95, 12.84, -0.89, 1),
	            v4(-23.73, 9.89, -7.11, 1),
	            v4(-43.89, 12.16, -0.55, 1),
	            v4(-78.57, 20.11, 27.22, 1),
	            v4(-126.09, 43.24, 75.85, 1),
	            v4(-145.65, 89.83, 103.82, 1),
	            v4(-154.76, 125.2, 101.47, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["153"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["153"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_29_4_v42";
	Curves["154"] = function () {
	    var Curve_v01 = [[v4(-2.64, 5.32, 2.76, 1),
	            v4(0.16, 4.64, 7, 1),
	            v4(5.06, 3.22, 17.49, 1),
	            v4(11.83, 0.37, 40.91, 1),
	            v4(19.37, -4.92, 70.18, 1),
	            v4(23.7, -4.97, 103.9, 1),
	            v4(-6.57, -14.12, 111.96, 1),
	            v4(-49.95, -15.91, 81.78, 1),
	            v4(-54.31, -4.96, 4.86, 1),
	            v4(-52.93, -0.39, -16.32, 1),
	            v4(-39.15, 12.54, -15.25, 1),
	            v4(-28.29, 17.52, -11.86, 1),
	            v4(-24.73, 19.22, -10.71, 1),
	        ], [v4(-2.91, 6.43, 2.85, 1),
	            v4(-0.12, 5.93, 7.09, 1),
	            v4(4.86, 5.19, 17.51, 1),
	            v4(11.91, 3.72, 40.81, 1),
	            v4(19.37, -0.45, 70.1, 1),
	            v4(23.59, -0.04, 103.9, 1),
	            v4(-7.08, -9.14, 112.06, 1),
	            v4(-52.32, -5.27, 87.84, 1),
	            v4(-59.78, 1.65, 14.79, 1),
	            v4(-58.72, 2.25, -6.94, 1),
	            v4(-42.62, 12.09, -7.9, 1),
	            v4(-30.69, 15.92, -5.33, 1),
	            v4(-26.78, 17.33, -4.48, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["154"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["154"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_41_4_v59";
	Curves["155"] = function () {
	    var Curve_v01 = [[v4(-5.8, 2.23, -9.02, 1),
	            v4(-3.67, -0.01, -6.73, 1),
	            v4(1.1, -4.34, -0.45, 1),
	            v4(11.46, -9.57, 22.26, 1),
	            v4(8.38, -14.51, 89.37, 1),
	            v4(-22.65, -15.34, 171.96, 1),
	            v4(-51.83, -3.35, 182.17, 1),
	            v4(-51.38, 15.97, 132.59, 1),
	            v4(-28.01, 35, 4.86, 1),
	            v4(-21.48, 35.39, -16.32, 1),
	            v4(1.92, 30.44, -15.25, 1),
	            v4(12.42, 25.15, -11.86, 1),
	            v4(15.95, 23.44, -10.71, 1),
	        ], [v4(-1.49, 4.77, -8.43, 1),
	            v4(0.82, 2.65, -6.11, 1),
	            v4(6.63, -1.28, 0.41, 1),
	            v4(19.95, -6.04, 20.91, 1),
	            v4(24.69, -11.5, 59.13, 1),
	            v4(-10.17, -13.1, 150.65, 1),
	            v4(-49.03, -1.2, 182.28, 1),
	            v4(-42.7, 20.55, 141.16, 1),
	            v4(-21.69, 40.71, 14.79, 1),
	            v4(-20.55, 40.37, -6.94, 1),
	            v4(-1.24, 33.18, -7.9, 1),
	            v4(7.77, 26.94, -5.33, 1),
	            v4(10.97, 24.94, -4.48, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["155"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["155"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_41_4_v60";
	Curves["156"] = function () {
	    var Curve_v01 = [[v4(-16.75, 11.13, -39.13, 1),
	            v4(-25.78, 10.4, -35.75, 1),
	            v4(-48.67, 9.27, -27.58, 1),
	            v4(-87.44, 7.73, -6.23, 1),
	            v4(-94.55, 7.84, 28.01, 1),
	            v4(-15.84, -17.81, 109.68, 1),
	            v4(36.73, 10.28, 126.59, 1),
	            v4(90.4, 78.37, 72.19, 1),
	            v4(77.38, 31.86, -14.12, 1),
	            v4(59.96, 42.28, -40.22, 1),
	            v4(33.77, 29.76, -36.35, 1),
	            v4(22.77, 20.33, -31.27, 1),
	            v4(19.37, 17.18, -29.49, 1),
	        ], [v4(-14.39, 7.83, -38.25, 1),
	            v4(-23.21, 6.87, -34.84, 1),
	            v4(-45.52, 4.78, -26.6, 1),
	            v4(-83.4, -3.7, -5.25, 1),
	            v4(-91.05, -7.33, 29.07, 1),
	            v4(-15.52, -25.31, 109.71, 1),
	            v4(41.88, -6.93, 127.2, 1),
	            v4(97.66, 32.38, 79.48, 1),
	            v4(82.65, 21.32, -3.96, 1),
	            v4(68.43, 33.68, -36.05, 1),
	            v4(42.64, 24.83, -37.47, 1),
	            v4(27.31, 17.87, -33.68, 1),
	            v4(22.06, 15.35, -32.42, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["156"].animation = [[1780, 1], [1867, -1], [2085, -1], [2126, -1], [2396, -1], [2396.005, 1], [2483, -1], [2575, -1], [2575.005, -1], [2623, -1], [2799, -1], [2799.005, -1], [2847, -1], [3225, -1], [3225.005, -1], [3273, -1], [3449, -1], [3449.005, -1], [3497, -1], [6805, -1], [7052, -1]];
	Curves["156"].divisions = "|MAEmodelsPrevis|ExplosionAsecond_25200_1_2_124_202_247_100_200_100_100_50_20|_41_4_v61";
	Curves.numCurves = 157;
	Curves["157"] = function () {
	    var Curve_v01 = [[v4(0.47, 75.69, -98.62, 1),
	            v4(-3.25, 73.95, -98.55, 1),
	            v4(-16.48, 68.06, -98.44, 1),
	            v4(-32.81, 64.26, -98.46, 1),
	            v4(-41.9, 67.15, -98.66, 1),
	            v4(-46.03, 73.97, -98.98, 1),
	            v4(-44.86, 82.4, -99.3, 1),
	            v4(-38.83, 89.22, -99.51, 1),
	            v4(-31.5, 91.16, -99.54, 1),
	            v4(-26.84, 91.34, -99.53, 1),
	        ], [v4(6.14, 77, -96.02, 1),
	            v4(-0.14, 50.89, -96.01, 1),
	            v4(-33.19, 25.31, -96.03, 1),
	            v4(-72.97, 32.83, -95.93, 1),
	            v4(-103.83, 47.59, -95.64, 1),
	            v4(-117.68, 74.2, -95.28, 1),
	            v4(-107.55, 102.04, -95.06, 1),
	            v4(-75.22, 118.71, -95.1, 1),
	            v4(-29.85, 111.12, -95.23, 1),
	            v4(-11.94, 96.31, -95.27, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["157"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["157"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v348";
	Curves["158"] = function () {
	    var Curve_v01 = [[v4(1.89, 76.11, -92.49, 1),
	            v4(-2.08, 67.78, -90.68, 1),
	            v4(-6.91, 65.61, -89.24, 1),
	            v4(-16.46, 64.74, -92.22, 1),
	            v4(-24.73, 66.59, -94.34, 1),
	            v4(-36.74, 72.72, -92.3, 1),
	            v4(-31.9, 87.01, -89.94, 1),
	            v4(-22.87, 91.12, -87.27, 1),
	            v4(-19.02, 93.8, -86.29, 1),
	            v4(-10.79, 89.03, -87.71, 1),
	        ], [v4(-0.61, 60.11, -93.81, 1),
	            v4(-3.66, 50.11, -91.92, 1),
	            v4(-21.99, 13.16, -81.98, 1),
	            v4(-86.77, 9.92, -68.77, 1),
	            v4(-130.07, 57.58, -63.28, 1),
	            v4(-127.55, 111.22, -64.62, 1),
	            v4(-97.17, 137.08, -70.85, 1),
	            v4(-51.99, 134.22, -81.59, 1),
	            v4(-23.42, 112.85, -90.68, 1),
	            v4(-13.84, 97.33, -95.15, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["158"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["158"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v349";
	Curves["159"] = function () {
	    var Curve_v01 = [[v4(-18.98, 101.26, -96.13, 1),
	            v4(-28.16, 110.35, -92.09, 1),
	            v4(-54.34, 124.66, -82, 1),
	            v4(-104.38, 132.16, -65.15, 1),
	            v4(-154.42, 108.86, -50.83, 1),
	            v4(-181.3, 54.09, -42.73, 1),
	            v4(-174.67, 3.95, -42.97, 1),
	            v4(-144.74, -23.77, -51.34, 1),
	            v4(-102, -29.18, -65.36, 1),
	            v4(-54.46, -16.48, -81.33, 1),
	            v4(-13.3, 12.93, -95.58, 1),
	            v4(3.73, 41.4, -101.86, 1),
	            v4(8.36, 57.18, -103.76, 1),
	        ], [v4(-1.74, 78.25, -99.27, 1),
	            v4(-11.69, 85.49, -97.09, 1),
	            v4(-29.3, 96.35, -93.21, 1),
	            v4(-49.88, 101.74, -89.39, 1),
	            v4(-65.37, 96.85, -87.87, 1),
	            v4(-74.24, 83.95, -88.8, 1),
	            v4(-73.23, 67.57, -91.95, 1),
	            v4(-61.83, 53.19, -96.23, 1),
	            v4(-44.41, 45.37, -99.91, 1),
	            v4(-26.67, 46.41, -101.79, 1),
	            v4(-11.91, 56.07, -101.99, 1),
	            v4(-5.26, 66.76, -101.69, 1),
	            v4(-3.12, 72.62, -101.64, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["159"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["159"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v350";
	Curves["160"] = function () {
	    var Curve_v01 = [[v4(-8.99, 102.65, -88.6, 1),
	            v4(-23.45, 120.45, -81.95, 1),
	            v4(-62.06, 146.51, -64.76, 1),
	            v4(-134.97, 157.28, -33.65, 1),
	            v4(-205.92, 141.71, -4.37, 1),
	            v4(-256.01, 105.52, 15.66, 1),
	            v4(-269.94, 58.96, 20.67, 1),
	            v4(-243.15, 14.66, 9.04, 1),
	            v4(-186.21, -19.41, -15.8, 1),
	            v4(-110.54, -40.63, -46.97, 1),
	            v4(34.12, -15.64, -76.95, 1),
	            v4(32.78, 44.51, -91.93, 1),
	            v4(11.68, 62.82, -97.34, 1),
	        ], [v4(-0.8, 84.8, -131.16, 1),
	            v4(-5.04, 88.61, -130.31, 1),
	            v4(-15.61, 92.65, -128.1, 1),
	            v4(-34.19, 91.43, -124.18, 1),
	            v4(-51.31, 85.98, -120.72, 1),
	            v4(-62.62, 78.58, -118.63, 1),
	            v4(-65.12, 70.82, -118.32, 1),
	            v4(-58.73, 63.96, -119.45, 1),
	            v4(-46.1, 59.26, -121.27, 1),
	            v4(-30.67, 58.28, -123.37, 1),
	            v4(-14.51, 63.02, -126.14, 1),
	            v4(-3.24, 71.68, -129.21, 1),
	            v4(2.74, 77.86, -131.31, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["160"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["160"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v351";
	Curves["161"] = function () {
	    var Curve_v01 = [[v4(-32.42, 90.19, -113.95, 1),
	            v4(-33.61, 93.98, -114.01, 1),
	            v4(-35.09, 102.46, -114.13, 1),
	            v4(-32.27, 114.95, -114.23, 1),
	            v4(-23.84, 123.09, -114.26, 1),
	            v4(-12.65, 127.03, -114.26, 1),
	            v4(-0.27, 127.52, -114.23, 1),
	            v4(12.78, 121.52, -114.1, 1),
	            v4(19.19, 115.69, -113.98, 1),
	            v4(21.71, 112.99, -113.92, 1),
	        ], [v4(-11.15, 80.06, -119.72, 1),
	            v4(-59.53, 71, -119.95, 1),
	            v4(-98.73, 112.81, -120.89, 1),
	            v4(-92.51, 164.85, -122.28, 1),
	            v4(-72.12, 196.78, -123.5, 1),
	            v4(-44.26, 211.14, -124.45, 1),
	            v4(-14.91, 212.18, -125.27, 1),
	            v4(28.88, 187.36, -126.02, 1),
	            v4(37.06, 137.75, -126.22, 1),
	            v4(29.94, 119.6, -126.22, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["161"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["161"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v354";
	Curves["162"] = function () {
	    var Curve_v01 = [[v4(-16.31, 91.1, -123.26, 1),
	            v4(-24.76, 92.43, -123.44, 1),
	            v4(-35.1, 105.56, -123.75, 1),
	            v4(-30.04, 123.73, -123.81, 1),
	            v4(-18.71, 134.56, -123.56, 1),
	            v4(-5.9, 139.7, -123.13, 1),
	            v4(8.2, 139.58, -122.57, 1),
	            v4(19.59, 131.72, -121.63, 1),
	            v4(19.18, 115.49, -121.02, 1),
	            v4(15.85, 108.19, -120.86, 1),
	        ], [v4(-18.41, 87.74, -132.49, 1),
	            v4(-51.28, 77.76, -131.17, 1),
	            v4(-156.64, 101.09, -128.49, 1),
	            v4(-172.31, 221.79, -127.47, 1),
	            v4(-126.59, 272.22, -128.78, 1),
	            v4(-55.39, 289.38, -131.34, 1),
	            v4(29.09, 261.98, -135.29, 1),
	            v4(64.5, 142.95, -140.52, 1),
	            v4(25.76, 99.86, -142.78, 1),
	            v4(19.04, 90.04, -143.16, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["162"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["162"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v355";
	Curves["163"] = function () {
	    var Curve_v01 = [[v4(44.71, 53.7, -93.99, 1),
	            v4(51.79, 51.43, -92.76, 1),
	            v4(82.6, 48.65, -87.43, 1),
	            v4(123.82, 55.47, -80.3, 1),
	            v4(163.58, 94.18, -73.42, 1),
	            v4(146.31, 161.64, -76.41, 1),
	            v4(98.07, 177.6, -84.75, 1),
	            v4(53.25, 164.26, -92.73, 1),
	            v4(19.53, 157.73, -101.2, 1),
	            v4(8.47, 159.56, -102.5, 1),
	        ], [v4(25.04, 71.45, -86.73, 1),
	            v4(27.93, 71.05, -85.76, 1),
	            v4(31.88, 70.26, -84.44, 1),
	            v4(39.57, 74.14, -81.86, 1),
	            v4(48.56, 85.31, -78.85, 1),
	            v4(43.72, 103.2, -80.67, 1),
	            v4(35.09, 115.96, -83.46, 1),
	            v4(29.52, 126.65, -85.06, 1),
	            v4(21.31, 131.59, -87.88, 1),
	            v4(20.2, 132.29, -88.26, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["163"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["163"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v357";
	Curves["164"] = function () {
	    var Curve_v01 = [[v4(13.54, 70.13, -95.14, 1),
	            v4(20.12, 54.16, -87.95, 1),
	            v4(39.41, 10.45, -67.82, 1),
	            v4(149.24, -26.8, -30.48, 1),
	            v4(253.28, 20.8, -4.24, 1),
	            v4(266.26, 118.52, -15.65, 1),
	            v4(200, 170.3, -47.91, 1),
	            v4(106.85, 192.62, -87.48, 1),
	            v4(47.92, 164.79, -106.28, 1),
	            v4(38.4, 154.93, -108.55, 1),
	        ], [v4(28.67, 63.3, -98.69, 1),
	            v4(34.02, 60.27, -95.88, 1),
	            v4(48.1, 58.57, -88.28, 1),
	            v4(69.16, 64.48, -76.28, 1),
	            v4(80.62, 84.64, -69.29, 1),
	            v4(74.62, 119.49, -73.37, 1),
	            v4(57.96, 128.9, -87.96, 1),
	            v4(41.52, 125.51, -101.41, 1),
	            v4(22.74, 108.31, -106.93, 1),
	            v4(14.54, 102.47, -107.24, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["164"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["164"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v358";
	Curves["165"] = function () {
	    var Curve_v01 = [[v4(57.2, 48.11, -82.34, 1),
	            v4(82.3, 48.01, -70.73, 1),
	            v4(149.44, 49.72, -35.51, 1),
	            v4(273.9, 125.19, 50.28, 1),
	            v4(322.84, 244.57, 96.17, 1),
	            v4(260.45, 343.83, 81.85, 1),
	            v4(130.7, 339.29, 14.66, 1),
	            v4(19.43, 254.62, -65.66, 1),
	            v4(-8.89, 165.44, -95.91, 1),
	            v4(-11.16, 148.82, -99.12, 1),
	        ], [v4(-0.03, 70.42, -96.16, 1),
	            v4(3.63, 69.53, -94.51, 1),
	            v4(12.81, 66.96, -90.39, 1),
	            v4(31.45, 71.46, -82.02, 1),
	            v4(45.64, 85.3, -75.65, 1),
	            v4(40.15, 104.73, -78.12, 1),
	            v4(21.09, 109.29, -86.67, 1),
	            v4(2.35, 102.69, -95.09, 1),
	            v4(-5.49, 91.72, -98.6, 1),
	            v4(-6.42, 89.21, -99.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["165"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["165"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v359";
	Curves["166"] = function () {
	    var Curve_v01 = [[v4(-27.02, 92.01, -107.55, 1),
	            v4(-27.17, 94.42, -107.57, 1),
	            v4(-26.65, 99.46, -107.61, 1),
	            v4(-24.22, 106.59, -107.65, 1),
	            v4(-17.97, 111.82, -107.67, 1),
	            v4(-9.68, 113.86, -107.68, 1),
	            v4(-2.06, 112.72, -107.67, 1),
	            v4(3.97, 109.65, -107.65, 1),
	            v4(8.67, 103.26, -107.57, 1),
	            v4(9.19, 97.63, -107.67, 1),
	        ], [v4(-35.97, 86.93, -106.13, 1),
	            v4(-39.43, 89.37, -105.59, 1),
	            v4(-46.28, 99.15, -104.36, 1),
	            v4(-46.42, 127.77, -103.93, 1),
	            v4(-35.39, 145.34, -104.64, 1),
	            v4(-17.09, 146.92, -106.24, 1),
	            v4(9.21, 140.63, -108.26, 1),
	            v4(15.51, 109.29, -106.39, 1),
	            v4(15.27, 90.55, -106.86, 1),
	            v4(12.95, 85.45, -107.19, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["166"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["166"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v353";
	Curves["167"] = function () {
	    var Curve_v01 = [[v4(39.19, 61.19, -99.09, 1),
	            v4(47.17, 59.22, -99.09, 1),
	            v4(74.98, 60.18, -99.09, 1),
	            v4(103.87, 95.02, -99.09, 1),
	            v4(87, 132.24, -99.09, 1),
	            v4(42.19, 130.82, -99.09, 1),
	            v4(23.4, 127.64, -99.09, 1),
	        ], [v4(33.2, 72.88, -99.09, 1),
	            v4(34.29, 72.91, -99.09, 1),
	            v4(38.47, 75.55, -99.09, 1),
	            v4(42.55, 91.03, -99.09, 1),
	            v4(40.69, 107.07, -99.09, 1),
	            v4(36.95, 109.99, -99.09, 1),
	            v4(33.29, 110.22, -99.09, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["167"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["167"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v356";
	Curves["168"] = function () {
	    var Curve_v01 = [[v4(-24.63, 94.82, -99.14, 1),
	            v4(-23.65, 97.13, -99.17, 1),
	            v4(-21.04, 101.64, -99.3, 1),
	            v4(-15.42, 106.56, -99.7, 1),
	            v4(-8.65, 108.06, -100.15, 1),
	            v4(-2.53, 105.87, -100.36, 1),
	            v4(1.58, 101.44, -100.16, 1),
	            v4(3.76, 96.3, -99.62, 1),
	            v4(4.42, 92.89, -99.13, 1),
	            v4(4.6, 91.25, -98.88, 1),
	        ], [v4(-26.62, 102.93, -98.93, 1),
	            v4(-25.94, 105.25, -98.96, 1),
	            v4(-23.48, 110.46, -99.13, 1),
	            v4(-16.3, 117.47, -99.82, 1),
	            v4(-6.28, 120.48, -100.85, 1),
	            v4(3.57, 118.39, -101.74, 1),
	            v4(10.58, 112.18, -102, 1),
	            v4(13.54, 104.35, -101.47, 1),
	            v4(13.73, 99.67, -100.81, 1),
	            v4(13.57, 97.6, -100.46, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["168"].animation = [[3234, 1], [3362, 0.3401777634], [3651, 0.8477064408], [3742, -0.1350515804], [3933, 0.7109480198], [4038, -0.2208735937], [4151, -0.2324805238], [4389, -1]];
	Curves["168"].divisions = "|MAEmodelsPrevis|RibbonMagnetWaves_4000_1_1_99_134_181_200_200_100_100_100_20|_29_4_v352";
	Curves.numCurves = 169;
	Curves["169"] = function () {
	    var Curve_v01 = [[v4(57.29, 260.14, -445.83, 1),
	            v4(-10.11, 267.3, -469.07, 1),
	            v4(-113.24, 285.32, -445.64, 1),
	            v4(-132, 316.02, -307.16, 1),
	            v4(4.31, 308.07, -241.9, 1),
	            v4(119.87, 267.14, -286.98, 1),
	            v4(131.11, 227.26, -432.01, 1),
	            v4(30.94, 231.9, -500.93, 1),
	            v4(-65.95, 254.55, -497.62, 1),
	            v4(-109.69, 273.35, -468.18, 1),
	        ], [v4(72.37, 215.36, -480.89, 1),
	            v4(-29.73, 225.13, -515.58, 1),
	            v4(-185.57, 246.03, -480.1, 1),
	            v4(-212.15, 277.77, -272.06, 1),
	            v4(-5.06, 265.5, -174.55, 1),
	            v4(169.09, 219.65, -242.82, 1),
	            v4(184.94, 180.21, -460.76, 1),
	            v4(32.14, 187.51, -563.58, 1),
	            v4(-114.64, 213.14, -558.25, 1),
	            v4(-180.54, 233.45, -513.94, 1),
	        ], [v4(41.64, 177.03, -434.11, 1),
	            v4(-25.99, 188.83, -456.79, 1),
	            v4(-129.05, 210.82, -433.13, 1),
	            v4(-145.29, 240.62, -296.48, 1),
	            v4(-7.75, 224.76, -232.83, 1),
	            v4(106.91, 177.58, -277.85, 1),
	            v4(116.25, 141.23, -421.05, 1),
	            v4(14.6, 151.89, -488.43, 1),
	            v4(-82.56, 178.72, -484.65, 1),
	            v4(-125.98, 198.74, -455.36, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["169"].animation = [[4300, -1], [4336, -0.6635958119], [4458, -0.1569129607], [5457, 0.1740970978], [5528, 1]];
	Curves["169"].divisions = "|MAEmodelsPrevis|colorGalaxyCenter_750_1_3_240_239_196_200_1000_1000_100_100_20|_29_9_v1";
	Curves["170"] = function () {
	    var Curve_v01 = [[v4(5.38, 280.14, -409.96, 1),
	            v4(-30.61, 284.05, -412.18, 1),
	            v4(-63.23, 304.47, -343.78, 1),
	            v4(16.49, 296.35, -293.12, 1),
	            v4(80.17, 268.51, -338.8, 1),
	            v4(41.26, 257.51, -423.21, 1),
	            v4(-35.13, 277.04, -423.76, 1),
	            v4(-88.2, 295.94, -366.28, 1),
	            v4(-54.95, 305.56, -316.57, 1),
	            v4(-20.83, 305.11, -303.53, 1),
	        ], [v4(-2.71, 257.94, -427.96, 1),
	            v4(-56.41, 263.11, -431.16, 1),
	            v4(-104.2, 284.99, -329.69, 1),
	            v4(15.23, 273.4, -254.79, 1),
	            v4(109.5, 242.28, -322.72, 1),
	            v4(50.54, 232.97, -447.68, 1),
	            v4(-63.39, 255.79, -448.3, 1),
	            v4(-141.99, 276.32, -362.93, 1),
	            v4(-91.51, 285.65, -289.35, 1),
	            v4(-40.4, 284.19, -270.14, 1),
	        ], [v4(-5.75, 236.16, -401.43, 1),
	            v4(-41.68, 242.36, -403.5, 1),
	            v4(-73.1, 263.45, -335.9, 1),
	            v4(7.22, 249.37, -286.25, 1),
	            v4(69.91, 217.98, -331.54, 1),
	            v4(29.87, 211.6, -414.66, 1),
	            v4(-46.42, 235.7, -414.91, 1),
	            v4(-98.63, 255.97, -357.93, 1),
	            v4(-64.32, 263.71, -309.11, 1),
	            v4(-30.06, 261.02, -296.39, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["170"].animation = [[4300, -1], [4336, -0.6635958119], [4458, -0.1569129607], [5457, 0.1740970978], [5528, 1]];
	Curves["170"].divisions = "|MAEmodelsPrevis|colorGalaxyCenter_750_1_3_240_239_196_200_1000_1000_100_100_20|_29_9_v2";
	Curves["171"] = function () {
	    var Curve_v01 = [[v4(-5.11, 293.82, -379.53, 1),
	            v4(-13.66, 297.95, -371.06, 1),
	            v4(-0.68, 302.15, -338.03, 1),
	            v4(41.41, 287.13, -342.88, 1),
	            v4(32.98, 275.16, -392.32, 1),
	            v4(-7.4, 282.44, -402.01, 1),
	            v4(-28.48, 299.92, -365.1, 1),
	            v4(-4.31, 302.47, -329.92, 1),
	            v4(23.22, 295.52, -328.62, 1),
	            v4(32.41, 291.95, -335.95, 1),
	        ], [v4(-18.88, 276.84, -386.51, 1),
	            v4(-32.71, 281.46, -372.72, 1),
	            v4(-11.04, 285.12, -319.02, 1),
	            v4(57.43, 267.4, -326.96, 1),
	            v4(43.02, 255.65, -407.37, 1),
	            v4(-23.06, 264.89, -423.04, 1),
	            v4(-56.89, 283.89, -362.99, 1),
	            v4(-16.9, 285.45, -305.81, 1),
	            v4(27.98, 276.92, -303.74, 1),
	            v4(42.87, 272.81, -315.68, 1),
	        ], [v4(-14.38, 254.65, -372.39, 1),
	            v4(-22.74, 259.22, -364.01, 1),
	            v4(-9.3, 261.83, -331.47, 1),
	            v4(32.38, 243.54, -336.36, 1),
	            v4(23.31, 233.5, -385.14, 1),
	            v4(-17.01, 243.86, -394.58, 1),
	            v4(-37.39, 262.06, -358.09, 1),
	            v4(-12.77, 262.29, -323.47, 1),
	            v4(14.55, 253.11, -322.25, 1),
	            v4(23.55, 248.91, -329.5, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["171"].animation = [[4300, -1], [4336, -0.6635958119], [4458, -0.1569129607], [5457, 0.1740970978], [5528, 1]];
	Curves["171"].divisions = "|MAEmodelsPrevis|colorGalaxyCenter_750_1_3_240_239_196_200_1000_1000_100_100_20|_29_9_v3";
	Curves.numCurves = 172;
	Curves["172"] = function () {
	    var Curve_v01 = [[v4(-171.76, 326.26, -345.19, 1),
	            v4(-181.75, 327.19, -303.95, 1),
	            v4(-128.02, 325.23, -234.9, 1),
	            v4(-33.81, 302.83, -161.65, 1),
	            v4(94.8, 282.92, -176.29, 1),
	            v4(186.44, 267.13, -263.12, 1),
	            v4(199.73, 249.17, -380.9, 1),
	            v4(143.87, 230.7, -495.95, 1),
	            v4(72.11, 229.3, -537.4, 1),
	            v4(30.07, 235.53, -539.47, 1),
	        ], [v4(-255.44, 289.9, -331.79, 1),
	            v4(-269.11, 290.9, -273.44, 1),
	            v4(-191.5, 287.55, -175.93, 1),
	            v4(-55.28, 263.29, -73.05, 1),
	            v4(129.46, 243.03, -94.99, 1),
	            v4(260.38, 228.38, -218.71, 1),
	            v4(277.81, 210.2, -385.13, 1),
	            v4(196.09, 191.66, -547.01, 1),
	            v4(92.11, 189.73, -604.83, 1),
	            v4(31.41, 195.58, -607.36, 1),
	        ], [v4(-184.46, 240.74, -335.58, 1),
	            v4(-193.9, 240.91, -294.79, 1),
	            v4(-138.1, 237.67, -227.18, 1),
	            v4(-41.77, 211.69, -155.7, 1),
	            v4(88.09, 189.55, -171.33, 1),
	            v4(179.59, 174.16, -257.85, 1),
	            v4(190.63, 156.96, -373.89, 1),
	            v4(131.44, 140.04, -486.56, 1),
	            v4(57.65, 139.59, -526.71, 1),
	            v4(15.06, 146.56, -528.42, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["172"].animation = [[4257, -1], [4460, -0.1569129607], [5457, 0.2760017861], [5497, 1]];
	Curves["172"].divisions = "|MAEmodelsPrevis|colorGalaxyCenterFade_250_1_1_240_239_196_200_1000_1000_100_100_20|_29_9_v5";
	Curves.numCurves = 173;
	Curves["173"] = function () {
	    var Curve_v01 = [[v4(-1.03, 248.04, -581.08, 1),
	            v4(-67.09, 250.09, -588.05, 1),
	            v4(-184.58, 264.14, -548.05, 1),
	            v4(-286.25, 287.54, -407.63, 1),
	            v4(-278.61, 290.4, -238.91, 1),
	            v4(-126.25, 276.77, -116.91, 1),
	            v4(68.41, 269.38, -78.26, 1),
	            v4(249.2, 273.89, -164.35, 1),
	            v4(313.76, 274.43, -259.08, 1),
	            v4(330.71, 272.82, -310.29, 1),
	        ], [v4(-22.1, 202.65, -644, 1),
	            v4(-111.41, 205.8, -652.96, 1),
	            v4(-269.46, 221.37, -599.31, 1),
	            v4(-404.37, 245.54, -412.05, 1),
	            v4(-390.72, 247.4, -187.46, 1),
	            v4(-181.69, 231.06, -26.14, 1),
	            v4(84.68, 224.33, 23.13, 1),
	            v4(328.8, 230.35, -93.19, 1),
	            v4(414.1, 230.99, -219.59, 1),
	            v4(436.02, 229.56, -287.76, 1),
	        ], [v4(-40.47, 143.22, -555.66, 1),
	            v4(-104.82, 151.61, -559.16, 1),
	            v4(-212.13, 178.92, -515.99, 1),
	            v4(-293.13, 216.4, -377.85, 1),
	            v4(-268.03, 223.05, -217.71, 1),
	            v4(-107.57, 201.55, -110.28, 1),
	            v4(86.77, 181.03, -85.22, 1),
	            v4(255.48, 167.44, -177.91, 1),
	            v4(308.08, 157.02, -271.05, 1),
	            v4(318.62, 151.09, -320.12, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["173"].animation = [[4257, -1], [4460, -0.1569129607], [5457, 0.2760017861], [5497, 1]];
	Curves["173"].divisions = "|MAEmodelsPrevis|colorGalaxy_250_1_1_240_239_151_200_1000_700_100_100_10|_29_9_v4";
	Curves["174"] = function () {
	    var Curve_v01 = [[v4(-193.82, 341, -344.28, 1),
	            v4(-205.06, 341.81, -299.55, 1),
	            v4(-144.6, 340.09, -224.66, 1),
	            v4(-38.58, 320.48, -145.21, 1),
	            v4(106.16, 303.05, -161.09, 1),
	            v4(209.28, 289.23, -255.26, 1),
	            v4(224.24, 273.51, -383, 1),
	            v4(161.38, 257.33, -507.77, 1),
	            v4(80.62, 256.11, -552.74, 1),
	            v4(33.31, 261.56, -554.98, 1),
	        ], [v4(-288.43, 286.2, -328.92, 1),
	            v4(-303.81, 287.08, -265.63, 1),
	            v4(-216.47, 284.15, -159.88, 1),
	            v4(-63.18, 262.91, -48.29, 1),
	            v4(144.71, 245.17, -72.09, 1),
	            v4(292.04, 232.35, -206.26, 1),
	            v4(311.66, 216.43, -386.76, 1),
	            v4(219.7, 200.2, -562.33, 1),
	            v4(102.68, 198.5, -625.03, 1),
	            v4(34.37, 203.63, -627.77, 1),
	        ], [v4(-208.1, 223.36, -333.85, 1),
	            v4(-218.73, 223.5, -289.61, 1),
	            v4(-155.94, 220.67, -216.28, 1),
	            v4(-47.53, 197.92, -138.76, 1),
	            v4(98.6, 178.54, -155.71, 1),
	            v4(201.58, 165.06, -249.54, 1),
	            v4(214, 150, -375.4, 1),
	            v4(147.39, 135.19, -497.6, 1),
	            v4(64.35, 134.79, -541.14, 1),
	            v4(16.42, 140.9, -543, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["174"].animation = [[4257, -1], [4460, -0.1569129607], [5457, 0.2760017861], [5497, 1]];
	Curves["174"].divisions = "|MAEmodelsPrevis|colorGalaxy_250_1_1_240_239_151_200_1000_700_100_100_10|_29_9_v11";
	Curves["175"] = function () {
	    var Curve_v01 = [[v4(342.81, 207.92, -580.08, 1),
	            v4(203.49, 211.62, -660.38, 1),
	            v4(-10.6, 209.35, -680.59, 1),
	            v4(-254.35, 233.04, -663.44, 1),
	            v4(-462.27, 269.12, -600.47, 1),
	            v4(-605.56, 283.14, -480.58, 1),
	            v4(-647.14, 257.4, -316.9, 1),
	            v4(-631.99, 211.82, -149.03, 1),
	            v4(-544.77, 164.89, -52.25, 1),
	            v4(-484.16, 141.85, -16.44, 1),
	        ], [v4(482.29, 270.2, -666.21, 1),
	            v4(301.22, 273.21, -776.32, 1),
	            v4(19.35, 270.86, -805.48, 1),
	            v4(-304.56, 293.45, -784.04, 1),
	            v4(-584.48, 326.3, -700, 1),
	            v4(-779.83, 338.65, -538.43, 1),
	            v4(-839.31, 314.8, -316.81, 1),
	            v4(-825.68, 266.03, -88.31, 1),
	            v4(-711.64, 218.86, 43.67, 1),
	            v4(-631.15, 196.3, 92.54, 1),
	        ], [v4(370.57, 320.64, -596.01, 1),
	            v4(241.28, 326.03, -680.54, 1),
	            v4(35, 323.24, -703.84, 1),
	            v4(-204.09, 342.78, -688.49, 1),
	            v4(-411.91, 373.1, -625.57, 1),
	            v4(-557.96, 385.49, -504.39, 1),
	            v4(-604.9, 362.94, -338.13, 1),
	            v4(-596.69, 320.62, -166.93, 1),
	            v4(-514.9, 277.35, -67.38, 1),
	            v4(-456.86, 256.3, -30.22, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["175"].animation = [[4257, -1], [4460, -0.1569129607], [5457, 0.2760017861], [5497, 1]];
	Curves["175"].divisions = "|MAEmodelsPrevis|colorGalaxy_250_1_1_240_239_151_200_1000_700_100_100_10|_29_9_v6";
	Curves["176"] = function () {
	    var Curve_v01 = [[v4(229.23, 275.26, -368.14, 1),
	            v4(210.61, 258.43, -452.37, 1),
	            v4(91.99, 231.63, -592.27, 1),
	            v4(-209.84, 248.88, -568.71, 1),
	            v4(-316.39, 287.45, -325.29, 1),
	            v4(-101.52, 283.62, -124.76, 1),
	            v4(223.09, 320.2, -158.01, 1),
	            v4(329.46, 309.58, -385.8, 1),
	            v4(258.4, 271.54, -527.71, 1),
	            v4(155.27, 242.13, -573.55, 1),
	        ], [v4(390.01, 263.53, -360.19, 1),
	            v4(354.9, 244.82, -497.12, 1),
	            v4(149.88, 206.29, -723.14, 1),
	            v4(-348.26, 200.52, -682.73, 1),
	            v4(-513.83, 231.48, -284.5, 1),
	            v4(-151.34, 242.53, 41.32, 1),
	            v4(393.9, 317.41, -18.92, 1),
	            v4(562.44, 316.89, -391.72, 1),
	            v4(434.15, 266.43, -620.86, 1),
	            v4(257.25, 223.93, -693.62, 1),
	        ], [v4(241.64, 185.33, -359.03, 1),
	            v4(218.77, 169.05, -440.72, 1),
	            v4(89.74, 140.78, -575.09, 1),
	            v4(-218.35, 160.24, -548.93, 1),
	            v4(-316.94, 198.13, -309.89, 1),
	            v4(-88.83, 191.14, -116.7, 1),
	            v4(245.2, 234.94, -154.93, 1),
	            v4(345.64, 226.43, -378.49, 1),
	            v4(264.8, 183.9, -514.87, 1),
	            v4(155.88, 152.03, -557.76, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["176"].animation = [[4257, -1], [4460, -0.1569129607], [5457, 0.2760017861], [5497, 1]];
	Curves["176"].divisions = "|MAEmodelsPrevis|colorGalaxy_250_1_1_240_239_151_200_1000_700_100_100_10|_29_9_v7";
	Curves.numCurves = 177;
	Curves["177"] = function () {
	    var Curve_v01 = [[v4(252.07, 290.74, -430.21, 1),
	            v4(222.77, 281.23, -505.09, 1),
	            v4(88.9, 265.17, -611.78, 1),
	            v4(-185.17, 271.86, -576.76, 1),
	            v4(-341.83, 308.55, -407.73, 1),
	            v4(-282.1, 303.31, -171.43, 1),
	            v4(-39.9, 297.95, -59.76, 1),
	            v4(239.26, 340.46, -108.99, 1),
	            v4(344.77, 353.8, -228.64, 1),
	            v4(363.96, 342.89, -351.2, 1),
	        ], [v4(400.37, 257.78, -469.25, 1),
	            v4(351.74, 248.78, -588.8, 1),
	            v4(131.15, 231.3, -758.01, 1),
	            v4(-312.91, 240.1, -700.9, 1),
	            v4(-563.03, 280.43, -430.14, 1),
	            v4(-462.95, 271.58, -51.05, 1),
	            v4(-66.69, 264.01, 126.01, 1),
	            v4(386.98, 310.85, 44.47, 1),
	            v4(557.04, 328.03, -148.2, 1),
	            v4(586.2, 317.4, -344.53, 1),
	        ], [v4(309.25, 178.34, -440.49, 1),
	            v4(268.36, 169.13, -534.32, 1),
	            v4(89.15, 152.14, -666.89, 1),
	            v4(-265.65, 160.99, -620.27, 1),
	            v4(-463.26, 198.37, -405.6, 1),
	            v4(-379.51, 188.65, -107.59, 1),
	            v4(-61.1, 181.64, 30.38, 1),
	            v4(302.88, 227.75, -35.89, 1),
	            v4(438.08, 243.9, -188.41, 1),
	            v4(459.45, 233.75, -342.98, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["177"].animation = [[4257, -1], [4460, -0.1569129607], [5457, 0.2760017861], [5497, 1]];
	Curves["177"].divisions = "|MAEmodelsPrevis|colorGalaxyOuterRing_250_1_1_247_210_124_200_1000_300_100_100_20|_29_9_v9";
	Curves["178"] = function () {
	    var Curve_v01 = [[v4(-255.74, 310.6, -558.93, 1),
	            v4(-341.76, 337.89, -540.16, 1),
	            v4(-444.9, 356.52, -380.35, 1),
	            v4(-376.43, 334.36, -144, 1),
	            v4(-59.86, 300.6, -25.2, 1),
	            v4(294.61, 341.23, -54.87, 1),
	            v4(472.61, 374.8, -253.3, 1),
	            v4(495.41, 374.35, -487.55, 1),
	            v4(366, 341.6, -614.48, 1),
	            v4(251.97, 321.8, -636.9, 1),
	        ], [v4(-372.93, 232.16, -678.18, 1),
	            v4(-506.46, 259.22, -649.11, 1),
	            v4(-664.77, 273.53, -405.8, 1),
	            v4(-556.17, 244.64, -46.86, 1),
	            v4(-59.79, 214.06, 129.64, 1),
	            v4(490.59, 263.52, 80.34, 1),
	            v4(766.2, 308.29, -223.38, 1),
	            v4(791.38, 298.21, -577.23, 1),
	            v4(584.93, 258.22, -766.89, 1),
	            v4(411.58, 244.09, -800.37, 1),
	        ], [v4(-261.47, 178.72, -559.13, 1),
	            v4(-349.43, 204.38, -539.74, 1),
	            v4(-450.93, 216.38, -381.69, 1),
	            v4(-375.04, 186.71, -150.23, 1),
	            v4(-45.31, 158.83, -37.98, 1),
	            v4(320.69, 211.68, -72.48, 1),
	            v4(499.83, 252.1, -269.82, 1),
	            v4(512.07, 244.55, -498.37, 1),
	            v4(373.26, 209.87, -620.35, 1),
	            v4(257.45, 195.28, -641.32, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["178"].animation = [[4257, -1], [4460, -0.1569129607], [5457, 0.2760017861], [5497, 1]];
	Curves["178"].divisions = "|MAEmodelsPrevis|colorGalaxyOuterRing_250_1_1_247_210_124_200_1000_300_100_100_20|_29_9_v10";
	Curves.numCurves = 179;
	Curves["179"] = function () {
	    var Curve_v01 = [[v4(-0.84, 236.33, 2.95, 1),
	            v4(-1.12, 237.4, 3.45, 1),
	            v4(-1.42, 239.49, 4.76, 1),
	            v4(-1.01, 243.54, 7.05, 1),
	            v4(-0.35, 246.64, 9.34, 1),
	            v4(1.25, 254.84, 11.01, 1),
	            v4(1.97, 259.96, 10.32, 1),
	            v4(-0.46, 263.62, 9.71, 1),
	            v4(-1.68, 267.25, 9.26, 1),
	            v4(-2.8, 271, 9.08, 1),
	            v4(-4.53, 274.26, 9.14, 1),
	            v4(-6.06, 278.13, 9.5, 1),
	            v4(-4.2, 281.76, 10.15, 1),
	            v4(-1.41, 284.11, 10.44, 1),
	            v4(1.59, 286.26, 10.36, 1),
	            v4(4.62, 288.21, 9.56, 1),
	            v4(7.26, 290.1, 7.8, 1),
	            v4(9.53, 291.85, 5.49, 1),
	            v4(11.6, 293.56, 3.02, 1),
	            v4(13.69, 295.37, 0.58, 1),
	            v4(15.81, 297.31, -1.64, 1),
	            v4(18.38, 299.78, -3.06, 1),
	            v4(20.89, 302.43, -1.73, 1),
	            v4(22.39, 304.46, 0.98, 1),
	            v4(23.23, 305.88, 4.29, 1),
	            v4(23.48, 306.46, 7.94, 1),
	            v4(23.41, 306.41, 11.61, 1),
	            v4(23.09, 305.69, 15.22, 1),
	            v4(22.56, 304.14, 18.52, 1),
	            v4(21.65, 301.72, 21.22, 1),
	            v4(20.11, 298.59, 22.58, 1),
	            v4(18.99, 296.4, 22.7, 1),
	            v4(18.49, 295.28, 22.62, 1),
	        ], [v4(0.39, 236.33, 2.87, 1),
	            v4(0.01, 237.44, 3.13, 1),
	            v4(-0.43, 239.69, 4.1, 1),
	            v4(-0.66, 243.95, 5.83, 1),
	            v4(-0.79, 252.72, 7.75, 1),
	            v4(-2.07, 257.59, 7.42, 1),
	            v4(-3.72, 260.99, 5.74, 1),
	            v4(-5.28, 264.25, 4.35, 1),
	            v4(-7.08, 267.27, 2.88, 1),
	            v4(-8.93, 270.28, 1.57, 1),
	            v4(-10.81, 273.39, 0.33, 1),
	            v4(-12.61, 276.63, -0.65, 1),
	            v4(-14.02, 280.09, -0.94, 1),
	            v4(-14.81, 283.62, -0.29, 1),
	            v4(-15.15, 287.01, 1.02, 1),
	            v4(-15.13, 290.17, 2.84, 1),
	            v4(-14.73, 293.13, 4.96, 1),
	            v4(-13.17, 295.75, 7.05, 1),
	            v4(-10.68, 297.87, 8.69, 1),
	            v4(-7.7, 299.77, 9.73, 1),
	            v4(-4.52, 301.43, 10.01, 1),
	            v4(-1.17, 303.05, 10.07, 1),
	            v4(1.96, 304.56, 10.27, 1),
	            v4(5.34, 306.38, 11.58, 1),
	            v4(5.78, 307.17, 15.44, 1),
	            v4(4.93, 306.98, 18.93, 1),
	            v4(4.5, 306.37, 22.57, 1),
	            v4(5.59, 304.7, 25.8, 1),
	            v4(8.24, 302.34, 27.26, 1),
	            v4(11.07, 300.03, 26.95, 1),
	            v4(13.72, 297.76, 25.88, 1),
	            v4(15.28, 296.17, 24.88, 1),
	            v4(15.85, 295.26, 24.32, 1),
	        ], [v4(-0.26, 236.33, 3.41, 1),
	            v4(-0.64, 237.39, 3.85, 1),
	            v4(-1.05, 239.42, 5.1, 1),
	            v4(-0.97, 243.51, 7.32, 1),
	            v4(-0.66, 246.51, 9.68, 1),
	            v4(-0.1, 255.23, 11.08, 1),
	            v4(-0.94, 260.01, 9.52, 1),
	            v4(-3.01, 263.32, 8.47, 1),
	            v4(-4.78, 266.59, 7.33, 1),
	            v4(-6.48, 269.8, 6.4, 1),
	            v4(-8.39, 272.93, 5.66, 1),
	            v4(-10.48, 276.1, 5.14, 1),
	            v4(-11.4, 279.97, 5.18, 1),
	            v4(-10.04, 283.48, 5.92, 1),
	            v4(-8.04, 286.35, 6.61, 1),
	            v4(-5.68, 289.14, 6.88, 1),
	            v4(-3.44, 291.9, 6.18, 1),
	            v4(-1.04, 294.43, 5.22, 1),
	            v4(1.73, 296.66, 4.55, 1),
	            v4(4.71, 298.69, 4.22, 1),
	            v4(7.81, 300.55, 4.22, 1),
	            v4(10.94, 302.33, 4.69, 1),
	            v4(13.89, 304.08, 5.86, 1),
	            v4(16.26, 305.72, 8.25, 1),
	            v4(17.11, 306.61, 11.76, 1),
	            v4(16.89, 306.79, 15.38, 1),
	            v4(16.49, 306.58, 18.96, 1),
	            v4(16.21, 305.86, 22.53, 1),
	            v4(16.55, 304.45, 25.84, 1),
	            v4(17.63, 301.97, 28.52, 1),
	            v4(19.26, 298.55, 28.76, 1),
	            v4(19.99, 296.39, 27.94, 1),
	            v4(20.12, 295.27, 27.49, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["179"].animation = [[2442, 1], [2515, -1], [2515.01, 1], [5451, 1], [5577, 0.142960024], [6371, -0.334], [6557, -1]];
	Curves["179"].divisions = "|MAEmodelsPrevis|FlowerA_500_1_2_256_256_242_200_50_100_100_100_5|_121_9_v6";
	Curves["180"] = function () {
	    var Curve_v01 = [[v4(3.37, 236.94, -4.79, 1),
	            v4(3.56, 238.01, -5.12, 1),
	            v4(4.05, 240.17, -5.69, 1),
	            v4(4.86, 244.57, -6.18, 1),
	            v4(5.58, 253.14, -6.24, 1),
	            v4(5.09, 258.16, -6.52, 1),
	            v4(3.64, 261.7, -7.24, 1),
	            v4(1.99, 264.76, -8.27, 1),
	            v4(0.25, 267.7, -9.58, 1),
	            v4(-1.48, 270.34, -11.09, 1),
	            v4(-3.26, 272.92, -12.77, 1),
	            v4(-5.04, 275.54, -14.44, 1),
	            v4(-6.77, 278.29, -15.81, 1),
	            v4(-8.38, 281.23, -16.73, 1),
	            v4(-9.5, 284.51, -16.59, 1),
	            v4(-9.99, 287.72, -15.5, 1),
	            v4(-10.31, 290.87, -14.26, 1),
	            v4(-10.48, 293.99, -12.88, 1),
	            v4(-10.56, 297.06, -11.39, 1),
	            v4(-10.53, 299.78, -9.32, 1),
	            v4(-10.45, 302.12, -6.81, 1),
	            v4(-10.69, 304.34, -4.28, 1),
	            v4(-11.47, 306.73, -1.85, 1),
	            v4(-14.05, 308.89, -0.52, 1),
	            v4(-17.5, 309.58, -0.99, 1),
	            v4(-20.83, 309.59, -1.48, 1),
	            v4(-24.23, 308.91, -1.57, 1),
	            v4(-27.32, 307.6, -0.84, 1),
	            v4(-29.7, 305.63, 0.84, 1),
	            v4(-30.62, 303.42, 3.36, 1),
	            v4(-30.75, 301.21, 5.94, 1),
	            v4(-30.52, 299.66, 7.61, 1),
	            v4(-30.35, 298.81, 8.34, 1),
	        ], [v4(3.03, 236.63, -6.24, 1),
	            v4(3.07, 237.64, -6.7, 1),
	            v4(3.25, 239.71, -7.56, 1),
	            v4(3.66, 244.02, -8.42, 1),
	            v4(3.97, 252.56, -8.62, 1),
	            v4(2.94, 257.46, -8.75, 1),
	            v4(1.18, 260.77, -9.07, 1),
	            v4(-0.66, 263.77, -9.63, 1),
	            v4(-2.56, 266.75, -10.36, 1),
	            v4(-4.43, 269.51, -11.16, 1),
	            v4(-6.3, 272.37, -11.91, 1),
	            v4(-8.09, 275.38, -12.46, 1),
	            v4(-9.52, 278.62, -12.36, 1),
	            v4(-10.24, 281.82, -11.25, 1),
	            v4(-10.14, 284.55, -9.27, 1),
	            v4(-9.68, 286.94, -6.99, 1),
	            v4(-9.24, 289.3, -4.67, 1),
	            v4(-8.88, 291.72, -2.38, 1),
	            v4(-8.55, 294.24, -0.22, 1),
	            v4(-8.39, 296.84, 1.88, 1),
	            v4(-8.54, 299.37, 4.06, 1),
	            v4(-9.07, 301.81, 6.3, 1),
	            v4(-10.16, 304.18, 8.39, 1),
	            v4(-12.04, 306.38, 10.18, 1),
	            v4(-14.96, 307.9, 11.13, 1),
	            v4(-18.29, 308.46, 11.26, 1),
	            v4(-21.63, 308.36, 11.31, 1),
	            v4(-24.91, 307.64, 11.55, 1),
	            v4(-27.98, 306.39, 12.06, 1),
	            v4(-30.63, 304.46, 12.96, 1),
	            v4(-32.14, 301.76, 14.4, 1),
	            v4(-32.49, 299.75, 15.32, 1),
	            v4(-32.55, 298.68, 15.66, 1),
	        ], [v4(1.81, 236.33, -5.86, 1),
	            v4(1.67, 237.28, -6.32, 1),
	            v4(1.49, 239.22, -7.21, 1),
	            v4(1.36, 242.26, -8.18, 1),
	            v4(1.17, 246.57, -8.47, 1),
	            v4(0.06, 254.56, -8.39, 1),
	            v4(-1.53, 259.19, -8.25, 1),
	            v4(-3.11, 262.4, -8.21, 1),
	            v4(-4.7, 265.48, -8.24, 1),
	            v4(-6.21, 268.65, -8.18, 1),
	            v4(-7.59, 271.63, -7.83, 1),
	            v4(-8.73, 274.72, -7.06, 1),
	            v4(-9.27, 277.79, -5.62, 1),
	            v4(-9.12, 280.52, -3.62, 1),
	            v4(-8.53, 282.81, -1.35, 1),
	            v4(-7.64, 284.7, 1.09, 1),
	            v4(-6.66, 286.44, 3.58, 1),
	            v4(-5.75, 288.21, 6.09, 1),
	            v4(-4.97, 290.09, 8.56, 1),
	            v4(-4.32, 292.15, 10.92, 1),
	            v4(-3.83, 294.47, 13.08, 1),
	            v4(-3.87, 297.15, 14.9, 1),
	            v4(-4.79, 300, 16.13, 1),
	            v4(-6.25, 302.64, 17.21, 1),
	            v4(-8.1, 304.96, 18.44, 1),
	            v4(-10.51, 306.73, 19.68, 1),
	            v4(-13.55, 307.44, 20.69, 1),
	            v4(-16.73, 306.95, 21.13, 1),
	            v4(-19.7, 305.7, 21.1, 1),
	            v4(-22.27, 303.79, 20.55, 1),
	            v4(-24.1, 301.34, 19.49, 1),
	            v4(-24.92, 299.53, 18.73, 1),
	            v4(-25.23, 298.56, 18.39, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["180"].animation = [[2442, 1], [2515, -1], [2515.01, 1], [5451, 1], [5577, 0.142960024], [6371, -0.334], [6557, -1]];
	Curves["180"].divisions = "|MAEmodelsPrevis|FlowerA_500_1_2_256_256_242_200_50_100_100_100_5|_121_9_v7";
	Curves["181"] = function () {
	    var Curve_v01 = [[v4(0.9, 236.37, -5.77, 1),
	            v4(1.34, 237.42, -5.66, 1),
	            v4(2, 239.61, -5.45, 1),
	            v4(2.84, 244.04, -5.07, 1),
	            v4(4.28, 252.39, -4.61, 1),
	            v4(4.63, 257.43, -4.66, 1),
	            v4(4.02, 261.3, -5.2, 1),
	            v4(3.18, 264.8, -5.96, 1),
	            v4(2.24, 268.25, -6.95, 1),
	            v4(1.47, 271.49, -8.15, 1),
	            v4(1, 274.83, -9.5, 1),
	            v4(1.13, 278.27, -10.72, 1),
	            v4(1.87, 281.64, -11.72, 1),
	            v4(3.05, 284.82, -12.36, 1),
	            v4(4.52, 287.88, -12.88, 1),
	            v4(6.07, 290.8, -13.83, 1),
	            v4(7.52, 293.57, -15.24, 1),
	            v4(8.74, 296.34, -16.85, 1),
	            v4(9.55, 299.22, -18.55, 1),
	            v4(9.73, 302.28, -20.11, 1),
	            v4(8.86, 305.53, -21.12, 1),
	            v4(6.78, 308.34, -21.22, 1),
	            v4(4.09, 310.44, -20.81, 1),
	            v4(1.04, 312.07, -20.67, 1),
	            v4(-2.2, 313.1, -21.27, 1),
	            v4(-5.37, 313.49, -22.64, 1),
	            v4(-8.12, 313.22, -24.72, 1),
	            v4(-10.53, 312.43, -27.02, 1),
	            v4(-12.97, 311.09, -29.08, 1),
	            v4(-15.62, 309, -30.04, 1),
	            v4(-18.18, 306.67, -29.48, 1),
	            v4(-19.69, 305.31, -28.43, 1),
	            v4(-20.41, 304.7, -27.78, 1),
	        ], [v4(0.54, 237, -7.01, 1),
	            v4(0.92, 238.04, -7.05, 1),
	            v4(1.42, 240.21, -7.15, 1),
	            v4(1.92, 244.57, -7.31, 1),
	            v4(3.07, 252.92, -7.42, 1),
	            v4(2.76, 257.89, -8.11, 1),
	            v4(1.73, 261.38, -9.03, 1),
	            v4(0.71, 264.66, -10, 1),
	            v4(-0.26, 267.99, -11.02, 1),
	            v4(-1.03, 271.17, -12.01, 1),
	            v4(-1.56, 274.54, -12.89, 1),
	            v4(-1.65, 278.09, -13.25, 1),
	            v4(-1.28, 281.58, -12.93, 1),
	            v4(-0.7, 284.76, -11.95, 1),
	            v4(-0.02, 287.75, -10.67, 1),
	            v4(0.72, 290.86, -9.75, 1),
	            v4(1.3, 294.12, -9.37, 1),
	            v4(1.36, 297.46, -9.52, 1),
	            v4(0.57, 300.68, -10.04, 1),
	            v4(-1.12, 303.51, -10.61, 1),
	            v4(-3.35, 305.94, -11.11, 1),
	            v4(-5.91, 308.04, -11.41, 1),
	            v4(-8.68, 309.85, -11.69, 1),
	            v4(-11.58, 311.36, -12.31, 1),
	            v4(-14.46, 312.46, -13.62, 1),
	            v4(-17.11, 313.03, -15.57, 1),
	            v4(-19.41, 313.06, -17.99, 1),
	            v4(-21.32, 312.56, -20.68, 1),
	            v4(-23.08, 311.57, -23.32, 1),
	            v4(-24.85, 309.88, -25.63, 1),
	            v4(-26.74, 307.29, -26.82, 1),
	            v4(-27.99, 305.42, -26.57, 1),
	            v4(-28.61, 304.57, -26.2, 1),
	        ], [v4(0.01, 237.63, -6.21, 1),
	            v4(0.25, 238.69, -6.38, 1),
	            v4(0.42, 240.86, -6.77, 1),
	            v4(0.43, 245.17, -7.43, 1),
	            v4(0.88, 253.53, -8.16, 1),
	            v4(0.01, 258.29, -9.24, 1),
	            v4(-1.13, 261.64, -10.29, 1),
	            v4(-2.08, 264.94, -11.23, 1),
	            v4(-2.81, 268.4, -12.01, 1),
	            v4(-3.36, 271.72, -12.49, 1),
	            v4(-3.74, 275.21, -12.49, 1),
	            v4(-3.96, 278.64, -11.62, 1),
	            v4(-4.12, 281.74, -10.04, 1),
	            v4(-4.4, 284.35, -7.95, 1),
	            v4(-4.77, 286.67, -5.64, 1),
	            v4(-5.19, 288.98, -3.33, 1),
	            v4(-5.67, 291.42, -1.16, 1),
	            v4(-6.35, 294.06, 0.71, 1),
	            v4(-7.34, 296.94, 2.02, 1),
	            v4(-8.86, 299.83, 2.65, 1),
	            v4(-10.94, 302.41, 2.68, 1),
	            v4(-13.28, 304.71, 2.35, 1),
	            v4(-15.75, 306.84, 1.81, 1),
	            v4(-18.27, 308.82, 1.08, 1),
	            v4(-20.81, 310.61, -0.1, 1),
	            v4(-23.11, 311.99, -2.07, 1),
	            v4(-24.98, 312.73, -4.73, 1),
	            v4(-26.39, 312.68, -7.75, 1),
	            v4(-27.36, 311.8, -10.81, 1),
	            v4(-27.97, 310.08, -13.6, 1),
	            v4(-28.25, 307.5, -15.7, 1),
	            v4(-28.35, 305.5, -16.64, 1),
	            v4(-28.43, 304.45, -16.96, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["181"].animation = [[2442, 1], [2515, -1], [2515.01, 1], [5451, 1], [5577, 0.142960024], [6371, -0.334], [6557, -1]];
	Curves["181"].divisions = "|MAEmodelsPrevis|FlowerA_500_1_2_256_256_242_200_50_100_100_100_5|_121_9_v8";
	Curves["182"] = function () {
	    var Curve_v01 = [[v4(-1.26, 240.14, 10.33, 1),
	            v4(-1.18, 241.31, 10.62, 1),
	            v4(-0.93, 244.56, 11.14, 1),
	            v4(0.47, 253.7, 11.29, 1),
	            v4(2.12, 258.26, 10.27, 1),
	            v4(3.24, 261.7, 8.25, 1),
	            v4(4.67, 264.58, 6.12, 1),
	            v4(6.03, 267.42, 3.96, 1),
	            v4(7.31, 270.36, 1.93, 1),
	            v4(8.32, 273.63, 0.1, 1),
	            v4(9.12, 277.16, -1.25, 1),
	            v4(9.73, 280.84, -1.82, 1),
	            v4(10.08, 284.48, -1.61, 1),
	            v4(10.32, 288.07, -0.86, 1),
	            v4(10.97, 291.54, 0.04, 1),
	            v4(12.28, 294.95, 0.71, 1),
	            v4(14.45, 297.92, 0.35, 1),
	            v4(16.86, 300.49, -0.68, 1),
	            v4(19.22, 302.98, -1.85, 1),
	            v4(20.98, 305.82, -3.61, 1),
	            v4(20.61, 308.58, -6.19, 1),
	            v4(19.64, 310.27, -9.3, 1),
	            v4(18.81, 311.29, -12.72, 1),
	            v4(18.67, 311.83, -16.39, 1),
	            v4(19.79, 311.9, -19.91, 1),
	            v4(21.93, 311.55, -22.94, 1),
	            v4(23.98, 310.94, -25.77, 1),
	            v4(25.66, 309.75, -29.1, 1),
	            v4(24.14, 307.97, -32.23, 1),
	            v4(21.34, 306.54, -34.13, 1),
	            v4(18.3, 305.24, -35.68, 1),
	            v4(16.1, 304.49, -36.45, 1),
	            v4(15, 304.13, -36.81, 1),
	        ], [v4(-1.09, 239.55, 9.15, 1),
	            v4(-0.78, 240.65, 9.55, 1),
	            v4(-0.12, 243.58, 10.54, 1),
	            v4(1.65, 252.41, 11.59, 1),
	            v4(3.86, 256.71, 10.56, 1),
	            v4(5.03, 259.79, 8.18, 1),
	            v4(6.24, 262.38, 5.67, 1),
	            v4(7.4, 264.92, 3.13, 1),
	            v4(8.45, 267.49, 0.61, 1),
	            v4(9.24, 270.25, -1.89, 1),
	            v4(9.62, 273.13, -4.33, 1),
	            v4(9.59, 276.16, -6.49, 1),
	            v4(9.01, 279.44, -7.99, 1),
	            v4(7.86, 282.86, -8.61, 1),
	            v4(6.33, 286.16, -8.44, 1),
	            v4(5, 289.51, -8.18, 1),
	            v4(4.17, 293.08, -8.23, 1),
	            v4(4.4, 296.69, -8.95, 1),
	            v4(5.61, 299.86, -10.31, 1),
	            v4(7.12, 302.75, -11.88, 1),
	            v4(8.65, 305.47, -13.74, 1),
	            v4(9.63, 308.18, -15.96, 1),
	            v4(10.15, 310.49, -18.75, 1),
	            v4(10.53, 311.95, -22.08, 1),
	            v4(11.18, 312.74, -25.58, 1),
	            v4(12.45, 312.94, -28.99, 1),
	            v4(14.47, 312.63, -32.04, 1),
	            v4(16.47, 311.9, -34.9, 1),
	            v4(18.32, 310.62, -37.93, 1),
	            v4(17.85, 308.28, -40.92, 1),
	            v4(15.45, 306.06, -42.77, 1),
	            v4(13.63, 304.84, -43.63, 1),
	            v4(12.62, 304.25, -44.02, 1),
	        ], [v4(-1.12, 238.95, 5.29, 1),
	            v4(-0.74, 239.99, 5.67, 1),
	            v4(-0.01, 241.84, 6.71, 1),
	            v4(1.51, 245.77, 8.34, 1),
	            v4(3.72, 253.99, 7.78, 1),
	            v4(4.85, 257.81, 5.52, 1),
	            v4(5.76, 260.58, 3.11, 1),
	            v4(6.64, 263.14, 0.7, 1),
	            v4(7.42, 265.77, -1.67, 1),
	            v4(7.95, 268.34, -4.06, 1),
	            v4(8.04, 270.99, -6.5, 1),
	            v4(7.64, 273.74, -8.82, 1),
	            v4(6.66, 276.56, -10.78, 1),
	            v4(5.13, 279.33, -12.21, 1),
	            v4(3.15, 282.05, -13.01, 1),
	            v4(0.95, 284.67, -13.32, 1),
	            v4(-1.24, 287.3, -13.57, 1),
	            v4(-3.23, 290.07, -14.08, 1),
	            v4(-4.91, 292.97, -14.84, 1),
	            v4(-6.09, 296.07, -15.8, 1),
	            v4(-6.61, 299.28, -16.96, 1),
	            v4(-6.55, 302.42, -18.38, 1),
	            v4(-5.99, 305.39, -20.04, 1),
	            v4(-4.92, 308.16, -21.79, 1),
	            v4(-3.44, 310.67, -23.63, 1),
	            v4(-1.62, 312.62, -25.82, 1),
	            v4(0.39, 313.79, -28.4, 1),
	            v4(2.44, 313.99, -31.2, 1),
	            v4(4.31, 313.03, -33.98, 1),
	            v4(5.82, 310.9, -36.34, 1),
	            v4(6.61, 307.74, -37.67, 1),
	            v4(6.67, 305.5, -38.14, 1),
	            v4(6.54, 304.38, -38.34, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["182"].animation = [[2442, 1], [2515, -1], [2515.01, 1], [5451, 1], [5577, 0.142960024], [6371, -0.334], [6557, -1]];
	Curves["182"].divisions = "|MAEmodelsPrevis|FlowerA_500_1_2_256_256_242_200_50_100_100_100_5|_121_9_v9";
	Curves["183"] = function () {
	    var Curve_v01 = [[v4(-0.2, 238.37, 4.25, 1),
	            v4(-0.61, 239.45, 4.71, 1),
	            v4(-1.2, 241.5, 6.04, 1),
	            v4(-1.64, 245.62, 8.29, 1),
	            v4(-1.56, 254.52, 9.95, 1),
	            v4(-2.46, 259.59, 9.91, 1),
	            v4(-4.39, 263.29, 9.17, 1),
	            v4(-6.3, 266.75, 8.66, 1),
	            v4(-7.7, 270.43, 8.28, 1),
	            v4(-7.65, 274.45, 8.2, 1),
	            v4(-5.87, 278.07, 8.43, 1),
	            v4(-3.55, 281.13, 8.89, 1),
	            v4(-1.01, 283.83, 9.63, 1),
	            v4(1.14, 286.65, 10.77, 1),
	            v4(2.97, 289.6, 12.16, 1),
	            v4(4.6, 292.66, 13.49, 1),
	            v4(6.35, 295.94, 14.18, 1),
	            v4(8.29, 299.12, 13.27, 1),
	            v4(10.03, 301.48, 10.88, 1),
	            v4(11.85, 303.45, 8.33, 1),
	            v4(14.16, 305.4, 6.06, 1),
	            v4(17.58, 307.16, 5.37, 1),
	            v4(21.05, 307.98, 6.81, 1),
	            v4(24.21, 308.25, 8.66, 1),
	            v4(27.6, 308.18, 10.41, 1),
	            v4(31.43, 307.45, 10.24, 1),
	            v4(34.18, 306.28, 7.71, 1),
	            v4(35.91, 305, 4.72, 1),
	            v4(36.85, 303.59, 1.33, 1),
	            v4(37.21, 302.14, -2.07, 1),
	            v4(37.15, 300.51, -5.43, 1),
	            v4(36.85, 299.29, -7.59, 1),
	            v4(36.54, 298.51, -8.51, 1),
	        ], [v4(0.12, 237.35, 5.38, 1),
	            v4(-0.23, 238.4, 5.87, 1),
	            v4(-0.66, 240.31, 7.24, 1),
	            v4(-0.79, 244.19, 9.68, 1),
	            v4(-0.36, 247.2, 12.01, 1),
	            v4(0.06, 255.78, 13.5, 1),
	            v4(-0.63, 260.69, 12.62, 1),
	            v4(-1.51, 264.47, 11.37, 1),
	            v4(-2.02, 268.06, 9.93, 1),
	            v4(-1.88, 271.57, 8.53, 1),
	            v4(-0.84, 274.94, 7.26, 1),
	            v4(0.77, 278.19, 6.14, 1),
	            v4(2.6, 281.3, 5.04, 1),
	            v4(4.47, 284.28, 3.97, 1),
	            v4(6.07, 287.34, 2.95, 1),
	            v4(7.41, 290.48, 1.84, 1),
	            v4(8.59, 293.63, 0.57, 1),
	            v4(9.87, 296.78, -0.6, 1),
	            v4(11.43, 299.82, -1.72, 1),
	            v4(13.29, 302.47, -3.32, 1),
	            v4(15.44, 304.75, -5.08, 1),
	            v4(18.17, 306.78, -6.37, 1),
	            v4(21.48, 308.33, -6.59, 1),
	            v4(24.92, 309.16, -5.79, 1),
	            v4(28.23, 309.44, -4.4, 1),
	            v4(31.55, 309.34, -3.04, 1),
	            v4(35.05, 308.78, -2.17, 1),
	            v4(38.49, 307.59, -2.7, 1),
	            v4(41.22, 305.84, -4.43, 1),
	            v4(42.67, 303.65, -6.99, 1),
	            v4(42.95, 301.28, -9.71, 1),
	            v4(42.66, 299.59, -11.41, 1),
	            v4(42.34, 298.64, -12.08, 1),
	        ], [v4(0.41, 236.33, 4.94, 1),
	            v4(0.2, 237.41, 5.33, 1),
	            v4(0.01, 239.42, 6.49, 1),
	            v4(0.29, 242.14, 8.74, 1),
	            v4(0.99, 245.81, 10.98, 1),
	            v4(1.91, 254.19, 12.8, 1),
	            v4(2.44, 259.2, 12.34, 1),
	            v4(2.9, 262.88, 10.94, 1),
	            v4(3.49, 266.16, 9.23, 1),
	            v4(4.22, 269.27, 7.37, 1),
	            v4(5.03, 272.24, 5.48, 1),
	            v4(5.92, 275.27, 3.6, 1),
	            v4(6.8, 278.28, 1.69, 1),
	            v4(7.62, 281.17, -0.29, 1),
	            v4(8.35, 283.9, -2.35, 1),
	            v4(8.94, 286.57, -4.52, 1),
	            v4(9.4, 289.17, -6.8, 1),
	            v4(9.76, 291.66, -9.23, 1),
	            v4(10.08, 294.09, -11.71, 1),
	            v4(10.47, 296.64, -14.06, 1),
	            v4(11.12, 299.56, -15.91, 1),
	            v4(12.3, 302.7, -17, 1),
	            v4(14.2, 305.66, -17.32, 1),
	            v4(16.72, 308.1, -17.14, 1),
	            v4(19.75, 309.83, -16.69, 1),
	            v4(23.11, 310.67, -16.02, 1),
	            v4(26.53, 310.64, -15.25, 1),
	            v4(29.86, 309.84, -14.42, 1),
	            v4(32.86, 308.22, -13.62, 1),
	            v4(35.25, 305.67, -12.84, 1),
	            v4(36.13, 302.25, -12.23, 1),
	            v4(35.96, 299.92, -12.06, 1),
	            v4(35.74, 298.78, -12.11, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["183"].animation = [[2442, 1], [2515, -1], [2515.01, 1], [5451, 1], [5577, 0.142960024], [6371, -0.334], [6557, -1]];
	Curves["183"].divisions = "|MAEmodelsPrevis|FlowerA_500_1_2_256_256_242_200_50_100_100_100_5|_121_9_v10";
	Curves.numCurves = 184;
	Curves["184"] = function () {
	    var Curve_v01 = [[v4(-0.84, 236.33, 2.95, 1),
	            v4(-1.12, 237.4, 3.45, 1),
	            v4(-1.42, 239.49, 4.76, 1),
	            v4(-1.01, 243.54, 7.05, 1),
	            v4(-0.35, 246.64, 9.34, 1),
	            v4(1.25, 254.84, 11.01, 1),
	            v4(1.97, 259.96, 10.32, 1),
	            v4(-0.46, 263.62, 9.71, 1),
	            v4(-1.68, 267.25, 9.26, 1),
	            v4(-2.8, 271, 9.08, 1),
	            v4(-4.53, 274.26, 9.14, 1),
	            v4(-6.06, 278.13, 9.5, 1),
	            v4(-4.2, 281.76, 10.15, 1),
	            v4(-1.41, 284.11, 10.44, 1),
	            v4(1.59, 286.26, 10.36, 1),
	            v4(4.62, 288.21, 9.56, 1),
	            v4(7.26, 290.1, 7.8, 1),
	            v4(9.53, 291.85, 5.49, 1),
	            v4(11.6, 293.56, 3.02, 1),
	            v4(13.69, 295.37, 0.58, 1),
	            v4(15.81, 297.31, -1.64, 1),
	            v4(18.38, 299.78, -3.06, 1),
	            v4(20.89, 302.43, -1.73, 1),
	            v4(22.39, 304.46, 0.98, 1),
	            v4(23.23, 305.88, 4.29, 1),
	            v4(23.48, 306.46, 7.94, 1),
	            v4(23.41, 306.41, 11.61, 1),
	            v4(23.09, 305.69, 15.22, 1),
	            v4(22.56, 304.14, 18.52, 1),
	            v4(21.65, 301.72, 21.22, 1),
	            v4(20.11, 298.59, 22.58, 1),
	            v4(18.99, 296.4, 22.7, 1),
	            v4(18.49, 295.28, 22.62, 1),
	        ], [v4(0.39, 236.33, 2.87, 1),
	            v4(0.01, 237.44, 3.13, 1),
	            v4(-0.43, 239.69, 4.1, 1),
	            v4(-0.66, 243.95, 5.83, 1),
	            v4(-0.79, 252.72, 7.75, 1),
	            v4(-2.07, 257.59, 7.42, 1),
	            v4(-3.72, 260.99, 5.74, 1),
	            v4(-5.28, 264.25, 4.35, 1),
	            v4(-7.08, 267.27, 2.88, 1),
	            v4(-8.93, 270.28, 1.57, 1),
	            v4(-10.81, 273.39, 0.33, 1),
	            v4(-12.61, 276.63, -0.65, 1),
	            v4(-14.02, 280.09, -0.94, 1),
	            v4(-14.81, 283.62, -0.29, 1),
	            v4(-15.15, 287.01, 1.02, 1),
	            v4(-15.13, 290.17, 2.84, 1),
	            v4(-14.73, 293.13, 4.96, 1),
	            v4(-13.17, 295.75, 7.05, 1),
	            v4(-10.68, 297.87, 8.69, 1),
	            v4(-7.7, 299.77, 9.73, 1),
	            v4(-4.52, 301.43, 10.01, 1),
	            v4(-1.17, 303.05, 10.07, 1),
	            v4(1.96, 304.56, 10.27, 1),
	            v4(5.34, 306.38, 11.58, 1),
	            v4(5.78, 307.17, 15.44, 1),
	            v4(4.93, 306.98, 18.93, 1),
	            v4(4.5, 306.37, 22.57, 1),
	            v4(5.59, 304.7, 25.8, 1),
	            v4(8.24, 302.34, 27.26, 1),
	            v4(11.07, 300.03, 26.95, 1),
	            v4(13.72, 297.76, 25.88, 1),
	            v4(15.28, 296.17, 24.88, 1),
	            v4(15.85, 295.26, 24.32, 1),
	        ], [v4(-0.26, 236.33, 3.41, 1),
	            v4(-0.64, 237.39, 3.85, 1),
	            v4(-1.05, 239.42, 5.1, 1),
	            v4(-0.97, 243.51, 7.32, 1),
	            v4(-0.66, 246.51, 9.68, 1),
	            v4(-0.1, 255.23, 11.08, 1),
	            v4(-0.94, 260.01, 9.52, 1),
	            v4(-3.01, 263.32, 8.47, 1),
	            v4(-4.78, 266.59, 7.33, 1),
	            v4(-6.48, 269.8, 6.4, 1),
	            v4(-8.39, 272.93, 5.66, 1),
	            v4(-10.48, 276.1, 5.14, 1),
	            v4(-11.4, 279.97, 5.18, 1),
	            v4(-10.04, 283.48, 5.92, 1),
	            v4(-8.04, 286.35, 6.61, 1),
	            v4(-5.68, 289.14, 6.88, 1),
	            v4(-3.44, 291.9, 6.18, 1),
	            v4(-1.04, 294.43, 5.22, 1),
	            v4(1.73, 296.66, 4.55, 1),
	            v4(4.71, 298.69, 4.22, 1),
	            v4(7.81, 300.55, 4.22, 1),
	            v4(10.94, 302.33, 4.69, 1),
	            v4(13.89, 304.08, 5.86, 1),
	            v4(16.26, 305.72, 8.25, 1),
	            v4(17.11, 306.61, 11.76, 1),
	            v4(16.89, 306.79, 15.38, 1),
	            v4(16.49, 306.58, 18.96, 1),
	            v4(16.21, 305.86, 22.53, 1),
	            v4(16.55, 304.45, 25.84, 1),
	            v4(17.63, 301.97, 28.52, 1),
	            v4(19.26, 298.55, 28.76, 1),
	            v4(19.99, 296.39, 27.94, 1),
	            v4(20.12, 295.27, 27.49, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["184"].animation = [[6212, 1], [6369, 0.43], [6898, -0.334], [7376, 0.449]];
	Curves["184"].divisions = "|MAEmodelsPrevis|tunnelFlowerA_2000_1_2_256_256_243_75_50_100_100_100_3|_121_9_v1";
	Curves["185"] = function () {
	    var Curve_v01 = [[v4(3.37, 236.94, -4.79, 1),
	            v4(3.56, 238.01, -5.12, 1),
	            v4(4.05, 240.17, -5.69, 1),
	            v4(4.86, 244.57, -6.18, 1),
	            v4(5.58, 253.14, -6.24, 1),
	            v4(5.09, 258.16, -6.52, 1),
	            v4(3.64, 261.7, -7.24, 1),
	            v4(1.99, 264.76, -8.27, 1),
	            v4(0.25, 267.7, -9.58, 1),
	            v4(-1.48, 270.34, -11.09, 1),
	            v4(-3.26, 272.92, -12.77, 1),
	            v4(-5.04, 275.54, -14.44, 1),
	            v4(-6.77, 278.29, -15.81, 1),
	            v4(-8.38, 281.23, -16.73, 1),
	            v4(-9.5, 284.51, -16.59, 1),
	            v4(-9.99, 287.72, -15.5, 1),
	            v4(-10.31, 290.87, -14.26, 1),
	            v4(-10.48, 293.99, -12.88, 1),
	            v4(-10.56, 297.06, -11.39, 1),
	            v4(-10.53, 299.78, -9.32, 1),
	            v4(-10.45, 302.12, -6.81, 1),
	            v4(-10.69, 304.34, -4.28, 1),
	            v4(-11.47, 306.73, -1.85, 1),
	            v4(-14.05, 308.89, -0.52, 1),
	            v4(-17.5, 309.58, -0.99, 1),
	            v4(-20.83, 309.59, -1.48, 1),
	            v4(-24.23, 308.91, -1.57, 1),
	            v4(-27.32, 307.6, -0.84, 1),
	            v4(-29.7, 305.63, 0.84, 1),
	            v4(-30.62, 303.42, 3.36, 1),
	            v4(-30.75, 301.21, 5.94, 1),
	            v4(-30.52, 299.66, 7.61, 1),
	            v4(-30.35, 298.81, 8.34, 1),
	        ], [v4(3.03, 236.63, -6.24, 1),
	            v4(3.07, 237.64, -6.7, 1),
	            v4(3.25, 239.71, -7.56, 1),
	            v4(3.66, 244.02, -8.42, 1),
	            v4(3.97, 252.56, -8.62, 1),
	            v4(2.94, 257.46, -8.75, 1),
	            v4(1.18, 260.77, -9.07, 1),
	            v4(-0.66, 263.77, -9.63, 1),
	            v4(-2.56, 266.75, -10.36, 1),
	            v4(-4.43, 269.51, -11.16, 1),
	            v4(-6.3, 272.37, -11.91, 1),
	            v4(-8.09, 275.38, -12.46, 1),
	            v4(-9.52, 278.62, -12.36, 1),
	            v4(-10.24, 281.82, -11.25, 1),
	            v4(-10.14, 284.55, -9.27, 1),
	            v4(-9.68, 286.94, -6.99, 1),
	            v4(-9.24, 289.3, -4.67, 1),
	            v4(-8.88, 291.72, -2.38, 1),
	            v4(-8.55, 294.24, -0.22, 1),
	            v4(-8.39, 296.84, 1.88, 1),
	            v4(-8.54, 299.37, 4.06, 1),
	            v4(-9.07, 301.81, 6.3, 1),
	            v4(-10.16, 304.18, 8.39, 1),
	            v4(-12.04, 306.38, 10.18, 1),
	            v4(-14.96, 307.9, 11.13, 1),
	            v4(-18.29, 308.46, 11.26, 1),
	            v4(-21.63, 308.36, 11.31, 1),
	            v4(-24.91, 307.64, 11.55, 1),
	            v4(-27.98, 306.39, 12.06, 1),
	            v4(-30.63, 304.46, 12.96, 1),
	            v4(-32.14, 301.76, 14.4, 1),
	            v4(-32.49, 299.75, 15.32, 1),
	            v4(-32.55, 298.68, 15.66, 1),
	        ], [v4(1.81, 236.33, -5.86, 1),
	            v4(1.67, 237.28, -6.32, 1),
	            v4(1.49, 239.22, -7.21, 1),
	            v4(1.36, 242.26, -8.18, 1),
	            v4(1.17, 246.57, -8.47, 1),
	            v4(0.06, 254.56, -8.39, 1),
	            v4(-1.53, 259.19, -8.25, 1),
	            v4(-3.11, 262.4, -8.21, 1),
	            v4(-4.7, 265.48, -8.24, 1),
	            v4(-6.21, 268.65, -8.18, 1),
	            v4(-7.59, 271.63, -7.83, 1),
	            v4(-8.73, 274.72, -7.06, 1),
	            v4(-9.27, 277.79, -5.62, 1),
	            v4(-9.12, 280.52, -3.62, 1),
	            v4(-8.53, 282.81, -1.35, 1),
	            v4(-7.64, 284.7, 1.09, 1),
	            v4(-6.66, 286.44, 3.58, 1),
	            v4(-5.75, 288.21, 6.09, 1),
	            v4(-4.97, 290.09, 8.56, 1),
	            v4(-4.32, 292.15, 10.92, 1),
	            v4(-3.83, 294.47, 13.08, 1),
	            v4(-3.87, 297.15, 14.9, 1),
	            v4(-4.79, 300, 16.13, 1),
	            v4(-6.25, 302.64, 17.21, 1),
	            v4(-8.1, 304.96, 18.44, 1),
	            v4(-10.51, 306.73, 19.68, 1),
	            v4(-13.55, 307.44, 20.69, 1),
	            v4(-16.73, 306.95, 21.13, 1),
	            v4(-19.7, 305.7, 21.1, 1),
	            v4(-22.27, 303.79, 20.55, 1),
	            v4(-24.1, 301.34, 19.49, 1),
	            v4(-24.92, 299.53, 18.73, 1),
	            v4(-25.23, 298.56, 18.39, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["185"].animation = [[6212, 1], [6369, 0.43], [6898, -0.334], [7376, 0.449]];
	Curves["185"].divisions = "|MAEmodelsPrevis|tunnelFlowerA_2000_1_2_256_256_243_75_50_100_100_100_3|_121_9_v2";
	Curves["186"] = function () {
	    var Curve_v01 = [[v4(0.9, 236.37, -5.77, 1),
	            v4(1.34, 237.42, -5.66, 1),
	            v4(2, 239.61, -5.45, 1),
	            v4(2.84, 244.04, -5.07, 1),
	            v4(4.28, 252.39, -4.61, 1),
	            v4(4.63, 257.43, -4.66, 1),
	            v4(4.02, 261.3, -5.2, 1),
	            v4(3.18, 264.8, -5.96, 1),
	            v4(2.24, 268.25, -6.95, 1),
	            v4(1.47, 271.49, -8.15, 1),
	            v4(1, 274.83, -9.5, 1),
	            v4(1.13, 278.27, -10.72, 1),
	            v4(1.87, 281.64, -11.72, 1),
	            v4(3.05, 284.82, -12.36, 1),
	            v4(4.52, 287.88, -12.88, 1),
	            v4(6.07, 290.8, -13.83, 1),
	            v4(7.52, 293.57, -15.24, 1),
	            v4(8.74, 296.34, -16.85, 1),
	            v4(9.55, 299.22, -18.55, 1),
	            v4(9.73, 302.28, -20.11, 1),
	            v4(8.86, 305.53, -21.12, 1),
	            v4(6.78, 308.34, -21.22, 1),
	            v4(4.09, 310.44, -20.81, 1),
	            v4(1.04, 312.07, -20.67, 1),
	            v4(-2.2, 313.1, -21.27, 1),
	            v4(-5.37, 313.49, -22.64, 1),
	            v4(-8.12, 313.22, -24.72, 1),
	            v4(-10.53, 312.43, -27.02, 1),
	            v4(-12.97, 311.09, -29.08, 1),
	            v4(-15.62, 309, -30.04, 1),
	            v4(-18.18, 306.67, -29.48, 1),
	            v4(-19.69, 305.31, -28.43, 1),
	            v4(-20.41, 304.7, -27.78, 1),
	        ], [v4(0.54, 237, -7.01, 1),
	            v4(0.92, 238.04, -7.05, 1),
	            v4(1.42, 240.21, -7.15, 1),
	            v4(1.92, 244.57, -7.31, 1),
	            v4(3.07, 252.92, -7.42, 1),
	            v4(2.76, 257.89, -8.11, 1),
	            v4(1.73, 261.38, -9.03, 1),
	            v4(0.71, 264.66, -10, 1),
	            v4(-0.26, 267.99, -11.02, 1),
	            v4(-1.03, 271.17, -12.01, 1),
	            v4(-1.56, 274.54, -12.89, 1),
	            v4(-1.65, 278.09, -13.25, 1),
	            v4(-1.28, 281.58, -12.93, 1),
	            v4(-0.7, 284.76, -11.95, 1),
	            v4(-0.02, 287.75, -10.67, 1),
	            v4(0.72, 290.86, -9.75, 1),
	            v4(1.3, 294.12, -9.37, 1),
	            v4(1.36, 297.46, -9.52, 1),
	            v4(0.57, 300.68, -10.04, 1),
	            v4(-1.12, 303.51, -10.61, 1),
	            v4(-3.35, 305.94, -11.11, 1),
	            v4(-5.91, 308.04, -11.41, 1),
	            v4(-8.68, 309.85, -11.69, 1),
	            v4(-11.58, 311.36, -12.31, 1),
	            v4(-14.46, 312.46, -13.62, 1),
	            v4(-17.11, 313.03, -15.57, 1),
	            v4(-19.41, 313.06, -17.99, 1),
	            v4(-21.32, 312.56, -20.68, 1),
	            v4(-23.08, 311.57, -23.32, 1),
	            v4(-24.85, 309.88, -25.63, 1),
	            v4(-26.74, 307.29, -26.82, 1),
	            v4(-27.99, 305.42, -26.57, 1),
	            v4(-28.61, 304.57, -26.2, 1),
	        ], [v4(0.01, 237.63, -6.21, 1),
	            v4(0.25, 238.69, -6.38, 1),
	            v4(0.42, 240.86, -6.77, 1),
	            v4(0.43, 245.17, -7.43, 1),
	            v4(0.88, 253.53, -8.16, 1),
	            v4(0.01, 258.29, -9.24, 1),
	            v4(-1.13, 261.64, -10.29, 1),
	            v4(-2.08, 264.94, -11.23, 1),
	            v4(-2.81, 268.4, -12.01, 1),
	            v4(-3.36, 271.72, -12.49, 1),
	            v4(-3.74, 275.21, -12.49, 1),
	            v4(-3.96, 278.64, -11.62, 1),
	            v4(-4.12, 281.74, -10.04, 1),
	            v4(-4.4, 284.35, -7.95, 1),
	            v4(-4.77, 286.67, -5.64, 1),
	            v4(-5.19, 288.98, -3.33, 1),
	            v4(-5.67, 291.42, -1.16, 1),
	            v4(-6.35, 294.06, 0.71, 1),
	            v4(-7.34, 296.94, 2.02, 1),
	            v4(-8.86, 299.83, 2.65, 1),
	            v4(-10.94, 302.41, 2.68, 1),
	            v4(-13.28, 304.71, 2.35, 1),
	            v4(-15.75, 306.84, 1.81, 1),
	            v4(-18.27, 308.82, 1.08, 1),
	            v4(-20.81, 310.61, -0.1, 1),
	            v4(-23.11, 311.99, -2.07, 1),
	            v4(-24.98, 312.73, -4.73, 1),
	            v4(-26.39, 312.68, -7.75, 1),
	            v4(-27.36, 311.8, -10.81, 1),
	            v4(-27.97, 310.08, -13.6, 1),
	            v4(-28.25, 307.5, -15.7, 1),
	            v4(-28.35, 305.5, -16.64, 1),
	            v4(-28.43, 304.45, -16.96, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["186"].animation = [[6212, 1], [6369, 0.43], [6898, -0.334], [7376, 0.449]];
	Curves["186"].divisions = "|MAEmodelsPrevis|tunnelFlowerA_2000_1_2_256_256_243_75_50_100_100_100_3|_121_9_v3";
	Curves["187"] = function () {
	    var Curve_v01 = [[v4(-1.26, 240.14, 10.33, 1),
	            v4(-1.18, 241.31, 10.62, 1),
	            v4(-0.93, 244.56, 11.14, 1),
	            v4(0.47, 253.7, 11.29, 1),
	            v4(2.12, 258.26, 10.27, 1),
	            v4(3.24, 261.7, 8.25, 1),
	            v4(4.67, 264.58, 6.12, 1),
	            v4(6.03, 267.42, 3.96, 1),
	            v4(7.31, 270.36, 1.93, 1),
	            v4(8.32, 273.63, 0.1, 1),
	            v4(9.12, 277.16, -1.25, 1),
	            v4(9.73, 280.84, -1.82, 1),
	            v4(10.08, 284.48, -1.61, 1),
	            v4(10.32, 288.07, -0.86, 1),
	            v4(10.97, 291.54, 0.04, 1),
	            v4(12.28, 294.95, 0.71, 1),
	            v4(14.45, 297.92, 0.35, 1),
	            v4(16.86, 300.49, -0.68, 1),
	            v4(19.22, 302.98, -1.85, 1),
	            v4(20.98, 305.82, -3.61, 1),
	            v4(20.61, 308.58, -6.19, 1),
	            v4(19.64, 310.27, -9.3, 1),
	            v4(18.81, 311.29, -12.72, 1),
	            v4(18.67, 311.83, -16.39, 1),
	            v4(19.79, 311.9, -19.91, 1),
	            v4(21.93, 311.55, -22.94, 1),
	            v4(23.98, 310.94, -25.77, 1),
	            v4(25.66, 309.75, -29.1, 1),
	            v4(24.14, 307.97, -32.23, 1),
	            v4(21.34, 306.54, -34.13, 1),
	            v4(18.3, 305.24, -35.68, 1),
	            v4(16.1, 304.49, -36.45, 1),
	            v4(15, 304.13, -36.81, 1),
	        ], [v4(-1.09, 239.55, 9.15, 1),
	            v4(-0.78, 240.65, 9.55, 1),
	            v4(-0.12, 243.58, 10.54, 1),
	            v4(1.65, 252.41, 11.59, 1),
	            v4(3.86, 256.71, 10.56, 1),
	            v4(5.03, 259.79, 8.18, 1),
	            v4(6.24, 262.38, 5.67, 1),
	            v4(7.4, 264.92, 3.13, 1),
	            v4(8.45, 267.49, 0.61, 1),
	            v4(9.24, 270.25, -1.89, 1),
	            v4(9.62, 273.13, -4.33, 1),
	            v4(9.59, 276.16, -6.49, 1),
	            v4(9.01, 279.44, -7.99, 1),
	            v4(7.86, 282.86, -8.61, 1),
	            v4(6.33, 286.16, -8.44, 1),
	            v4(5, 289.51, -8.18, 1),
	            v4(4.17, 293.08, -8.23, 1),
	            v4(4.4, 296.69, -8.95, 1),
	            v4(5.61, 299.86, -10.31, 1),
	            v4(7.12, 302.75, -11.88, 1),
	            v4(8.65, 305.47, -13.74, 1),
	            v4(9.63, 308.18, -15.96, 1),
	            v4(10.15, 310.49, -18.75, 1),
	            v4(10.53, 311.95, -22.08, 1),
	            v4(11.18, 312.74, -25.58, 1),
	            v4(12.45, 312.94, -28.99, 1),
	            v4(14.47, 312.63, -32.04, 1),
	            v4(16.47, 311.9, -34.9, 1),
	            v4(18.32, 310.62, -37.93, 1),
	            v4(17.85, 308.28, -40.92, 1),
	            v4(15.45, 306.06, -42.77, 1),
	            v4(13.63, 304.84, -43.63, 1),
	            v4(12.62, 304.25, -44.02, 1),
	        ], [v4(-1.12, 238.95, 5.29, 1),
	            v4(-0.74, 239.99, 5.67, 1),
	            v4(-0.01, 241.84, 6.71, 1),
	            v4(1.51, 245.77, 8.34, 1),
	            v4(3.72, 253.99, 7.78, 1),
	            v4(4.85, 257.81, 5.52, 1),
	            v4(5.76, 260.58, 3.11, 1),
	            v4(6.64, 263.14, 0.7, 1),
	            v4(7.42, 265.77, -1.67, 1),
	            v4(7.95, 268.34, -4.06, 1),
	            v4(8.04, 270.99, -6.5, 1),
	            v4(7.64, 273.74, -8.82, 1),
	            v4(6.66, 276.56, -10.78, 1),
	            v4(5.13, 279.33, -12.21, 1),
	            v4(3.15, 282.05, -13.01, 1),
	            v4(0.95, 284.67, -13.32, 1),
	            v4(-1.24, 287.3, -13.57, 1),
	            v4(-3.23, 290.07, -14.08, 1),
	            v4(-4.91, 292.97, -14.84, 1),
	            v4(-6.09, 296.07, -15.8, 1),
	            v4(-6.61, 299.28, -16.96, 1),
	            v4(-6.55, 302.42, -18.38, 1),
	            v4(-5.99, 305.39, -20.04, 1),
	            v4(-4.92, 308.16, -21.79, 1),
	            v4(-3.44, 310.67, -23.63, 1),
	            v4(-1.62, 312.62, -25.82, 1),
	            v4(0.39, 313.79, -28.4, 1),
	            v4(2.44, 313.99, -31.2, 1),
	            v4(4.31, 313.03, -33.98, 1),
	            v4(5.82, 310.9, -36.34, 1),
	            v4(6.61, 307.74, -37.67, 1),
	            v4(6.67, 305.5, -38.14, 1),
	            v4(6.54, 304.38, -38.34, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["187"].animation = [[6212, 1], [6369, 0.43], [6898, -0.334], [7376, 0.449]];
	Curves["187"].divisions = "|MAEmodelsPrevis|tunnelFlowerA_2000_1_2_256_256_243_75_50_100_100_100_3|_121_9_v4";
	Curves["188"] = function () {
	    var Curve_v01 = [[v4(-0.2, 238.37, 4.25, 1),
	            v4(-0.61, 239.45, 4.71, 1),
	            v4(-1.2, 241.5, 6.04, 1),
	            v4(-1.64, 245.62, 8.29, 1),
	            v4(-1.56, 254.52, 9.95, 1),
	            v4(-2.46, 259.59, 9.91, 1),
	            v4(-4.39, 263.29, 9.17, 1),
	            v4(-6.3, 266.75, 8.66, 1),
	            v4(-7.7, 270.43, 8.28, 1),
	            v4(-7.65, 274.45, 8.2, 1),
	            v4(-5.87, 278.07, 8.43, 1),
	            v4(-3.55, 281.13, 8.89, 1),
	            v4(-1.01, 283.83, 9.63, 1),
	            v4(1.14, 286.65, 10.77, 1),
	            v4(2.97, 289.6, 12.16, 1),
	            v4(4.6, 292.66, 13.49, 1),
	            v4(6.35, 295.94, 14.18, 1),
	            v4(8.29, 299.12, 13.27, 1),
	            v4(10.03, 301.48, 10.88, 1),
	            v4(11.85, 303.45, 8.33, 1),
	            v4(14.16, 305.4, 6.06, 1),
	            v4(17.58, 307.16, 5.37, 1),
	            v4(21.05, 307.98, 6.81, 1),
	            v4(24.21, 308.25, 8.66, 1),
	            v4(27.6, 308.18, 10.41, 1),
	            v4(31.43, 307.45, 10.24, 1),
	            v4(34.18, 306.28, 7.71, 1),
	            v4(35.91, 305, 4.72, 1),
	            v4(36.85, 303.59, 1.33, 1),
	            v4(37.21, 302.14, -2.07, 1),
	            v4(37.15, 300.51, -5.43, 1),
	            v4(36.85, 299.29, -7.59, 1),
	            v4(36.54, 298.51, -8.51, 1),
	        ], [v4(0.12, 237.35, 5.38, 1),
	            v4(-0.23, 238.4, 5.87, 1),
	            v4(-0.66, 240.31, 7.24, 1),
	            v4(-0.79, 244.19, 9.68, 1),
	            v4(-0.36, 247.2, 12.01, 1),
	            v4(0.06, 255.78, 13.5, 1),
	            v4(-0.63, 260.69, 12.62, 1),
	            v4(-1.51, 264.47, 11.37, 1),
	            v4(-2.02, 268.06, 9.93, 1),
	            v4(-1.88, 271.57, 8.53, 1),
	            v4(-0.84, 274.94, 7.26, 1),
	            v4(0.77, 278.19, 6.14, 1),
	            v4(2.6, 281.3, 5.04, 1),
	            v4(4.47, 284.28, 3.97, 1),
	            v4(6.07, 287.34, 2.95, 1),
	            v4(7.41, 290.48, 1.84, 1),
	            v4(8.59, 293.63, 0.57, 1),
	            v4(9.87, 296.78, -0.6, 1),
	            v4(11.43, 299.82, -1.72, 1),
	            v4(13.29, 302.47, -3.32, 1),
	            v4(15.44, 304.75, -5.08, 1),
	            v4(18.17, 306.78, -6.37, 1),
	            v4(21.48, 308.33, -6.59, 1),
	            v4(24.92, 309.16, -5.79, 1),
	            v4(28.23, 309.44, -4.4, 1),
	            v4(31.55, 309.34, -3.04, 1),
	            v4(35.05, 308.78, -2.17, 1),
	            v4(38.49, 307.59, -2.7, 1),
	            v4(41.22, 305.84, -4.43, 1),
	            v4(42.67, 303.65, -6.99, 1),
	            v4(42.95, 301.28, -9.71, 1),
	            v4(42.66, 299.59, -11.41, 1),
	            v4(42.34, 298.64, -12.08, 1),
	        ], [v4(0.41, 236.33, 4.94, 1),
	            v4(0.2, 237.41, 5.33, 1),
	            v4(0.01, 239.42, 6.49, 1),
	            v4(0.29, 242.14, 8.74, 1),
	            v4(0.99, 245.81, 10.98, 1),
	            v4(1.91, 254.19, 12.8, 1),
	            v4(2.44, 259.2, 12.34, 1),
	            v4(2.9, 262.88, 10.94, 1),
	            v4(3.49, 266.16, 9.23, 1),
	            v4(4.22, 269.27, 7.37, 1),
	            v4(5.03, 272.24, 5.48, 1),
	            v4(5.92, 275.27, 3.6, 1),
	            v4(6.8, 278.28, 1.69, 1),
	            v4(7.62, 281.17, -0.29, 1),
	            v4(8.35, 283.9, -2.35, 1),
	            v4(8.94, 286.57, -4.52, 1),
	            v4(9.4, 289.17, -6.8, 1),
	            v4(9.76, 291.66, -9.23, 1),
	            v4(10.08, 294.09, -11.71, 1),
	            v4(10.47, 296.64, -14.06, 1),
	            v4(11.12, 299.56, -15.91, 1),
	            v4(12.3, 302.7, -17, 1),
	            v4(14.2, 305.66, -17.32, 1),
	            v4(16.72, 308.1, -17.14, 1),
	            v4(19.75, 309.83, -16.69, 1),
	            v4(23.11, 310.67, -16.02, 1),
	            v4(26.53, 310.64, -15.25, 1),
	            v4(29.86, 309.84, -14.42, 1),
	            v4(32.86, 308.22, -13.62, 1),
	            v4(35.25, 305.67, -12.84, 1),
	            v4(36.13, 302.25, -12.23, 1),
	            v4(35.96, 299.92, -12.06, 1),
	            v4(35.74, 298.78, -12.11, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["188"].animation = [[6212, 1], [6369, 0.43], [6898, -0.334], [7376, 0.449]];
	Curves["188"].divisions = "|MAEmodelsPrevis|tunnelFlowerA_2000_1_2_256_256_243_75_50_100_100_100_3|_121_9_v5";
	Curves.numCurves = 189;
	Curves["189"] = function () {
	    var Curve_v01 = [[v4(3.6, 278.46, -4.59, 1),
	            v4(4.44, 282.61, -4.64, 1),
	            v4(7.07, 290.53, -4.86, 1),
	            v4(13.93, 301.38, -7.05, 1),
	            v4(22.22, 304.74, -7.03, 1),
	            v4(26.4, 304.77, -7.29, 1),
	        ], [v4(2.74, 275.95, -3.06, 1),
	            v4(3.23, 280.29, -2.54, 1),
	            v4(5.12, 288.69, -0.96, 1),
	            v4(11.25, 300.31, 1.73, 1),
	            v4(19.06, 304.45, 4.87, 1),
	            v4(23.36, 304.73, 5.6, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["189"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["189"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v1";
	Curves["190"] = function () {
	    var Curve_v01 = [[v4(6.65, 247.28, -8.69, 1),
	            v4(7.46, 249.74, -9.67, 1),
	            v4(9.6, 254.46, -11.45, 1),
	            v4(15.05, 259.85, -15.12, 1),
	            v4(19.55, 261.3, -18.05, 1),
	            v4(21.85, 261.33, -19.61, 1),
	        ], [v4(6.84, 245.8, -6.44, 1),
	            v4(7.97, 248.33, -6.65, 1),
	            v4(10.61, 253.33, -7.18, 1),
	            v4(16.71, 259.15, -7.81, 1),
	            v4(22.23, 261.06, -8.75, 1),
	            v4(24.95, 261.27, -8.17, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["190"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["190"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v2";
	Curves["191"] = function () {
	    var Curve_v01 = [[v4(10.17, 276.52, -0.15, 1),
	            v4(11.29, 278.05, 0.15, 1),
	            v4(13.87, 280.77, 0.79, 1),
	            v4(18.58, 283.88, 2.08, 1),
	            v4(22.12, 284.8, 3.28, 1),
	            v4(23.93, 284.93, 3.87, 1),
	        ], [v4(8.41, 278, 4.35, 1),
	            v4(9.24, 279.24, 5.09, 1),
	            v4(11.18, 281.46, 6.64, 1),
	            v4(14.37, 284, 9.55, 1),
	            v4(16.44, 284.76, 12.12, 1),
	            v4(17.17, 284.91, 13.6, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["191"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["191"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v3";
	Curves["192"] = function () {
	    var Curve_v01 = [[v4(5.54, 266.13, -16.73, 1),
	            v4(6.28, 267.5, -17.91, 1),
	            v4(8.13, 270.02, -20.56, 1),
	            v4(11.79, 272.01, -24.76, 1),
	            v4(14.45, 272.25, -27.91, 1),
	            v4(15.27, 271.7, -29.65, 1),
	        ], [v4(11.28, 265.16, -9.85, 1),
	            v4(12.38, 266.6, -10.56, 1),
	            v4(15.29, 269.14, -11.3, 1),
	            v4(20.34, 271.71, -12.7, 1),
	            v4(24.23, 272.12, -13.46, 1),
	            v4(26.16, 272, -13.48, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["192"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["192"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v4";
	Curves["193"] = function () {
	    var Curve_v01 = [[v4(-2.03, 290.99, -12.87, 1),
	            v4(-2.24, 293.1, -13.97, 1),
	            v4(-2.94, 297.09, -16.47, 1),
	            v4(-3.69, 301.69, -22.07, 1),
	            v4(-4.8, 303.27, -26.43, 1),
	            v4(-5.52, 303.53, -28.71, 1),
	        ], [v4(5.68, 293.94, -13.12, 1),
	            v4(6.53, 295.75, -13.98, 1),
	            v4(8.65, 298.99, -15.95, 1),
	            v4(12.72, 302.63, -19.64, 1),
	            v4(15.74, 303.56, -22.78, 1),
	            v4(17.74, 303.63, -23.69, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["193"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["193"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v5";
	Curves["194"] = function () {
	    var Curve_v01 = [[v4(-3.86, 277.37, -4.57, 1),
	            v4(-4.77, 281.33, -4.75, 1),
	            v4(-7.2, 288.87, -6.52, 1),
	            v4(-13.92, 299.2, -8.15, 1),
	            v4(-21.26, 302.38, -11.45, 1),
	            v4(-24.92, 302.46, -13.1, 1),
	        ], [v4(-3.5, 276.91, -6.02, 1),
	            v4(-4.1, 280.81, -6.85, 1),
	            v4(-5.66, 288.34, -9.18, 1),
	            v4(-9.41, 298.62, -14.75, 1),
	            v4(-14.28, 302.18, -20.77, 1),
	            v4(-17.15, 302.43, -23.57, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["194"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["194"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v6";
	Curves["195"] = function () {
	    var Curve_v01 = [[v4(-9.47, 275.55, -3.36, 1),
	            v4(-10.84, 277.77, -3.53, 1),
	            v4(-14.3, 282.02, -3.94, 1),
	            v4(-21.19, 285.96, -4.62, 1),
	            v4(-26.71, 286.71, -5.15, 1),
	            v4(-29.26, 285.99, -5.3, 1),
	        ], [v4(-9.72, 277.01, -8.63, 1),
	            v4(-10.94, 279.03, -9.31, 1),
	            v4(-13.93, 282.75, -11.21, 1),
	            v4(-19.12, 286.1, -15.36, 1),
	            v4(-23.66, 286.67, -17.93, 1),
	            v4(-25.73, 285.95, -19.08, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["195"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["195"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v7";
	Curves["196"] = function () {
	    var Curve_v01 = [[v4(-16.1, 290.82, -1.02, 1),
	            v4(-17.52, 291.77, -1.06, 1),
	            v4(-20.56, 293.37, -1.09, 1),
	            v4(-25.64, 294.36, -0.9, 1),
	            v4(-29.07, 293.96, -0.97, 1),
	            v4(-30.61, 293.18, -1.17, 1),
	        ], [v4(-18.11, 291.89, -6.27, 1),
	            v4(-19.44, 292.64, -6.48, 1),
	            v4(-22.22, 293.75, -6.89, 1),
	            v4(-26.77, 294.38, -7.76, 1),
	            v4(-29.65, 293.71, -8.53, 1),
	            v4(-30.95, 292.93, -8.88, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["196"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["196"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v8";
	Curves["197"] = function () {
	    var Curve_v01 = [[v4(-12.21, 270.37, 5.68, 1),
	            v4(-13.1, 271.31, 6.61, 1),
	            v4(-15.49, 273, 8.14, 1),
	            v4(-19, 274.09, 11.22, 1),
	            v4(-21.86, 274.12, 12.9, 1),
	            v4(-23.18, 273.65, 13.68, 1),
	        ], [v4(-14.73, 270.2, 0.99, 1),
	            v4(-15.94, 271.21, 1.6, 1),
	            v4(-19.55, 272.98, 2.73, 1),
	            v4(-23.18, 274.75, 4.56, 1),
	            v4(-28.59, 273.28, 6.32, 1),
	            v4(-27.65, 273.54, 6.76, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["197"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["197"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v9";
	Curves["198"] = function () {
	    var Curve_v01 = [[v4(-3.88, 294, 0.2, 1),
	            v4(-3.93, 297.13, 1.77, 1),
	            v4(-5.44, 303.44, 5.06, 1),
	            v4(-6.73, 311.01, 11.63, 1),
	            v4(-13.07, 311.63, 19.64, 1),
	            v4(-12.98, 311.4, 20.95, 1),
	        ], [v4(-6.34, 296.02, -1.46, 1),
	            v4(-7.72, 298.77, -1.43, 1),
	            v4(-10.65, 304.22, -1.01, 1),
	            v4(-17.83, 310.32, 0.18, 1),
	            v4(-23.76, 311.78, 1.81, 1),
	            v4(-26.78, 311.54, 2.51, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["198"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["198"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v10";
	Curves["199"] = function () {
	    var Curve_v01 = [[v4(-0.73, 281.42, 6.58, 1),
	            v4(-0.82, 282.67, 7.8, 1),
	            v4(-1.28, 284.9, 10.49, 1),
	            v4(-2.41, 287.17, 15.15, 1),
	            v4(-3.3, 287.61, 18.56, 1),
	            v4(-4.25, 287.6, 20.07, 1),
	        ], [v4(-8.23, 282.03, 4.4, 1),
	            v4(-8.15, 283.06, 5.81, 1),
	            v4(-10.14, 285.54, 8.18, 1),
	            v4(-12.69, 287.4, 12.35, 1),
	            v4(-15.07, 287.75, 15.26, 1),
	            v4(-15.9, 287.5, 16.82, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["199"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["199"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v11";
	Curves["200"] = function () {
	    var Curve_v01 = [[v4(2.48, 286.97, -0.39, 1),
	            v4(3.65, 290.34, 0.13, 1),
	            v4(6.21, 296.99, 1.51, 1),
	            v4(11.61, 305.57, 5.88, 1),
	            v4(17.03, 308.09, 10.64, 1),
	            v4(19.22, 308.15, 13.5, 1),
	        ], [v4(0.78, 288.65, 0.8, 1),
	            v4(1.92, 291.73, 1.72, 1),
	            v4(2.77, 298.07, 4.22, 1),
	            v4(4.84, 305.82, 10.9, 1),
	            v4(7.2, 308.09, 17.16, 1),
	            v4(7.9, 308.15, 20.5, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["200"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["200"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v12";
	Curves["201"] = function () {
	    var Curve_v01 = [[v4(6.64, 258.13, 7, 1),
	            v4(7.36, 259.36, 8.04, 1),
	            v4(8.14, 261.45, 10.66, 1),
	            v4(9.13, 263.59, 15.37, 1),
	            v4(9.55, 263.97, 18.82, 1),
	            v4(9.94, 263.93, 20.5, 1),
	        ], [v4(0.72, 255.45, 6.45, 1),
	            v4(1.34, 257.23, 7.73, 1),
	            v4(1.39, 260.59, 11.02, 1),
	            v4(2.2, 263.66, 17.17, 1),
	            v4(0.46, 264.18, 21.77, 1),
	            v4(0.34, 263.8, 23.97, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["201"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["201"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v13";
	Curves["202"] = function () {
	    var Curve_v01 = [[v4(0.46, 244.85, -11.88, 1),
	            v4(0.49, 247.15, -12.95, 1),
	            v4(0.67, 251.71, -15.35, 1),
	            v4(1.25, 257.09, -20.87, 1),
	            v4(2.77, 259.24, -25.45, 1),
	            v4(2.73, 259.71, -27.96, 1),
	        ], [v4(3.63, 248.69, -13.11, 1),
	            v4(3.9, 250.71, -14.26, 1),
	            v4(4.97, 254.54, -16.95, 1),
	            v4(8.49, 258.7, -21.59, 1),
	            v4(10.72, 259.9, -25.69, 1),
	            v4(12.16, 259.99, -27.54, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["202"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["202"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v14";
	Curves["203"] = function () {
	    var Curve_v01 = [[v4(-1.07, 277.2, -19.26, 1),
	            v4(-1.39, 278.26, -20.49, 1),
	            v4(-1.88, 280.22, -23.26, 1),
	            v4(-2.03, 281.82, -28, 1),
	            v4(-2.38, 282.03, -31.41, 1),
	            v4(-2.21, 281.77, -33.05, 1),
	        ], [v4(3.69, 277.32, -18.95, 1),
	            v4(4.33, 278.41, -20.14, 1),
	            v4(4.34, 280.4, -23.19, 1),
	            v4(5.81, 281.95, -27.85, 1),
	            v4(6.8, 282, -31.43, 1),
	            v4(8.19, 281.66, -32.49, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["203"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["203"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v15";
	Curves["204"] = function () {
	    var Curve_v01 = [[v4(-10.32, 268.63, -12.85, 1),
	            v4(-11.08, 269.91, -13.91, 1),
	            v4(-12.58, 272.18, -16.43, 1),
	            v4(-15.53, 274.43, -20.52, 1),
	            v4(-17.99, 274.8, -23.33, 1),
	            v4(-19.15, 274.66, -24.73, 1),
	        ], [v4(-7.51, 269.81, -16.91, 1),
	            v4(-7.99, 270.86, -18.03, 1),
	            v4(-9, 272.74, -20.48, 1),
	            v4(-10.63, 274.5, -24.71, 1),
	            v4(-11.74, 274.77, -27.77, 1),
	            v4(-12.22, 274.67, -29.3, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["204"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["204"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v16";
	Curves["205"] = function () {
	    var Curve_v01 = [[v4(10.96, 275, 3.98, 1),
	            v4(12.4, 276.06, 4.04, 1),
	            v4(14.22, 278.18, 6.15, 1),
	            v4(18.47, 280.1, 8.4, 1),
	            v4(21.29, 280.43, 10.36, 1),
	            v4(22.62, 280.31, 11.41, 1),
	        ], [v4(7.94, 274.54, 6.18, 1),
	            v4(8.41, 275.72, 7.33, 1),
	            v4(9.9, 277.91, 9.68, 1),
	            v4(13.28, 280.02, 13.01, 1),
	            v4(15.87, 280.39, 15.38, 1),
	            v4(17.14, 280.33, 16.53, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["205"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["205"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v17";
	Curves["206"] = function () {
	    var Curve_v01 = [[v4(12.19, 285.08, -8.44, 1),
	            v4(13.43, 286.48, -8.91, 1),
	            v4(16.3, 289, -9.82, 1),
	            v4(21.23, 291.38, -11.85, 1),
	            v4(25.05, 291.71, -12.9, 1),
	            v4(27, 291.48, -12.66, 1),
	        ], [v4(12.34, 284.77, -2.98, 1),
	            v4(13.47, 285.99, -3.04, 1),
	            v4(15.97, 288.2, -3.1, 1),
	            v4(20.35, 290.69, -2.79, 1),
	            v4(23.62, 291.4, -2.4, 1),
	            v4(25.27, 291.52, -2.31, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["206"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["206"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v18";
	Curves["207"] = function () {
	    var Curve_v01 = [[v4(6.06, 275.31, 4.54, 1),
	            v4(6.42, 277.19, 5.47, 1),
	            v4(7.67, 280.88, 7.28, 1),
	            v4(11.26, 285.25, 10.43, 1),
	            v4(13.41, 287.25, 13.65, 1),
	            v4(13.94, 287.81, 15.66, 1),
	        ], [v4(1.34, 278.4, 7.85, 1),
	            v4(1.68, 279.92, 8.82, 1),
	            v4(2.46, 282.75, 11.03, 1),
	            v4(3.87, 286.12, 15.19, 1),
	            v4(4.82, 287.6, 18.44, 1),
	            v4(5.19, 288.02, 20.19, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["207"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["207"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v19";
	Curves["208"] = function () {
	    var Curve_v01 = [[v4(-6.3, 250.36, -3.14, 1),
	            v4(-7.53, 251.68, -2.65, 1),
	            v4(-10.37, 254.06, -1.72, 1),
	            v4(-14.68, 256.5, 1.1, 1),
	            v4(-18.11, 256.89, 2.82, 1),
	            v4(-19.85, 256.76, 3.48, 1),
	        ], [v4(-5.04, 250.71, -10.1, 1),
	            v4(-6.34, 252.25, -9.93, 1),
	            v4(-9.33, 255.03, -9.37, 1),
	            v4(-14.73, 257.76, -8.35, 1),
	            v4(-18.85, 258.23, -7.84, 1),
	            v4(-20.84, 258.02, -7.58, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["208"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["208"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v20";
	Curves["209"] = function () {
	    var Curve_v01 = [[v4(-4.05, 269.98, -11.3, 1),
	            v4(-4.39, 272.05, -12.28, 1),
	            v4(-5.15, 276.11, -14.5, 1),
	            v4(-6.99, 280.95, -19.29, 1),
	            v4(-8.7, 282.99, -23.2, 1),
	            v4(-9.08, 283.5, -25.46, 1),
	        ], [v4(-1.17, 270.13, -12.44, 1),
	            v4(-1.15, 272.2, -13.49, 1),
	            v4(-1.21, 276.27, -15.84, 1),
	            v4(-1.96, 281.07, -20.98, 1),
	            v4(-2.37, 283.07, -25.23, 1),
	            v4(-2.56, 283.56, -27.51, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["209"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["209"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v21";
	Curves["210"] = function () {
	    var Curve_v01 = [[v4(6.56, 265.5, -10.93, 1),
	            v4(7.23, 267.35, -11.76, 1),
	            v4(9.23, 270.81, -13.2, 1),
	            v4(13.33, 274.84, -16.11, 1),
	            v4(16.44, 276.42, -18.61, 1),
	            v4(18.43, 276.77, -19.37, 1),
	        ], [v4(8.71, 265.21, -6.65, 1),
	            v4(9.65, 266.88, -6.71, 1),
	            v4(11.81, 270.11, -6.82, 1),
	            v4(16.19, 273.92, -6.61, 1),
	            v4(19.62, 275.71, -6.28, 1),
	            v4(21.46, 276.28, -6.38, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["210"].animation = [[5351, 1], [5708, 0.2177741861], [6428, -0.2098620625], [7044, -1]];
	Curves["210"].divisions = "|MAEmodelsPrevis|flowerEnd_12000_1_3_256_256_229_100_30_100_100_20_7|_13_5_v22";
	Curves.numCurves = 211;
	Curves["211"] = function () {
	    var Curve_v01 = [[v4(-0.5, -19.06, -4.86, 1),
	            v4(-0.67, -19.06, -5.53, 1),
	            v4(-0.83, -19.06, -6.19, 1),
	            v4(-1, -19.06, -6.86, 1),
	        ], [v4(0.5, -19.06, -4.86, 1),
	            v4(0.67, -19.06, -5.53, 1),
	            v4(1.14, 15.63, -7.9, 1),
	            v4(2.56, 45.5, -14.54, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["211"].animation = [[6891, 1], [7096, -1]];
	Curves["211"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v1";
	Curves["212"] = function () {
	    var Curve_v01 = [[v4(-1.7, -18.56, -4.4, 1),
	            v4(-2.25, -18.56, -4.92, 1),
	            v4(-3.85, 16.13, -6.75, 1),
	            v4(-8.59, 46, -11.9, 1),
	        ], [v4(-0.77, -18.56, -5, 1),
	            v4(-1.02, -18.56, -5.72, 1),
	            v4(-1.74, 16.13, -8.25, 1),
	            v4(-3.87, 46, -15.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["212"].animation = [[6891, 1], [7096, -1]];
	Curves["212"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v2";
	Curves["213"] = function () {
	    var Curve_v01 = [[v4(-2.52, -18.01, -3.26, 1),
	            v4(-3.34, -18.01, -3.41, 1),
	            v4(-5.72, 16.68, -3.93, 1),
	            v4(-12.75, 46.55, -5.38, 1),
	        ], [v4(-2.03, -18.01, -4.37, 1),
	            v4(-2.69, -18.01, -4.88, 1),
	            v4(-4.59, 16.68, -6.69, 1),
	            v4(-10.23, 46.55, -11.77, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["213"].animation = [[6891, 1], [7096, -1]];
	Curves["213"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v3";
	Curves["214"] = function () {
	    var Curve_v01 = [[v4(-2.6, -17.41, -1.72, 1),
	            v4(-3.45, -17.41, -1.36, 1),
	            v4(-5.89, 17.29, -0.09, 1),
	            v4(-13.13, 47.16, 3.44, 1),
	        ], [v4(-2.81, -17.41, -3.03, 1),
	            v4(-3.72, -17.41, -3.11, 1),
	            v4(-6.37, 17.29, -3.39, 1),
	            v4(-14.2, 47.16, -4.16, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["214"].animation = [[6891, 1], [7096, -1]];
	Curves["214"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v4";
	Curves["215"] = function () {
	    var Curve_v01 = [[v4(-1.75, -16.74, -0.24, 1),
	            v4(-2.31, -16.74, 0.59, 1),
	            v4(-3.95, 17.95, 3.55, 1),
	            v4(-8.8, 47.82, 11.84, 1),
	        ], [v4(-2.73, -16.74, -1.33, 1),
	            v4(-3.62, -16.74, -0.86, 1),
	            v4(-6.19, 17.95, 0.83, 1),
	            v4(-13.82, 47.82, 5.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["215"].animation = [[6891, 1], [7096, -1]];
	Curves["215"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v5";
	Curves["216"] = function () {
	    var Curve_v01 = [[v4(-0.08, -16.01, 0.61, 1),
	            v4(-0.1, -16.01, 1.72, 1),
	            v4(-0.16, 18.68, 5.65, 1),
	            v4(-0.35, 48.55, 16.66, 1),
	        ], [v4(-1.64, -16.01, 0.19, 1),
	            v4(-2.17, -16.01, 1.16, 1),
	            v4(-3.72, 18.68, 4.61, 1),
	            v4(-8.32, 48.55, 14.25, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["216"].animation = [[6891, 1], [7096, -1]];
	Curves["216"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v6";
	Curves["217"] = function () {
	    var Curve_v01 = [[v4(1.97, -15.21, 0.4, 1),
	            v4(2.62, -15.21, 1.43, 1),
	            v4(4.48, 19.49, 5.1, 1),
	            v4(10, 49.36, 15.39, 1),
	        ], [v4(0.29, -15.21, 0.94, 1),
	            v4(0.37, -15.21, 2.16, 1),
	            v4(0.62, 19.49, 6.47, 1),
	            v4(1.38, 49.36, 18.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["217"].animation = [[6891, 1], [7096, -1]];
	Curves["217"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v7";
	Curves["218"] = function () {
	    var Curve_v01 = [[v4(3.73, -14.32, -1.03, 1),
	            v4(4.95, -14.32, -0.47, 1),
	            v4(8.46, 20.38, 1.55, 1),
	            v4(18.88, 50.24, 7.21, 1),
	        ], [v4(2.51, -14.32, 0.48, 1),
	            v4(3.31, -14.32, 1.55, 1),
	            v4(5.65, 20.38, 5.34, 1),
	            v4(12.6, 50.24, 15.97, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["218"].animation = [[6891, 1], [7096, -1]];
	Curves["218"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v8";
	Curves["219"] = function () {
	    var Curve_v01 = [[v4(4.5, -13.35, -3.41, 1),
	            v4(5.96, -13.35, -3.61, 1),
	            v4(10.19, 21.35, -4.33, 1),
	            v4(22.73, 51.22, -6.33, 1),
	        ], [v4(4.28, -13.35, -1.27, 1),
	            v4(5.66, -13.35, -0.77, 1),
	            v4(9.68, 21.35, 1.01, 1),
	            v4(21.59, 51.22, 5.99, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["219"].animation = [[6891, 1], [7096, -1]];
	Curves["219"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v9";
	Curves["220"] = function () {
	    var Curve_v01 = [[v4(3.79, -12.27, -6.06, 1),
	            v4(5.01, -12.27, -7.12, 1),
	            v4(8.57, 22.42, -10.89, 1),
	            v4(19.1, 52.29, -21.44, 1),
	        ], [v4(4.86, -12.27, -3.96, 1),
	            v4(6.44, -12.27, -4.32, 1),
	            v4(11.02, 22.42, -5.63, 1),
	            v4(24.58, 52.29, -9.29, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["220"].animation = [[6891, 1], [7096, -1]];
	Curves["220"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v10";
	Curves["221"] = function () {
	    var Curve_v01 = [[v4(1.55, -11.1, -8.08, 1),
	            v4(2.04, -11.1, -9.79, 1),
	            v4(3.47, 23.6, -15.87, 1),
	            v4(7.73, 53.47, -32.91, 1),
	        ], [v4(3.79, -11.1, -6.78, 1),
	            v4(5.03, -11.1, -8.06, 1),
	            v4(8.62, 23.6, -12.63, 1),
	            v4(19.23, 53.47, -25.41, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["221"].animation = [[6891, 1], [7096, -1]];
	Curves["221"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v11";
	Curves["222"] = function () {
	    var Curve_v01 = [[v4(-1.73, -9.8, -8.6, 1),
	            v4(-2.31, -9.8, -10.47, 1),
	            v4(-2.88, -9.8, -12.34, 1),
	            v4(-3.46, -9.8, -14.22, 1),
	        ], [v4(1.12, -9.8, -8.75, 1),
	            v4(1.49, -9.8, -10.67, 1),
	            v4(2.57, 24.9, -17.51, 1),
	            v4(5.74, 54.77, -36.67, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["222"].animation = [[6891, 1], [7096, -1]];
	Curves["222"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v12";
	Curves["223"] = function () {
	    var Curve_v01 = [[v4(-5.07, -8.37, -7.11, 1),
	            v4(-6.72, -8.37, -8.49, 1),
	            v4(-11.5, 26.32, -13.43, 1),
	            v4(-25.68, 56.19, -27.27, 1),
	        ], [v4(-2.53, -8.37, -8.95, 1),
	            v4(-3.34, -8.37, -10.95, 1),
	            v4(-5.69, 26.32, -18.05, 1),
	            v4(-12.67, 56.19, -37.93, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["223"].animation = [[6891, 1], [7096, -1]];
	Curves["223"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v13";
	Curves["224"] = function () {
	    var Curve_v01 = [[v4(-7.26, -6.8, -3.74, 1),
	            v4(-9.61, -6.8, -4.03, 1),
	            v4(-16.44, 27.89, -5.07, 1),
	            v4(-36.67, 57.76, -8, 1),
	        ], [v4(-6.02, -6.8, -6.96, 1),
	            v4(-7.96, -6.8, -8.32, 1),
	            v4(-13.61, 27.89, -13.14, 1),
	            v4(-30.33, 57.76, -26.64, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["224"].animation = [[6891, 1], [7096, -1]];
	Curves["224"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v14";
	Curves["225"] = function () {
	    var Curve_v01 = [[v4(-7.26, -5.08, 0.68, 1),
	            v4(-9.6, -5.08, 1.83, 1),
	            v4(-16.41, 29.62, 5.87, 1),
	            v4(-36.59, 59.49, 17.2, 1),
	        ], [v4(-8.05, -5.08, -3.03, 1),
	            v4(-10.65, -5.08, -3.13, 1),
	            v4(-18.22, 29.62, -3.43, 1),
	            v4(-40.63, 59.49, -4.27, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["225"].animation = [[6891, 1], [7096, -1]];
	Curves["225"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v15";
	Curves["226"] = function () {
	    var Curve_v01 = [[v4(-4.61, -3.18, 4.76, 1),
	            v4(-6.08, -3.18, 7.22, 1),
	            v4(-10.39, 31.52, 15.95, 1),
	            v4(-23.14, 61.39, 40.4, 1),
	        ], [v4(-7.56, -3.18, 1.81, 1),
	            v4(-10.02, -3.18, 3.28, 1),
	            v4(-17.15, 31.52, 8.56, 1),
	            v4(-38.27, 61.39, 23.32, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["226"].animation = [[6891, 1], [7096, -1]];
	Curves["226"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v16";
	Curves["227"] = function () {
	    var Curve_v01 = [[v4(0.28, -1.09, 6.93, 1),
	            v4(0.39, -1.09, 10.09, 1),
	            v4(0.69, 33.61, 21.3, 1),
	            v4(1.58, 63.48, 52.7, 1),
	        ], [v4(-4.22, -1.09, 5.98, 1),
	            v4(-5.6, -1.09, 8.82, 1),
	            v4(-9.6, 33.61, 18.91, 1),
	            v4(-21.44, 63.48, 47.18, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["227"].animation = [[6891, 1], [7096, -1]];
	Curves["227"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v17";
	Curves["228"] = function () {
	    var Curve_v01 = [[v4(6.09, 1.21, 6.01, 1),
	            v4(8.08, 1.21, 8.86, 1),
	            v4(13.84, 35.9, 18.98, 1),
	            v4(30.91, 65.77, 47.34, 1),
	        ], [v4(1.37, 1.21, 7.82, 1),
	            v4(1.79, 1.21, 11.27, 1),
	            v4(3.04, 35.9, 23.52, 1),
	            v4(6.75, 65.77, 57.81, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["228"].animation = [[6891, 1], [7096, -1]];
	Curves["228"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v18";
	Curves["229"] = function () {
	    var Curve_v01 = [[v4(10.9, 3.74, 1.68, 1),
	            v4(14.44, 3.74, 3.11, 1),
	            v4(24.7, 38.43, 8.22, 1),
	            v4(55.12, 68.3, 22.55, 1),
	        ], [v4(7.63, 3.74, 6.18, 1),
	            v4(10.09, 3.74, 9.11, 1),
	            v4(17.22, 38.43, 19.48, 1),
	            v4(38.39, 68.3, 48.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["229"].animation = [[6891, 1], [7096, -1]];
	Curves["229"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v19";
	Curves["230"] = function () {
	    var Curve_v01 = [[v4(12.74, 6.52, -5.2, 1),
	            v4(16.87, 6.52, -6, 1),
	            v4(28.83, 41.21, -8.81, 1),
	            v4(64.31, 71.08, -16.7, 1),
	        ], [v4(12.42, 6.52, 0.91, 1),
	            v4(16.44, 6.52, 2.14, 1),
	            v4(28.1, 41.21, 6.47, 1),
	            v4(62.67, 71.08, 18.61, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["230"].animation = [[6891, 1], [7096, -1]];
	Curves["230"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v20";
	Curves["231"] = function () {
	    var Curve_v01 = [[v4(10.32, 9.57, -12.64, 1),
	            v4(13.64, 9.57, -15.86, 1),
	            v4(23.3, 44.27, -27.24, 1),
	            v4(51.95, 74.14, -59.12, 1),
	        ], [v4(13.68, 9.57, -6.82, 1),
	            v4(18.13, 9.57, -8.09, 1),
	            v4(31, 44.27, -12.65, 1),
	            v4(69.17, 74.14, -25.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["231"].animation = [[6891, 1], [7096, -1]];
	Curves["231"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v21";
	Curves["232"] = function () {
	    var Curve_v01 = [[v4(3.62, 12.94, -18.06, 1),
	            v4(4.76, 12.94, -23.02, 1),
	            v4(8.11, 47.63, -40.61, 1),
	            v4(18.04, 77.5, -89.89, 1),
	        ], [v4(10.22, 12.94, -14.7, 1),
	            v4(13.56, 12.94, -18.54, 1),
	            v4(23.21, 47.63, -32.2, 1),
	            v4(51.8, 77.5, -70.47, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["232"].animation = [[6891, 1], [7096, -1]];
	Curves["232"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v22";
	Curves["233"] = function () {
	    var Curve_v01 = [[v4(-5.8, 16.64, -19.05, 1),
	            v4(-7.72, 16.64, -24.31, 1),
	            v4(-13.23, 51.33, -43, 1),
	            v4(-29.57, 81.2, -95.35, 1),
	        ], [v4(2.3, 16.64, -19.9, 1),
	            v4(3.08, 16.64, -25.44, 1),
	            v4(5.3, 51.33, -45.13, 1),
	            v4(11.88, 81.2, -100.27, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["233"].animation = [[6891, 1], [7096, -1]];
	Curves["233"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v23";
	Curves["234"] = function () {
	    var Curve_v01 = [[v4(-15.09, 20.71, -14.32, 1),
	            v4(-20, 20.71, -18.02, 1),
	            v4(-34.23, 55.4, -31.21, 1),
	            v4(-76.39, 85.27, -68.18, 1),
	        ], [v4(-8.13, 20.71, -19.95, 1),
	            v4(-10.72, 20.71, -25.53, 1),
	            v4(-18.3, 55.4, -45.32, 1),
	            v4(-40.76, 85.27, -100.75, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["234"].animation = [[6891, 1], [7096, -1]];
	Curves["234"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v24";
	Curves["235"] = function () {
	    var Curve_v01 = [[v4(-20.82, 25.18, -4.39, 1),
	            v4(-27.57, 25.18, -4.86, 1),
	            v4(-47.14, 59.88, -6.59, 1),
	            v4(-105.17, 89.75, -11.44, 1),
	        ], [v4(-17.77, 25.18, -13.75, 1),
	            v4(-23.51, 25.18, -17.35, 1),
	            v4(-40.18, 59.88, -30.04, 1),
	            v4(-89.58, 89.75, -65.6, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["235"].animation = [[6891, 1], [7096, -1]];
	Curves["235"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v25";
	Curves["236"] = function () {
	    var Curve_v01 = [[v4(-20.16, 30.11, 8.21, 1),
	            v4(-26.66, 30.11, 11.82, 1),
	            v4(-45.57, 64.81, 24.59, 1),
	            v4(-101.61, 94.67, 60.36, 1),
	        ], [v4(-22.96, 30.11, -2.26, 1),
	            v4(-30.4, 30.11, -2.13, 1),
	            v4(-51.99, 64.81, -1.61, 1),
	            v4(-115.97, 94.67, -0.14, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["236"].animation = [[6891, 1], [7096, -1]];
	Curves["236"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v26";
	Curves["237"] = function () {
	    var Curve_v01 = [[v4(-12, 35.53, 19.43, 1),
	            v4(-15.84, 35.53, 26.66, 1),
	            v4(-27.03, 70.22, 52.32, 1),
	            v4(-60.22, 100.09, 124.19, 1),
	        ], [v4(-20.86, 35.53, 11.45, 1),
	            v4(-27.65, 35.53, 16.03, 1),
	            v4(-47.31, 70.22, 32.36, 1),
	            v4(-105.57, 100.09, 78.09, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["237"].animation = [[6891, 1], [7096, -1]];
	Curves["237"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v27";
	Curves["238"] = function () {
	    var Curve_v01 = [[v4(2.25, 41.49, 24.9, 1),
	            v4(3.04, 41.49, 33.87, 1),
	            v4(5.26, 76.18, 65.76, 1),
	            v4(11.84, 106.05, 155.08, 1),
	        ], [v4(-10.7, 41.49, 22.84, 1),
	            v4(-14.22, 41.49, 31.14, 1),
	            v4(-24.38, 76.18, 60.63, 1),
	            v4(-54.47, 106.05, 143.23, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["238"].animation = [[6891, 1], [7096, -1]];
	Curves["238"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v28";
	Curves["239"] = function () {
	    var Curve_v01 = [[v4(18.67, 48.04, 21.4, 1),
	            v4(24.78, 48.04, 29.21, 1),
	            v4(42.42, 82.74, 57, 1),
	            v4(94.7, 112.61, 134.85, 1),
	        ], [v4(5.49, 48.04, 27.27, 1),
	            v4(7.21, 48.04, 37.03, 1),
	            v4(12.26, 82.74, 71.68, 1),
	            v4(27.24, 112.61, 168.76, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["239"].animation = [[6891, 1], [7096, -1]];
	Curves["239"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v29";
	Curves["240"] = function () {
	    var Curve_v01 = [[v4(31.72, 55.25, 8.34, 1),
	            v4(42.03, 55.25, 11.89, 1),
	            v4(71.89, 89.95, 24.58, 1),
	            v4(160.41, 119.82, 60.13, 1),
	        ], [v4(23.08, 55.25, 21.65, 1),
	            v4(30.51, 55.25, 29.62, 1),
	            v4(52.12, 89.95, 57.88, 1),
	            v4(116.17, 119.82, 137.04, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["240"].animation = [[6891, 1], [7096, -1]];
	Curves["240"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v30";
	Curves["241"] = function () {
	    var Curve_v01 = [[v4(35.94, 63.18, -11.53, 1),
	            v4(47.58, 63.18, -14.43, 1),
	            v4(81.33, 97.88, -24.64, 1),
	            v4(181.38, 127.75, -53.24, 1),
	        ], [v4(35.94, 63.18, 5.92, 1),
	            v4(47.58, 63.18, 8.83, 1),
	            v4(81.33, 97.88, 19.04, 1),
	            v4(181.38, 127.75, 47.64, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["241"].animation = [[6891, 1], [7096, -1]];
	Curves["241"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v31";
	Curves["242"] = function () {
	    var Curve_v01 = [[v4(27.93, 71.91, -32.38, 1),
	            v4(36.92, 71.91, -42.04, 1),
	            v4(63.06, 106.6, -76.23, 1),
	            v4(140.56, 136.47, -172.01, 1),
	        ], [v4(38.39, 71.91, -16.29, 1),
	            v4(50.86, 71.91, -20.57, 1),
	            v4(86.99, 106.6, -35.93, 1),
	            v4(194.1, 136.47, -78.95, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["242"].animation = [[6891, 1], [7096, -1]];
	Curves["242"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v32";
	Curves["243"] = function () {
	    var Curve_v01 = [[v4(8.05, 81.5, -46.83, 1),
	            v4(10.56, 81.5, -61.12, 1),
	            v4(17.95, 116.2, -111.86, 1),
	            v4(39.88, 146.07, -253.98, 1),
	        ], [v4(27.33, 81.5, -38.24, 1),
	            v4(36.27, 81.5, -49.67, 1),
	            v4(62.1, 116.2, -90.36, 1),
	            v4(138.65, 146.07, -204.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["243"].animation = [[6891, 1], [7096, -1]];
	Curves["243"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v33";
	Curves["244"] = function () {
	    var Curve_v01 = [[v4(-18.95, 92.06, -48.24, 1),
	            v4(-25.2, 92.06, -62.92, 1),
	            v4(-43.19, 126.76, -115.17, 1),
	            v4(-96.5, 156.63, -261.5, 1),
	        ], [v4(3.99, 92.06, -51.87, 1),
	            v4(5.39, 92.06, -67.77, 1),
	            v4(9.32, 126.76, -124.26, 1),
	            v4(20.97, 156.63, -282.5, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["244"].animation = [[6891, 1], [7096, -1]];
	Curves["244"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v34";
	Curves["245"] = function () {
	    var Curve_v01 = [[v4(-44.71, 103.67, -33.36, 1),
	            v4(-59.27, 103.67, -43.17, 1),
	            v4(-101.4, 138.37, -78.17, 1),
	            v4(-226.3, 168.24, -176.19, 1),
	        ], [v4(-25.72, 103.67, -50.46, 1),
	            v4(-33.95, 103.67, -65.96, 1),
	            v4(-57.94, 138.37, -120.96, 1),
	            v4(-129.08, 168.24, -275.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["245"].animation = [[6891, 1], [7096, -1]];
	Curves["245"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v35";
	Curves["246"] = function () {
	    var Curve_v01 = [[v4(-59.55, 116.45, -4.21, 1),
	            v4(-78.86, 116.45, -4.54, 1),
	            v4(-134.84, 151.14, -5.89, 1),
	            v4(-300.78, 181.01, -9.69, 1),
	        ], [v4(-52.28, 116.45, -31.36, 1),
	            v4(-69.16, 116.45, -40.73, 1),
	            v4(-118.19, 151.14, -73.85, 1),
	            v4(-263.54, 181.01, -166.62, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["246"].animation = [[6891, 1], [7096, -1]];
	Curves["246"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v36";
	Curves["247"] = function () {
	    var Curve_v01 = [[v4(-55.78, 130.5, 31.57, 1),
	            v4(-73.79, 130.5, 42.84, 1),
	            v4(-126.09, 165.2, 82.68, 1),
	            v4(-281.14, 195.06, 194.28, 1),
	        ], [v4(-65.33, 130.5, 2.18, 1),
	            v4(-86.53, 130.5, 3.64, 1),
	            v4(-147.96, 165.2, 9.08, 1),
	            v4(-330.06, 195.06, 24.32, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["247"].animation = [[6891, 1], [7096, -1]];
	Curves["247"].divisions = "|MAEmodelsPrevis|spiral_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v37";
	Curves.numCurves = 248;
	Curves["248"] = function () {
	    var Curve_v01 = [[v4(0.5, -19.06, -0.74, 1),
	            v4(0.67, -19.06, -0.08, 1),
	            v4(1.14, 15.63, 2.3, 1),
	            v4(2.56, 45.5, 8.93, 1),
	        ], [v4(-0.5, -19.06, -0.74, 1),
	            v4(-0.67, -19.06, -0.08, 1),
	            v4(-1.14, 15.63, 2.3, 1),
	            v4(-2.56, 45.5, 8.93, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["248"].animation = [[6891, 1], [7096, -1]];
	Curves["248"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v38";
	Curves["249"] = function () {
	    var Curve_v01 = [[v4(1.7, -18.56, -1.2, 1),
	            v4(2.25, -18.56, -0.69, 1),
	            v4(3.85, 16.13, 1.15, 1),
	            v4(8.59, 46, 6.29, 1),
	        ], [v4(0.77, -18.56, -0.6, 1),
	            v4(1.02, -18.56, 0.11, 1),
	            v4(1.74, 16.13, 2.65, 1),
	            v4(3.87, 46, 9.76, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["249"].animation = [[6891, 1], [7096, -1]];
	Curves["249"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v39";
	Curves["250"] = function () {
	    var Curve_v01 = [[v4(2.52, -18.01, -2.34, 1),
	            v4(3.34, -18.01, -2.2, 1),
	            v4(5.72, 16.68, -1.68, 1),
	            v4(12.75, 46.55, -0.22, 1),
	        ], [v4(2.03, -18.01, -1.24, 1),
	            v4(2.69, -18.01, -0.72, 1),
	            v4(4.59, 16.68, 1.09, 1),
	            v4(10.23, 46.55, 6.17, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["250"].animation = [[6891, 1], [7096, -1]];
	Curves["250"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v40";
	Curves["251"] = function () {
	    var Curve_v01 = [[v4(2.6, -17.41, -3.89, 1),
	            v4(3.45, -17.41, -4.25, 1),
	            v4(5.89, 17.29, -5.51, 1),
	            v4(13.13, 47.16, -9.05, 1),
	        ], [v4(2.81, -17.41, -2.57, 1),
	            v4(3.72, -17.41, -2.49, 1),
	            v4(6.37, 17.29, -2.22, 1),
	            v4(14.2, 47.16, -1.45, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["251"].animation = [[6891, 1], [7096, -1]];
	Curves["251"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v41";
	Curves["252"] = function () {
	    var Curve_v01 = [[v4(1.75, -16.74, -5.36, 1),
	            v4(2.31, -16.74, -6.2, 1),
	            v4(3.95, 17.95, -9.16, 1),
	            v4(8.8, 47.82, -17.44, 1),
	        ], [v4(2.73, -16.74, -4.28, 1),
	            v4(3.62, -16.74, -4.75, 1),
	            v4(6.19, 17.95, -6.43, 1),
	            v4(13.82, 47.82, -11.15, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["252"].animation = [[6891, 1], [7096, -1]];
	Curves["252"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v42";
	Curves["253"] = function () {
	    var Curve_v01 = [[v4(0.08, -16.01, -6.21, 1),
	            v4(0.1, -16.01, -7.32, 1),
	            v4(0.16, 18.68, -11.25, 1),
	            v4(0.35, 48.55, -22.26, 1),
	        ], [v4(1.64, -16.01, -5.8, 1),
	            v4(2.17, -16.01, -6.77, 1),
	            v4(3.72, 18.68, -10.21, 1),
	            v4(8.32, 48.55, -19.85, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["253"].animation = [[6891, 1], [7096, -1]];
	Curves["253"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v43";
	Curves["254"] = function () {
	    var Curve_v01 = [[v4(-1.97, -15.21, -6, 1),
	            v4(-2.62, -15.21, -7.03, 1),
	            v4(-4.48, 19.49, -10.7, 1),
	            v4(-10, 49.36, -20.99, 1),
	        ], [v4(-0.29, -15.21, -6.55, 1),
	            v4(-0.37, -15.21, -7.76, 1),
	            v4(-0.62, 19.49, -12.07, 1),
	            v4(-1.38, 49.36, -24.16, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["254"].animation = [[6891, 1], [7096, -1]];
	Curves["254"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v44";
	Curves["255"] = function () {
	    var Curve_v01 = [[v4(-3.73, -14.32, -4.57, 1),
	            v4(-4.95, -14.32, -5.14, 1),
	            v4(-8.46, 20.38, -7.16, 1),
	            v4(-18.88, 50.24, -12.82, 1),
	        ], [v4(-2.51, -14.32, -6.08, 1),
	            v4(-3.31, -14.32, -7.15, 1),
	            v4(-5.65, 20.38, -10.95, 1),
	            v4(-12.6, 50.24, -21.57, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["255"].animation = [[6891, 1], [7096, -1]];
	Curves["255"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v45";
	Curves["256"] = function () {
	    var Curve_v01 = [[v4(-4.5, -13.35, -2.2, 1),
	            v4(-5.96, -13.35, -1.99, 1),
	            v4(-10.19, 21.35, -1.28, 1),
	            v4(-22.73, 51.22, 0.73, 1),
	        ], [v4(-4.28, -13.35, -4.33, 1),
	            v4(-5.66, -13.35, -4.83, 1),
	            v4(-9.68, 21.35, -6.61, 1),
	            v4(-21.59, 51.22, -11.59, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["256"].animation = [[6891, 1], [7096, -1]];
	Curves["256"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v46";
	Curves["257"] = function () {
	    var Curve_v01 = [[v4(-3.79, -12.27, 0.45, 1),
	            v4(-5.01, -12.27, 1.52, 1),
	            v4(-8.57, 22.42, 5.28, 1),
	            v4(-19.1, 52.29, 15.83, 1),
	        ], [v4(-4.86, -12.27, -1.65, 1),
	            v4(-6.44, -12.27, -1.28, 1),
	            v4(-11.02, 22.42, 0.02, 1),
	            v4(-24.58, 52.29, 3.69, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["257"].animation = [[6891, 1], [7096, -1]];
	Curves["257"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v47";
	Curves["258"] = function () {
	    var Curve_v01 = [[v4(-1.55, -11.1, 2.47, 1),
	            v4(-2.04, -11.1, 4.19, 1),
	            v4(-3.47, 23.6, 10.27, 1),
	            v4(-7.73, 53.47, 27.31, 1),
	        ], [v4(-3.79, -11.1, 1.18, 1),
	            v4(-5.03, -11.1, 2.46, 1),
	            v4(-8.62, 23.6, 7.02, 1),
	            v4(-19.23, 53.47, 19.81, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["258"].animation = [[6891, 1], [7096, -1]];
	Curves["258"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v48";
	Curves["259"] = function () {
	    var Curve_v01 = [[v4(1.73, -9.8, 2.99, 1),
	            v4(2.31, -9.8, 4.87, 1),
	            v4(3.96, 24.9, 11.53, 1),
	            v4(8.85, 54.77, 30.2, 1),
	        ], [v4(-1.12, -9.8, 3.14, 1),
	            v4(-1.49, -9.8, 5.07, 1),
	            v4(-2.57, 24.9, 11.91, 1),
	            v4(-5.74, 54.77, 31.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["259"].animation = [[6891, 1], [7096, -1]];
	Curves["259"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v49";
	Curves["260"] = function () {
	    var Curve_v01 = [[v4(5.07, -8.37, 1.51, 1),
	            v4(6.72, -8.37, 2.89, 1),
	            v4(11.5, 26.32, 7.83, 1),
	            v4(25.68, 56.19, 21.66, 1),
	        ], [v4(2.53, -8.37, 3.35, 1),
	            v4(3.34, -8.37, 5.35, 1),
	            v4(5.69, 26.32, 12.45, 1),
	            v4(12.67, 56.19, 32.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["260"].animation = [[6891, 1], [7096, -1]];
	Curves["260"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v50";
	Curves["261"] = function () {
	    var Curve_v01 = [[v4(7.26, -6.8, -1.86, 1),
	            v4(9.61, -6.8, -1.58, 1),
	            v4(16.44, 27.89, -0.53, 1),
	            v4(36.67, 57.76, 2.4, 1),
	        ], [v4(6.02, -6.8, 1.36, 1),
	            v4(7.96, -6.8, 2.72, 1),
	            v4(13.61, 27.89, 7.54, 1),
	            v4(30.33, 57.76, 21.03, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["261"].animation = [[6891, 1], [7096, -1]];
	Curves["261"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v51";
	Curves["262"] = function () {
	    var Curve_v01 = [[v4(7.26, -5.08, -6.29, 1),
	            v4(9.6, -5.08, -7.43, 1),
	            v4(16.41, 29.62, -11.47, 1),
	            v4(36.59, 59.49, -22.8, 1),
	        ], [v4(8.05, -5.08, -2.57, 1),
	            v4(10.65, -5.08, -2.48, 1),
	            v4(18.22, 29.62, -2.18, 1),
	            v4(40.63, 59.49, -1.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["262"].animation = [[6891, 1], [7096, -1]];
	Curves["262"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v52";
	Curves["263"] = function () {
	    var Curve_v01 = [[v4(4.61, -3.18, -10.36, 1),
	            v4(6.08, -3.18, -12.82, 1),
	            v4(10.39, 31.52, -21.55, 1),
	            v4(23.14, 61.39, -46, 1),
	        ], [v4(7.56, -3.18, -7.41, 1),
	            v4(10.02, -3.18, -8.89, 1),
	            v4(17.15, 31.52, -14.16, 1),
	            v4(38.27, 61.39, -28.93, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["263"].animation = [[6891, 1], [7096, -1]];
	Curves["263"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v53";
	Curves["264"] = function () {
	    var Curve_v01 = [[v4(-0.28, -1.09, -12.54, 1),
	            v4(-0.39, -1.09, -15.69, 1),
	            v4(-0.69, 33.61, -26.9, 1),
	            v4(-1.58, 63.48, -58.31, 1),
	        ], [v4(4.22, -1.09, -11.58, 1),
	            v4(5.6, -1.09, -14.42, 1),
	            v4(9.6, 33.61, -24.51, 1),
	            v4(21.44, 63.48, -52.78, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["264"].animation = [[6891, 1], [7096, -1]];
	Curves["264"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v54";
	Curves["265"] = function () {
	    var Curve_v01 = [[v4(-6.09, 1.21, -11.62, 1),
	            v4(-8.08, 1.21, -14.46, 1),
	            v4(-10.08, 1.21, -17.3, 1),
	            v4(-12.07, 1.21, -20.15, 1),
	        ], [v4(-1.37, 1.21, -13.43, 1),
	            v4(-1.79, 1.21, -16.87, 1),
	            v4(-3.04, 35.9, -29.12, 1),
	            v4(-6.75, 65.77, -63.41, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["265"].animation = [[6891, 1], [7096, -1]];
	Curves["265"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v55";
	Curves["266"] = function () {
	    var Curve_v01 = [[v4(-10.9, 3.74, -7.28, 1),
	            v4(-14.44, 3.74, -8.71, 1),
	            v4(-24.7, 38.43, -13.83, 1),
	            v4(-55.12, 68.3, -28.15, 1),
	        ], [v4(-7.63, 3.74, -11.78, 1),
	            v4(-10.09, 3.74, -14.71, 1),
	            v4(-17.22, 38.43, -25.09, 1),
	            v4(-38.39, 68.3, -54.15, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["266"].animation = [[6891, 1], [7096, -1]];
	Curves["266"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v56";
	Curves["267"] = function () {
	    var Curve_v01 = [[v4(-12.74, 6.52, -0.41, 1),
	            v4(-16.87, 6.52, 0.4, 1),
	            v4(-28.83, 41.21, 3.21, 1),
	            v4(-64.31, 71.08, 11.1, 1),
	        ], [v4(-12.42, 6.52, -6.51, 1),
	            v4(-16.44, 6.52, -7.75, 1),
	            v4(-28.1, 41.21, -12.08, 1),
	            v4(-62.67, 71.08, -24.21, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["267"].animation = [[6891, 1], [7096, -1]];
	Curves["267"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v57";
	Curves["268"] = function () {
	    var Curve_v01 = [[v4(-10.32, 9.57, 7.04, 1),
	            v4(-13.64, 9.57, 10.25, 1),
	            v4(-23.3, 44.27, 21.63, 1),
	            v4(-51.95, 74.14, 53.51, 1),
	        ], [v4(-13.68, 9.57, 1.21, 1),
	            v4(-18.13, 9.57, 2.49, 1),
	            v4(-31, 44.27, 7.05, 1),
	            v4(-69.17, 74.14, 19.83, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["268"].animation = [[6891, 1], [7096, -1]];
	Curves["268"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v58";
	Curves["269"] = function () {
	    var Curve_v01 = [[v4(-3.62, 12.94, 12.46, 1),
	            v4(-4.76, 12.94, 17.42, 1),
	            v4(-8.11, 47.63, 35.01, 1),
	            v4(-18.04, 77.5, 84.29, 1),
	        ], [v4(-10.22, 12.94, 9.1, 1),
	            v4(-13.56, 12.94, 12.94, 1),
	            v4(-23.21, 47.63, 26.6, 1),
	            v4(-51.8, 77.5, 64.87, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["269"].animation = [[6891, 1], [7096, -1]];
	Curves["269"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v59";
	Curves["270"] = function () {
	    var Curve_v01 = [[v4(5.8, 16.64, 13.45, 1),
	            v4(7.72, 16.64, 18.7, 1),
	            v4(13.23, 51.33, 37.39, 1),
	            v4(29.57, 81.2, 89.74, 1),
	        ], [v4(-2.3, 16.64, 14.3, 1),
	            v4(-3.08, 16.64, 19.84, 1),
	            v4(-5.3, 51.33, 39.52, 1),
	            v4(-11.88, 81.2, 94.66, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["270"].animation = [[6891, 1], [7096, -1]];
	Curves["270"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v60";
	Curves["271"] = function () {
	    var Curve_v01 = [[v4(15.09, 20.71, 8.71, 1),
	            v4(20, 20.71, 12.41, 1),
	            v4(34.23, 55.4, 25.61, 1),
	            v4(76.39, 85.27, 62.57, 1),
	        ], [v4(8.13, 20.71, 14.35, 1),
	            v4(10.72, 20.71, 19.93, 1),
	            v4(18.3, 55.4, 39.72, 1),
	            v4(40.76, 85.27, 95.15, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["271"].animation = [[6891, 1], [7096, -1]];
	Curves["271"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v61";
	Curves["272"] = function () {
	    var Curve_v01 = [[v4(20.82, 25.18, -1.22, 1),
	            v4(27.57, 25.18, -0.75, 1),
	            v4(47.14, 59.88, 0.99, 1),
	            v4(105.17, 89.75, 5.84, 1),
	        ], [v4(17.77, 25.18, 8.15, 1),
	            v4(23.51, 25.18, 11.74, 1),
	            v4(40.18, 59.88, 24.44, 1),
	            v4(89.58, 89.75, 60, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["272"].animation = [[6891, 1], [7096, -1]];
	Curves["272"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v62";
	Curves["273"] = function () {
	    var Curve_v01 = [[v4(20.16, 30.11, -13.81, 1),
	            v4(26.66, 30.11, -17.42, 1),
	            v4(45.57, 64.81, -30.19, 1),
	            v4(101.61, 94.67, -65.96, 1),
	        ], [v4(22.96, 30.11, -3.35, 1),
	            v4(30.4, 30.11, -3.47, 1),
	            v4(51.99, 64.81, -3.99, 1),
	            v4(115.97, 94.67, -5.46, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["273"].animation = [[6891, 1], [7096, -1]];
	Curves["273"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v63";
	Curves["274"] = function () {
	    var Curve_v01 = [[v4(12, 35.53, -25.03, 1),
	            v4(15.84, 35.53, -32.27, 1),
	            v4(27.03, 70.22, -57.92, 1),
	            v4(60.22, 100.09, -129.79, 1),
	        ], [v4(20.86, 35.53, -17.06, 1),
	            v4(27.65, 35.53, -21.63, 1),
	            v4(47.31, 70.22, -37.96, 1),
	            v4(105.57, 100.09, -83.69, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["274"].animation = [[6891, 1], [7096, -1]];
	Curves["274"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v64";
	Curves["275"] = function () {
	    var Curve_v01 = [[v4(-2.25, 41.49, -30.5, 1),
	            v4(-3.04, 41.49, -39.47, 1),
	            v4(-5.26, 76.18, -71.36, 1),
	            v4(-11.84, 106.05, -160.69, 1),
	        ], [v4(10.7, 41.49, -28.45, 1),
	            v4(14.22, 41.49, -36.74, 1),
	            v4(24.38, 76.18, -66.23, 1),
	            v4(54.47, 106.05, -148.83, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["275"].animation = [[6891, 1], [7096, -1]];
	Curves["275"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v65";
	Curves["276"] = function () {
	    var Curve_v01 = [[v4(-18.67, 48.04, -27.01, 1),
	            v4(-24.78, 48.04, -34.81, 1),
	            v4(-42.42, 82.74, -62.6, 1),
	            v4(-94.7, 112.61, -140.45, 1),
	        ], [v4(-5.49, 48.04, -32.87, 1),
	            v4(-7.21, 48.04, -42.63, 1),
	            v4(-12.26, 82.74, -77.29, 1),
	            v4(-27.24, 112.61, -174.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["276"].animation = [[6891, 1], [7096, -1]];
	Curves["276"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v66";
	Curves["277"] = function () {
	    var Curve_v01 = [[v4(-31.72, 55.25, -13.95, 1),
	            v4(-42.03, 55.25, -17.49, 1),
	            v4(-71.89, 89.95, -30.18, 1),
	            v4(-160.41, 119.82, -65.73, 1),
	        ], [v4(-23.08, 55.25, -27.25, 1),
	            v4(-30.51, 55.25, -35.23, 1),
	            v4(-52.12, 89.95, -63.49, 1),
	            v4(-116.17, 119.82, -142.65, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["277"].animation = [[6891, 1], [7096, -1]];
	Curves["277"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v67";
	Curves["278"] = function () {
	    var Curve_v01 = [[v4(-35.94, 63.18, 5.92, 1),
	            v4(-47.58, 63.18, 8.83, 1),
	            v4(-81.33, 97.88, 19.04, 1),
	            v4(-181.38, 127.75, 47.64, 1),
	        ], [v4(-35.94, 63.18, -11.53, 1),
	            v4(-47.58, 63.18, -14.43, 1),
	            v4(-81.33, 97.88, -24.64, 1),
	            v4(-181.38, 127.75, -53.24, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["278"].animation = [[6891, 1], [7096, -1]];
	Curves["278"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v68";
	Curves["279"] = function () {
	    var Curve_v01 = [[v4(-27.93, 71.91, 26.78, 1),
	            v4(-36.92, 71.91, 36.43, 1),
	            v4(-63.06, 106.6, 70.63, 1),
	            v4(-140.56, 136.47, 166.41, 1),
	        ], [v4(-38.39, 71.91, 10.68, 1),
	            v4(-50.86, 71.91, 14.97, 1),
	            v4(-86.99, 106.6, 30.33, 1),
	            v4(-194.1, 136.47, 73.35, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["279"].animation = [[6891, 1], [7096, -1]];
	Curves["279"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v69";
	Curves["280"] = function () {
	    var Curve_v01 = [[v4(-8.05, 81.5, 41.22, 1),
	            v4(-10.56, 81.5, 55.51, 1),
	            v4(-17.95, 116.2, 106.25, 1),
	            v4(-39.88, 146.07, 248.38, 1),
	        ], [v4(-27.33, 81.5, 32.64, 1),
	            v4(-36.27, 81.5, 44.06, 1),
	            v4(-62.1, 116.2, 84.75, 1),
	            v4(-138.65, 146.07, 198.73, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["280"].animation = [[6891, 1], [7096, -1]];
	Curves["280"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v70";
	Curves["281"] = function () {
	    var Curve_v01 = [[v4(18.95, 92.06, 42.63, 1),
	            v4(25.2, 92.06, 57.32, 1),
	            v4(43.19, 126.76, 109.56, 1),
	            v4(96.5, 156.63, 255.89, 1),
	        ], [v4(-3.99, 92.06, 46.27, 1),
	            v4(-5.39, 92.06, 62.16, 1),
	            v4(-9.32, 126.76, 118.66, 1),
	            v4(-20.97, 156.63, 276.9, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["281"].animation = [[6891, 1], [7096, -1]];
	Curves["281"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v71";
	Curves["282"] = function () {
	    var Curve_v01 = [[v4(44.71, 103.67, 27.76, 1),
	            v4(59.27, 103.67, 37.57, 1),
	            v4(101.4, 138.37, 72.56, 1),
	            v4(226.3, 168.24, 170.59, 1),
	        ], [v4(25.72, 103.67, 44.85, 1),
	            v4(33.95, 103.67, 60.36, 1),
	            v4(57.94, 138.37, 115.36, 1),
	            v4(129.08, 168.24, 269.41, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["282"].animation = [[6891, 1], [7096, -1]];
	Curves["282"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v72";
	Curves["283"] = function () {
	    var Curve_v01 = [[v4(59.55, 116.45, -1.39, 1),
	            v4(78.86, 116.45, -1.07, 1),
	            v4(134.84, 151.14, 0.29, 1),
	            v4(300.78, 181.01, 4.09, 1),
	        ], [v4(52.28, 116.45, 25.75, 1),
	            v4(69.16, 116.45, 35.13, 1),
	            v4(118.19, 151.14, 68.25, 1),
	            v4(263.54, 181.01, 161.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["283"].animation = [[6891, 1], [7096, -1]];
	Curves["283"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v73";
	Curves["284"] = function () {
	    var Curve_v01 = [[v4(55.78, 130.5, -37.18, 1),
	            v4(73.79, 130.5, -48.45, 1),
	            v4(126.09, 165.2, -88.29, 1),
	            v4(281.14, 195.06, -199.89, 1),
	        ], [v4(65.33, 130.5, -7.78, 1),
	            v4(86.53, 130.5, -9.25, 1),
	            v4(147.96, 165.2, -14.69, 1),
	            v4(330.06, 195.06, -29.92, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["284"].animation = [[6891, 1], [7096, -1]];
	Curves["284"].divisions = "|MAEmodelsPrevis|spiral2_20000_3_2_242_256_256_400_10_100_100_50_10|_9_4_v74";
	Curves.numCurves = 285;
	Curves["285"] = function () {
	    var Curve_v01 = [[v4(-13.9, 11.69, -11.21, 1),
	            v4(-21.96, 94.97, -15.23, 1),
	            v4(-68.54, 191.41, -21.94, 1),
	            v4(-121.3, 282.46, -41.05, 1),
	        ], [v4(-8.41, 11.69, 2.6, 1),
	            v4(-15.49, 94.97, 7.23, 1),
	            v4(-51.81, 191.41, 42.66, 1),
	            v4(-91.2, 282.46, 73.39, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["285"].animation = [[6806, -1], [7200, -0.4682814266], [7659, 1]];
	Curves["285"].divisions = "|MAEmodelsPrevis|tunnelEnd_1000_1_1_242_256_256_300_50_100_100_20_20|_20_5_v334";
	Curves["286"] = function () {
	    var Curve_v01 = [[v4(5.5, 11.69, -20.06, 1),
	            v4(9.78, 94.97, -30.98, 1),
	            v4(16.68, 191.41, -73.36, 1),
	            v4(31.67, 282.46, -133.08, 1),
	        ], [v4(-17.05, 11.69, -1.95, 1),
	            v4(-26.94, 94.97, -0.81, 1),
	            v4(-71.06, 191.41, 19.13, 1),
	            v4(-126.53, 282.46, 31.9, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["286"].animation = [[6806, -1], [7200, -0.4682814266], [7659, 1]];
	Curves["286"].divisions = "|MAEmodelsPrevis|tunnelEnd_1000_1_1_242_256_256_300_50_100_100_20_20|_20_5_v331";
	Curves["287"] = function () {
	    var Curve_v01 = [[v4(16.17, 11.69, -0.25, 1),
	            v4(26.81, 94.97, 2.55, 1),
	            v4(67.97, 191.41, 27.83, 1),
	            v4(121.34, 282.46, 47.42, 1),
	        ], [v4(16.96, 11.69, -13.21, 1),
	            v4(27.28, 94.97, -20.03, 1),
	            v4(67.64, 191.41, -38.38, 1),
	            v4(121.2, 282.46, -70.2, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["287"].animation = [[6806, -1], [7200, -0.4682814266], [7659, 1]];
	Curves["287"].divisions = "|MAEmodelsPrevis|tunnelEnd_1000_1_1_242_256_256_300_50_100_100_20_20|_20_5_v332";
	Curves["288"] = function () {
	    var Curve_v01 = [[v4(2.86, 11.69, 4.25, 1),
	            v4(9.89, 94.97, 14.08, 1),
	            v4(24.3, 191.41, 63.19, 1),
	            v4(43.35, 282.46, 109.7, 1),
	        ], [v4(13.04, 11.69, -6.97, 1),
	            v4(25.63, 94.97, -7.74, 1),
	            v4(72.35, 191.41, 0.23, 1),
	            v4(128.62, 282.46, -1.73, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["288"].animation = [[6806, -1], [7200, -0.4682814266], [7659, 1]];
	Curves["288"].divisions = "|MAEmodelsPrevis|tunnelEnd_1000_1_1_242_256_256_300_50_100_100_20_20|_20_5_v333";
	Curves.numCurves = 289;
	Curves["289"] = function () {
	    var Curve_v01 = [[v4(26.41, 51.5, -107.05, 1),
	            v4(26.78, 52.37, -107.02, 1),
	            v4(27.42, 53.92, -106.98, 1),
	            v4(27.64, 56.32, -106.94, 1),
	            v4(27.59, 60.06, -106.91, 1),
	            v4(27.38, 71.82, -106.97, 1),
	            v4(15.4, 98.92, -118.68, 1),
	            v4(10.5, 106.78, -120.59, 1),
	            v4(33.33, 142.84, -178.71, 1),
	            v4(77.05, 107.92, -126.46, 1),
	            v4(50.74, 156.57, -106.87, 1),
	            v4(55.97, 205.76, -142.83, 1),
	            v4(3.57, 182.89, -148.88, 1),
	            v4(22.78, 231.96, -120.14, 1),
	            v4(32.03, 271.18, -134.47, 1),
	            v4(35.09, 311.61, -99.61, 1),
	            v4(55.19, 322.58, -65.68, 1),
	            v4(64.59, 326.87, -21.18, 1),
	            v4(64, 330.54, 21, 1),
	            v4(52.23, 331.35, 64.87, 1),
	            v4(38.11, 328.91, 90.47, 1),
	            v4(29.1, 328.72, 101.99, 1),
	        ], [v4(25, 51.6, -111.54, 1),
	            v4(24.58, 52.57, -111.48, 1),
	            v4(23.81, 54.32, -111.39, 1),
	            v4(23.64, 57.02, -111.31, 1),
	            v4(23.55, 60.84, -111.27, 1),
	            v4(23.23, 72.48, -111.43, 1),
	            v4(12.27, 99.68, -121.49, 1),
	            v4(13.34, 107.37, -124.2, 1),
	            v4(35.15, 142.64, -181.39, 1),
	            v4(78.93, 108.01, -128.48, 1),
	            v4(52.12, 157.43, -109.72, 1),
	            v4(57.45, 205.74, -146.07, 1),
	            v4(4.83, 182.89, -151.12, 1),
	            v4(24.81, 232.51, -123.05, 1),
	            v4(33.53, 271.36, -137.01, 1),
	            v4(36.88, 311.81, -102.15, 1),
	            v4(56.87, 322.56, -68.18, 1),
	            v4(67.26, 326.91, -23.75, 1),
	            v4(69.39, 330.53, 19, 1),
	            v4(72.57, 331.35, 68.72, 1),
	            v4(82.75, 328.9, 94, 1),
	            v4(84.45, 328.72, 107.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["289"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["289"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v1";
	Curves["290"] = function () {
	    var Curve_v01 = [[v4(27.84, 5.3, -4.98, 1),
	            v4(27.87, 5.6, -4.75, 1),
	            v4(27.88, 6.41, -4.63, 1),
	            v4(27.86, 7.67, -4.62, 1),
	            v4(27.83, 10.22, -4.63, 1),
	            v4(33.71, 30.77, -13.61, 1),
	            v4(29.79, 68.12, -19.34, 1),
	            v4(38.91, 119.19, -23.19, 1),
	            v4(8.55, 142.24, 43.73, 1),
	            v4(1.25, 110.24, -27.4, 1),
	            v4(64.08, 151.62, -7.72, 1),
	            v4(30.04, 200.79, -51.82, 1),
	            v4(110.88, 205.9, -65.77, 1),
	            v4(133.23, 224.32, -88.54, 1),
	            v4(189.06, 280.63, -92.23, 1),
	            v4(127.28, 311.58, -55.81, 1),
	            v4(113.71, 243.47, -89.34, 1),
	            v4(165.31, 254.58, -134.86, 1),
	            v4(190.18, 301.67, -129.9, 1),
	            v4(250.96, 305.56, -159.26, 1),
	            v4(270.28, 288.37, -164.95, 1),
	            v4(280.62, 271.8, -170.75, 1),
	        ], [v4(27.68, 5.57, -5.91, 1),
	            v4(27.59, 6.06, -6.19, 1),
	            v4(27.48, 6.94, -6.34, 1),
	            v4(27.36, 8.34, -6.44, 1),
	            v4(27.19, 10.65, -6.54, 1),
	            v4(25.71, 22.94, -7.89, 1),
	            v4(28.32, 69.57, -22.11, 1),
	            v4(39.87, 118.42, -26.58, 1),
	            v4(8.56, 142.63, 40.64, 1),
	            v4(1.5, 110.06, -30.52, 1),
	            v4(64.28, 151.6, -10.88, 1),
	            v4(30.24, 200.72, -54.92, 1),
	            v4(111.03, 205.92, -68.92, 1),
	            v4(133.43, 224.27, -91.67, 1),
	            v4(189.27, 280.57, -95.42, 1),
	            v4(127.59, 311.62, -58.99, 1),
	            v4(113.9, 243.5, -92.45, 1),
	            v4(165.53, 254.56, -138.02, 1),
	            v4(190.4, 301.66, -133.06, 1),
	            v4(238.62, 304.54, -184.6, 1),
	            v4(248.95, 286.61, -206.17, 1),
	            v4(256.79, 269.84, -216.37, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["290"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["290"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v2";
	Curves["291"] = function () {
	    var Curve_v01 = [[v4(-36.74, 36.28, -80.08, 1),
	            v4(-36.74, 36.77, -80.09, 1),
	            v4(-36.12, 38.99, -80.4, 1),
	            v4(-36.18, 42.58, -80.49, 1),
	            v4(-36.54, 49.73, -80.73, 1),
	            v4(-37.42, 62.31, -81.51, 1),
	            v4(-48.14, 88.2, -84.53, 1),
	            v4(-42.09, 123.91, -92.54, 1),
	            v4(-48.81, 168.02, -98.98, 1),
	            v4(-59.17, 210.64, -106.34, 1),
	            v4(-75.71, 249.78, -122.19, 1),
	            v4(-93.14, 281.09, -149.28, 1),
	            v4(-107.65, 306.62, -183.27, 1),
	            v4(-111.93, 325.17, -224.6, 1),
	            v4(-102.34, 333.69, -267.99, 1),
	            v4(-82.96, 337.09, -308.28, 1),
	            v4(-55.96, 338.46, -344.13, 1),
	            v4(-21.2, 340.07, -372.65, 1),
	            v4(19.15, 343.12, -392.09, 1),
	            v4(61.71, 348.37, -404.7, 1),
	            v4(90.83, 353.79, -409.01, 1),
	            v4(104.94, 358.65, -409.42, 1),
	        ], [v4(-38.58, 36.28, -79.21, 1),
	            v4(-38.58, 36.72, -79.21, 1),
	            v4(-39.22, 39.04, -78.96, 1),
	            v4(-39.39, 42.65, -79.17, 1),
	            v4(-39.91, 49.89, -79.95, 1),
	            v4(-41.35, 62.04, -82.19, 1),
	            v4(-49.51, 87.5, -88.55, 1),
	            v4(-41.23, 123.01, -94.58, 1),
	            v4(-48.73, 167.16, -102.53, 1),
	            v4(-58.52, 209.91, -109.05, 1),
	            v4(-75.28, 249.2, -125.13, 1),
	            v4(-92.61, 280.69, -151.92, 1),
	            v4(-107.32, 306.32, -185.99, 1),
	            v4(-111.72, 325.03, -227.25, 1),
	            v4(-102.27, 333.64, -270.75, 1),
	            v4(-82.91, 337.07, -311.51, 1),
	            v4(-55.93, 338.45, -356.26, 1),
	            v4(-21.16, 340.06, -390.96, 1),
	            v4(20.02, 343.1, -416.05, 1),
	            v4(69.96, 348.36, -459.71, 1),
	            v4(93.53, 353.78, -504.73, 1),
	            v4(105.17, 358.65, -516.13, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["291"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["291"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v3";
	Curves["292"] = function () {
	    var Curve_v01 = [[v4(4.04, 29.9, -56.7, 1),
	            v4(4.04, 30.08, -56.74, 1),
	            v4(4.35, 30.81, -56.67, 1),
	            v4(4.34, 32.17, -56.91, 1),
	            v4(4.14, 34.77, -57.4, 1),
	            v4(2.02, 51.48, -59.74, 1),
	            v4(-10.03, 75.97, -57.92, 1),
	            v4(33.77, 111.55, -66.07, 1),
	            v4(-1.45, 119.82, -125.23, 1),
	            v4(-43.05, 141.51, -114.35, 1),
	            v4(-88.86, 156.41, -93.68, 1),
	            v4(-70.74, 168.09, -32.32, 1),
	            v4(-55.83, 221.83, -53.59, 1),
	            v4(-122.05, 227.09, -83.31, 1),
	            v4(-77.09, 272.52, -112.73, 1),
	            v4(-87.55, 301.67, -56.35, 1),
	            v4(-127.59, 307.03, -35.84, 1),
	            v4(-170.48, 305.49, -11.69, 1),
	            v4(-219.44, 310.18, -3.07, 1),
	            v4(-266.16, 312.63, 15.66, 1),
	            v4(-296.88, 315.68, 24.77, 1),
	            v4(-311.86, 316.89, 29.84, 1),
	        ], [v4(2.85, 29.9, -57.49, 1),
	            v4(2.86, 30.14, -57.55, 1),
	            v4(2.53, 31, -58.01, 1),
	            v4(2.47, 32.35, -58.38, 1),
	            v4(2.38, 34.9, -58.97, 1),
	            v4(1.02, 51.56, -61.72, 1),
	            v4(-10.52, 76.6, -59.54, 1),
	            v4(34.24, 111.34, -69.98, 1),
	            v4(-1.3, 119.91, -127.98, 1),
	            v4(-42.74, 141.45, -117.73, 1),
	            v4(-88.65, 156.43, -96.76, 1),
	            v4(-70.51, 168.06, -35.55, 1),
	            v4(-55.59, 221.83, -56.71, 1),
	            v4(-121.82, 227.08, -86.47, 1),
	            v4(-76.87, 272.51, -115.89, 1),
	            v4(-87.3, 301.67, -59.57, 1),
	            v4(-127.35, 307.03, -41.22, 1),
	            v4(-170.2, 305.49, -21.18, 1),
	            v4(-217.79, 310.18, -25.74, 1),
	            v4(-264.67, 312.63, -31.3, 1),
	            v4(-295.97, 315.68, -36.23, 1),
	            v4(-311.63, 316.89, -34.87, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["292"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["292"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v4";
	Curves["293"] = function () {
	    var Curve_v01 = [[v4(31.21, 34.3, -67.87, 1),
	            v4(31.43, 34.65, -67.79, 1),
	            v4(31.96, 36.04, -67.58, 1),
	            v4(32.08, 38.73, -67.49, 1),
	            v4(32.09, 42.96, -67.47, 1),
	            v4(31.01, 55.48, -68.79, 1),
	            v4(21.39, 87.71, -83.94, 1),
	            v4(41.53, 102.86, -110.53, 1),
	            v4(57.66, 117.6, -156.4, 1),
	            v4(81.29, 118.14, -190.83, 1),
	            v4(95.51, 146.66, -241.84, 1),
	            v4(59.27, 183.32, -216.37, 1),
	            v4(36.07, 194.49, -184.41, 1),
	            v4(3.54, 213.35, -155.38, 1),
	            v4(-27.29, 226.33, -124.43, 1),
	            v4(-62.8, 240.9, -98.64, 1),
	            v4(-103.89, 252.53, -79.39, 1),
	            v4(-150.6, 260.64, -82.19, 1),
	            v4(-191.82, 264.41, -103.98, 1),
	            v4(-225.94, 268.54, -134.69, 1),
	            v4(-244.67, 271.63, -159.09, 1),
	            v4(-253.19, 273.38, -171.67, 1),
	        ], [v4(29.65, 34.3, -68.27, 1),
	            v4(29.44, 34.76, -68.31, 1),
	            v4(29.04, 36.42, -68.4, 1),
	            v4(29.01, 39.33, -68.4, 1),
	            v4(29.01, 43.45, -68.4, 1),
	            v4(28.26, 55.76, -69.95, 1),
	            v4(19.7, 87.59, -85.91, 1),
	            v4(40.91, 102.41, -112.15, 1),
	            v4(57.35, 117.14, -158.24, 1),
	            v4(80.5, 118.2, -192.43, 1),
	            v4(96.28, 145.03, -244.35, 1),
	            v4(60.47, 183.07, -220.87, 1),
	            v4(36.92, 193.99, -188.01, 1),
	            v4(4.47, 213.11, -159.3, 1),
	            v4(-26.51, 226.04, -128.03, 1),
	            v4(-61.99, 240.73, -102.18, 1),
	            v4(-103.13, 252.4, -82.64, 1),
	            v4(-149.55, 260.61, -85.38, 1),
	            v4(-180.17, 264.38, -111.67, 1),
	            v4(-198.22, 268.53, -149.21, 1),
	            v4(-210.29, 271.62, -176.51, 1),
	            v4(-217.93, 273.38, -189.5, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["293"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["293"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v5";
	Curves["294"] = function () {
	    var Curve_v01 = [[v4(-79.7, 51.39, -116, 1),
	            v4(-78.83, 52.2, -116, 1),
	            v4(-78.65, 53.74, -116, 1),
	            v4(-78.6, 56.17, -116, 1),
	            v4(-78.57, 60.7, -115.98, 1),
	            v4(-78.58, 72.64, -115.88, 1),
	            v4(-87.83, 100.35, -103.8, 1),
	            v4(-89.47, 134.06, -95.05, 1),
	            v4(-150.36, 155.85, -100.9, 1),
	            v4(-117.19, 135.2, -155.84, 1),
	            v4(-89.95, 183.86, -137.57, 1),
	            v4(-166.96, 232.63, -119.93, 1),
	            v4(-155.2, 209.77, -68.51, 1),
	            v4(-134.51, 258.84, -96.2, 1),
	            v4(-151.1, 298.05, -100.15, 1),
	            v4(-119.25, 338.48, -114.65, 1),
	            v4(-93.96, 349.46, -144.91, 1),
	            v4(-55.47, 353.75, -169.54, 1),
	            v4(-16.58, 357.41, -186.09, 1),
	            v4(27.61, 358.22, -192.7, 1),
	            v4(56.21, 355.78, -188.6, 1),
	            v4(70.07, 355.6, -183.95, 1),
	        ], [v4(-83.18, 51.39, -114.67, 1),
	            v4(-83.98, 52.13, -114.68, 1),
	            v4(-84.08, 53.61, -114.69, 1),
	            v4(-84.03, 55.99, -114.68, 1),
	            v4(-83.93, 60.42, -114.61, 1),
	            v4(-83.99, 72.42, -114.24, 1),
	            v4(-90.75, 100.46, -104.27, 1),
	            v4(-93.83, 134.66, -96.52, 1),
	            v4(-153.49, 155.65, -101.72, 1),
	            v4(-119.72, 135.29, -156.94, 1),
	            v4(-93.1, 184.71, -137.92, 1),
	            v4(-170.51, 232.61, -120.25, 1),
	            v4(-157.74, 209.77, -68.96, 1),
	            v4(-137.92, 259.38, -97.15, 1),
	            v4(-153.99, 298.24, -100.8, 1),
	            v4(-122.25, 338.69, -118.89, 1),
	            v4(-96.88, 349.43, -152.84, 1),
	            v4(-58.45, 353.79, -181.38, 1),
	            v4(-19.58, 357.4, -210.52, 1),
	            v4(24.55, 358.23, -232.85, 1),
	            v4(53.13, 355.78, -234.9, 1),
	            v4(66.97, 355.6, -230.99, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["294"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["294"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v6";
	Curves["295"] = function () {
	    var Curve_v01 = [[v4(-7.76, 2.72, -4.53, 1),
	            v4(-7.6, 2.88, -4.54, 1),
	            v4(-7.48, 3.48, -4.64, 1),
	            v4(-7.48, 4.73, -4.91, 1),
	            v4(-7.61, 6.61, -5.3, 1),
	            v4(-11.59, 17.91, -7.28, 1),
	            v4(1.07, 48.45, -4.55, 1),
	            v4(13.04, 85.75, -5.55, 1),
	            v4(36.54, 106.74, 49.53, 1),
	            v4(-28.08, 86.39, 45.73, 1),
	            v4(-23.83, 135.8, 13.29, 1),
	            v4(-0.6, 184.11, 41.75, 1),
	            v4(38.64, 161.27, 6.34, 1),
	            v4(4.44, 210.88, 2.13, 1),
	            v4(8.86, 249.74, 17.99, 1),
	            v4(-19.13, 290.19, -3.07, 1),
	            v4(-57.68, 300.93, -11.25, 1),
	            v4(-97.47, 305.29, -33.58, 1),
	            v4(-130.33, 308.9, -60.11, 1),
	            v4(-156.9, 309.73, -95.94, 1),
	            v4(-166.74, 307.28, -123.09, 1),
	            v4(-169.15, 307.1, -137.48, 1),
	        ], [v4(-8.65, 2.72, -4.75, 1),
	            v4(-8.9, 2.89, -4.85, 1),
	            v4(-9.29, 3.52, -5.09, 1),
	            v4(-9.71, 4.99, -5.51, 1),
	            v4(-9.93, 7.25, -6.02, 1),
	            v4(-13.46, 18.69, -8.1, 1),
	            v4(-4.04, 48.56, -7.2, 1),
	            v4(12.29, 85.15, -10.09, 1),
	            v4(35.79, 106.94, 46.38, 1),
	            v4(-28.3, 86.29, 42.98, 1),
	            v4(-25, 134.95, 10.34, 1),
	            v4(-1.99, 184.13, 38.47, 1),
	            v4(37.84, 161.27, 3.89, 1),
	            v4(3.67, 210.34, -1.33, 1),
	            v4(8.03, 249.55, 15.17, 1),
	            v4(-18.79, 289.98, -6.11, 1),
	            v4(-56.35, 300.96, -14.18, 1),
	            v4(-93.94, 305.25, -36.55, 1),
	            v4(-113.1, 308.91, -63.06, 1),
	            v4(-121.27, 309.72, -98.94, 1),
	            v4(-124.38, 307.28, -126.11, 1),
	            v4(-126.1, 307.1, -140.52, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["295"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["295"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v7";
	Curves["296"] = function () {
	    var Curve_v01 = [[v4(10.85, 2.14, -5.25, 1),
	            v4(11.01, 2.75, -5.27, 1),
	            v4(11.19, 4.05, -5.3, 1),
	            v4(11.26, 6.33, -5.33, 1),
	            v4(11.34, 9.61, -5.37, 1),
	            v4(12.99, 21.36, -6.94, 1),
	            v4(22.18, 60.04, -5.02, 1),
	            v4(17.75, 108.25, 6.37, 1),
	            v4(-10.72, 132.47, -62.11, 1),
	            v4(46.55, 99.9, -19.29, 1),
	            v4(-10.32, 141.43, 13.78, 1),
	            v4(45.15, 190.55, 18.4, 1),
	            v4(0.96, 195.75, 87.45, 1),
	            v4(2.62, 214.1, 119.33, 1),
	            v4(-32.31, 270.4, 163.07, 1),
	            v4(-17.55, 301.45, 92.96, 1),
	            v4(16.38, 233.33, 105.45, 1),
	            v4(15.15, 244.39, 174.31, 1),
	            v4(-5.29, 291.49, 189.3, 1),
	            v4(-18.33, 293.66, 256.96, 1),
	            v4(-22.64, 275.23, 277.19, 1),
	            v4(-24.08, 258.31, 289.33, 1),
	        ], [v4(10.36, 2.39, -6.51, 1),
	            v4(10.21, 3.01, -6.52, 1),
	            v4(10.05, 4.28, -6.54, 1),
	            v4(10, 6.18, -6.56, 1),
	            v4(10.06, 8.96, -6.59, 1),
	            v4(11.2, 21.59, -7.88, 1),
	            v4(19.18, 58.45, -5.87, 1),
	            v4(15.89, 109.02, 3.37, 1),
	            v4(-12.99, 132.07, -64.2, 1),
	            v4(44.42, 100.08, -21.57, 1),
	            v4(-12.51, 141.45, 11.5, 1),
	            v4(43.01, 190.63, 16.15, 1),
	            v4(-1.27, 195.74, 85.21, 1),
	            v4(0.44, 214.15, 117.07, 1),
	            v4(-34.51, 270.47, 160.76, 1),
	            v4(-19.69, 301.41, 90.6, 1),
	            v4(13.43, 233.3, 103.21, 1),
	            v4(4.64, 244.42, 172.01, 1),
	            v4(-24.71, 291.5, 187.02, 1),
	            v4(-61.84, 293.66, 254.66, 1),
	            v4(-71.74, 275.22, 274.89, 1),
	            v4(-73.93, 258.31, 287.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["296"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["296"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v8";
	Curves["297"] = function () {
	    var Curve_v01 = [[v4(10.28, 5.93, -10.21, 1),
	            v4(10.2, 6.37, -10.21, 1),
	            v4(10.12, 7.16, -10.21, 1),
	            v4(10.07, 8.43, -10.21, 1),
	            v4(10.07, 10, -10.21, 1),
	            v4(8.83, 23.39, -10.01, 1),
	            v4(18.09, 51.21, -8.87, 1),
	            v4(16.74, 92.84, 3.07, 1),
	            v4(27.67, 136.99, 2.9, 1),
	            v4(39.1, 179.74, 0.08, 1),
	            v4(62.27, 219.03, -1.44, 1),
	            v4(93.73, 250.52, 3.85, 1),
	            v4(128.8, 276.15, 16, 1),
	            v4(162.21, 294.86, 40.6, 1),
	            v4(187.93, 303.47, 76.94, 1),
	            v4(204.66, 306.9, 118.47, 1),
	            v4(212.98, 308.28, 162.65, 1),
	            v4(211.65, 309.89, 211.45, 1),
	            v4(203.07, 312.93, 270.4, 1),
	            v4(187.89, 318.19, 326.23, 1),
	            v4(172.4, 323.61, 354.42, 1),
	            v4(163.17, 328.48, 365.13, 1),
	        ], [v4(10.62, 5.93, -8.94, 1),
	            v4(10.69, 6.36, -8.94, 1),
	            v4(10.77, 7.17, -8.94, 1),
	            v4(10.83, 8.45, -8.94, 1),
	            v4(10.84, 10.02, -8.94, 1),
	            v4(9.05, 23.81, -9.03, 1),
	            v4(13.69, 52.07, -10.47, 1),
	            v4(15.82, 93.74, 1.05, 1),
	            v4(25.11, 137.84, 0.44, 1),
	            v4(37.54, 180.47, -2.23, 1),
	            v4(60.39, 219.61, -3.74, 1),
	            v4(92.14, 250.91, 1.69, 1),
	            v4(127.02, 276.45, 13.92, 1),
	            v4(160.4, 295, 38.66, 1),
	            v4(185.55, 303.52, 74.9, 1),
	            v4(197.74, 306.91, 115.05, 1),
	            v4(199.89, 308.29, 157.33, 1),
	            v4(193.82, 309.9, 200.44, 1),
	            v4(171.52, 312.95, 232.15, 1),
	            v4(141.76, 318.2, 257.47, 1),
	            v4(122.49, 323.62, 276.37, 1),
	            v4(113.67, 328.48, 286.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["297"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["297"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v9";
	Curves["298"] = function () {
	    var Curve_v01 = [[v4(-0.9, 15.99, -30.47, 1),
	            v4(-0.76, 16.46, -30.47, 1),
	            v4(-0.59, 17.42, -30.47, 1),
	            v4(-0.51, 19, -30.46, 1),
	            v4(-0.47, 21.81, -30.45, 1),
	            v4(-0.88, 37.67, -29.47, 1),
	            v4(10.88, 50.57, -16.43, 1),
	            v4(-11.44, 85.04, 23.32, 1),
	            v4(55.34, 93.61, 36.24, 1),
	            v4(75.75, 115.15, -1.24, 1),
	            v4(91.26, 130.13, -49.28, 1),
	            v4(33.86, 141.76, -77.21, 1),
	            v4(39.4, 195.53, -51.91, 1),
	            v4(106.06, 200.78, -80.69, 1),
	            v4(97.43, 246.21, -27.68, 1),
	            v4(65.18, 275.37, -71.8, 1),
	            v4(80.39, 280.73, -112.87, 1),
	            v4(94.13, 279.19, -157.86, 1),
	            v4(129.8, 283.88, -183.46, 1),
	            v4(165.33, 286.33, -207.41, 1),
	            v4(189.63, 289.38, -225.62, 1),
	            v4(199.32, 290.59, -237.86, 1),
	        ], [v4(-2.39, 15.86, -30.08, 1),
	            v4(-2.52, 16.28, -30.07, 1),
	            v4(-2.7, 17.36, -30.07, 1),
	            v4(-2.75, 19.03, -30.06, 1),
	            v4(-2.75, 22.01, -30.06, 1),
	            v4(-2.94, 37.8, -30.17, 1),
	            v4(9.25, 50.11, -17.02, 1),
	            v4(-14.01, 85.25, 20.33, 1),
	            v4(53.41, 93.52, 34.28, 1),
	            v4(73.47, 115.21, -3.75, 1),
	            v4(89.14, 130.11, -51.51, 1),
	            v4(31.63, 141.79, -79.55, 1),
	            v4(37.26, 195.53, -54.2, 1),
	            v4(103.89, 200.79, -83, 1),
	            v4(95.25, 246.22, -29.97, 1),
	            v4(60.7, 275.37, -75.74, 1),
	            v4(72.6, 280.73, -119.12, 1),
	            v4(83.13, 279.19, -168.01, 1),
	            v4(109.88, 283.88, -211.08, 1),
	            v4(137.44, 286.33, -252.68, 1),
	            v4(160.88, 289.38, -274.48, 1),
	            v4(171.1, 290.59, -286.35, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["298"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["298"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v10";
	Curves["299"] = function () {
	    var Curve_v01 = [[v4(-16.79, 4.66, -6.5, 1),
	            v4(-16.62, 4.96, -6.62, 1),
	            v4(-16.44, 5.86, -6.76, 1),
	            v4(-16.38, 7.52, -6.82, 1),
	            v4(-16.39, 10.21, -6.84, 1),
	            v4(-16.09, 22.61, -7.2, 1),
	            v4(3.5, 57.85, -3.83, 1),
	            v4(8.76, 73.32, 30.99, 1),
	            v4(31.67, 88.05, 74.23, 1),
	            v4(41.27, 89.11, 114.37, 1),
	            v4(68.93, 115.94, 161.07, 1),
	            v4(75.78, 153.98, 118.79, 1),
	            v4(70.1, 164.9, 76.32, 1),
	            v4(70.82, 184.02, 33, 1),
	            v4(68.65, 196.95, -10.96, 1),
	            v4(73.6, 211.64, -54.43, 1),
	            v4(88.11, 223.31, -95.44, 1),
	            v4(123.1, 231.52, -124.38, 1),
	            v4(164.66, 235.29, -129.19, 1),
	            v4(205.24, 239.44, -120.53, 1),
	            v4(233.08, 242.53, -114.03, 1),
	            v4(247.36, 244.29, -112.2, 1),
	        ], [v4(-17.89, 4.69, -5.79, 1),
	            v4(-18.09, 4.99, -5.67, 1),
	            v4(-18.35, 5.89, -5.53, 1),
	            v4(-18.5, 7.43, -5.47, 1),
	            v4(-18.58, 10.01, -5.45, 1),
	            v4(-18.89, 22.15, -5.77, 1),
	            v4(0.84, 57.91, -4, 1),
	            v4(7.15, 73.77, 30.34, 1),
	            v4(30.11, 88.51, 73.2, 1),
	            v4(39.56, 89.05, 113.88, 1),
	            v4(67.6, 117.57, 158.8, 1),
	            v4(73.27, 154.23, 114.87, 1),
	            v4(68.01, 165.4, 73.26, 1),
	            v4(68.55, 184.26, 29.67, 1),
	            v4(66.53, 197.24, -13.97, 1),
	            v4(71.46, 211.81, -57.58, 1),
	            v4(85, 223.44, -100.89, 1),
	            v4(118.66, 231.55, -133.77, 1),
	            v4(163.95, 235.32, -156.83, 1),
	            v4(211.72, 239.45, -172.22, 1),
	            v4(243.24, 242.54, -174.11, 1),
	            v4(258.38, 244.29, -172.5, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["299"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["299"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v11";
	Curves["300"] = function () {
	    var Curve_v01 = [[v4(18.61, 6.17, -5.69, 1),
	            v4(18.79, 6.5, -5.61, 1),
	            v4(19.07, 7.56, -5.52, 1),
	            v4(19.28, 9.37, -5.5, 1),
	            v4(19.44, 11.8, -5.5, 1),
	            v4(23.73, 29.24, -8.84, 1),
	            v4(22.16, 96.07, 3.77, 1),
	            v4(121.57, 93.38, -1.21, 1),
	            v4(114.3, 175.26, -71.96, 1),
	            v4(121.7, 195.92, 32.67, 1),
	            v4(193.82, 202.21, 56.08, 1),
	            v4(259.64, 215.57, 87.96, 1),
	            v4(335.89, 221.68, 80.91, 1),
	            v4(401.7, 230.53, 64.53, 1),
	            v4(455.42, 236.94, 28.38, 1),
	            v4(497.25, 244.2, -20.55, 1),
	            v4(529.73, 250.69, -82.71, 1),
	            v4(532.82, 257.51, -141.91, 1),
	            v4(500.82, 264.24, -189.64, 1),
	            v4(452.57, 271.13, -237.49, 1),
	            v4(399.5, 277.21, -252.24, 1),
	            v4(381.67, 279.85, -264.88, 1),
	        ], [v4(17.71, 6.17, -6.28, 1),
	            v4(17.6, 6.46, -6.37, 1),
	            v4(17.47, 7.42, -6.49, 1),
	            v4(17.45, 9.17, -6.54, 1),
	            v4(17.49, 11.58, -6.55, 1),
	            v4(22.56, 28.6, -9.12, 1),
	            v4(19.8, 96.34, 0.82, 1),
	            v4(119.41, 93.2, -3.13, 1),
	            v4(112.13, 175.26, -74.44, 1),
	            v4(119.49, 195.9, 30.36, 1),
	            v4(191.58, 202.21, 53.73, 1),
	            v4(257.41, 215.55, 85.66, 1),
	            v4(333.67, 221.68, 78.61, 1),
	            v4(403.85, 230.53, 60.9, 1),
	            v4(467.94, 236.94, 21.54, 1),
	            v4(519.84, 244.19, -30.49, 1),
	            v4(557.37, 250.69, -94.65, 1),
	            v4(576.12, 257.5, -166.84, 1),
	            v4(573.22, 264.23, -240.1, 1),
	            v4(550.15, 271.13, -313.42, 1),
	            v4(501.61, 277.21, -336.5, 1),
	            v4(482.14, 279.85, -349.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["300"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["300"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v12";
	Curves["301"] = function () {
	    var Curve_v01 = [[v4(-19.62, 2.48, -0.82, 1),
	            v4(-19.73, 2.84, -0.7, 1),
	            v4(-19.83, 3.9, -0.5, 1),
	            v4(-19.85, 5.75, -0.25, 1),
	            v4(-19.82, 8.58, 0.11, 1),
	            v4(-12.8, 20.5, 1.73, 1),
	            v4(-24.01, 49.63, 6.85, 1),
	            v4(-30.49, 85.75, 12.81, 1),
	            v4(-82, 106.74, -17.73, 1),
	            v4(-27.63, 86.39, -52.86, 1),
	            v4(-11.89, 135.8, -24.18, 1),
	            v4(-47.45, 184.11, -33.41, 1),
	            v4(-58.17, 161.27, 18.35, 1),
	            v4(-28.09, 210.88, 1.53, 1),
	            v4(-41.04, 249.74, -8.7, 1),
	            v4(-6.31, 290.19, -10.21, 1),
	            v4(29.3, 300.93, -28.6, 1),
	            v4(75.03, 305.29, -36.69, 1),
	            v4(122.23, 308.9, -44.46, 1),
	            v4(171.86, 309.73, -43.7, 1),
	            v4(198.56, 307.28, -32.3, 1),
	            v4(209.41, 307.1, -22.63, 1),
	        ], [v4(-18.67, 2.48, -1.32, 1),
	            v4(-18.48, 2.82, -1.36, 1),
	            v4(-18.21, 3.9, -1.34, 1),
	            v4(-18.12, 5.68, -1.15, 1),
	            v4(-17.61, 8.43, -0.77, 1),
	            v4(-10.42, 20.25, 1.2, 1),
	            v4(-21.58, 49.24, 8.39, 1),
	            v4(-27.2, 85.15, 16.03, 1),
	            v4(-79.54, 106.94, -15.63, 1),
	            v4(-25.83, 86.29, -50.77, 1),
	            v4(-9.2, 134.95, -22.5, 1),
	            v4(-44.39, 184.13, -31.58, 1),
	            v4(-56.07, 161.27, 19.85, 1),
	            v4(-25.43, 210.34, 3.86, 1),
	            v4(-38.67, 249.55, -6.88, 1),
	            v4(-3.68, 289.98, -6.15, 1),
	            v4(32.23, 300.96, -22.46, 1),
	            v4(77.59, 305.25, -27.97, 1),
	            v4(119.81, 308.91, -26.04, 1),
	            v4(162.5, 309.72, -12.84, 1),
	            v4(186.5, 307.28, 3.25, 1),
	            v4(196.97, 307.1, 13.45, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["301"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["301"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v13";
	Curves["302"] = function () {
	    var Curve_v01 = [[v4(-6.39, 4.96, -12.25, 1),
	            v4(-6.46, 5.09, -12.27, 1),
	            v4(-6.59, 5.53, -12.3, 1),
	            v4(-6.74, 6.49, -12.33, 1),
	            v4(-6.81, 8.09, -12.33, 1),
	            v4(-5.79, 20.42, -7.68, 1),
	            v4(-16.85, 61.45, -5.48, 1),
	            v4(-20.15, 111.93, -17.84, 1),
	            v4(43.29, 136.15, 20.56, 1),
	            v4(-28.22, 103.58, 19.88, 1),
	            v4(-1.89, 145.12, -40.41, 1),
	            v4(-49.36, 194.24, -11.34, 1),
	            v4(-54.53, 199.43, -93.16, 1),
	            v4(-74.72, 217.79, -117.9, 1),
	            v4(-72.4, 274.08, -173.82, 1),
	            v4(-42.86, 305.13, -108.55, 1),
	            v4(-77.61, 237.01, -98.57, 1),
	            v4(-117.33, 248.07, -154.83, 1),
	            v4(-109.7, 295.18, -179.01, 1),
	            v4(-139.17, 297.34, -241.29, 1),
	            v4(-147.66, 278.91, -260.16, 1),
	            v4(-153.67, 262, -270.8, 1),
	        ], [v4(-5.2, 4.96, -11.86, 1),
	            v4(-5.08, 5.23, -11.81, 1),
	            v4(-4.97, 5.85, -11.75, 1),
	            v4(-4.89, 6.95, -11.68, 1),
	            v4(-4.88, 8.41, -11.63, 1),
	            v4(-4.02, 21.86, -7.85, 1),
	            v4(-13.95, 59.93, -6.72, 1),
	            v4(-16.87, 112.71, -16.52, 1),
	            v4(46.36, 135.76, 20.91, 1),
	            v4(-25.14, 103.76, 20.46, 1),
	            v4(1.23, 145.13, -39.87, 1),
	            v4(-46.3, 194.31, -10.8, 1),
	            v4(-51.41, 199.42, -92.68, 1),
	            v4(-71.63, 217.83, -117.36, 1),
	            v4(-69.26, 274.15, -173.26, 1),
	            v4(-39.74, 305.1, -107.91, 1),
	            v4(-73.65, 236.99, -97.96, 1),
	            v4(-105.36, 248.1, -153.38, 1),
	            v4(-87.86, 295.18, -178.69, 1),
	            v4(-84.06, 297.34, -250.55, 1),
	            v4(-84.56, 278.91, -272.46, 1),
	            v4(-84.47, 262, -283.98, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["302"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["302"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v14";
	Curves["303"] = function () {
	    var Curve_v01 = [[v4(4.77, 4.29, -10.61, 1),
	            v4(4.89, 4.62, -10.58, 1),
	            v4(5.01, 5.37, -10.55, 1),
	            v4(5.06, 6.56, -10.52, 1),
	            v4(5.01, 8.45, -10.48, 1),
	            v4(5.25, 22.39, -11.71, 1),
	            v4(-2.71, 50.7, -7.26, 1),
	            v4(-8.64, 92.04, -17.61, 1),
	            v4(-17.35, 136.19, -11.01, 1),
	            v4(-24.9, 178.94, -1.98, 1),
	            v4(-42.7, 218.23, 12.94, 1),
	            v4(-71.2, 249.71, 27.26, 1),
	            v4(-106.66, 275.35, 38.2, 1),
	            v4(-148.16, 294.05, 38.11, 1),
	            v4(-190.64, 302.67, 24.06, 1),
	            v4(-232.29, 306.09, 1.29, 1),
	            v4(-270.28, 307.48, -28.21, 1),
	            v4(-298.6, 309.08, -65.48, 1),
	            v4(-325.51, 312.13, -110.85, 1),
	            v4(-348.21, 317.39, -159.28, 1),
	            v4(-356, 322.81, -190.49, 1),
	            v4(-355.94, 327.67, -204.78, 1),
	        ], [v4(3.56, 4.29, -10.95, 1),
	            v4(3.43, 4.66, -10.98, 1),
	            v4(3.27, 5.57, -11.03, 1),
	            v4(3.19, 7.04, -11.03, 1),
	            v4(3.14, 9.09, -11, 1),
	            v4(4.49, 23.33, -12.3, 1),
	            v4(1.72, 51.75, -8.59, 1),
	            v4(-6.7, 92.94, -16.53, 1),
	            v4(-13.83, 137.04, -10.55, 1),
	            v4(-22.28, 179.66, -1.04, 1),
	            v4(-39.82, 218.8, 13.68, 1),
	            v4(-68.64, 250.11, 28.07, 1),
	            v4(-104, 275.64, 38.82, 1),
	            v4(-145.55, 294.2, 38.6, 1),
	            v4(-187.42, 302.72, 24.37, 1),
	            v4(-222.69, 306.11, 0.7, 1),
	            v4(-251.73, 307.49, -30.07, 1),
	            v4(-273.94, 309.09, -67.45, 1),
	            v4(-281.45, 312.14, -106.21, 1),
	            v4(-280.43, 317.4, -145.13, 1),
	            v4(-278.9, 322.81, -172.6, 1),
	            v4(-277.99, 327.67, -186.4, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["303"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["303"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v15";
	Curves["304"] = function () {
	    var Curve_v01 = [[v4(6.21, 15.75, -29.62, 1),
	            v4(6.05, 15.98, -29.62, 1),
	            v4(5.85, 16.66, -29.62, 1),
	            v4(5.69, 17.85, -29.63, 1),
	            v4(5.62, 19.5, -29.63, 1),
	            v4(2.3, 34.57, -29.15, 1),
	            v4(-0.51, 49.54, 0.61, 1),
	            v4(-6.17, 85.04, -46.01, 1),
	            v4(-67.67, 93.61, -16.96, 1),
	            v4(-61.97, 115.15, 25.34, 1),
	            v4(-46.09, 130.13, 73.25, 1),
	            v4(16.72, 141.76, 61.85, 1),
	            v4(-2.7, 195.53, 44.72, 1),
	            v4(-39.46, 200.78, 107.34, 1),
	            v4(-63.83, 246.21, 59.48, 1),
	            v4(-8.93, 275.37, 75.94, 1),
	            v4(7.13, 280.73, 117.98, 1),
	            v4(26.23, 279.19, 163.19, 1),
	            v4(13.89, 283.88, 210.82, 1),
	            v4(-5.66, 286.33, 257.62, 1),
	            v4(-19.57, 289.38, 288.35, 1),
	            v4(-21.57, 290.59, 303.99, 1),
	        ], [v4(7.04, 15.63, -29.63, 1),
	            v4(7.21, 15.88, -29.63, 1),
	            v4(7.41, 16.69, -29.64, 1),
	            v4(7.49, 17.99, -29.63, 1),
	            v4(7.5, 19.74, -29.63, 1),
	            v4(4.4, 34.83, -29.76, 1),
	            v4(1.08, 49.1, 0.01, 1),
	            v4(-2.33, 85.25, -45.12, 1),
	            v4(-64.95, 93.52, -16.52, 1),
	            v4(-58.64, 115.21, 26.02, 1),
	            v4(-43.06, 130.11, 73.8, 1),
	            v4(19.91, 141.79, 62.42, 1),
	            v4(0.37, 195.53, 45.3, 1),
	            v4(-36.34, 200.79, 107.92, 1),
	            v4(-60.72, 246.22, 60.03, 1),
	            v4(-5.8, 275.37, 76.53, 1),
	            v4(10.25, 280.73, 118.56, 1),
	            v4(29.7, 279.19, 163.83, 1),
	            v4(33.13, 283.88, 214.18, 1),
	            v4(38.72, 286.33, 265.3, 1),
	            v4(35.55, 289.38, 297.87, 1),
	            v4(34.97, 290.59, 313.75, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["304"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["304"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v16";
	Curves["305"] = function () {
	    var Curve_v01 = [[v4(9.68, 11.78, -22.61, 1),
	            v4(9.52, 12.01, -22.47, 1),
	            v4(9.33, 12.69, -22.31, 1),
	            v4(9.21, 14.24, -22.2, 1),
	            v4(9.2, 16.54, -22.17, 1),
	            v4(9.59, 28.32, -22.47, 1),
	            v4(-10.55, 64.15, -21.07, 1),
	            v4(-23.3, 79.83, -54.41, 1),
	            v4(-54.92, 94.56, -91.75, 1),
	            v4(-72.88, 95.62, -128.92, 1),
	            v4(-109.88, 122.45, -168.62, 1),
	            v4(-107.53, 160.49, -125.87, 1),
	            v4(-92.91, 171.4, -85.59, 1),
	            v4(-84.35, 190.53, -43.12, 1),
	            v4(-72.9, 203.46, -0.7, 1),
	            v4(-69.96, 218.15, 40.93, 1),
	            v4(-76.31, 229.82, 83.07, 1),
	            v4(-103.22, 238.02, 121.09, 1),
	            v4(-141.97, 241.8, 136.91, 1),
	            v4(-183.09, 245.95, 134.45, 1),
	            v4(-211.73, 249.04, 129.73, 1),
	            v4(-226.41, 250.8, 128.63, 1),
	        ], [v4(11.25, 12.18, -23.86, 1),
	            v4(11.42, 12.46, -23.99, 1),
	            v4(11.64, 13.2, -24.16, 1),
	            v4(11.85, 14.82, -24.3, 1),
	            v4(11.93, 17.58, -24.34, 1),
	            v4(11.41, 28.96, -24.39, 1),
	            v4(-8.11, 64.46, -22, 1),
	            v4(-21.59, 80.28, -54.13, 1),
	            v4(-53.17, 95.02, -91.09, 1),
	            v4(-71.1, 95.56, -128.81, 1),
	            v4(-108.09, 124.08, -166.7, 1),
	            v4(-104.25, 160.73, -122.57, 1),
	            v4(-90.22, 171.91, -83.05, 1),
	            v4(-81.43, 190.77, -40.34, 1),
	            v4(-70.12, 203.75, 1.85, 1),
	            v4(-65.62, 218.32, 45.52, 1),
	            v4(-68.32, 229.95, 92.34, 1),
	            v4(-91.77, 238.06, 134.79, 1),
	            v4(-129.52, 241.83, 170.01, 1),
	            v4(-173.82, 245.96, 195.58, 1),
	            v4(-205.65, 249.05, 202.91, 1),
	            v4(-221.52, 250.8, 203.72, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["305"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["305"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v17";
	Curves["306"] = function () {
	    var Curve_v01 = [[v4(-16.62, 9.37, -17.17, 1),
	            v4(-16.77, 9.53, -17.14, 1),
	            v4(-16.94, 10.07, -17.07, 1),
	            v4(-17.07, 11.42, -16.95, 1),
	            v4(-17.06, 14.68, -16.8, 1),
	            v4(-13.94, 26.09, -3, 1),
	            v4(-18.12, 89.43, -14.96, 1),
	            v4(-95.69, 86.74, 62.75, 1),
	            v4(-48.01, 168.62, 115.52, 1),
	            v4(-115.82, 189.28, 35.5, 1),
	            v4(-187.84, 195.56, 59.25, 1),
	            v4(-259.77, 208.92, 72.45, 1),
	            v4(-317.11, 215.04, 123.21, 1),
	            v4(-359.69, 223.89, 175.19, 1),
	            v4(-379.7, 230.3, 235.8, 1),
	            v4(-382.63, 237.55, 299.7, 1),
	            v4(-371.56, 244.04, 369.97, 1),
	            v4(-342.92, 250.86, 429.77, 1),
	            v4(-294.06, 257.59, 462.51, 1),
	            v4(-230.6, 264.48, 483.48, 1),
	            v4(-178.82, 270.57, 465.72, 1),
	            v4(-155.9, 273.21, 464.06, 1),
	        ], [v4(-15.35, 9.37, -17.26, 1),
	            v4(-15.35, 9.46, -17.26, 1),
	            v4(-15.13, 9.74, -17.27, 1),
	            v4(-14.86, 10.61, -17.26, 1),
	            v4(-14.66, 14.42, -17.22, 1),
	            v4(-12.92, 24.48, -3.34, 1),
	            v4(-14.4, 89.71, -14.02, 1),
	            v4(-92.82, 86.55, 63.03, 1),
	            v4(-44.79, 168.61, 116.24, 1),
	            v4(-112.67, 189.25, 36.06, 1),
	            v4(-184.64, 195.56, 59.82, 1),
	            v4(-256.61, 208.91, 72.99, 1),
	            v4(-313.95, 215.04, 123.75, 1),
	            v4(-360.09, 223.88, 179.52, 1),
	            v4(-388.52, 230.3, 249.15, 1),
	            v4(-399.62, 237.55, 321.8, 1),
	            v4(-391.97, 244.04, 395.73, 1),
	            v4(-364.42, 250.86, 465.04, 1),
	            v4(-318.78, 257.59, 522.41, 1),
	            v4(-256.83, 264.48, 567.92, 1),
	            v4(-204.03, 270.57, 557.84, 1),
	            v4(-180.72, 273.21, 556.7, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["306"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["306"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v18";
	Curves["307"] = function () {
	    var Curve_v01 = [[v4(11.04, -1.54, 7.85, 1),
	            v4(11.12, -1.29, 7.91, 1),
	            v4(11.32, -0.49, 7.84, 1),
	            v4(11.56, 0.95, 7.56, 1),
	            v4(11.66, 3.74, 7.07, 1),
	            v4(12.66, 15.49, 6.56, 1),
	            v4(15.96, 45.4, 14.99, 1),
	            v4(22.14, 81.68, 21.32, 1),
	            v4(-6.89, 102.67, 73.7, 1),
	            v4(-43.59, 82.31, 20.38, 1),
	            v4(-15.38, 131.73, 3.8, 1),
	            v4(-23.57, 180.04, 39.62, 1),
	            v4(28.48, 157.2, 48.83, 1),
	            v4(10.79, 206.81, 19.25, 1),
	            v4(0.76, 245.66, 32.5, 1),
	            v4(-2.6, 286.11, -2.33, 1),
	            v4(-22.54, 296.86, -37.59, 1),
	            v4(-32.43, 301.22, -82.87, 1),
	            v4(-37.82, 304.83, -126.35, 1),
	            v4(-31.97, 305.65, -170.96, 1),
	            v4(-18.22, 303.21, -196.04, 1),
	            v4(-8.15, 303.02, -206.91, 1),
	        ], [v4(10.96, -1.65, 6.88, 1),
	            v4(11.02, -1.37, 6.61, 1),
	            v4(11.21, -0.43, 6.08, 1),
	            v4(11.47, 1.26, 5.58, 1),
	            v4(11.61, 4.04, 5.11, 1),
	            v4(12.38, 15.72, 4.45, 1),
	            v4(17.46, 45.18, 12.55, 1),
	            v4(25.25, 81.08, 17.94, 1),
	            v4(-4.87, 102.87, 71.18, 1),
	            v4(-41.56, 82.22, 18.52, 1),
	            v4(-13.77, 130.88, 1.07, 1),
	            v4(-21.84, 180.06, 36.51, 1),
	            v4(29.92, 157.2, 46.69, 1),
	            v4(13.04, 206.27, 16.52, 1),
	            v4(2.69, 245.48, 30.07, 1),
	            v4(2.4, 285.91, -4.93, 1),
	            v4(-14.94, 296.89, -40.34, 1),
	            v4(-18.87, 302.81, -85.53, 1),
	            v4(-5.29, 313.73, -127.79, 1),
	            v4(22.38, 323.4, -170.84, 1),
	            v4(43.62, 324.26, -195.3, 1),
	            v4(54.3, 324.52, -206.06, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["307"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["307"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v19";
	Curves["308"] = function () {
	    var Curve_v01 = [[v4(-12, -0.91, 4.32, 1),
	            v4(-11.97, -0.65, 4.56, 1),
	            v4(-11.79, 0.19, 5.07, 1),
	            v4(-11.49, 1.58, 5.65, 1),
	            v4(-10.98, 3.51, 6.3, 1),
	            v4(-4.3, 14.63, 10.39, 1),
	            v4(1.8, 53.8, 18.18, 1),
	            v4(-8.39, 103.47, 21.78, 1),
	            v4(28.15, 127.69, -42.75, 1),
	            v4(29.55, 95.12, 28.75, 1),
	            v4(-31.48, 136.66, 4.18, 1),
	            v4(-1.04, 185.78, 50.79, 1),
	            v4(-82.68, 190.98, 58.33, 1),
	            v4(-106.82, 209.33, 79.24, 1),
	            v4(-162.78, 265.63, 78.54, 1),
	            v4(-98.4, 296.68, 47.12, 1),
	            v4(-87.41, 228.56, 81.57, 1),
	            v4(-142.5, 239.61, 122.9, 1),
	            v4(-168.23, 286.72, 117.62, 1),
	            v4(-220.62, 288.88, 170.37, 1),
	            v4(-231.89, 270.45, 189.26, 1),
	            v4(-238.37, 253.54, 200.02, 1),
	        ], [v4(-11.65, -0.91, 3.84, 1),
	            v4(-11.54, -0.62, 3.81, 1),
	            v4(-11.19, 0.37, 3.97, 1),
	            v4(-10.86, 2.05, 4.39, 1),
	            v4(-10.4, 4.1, 4.91, 1),
	            v4(-4.55, 16.2, 8.65, 1),
	            v4(0.3, 52.36, 15.31, 1),
	            v4(-7.17, 104.25, 18.47, 1),
	            v4(28.41, 127.3, -45.83, 1),
	            v4(30.04, 95.3, 25.66, 1),
	            v4(-31.03, 136.68, 1.05, 1),
	            v4(-0.59, 185.85, 47.72, 1),
	            v4(-82.29, 190.96, 55.21, 1),
	            v4(-106.38, 209.38, 76.13, 1),
	            v4(-162.32, 265.69, 75.38, 1),
	            v4(-97.85, 296.64, 43.98, 1),
	            v4(-86.98, 228.53, 78.48, 1),
	            v4(-142.02, 239.64, 119.76, 1),
	            v4(-166.43, 286.72, 112.85, 1),
	            v4(-227.81, 288.88, 144.12, 1),
	            v4(-246.42, 270.45, 153.15, 1),
	            v4(-256.88, 253.54, 159.46, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["308"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["308"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v20";
	Curves["309"] = function () {
	    var Curve_v01 = [[v4(-11.34, 11.35, -22.61, 1),
	            v4(-11.24, 11.64, -22.69, 1),
	            v4(-11.13, 12.31, -22.76, 1),
	            v4(-11.02, 13.48, -22.81, 1),
	            v4(-10.96, 15.27, -22.76, 1),
	            v4(-11.47, 26.64, -21.85, 1),
	            v4(-3.89, 54.63, -13.81, 1),
	            v4(-14.11, 96.16, -7.55, 1),
	            v4(-7.26, 140.3, 0.97, 1),
	            v4(1.99, 183.06, 8.25, 1),
	            v4(17.42, 222.35, 25.61, 1),
	            v4(32.57, 253.83, 53.68, 1),
	            v4(44.52, 279.47, 88.81, 1),
	            v4(45.64, 298.17, 130.29, 1),
	            v4(32.76, 306.79, 172.91, 1),
	            v4(10.27, 310.21, 211.62, 1),
	            v4(-19.48, 311.6, 245.33, 1),
	            v4(-56.42, 313.2, 271.09, 1),
	            v4(-98.24, 316.25, 287.33, 1),
	            v4(-141.74, 321.51, 296.54, 1),
	            v4(-171.16, 326.92, 298.54, 1),
	            v4(-185.27, 331.79, 297.83, 1),
	        ], [v4(-12.53, 10.99, -21.71, 1),
	            v4(-12.65, 11.28, -21.62, 1),
	            v4(-12.78, 11.97, -21.52, 1),
	            v4(-12.85, 13.11, -21.44, 1),
	            v4(-12.86, 14.72, -21.4, 1),
	            v4(-12.11, 27.01, -21.06, 1),
	            v4(-5.31, 55.44, -18.26, 1),
	            v4(-13.08, 97.05, -9.52, 1),
	            v4(-6.9, 141.16, -2.57, 1),
	            v4(2.85, 183.78, 5.6, 1),
	            v4(18.07, 222.92, 22.71, 1),
	            v4(33.3, 254.23, 51.1, 1),
	            v4(45.07, 279.76, 86.14, 1),
	            v4(46.01, 298.31, 126.89, 1),
	            v4(32.71, 306.83, 164.49, 1),
	            v4(9.83, 310.23, 197.21, 1),
	            v4(-20.08, 311.6, 228.19, 1),
	            v4(-56.25, 313.21, 253.74, 1),
	            v4(-94.18, 316.26, 259.78, 1),
	            v4(-133.03, 321.52, 255.76, 1),
	            v4(-160.63, 326.93, 252.34, 1),
	            v4(-174.49, 331.79, 250.78, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["309"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["309"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v21";
	Curves["310"] = function () {
	    var Curve_v01 = [[v4(-18.92, -0.44, 7.09, 1),
	            v4(-18.91, -0.26, 7.25, 1),
	            v4(-18.97, 0.34, 7.55, 1),
	            v4(-19.11, 1.53, 7.94, 1),
	            v4(-19.42, 4.21, 8.53, 1),
	            v4(-24.58, 20.37, 6.3, 1),
	            v4(-13.9, 45.54, 11.41, 1),
	            v4(-56.18, 80.3, -6.66, 1),
	            v4(-61.85, 88.87, 61.12, 1),
	            v4(-22.38, 110.41, 77.37, 1),
	            v4(27.04, 125.4, 87.63, 1),
	            v4(48.64, 137.02, 27.56, 1),
	            v4(24.08, 190.79, 35.78, 1),
	            v4(59.87, 196.04, 98.97, 1),
	            v4(6.23, 241.47, 96.09, 1),
	            v4(47.99, 270.63, 56.82, 1),
	            v4(92.41, 275.99, 63.97, 1),
	            v4(140.6, 274.45, 70.79, 1),
	            v4(172.58, 279.14, 108.33, 1),
	            v4(200.17, 281.59, 150.88, 1),
	            v4(218.64, 284.64, 178.99, 1),
	            v4(231.02, 285.85, 188.65, 1),
	        ], [v4(-18.98, -0.31, 5.4, 1),
	            v4(-19.04, -0.09, 5.3, 1),
	            v4(-19.16, 0.55, 5.25, 1),
	            v4(-19.32, 1.88, 5.36, 1),
	            v4(-19.48, 4.76, 5.9, 1),
	            v4(-23.78, 20.58, 4.18, 1),
	            v4(-13.58, 45.13, 9.7, 1),
	            v4(-53.49, 80.51, -9.54, 1),
	            v4(-60.1, 88.78, 58.99, 1),
	            v4(-20.13, 110.47, 74.84, 1),
	            v4(29.03, 125.37, 85.28, 1),
	            v4(50.73, 137.05, 25.09, 1),
	            v4(26.13, 190.79, 33.42, 1),
	            v4(61.93, 196.05, 96.56, 1),
	            v4(8.28, 241.48, 93.67, 1),
	            v4(50.06, 270.64, 54.4, 1),
	            v4(94.47, 275.99, 61.56, 1),
	            v4(143.92, 274.45, 66.73, 1),
	            v4(191.14, 279.14, 84.26, 1),
	            v4(239.27, 281.59, 99.85, 1),
	            v4(266.15, 284.64, 116.92, 1),
	            v4(279.64, 285.85, 125.11, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["310"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["310"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v22";
	Curves["311"] = function () {
	    var Curve_v01 = [[v4(-31.45, 7.11, -6.53, 1),
	            v4(-31.35, 7.24, -6.63, 1),
	            v4(-31.16, 7.86, -6.81, 1),
	            v4(-30.99, 9.5, -6.98, 1),
	            v4(-30.95, 12.85, -7.02, 1),
	            v4(-31.07, 25.31, -6.83, 1),
	            v4(-9.96, 55.23, -7.96, 1),
	            v4(1.55, 70.54, 24.92, 1),
	            v4(32.09, 85.26, 63.16, 1),
	            v4(48.97, 86.32, 100.83, 1),
	            v4(84.82, 113.16, 141.57, 1),
	            v4(83.7, 151.19, 98.77, 1),
	            v4(70.23, 162.11, 58.09, 1),
	            v4(62.9, 181.23, 15.39, 1),
	            v4(52.78, 194.16, -27.16, 1),
	            v4(50.97, 208.85, -68.62, 1),
	            v4(58.02, 220.52, -110.8, 1),
	            v4(85.4, 228.73, -146.46, 1),
	            v4(121.93, 232.5, -157.89, 1),
	            v4(160.44, 236.65, -156.2, 1),
	            v4(188.28, 239.75, -154.39, 1),
	            v4(202.78, 241.51, -154.89, 1),
	        ], [v4(-32.59, 7.11, -5.44, 1),
	            v4(-32.76, 7.38, -5.28, 1),
	            v4(-33.04, 8.42, -5.05, 1),
	            v4(-33.17, 10.44, -4.95, 1),
	            v4(-33.23, 13.68, -4.92, 1),
	            v4(-33.06, 25.74, -4.98, 1),
	            v4(-12.56, 55.34, -7.54, 1),
	            v4(-0.15, 70.99, 24.59, 1),
	            v4(30.36, 85.73, 62.44, 1),
	            v4(47.2, 86.26, 100.66, 1),
	            v4(83.09, 114.78, 139.6, 1),
	            v4(80.51, 151.44, 95.38, 1),
	            v4(67.62, 162.61, 55.47, 1),
	            v4(60.05, 181.47, 12.53, 1),
	            v4(49.96, 194.45, -29.97, 1),
	            v4(46.72, 209.02, -73.74, 1),
	            v4(51.98, 220.65, -118.81, 1),
	            v4(79.91, 228.76, -156.74, 1),
	            v4(125.51, 232.53, -182.09, 1),
	            v4(171.21, 236.67, -206.97, 1),
	            v4(200.44, 239.75, -221.26, 1),
	            v4(214.84, 241.51, -226.62, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["311"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["311"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v23";
	Curves["312"] = function () {
	    var Curve_v01 = [[v4(18.69, 11.7, -20.64, 1),
	            v4(18.69, 11.77, -20.54, 1),
	            v4(18.71, 12.08, -20.3, 1),
	            v4(18.76, 12.8, -19.97, 1),
	            v4(18.9, 14.57, -19.68, 1),
	            v4(21.93, 30.64, -16.25, 1),
	            v4(8.65, 101.35, -17.35, 1),
	            v4(74.76, 98.62, 59.33, 1),
	            v4(126.12, 180.5, 10.13, 1),
	            v4(48.11, 201.16, 80.24, 1),
	            v4(73.93, 207.44, 151.53, 1),
	            v4(89.21, 220.8, 223.05, 1),
	            v4(141.62, 226.92, 278.89, 1),
	            v4(194.98, 235.77, 321.03, 1),
	            v4(256.54, 242.18, 341.85, 1),
	            v4(320.88, 249.43, 345.42, 1),
	            v4(389.76, 255.92, 333.35, 1),
	            v4(440.06, 262.74, 303.92, 1),
	            v4(456.92, 269.47, 256.46, 1),
	            v4(460.7, 276.36, 194.61, 1),
	            v4(435.85, 282.45, 144.4, 1),
	            v4(415.22, 285.09, 119.59, 1),
	        ], [v4(19.22, 12.94, -24.48, 1),
	            v4(19.27, 13.23, -24.65, 1),
	            v4(19.34, 13.87, -24.82, 1),
	            v4(19.43, 15.03, -24.96, 1),
	            v4(19.52, 16.86, -24.94, 1),
	            v4(21.19, 30.96, -17.26, 1),
	            v4(9.79, 101.62, -20.74, 1),
	            v4(74.95, 98.44, 56.45, 1),
	            v4(126.75, 180.49, 6.89, 1),
	            v4(48.57, 201.14, 77.08, 1),
	            v4(74.41, 207.44, 148.32, 1),
	            v4(89.67, 220.79, 219.88, 1),
	            v4(142.07, 226.92, 275.73, 1),
	            v4(199.16, 235.76, 320.22, 1),
	            v4(269.58, 242.18, 346.62, 1),
	            v4(342.52, 249.43, 355.61, 1),
	            v4(416.21, 255.92, 345.8, 1),
	            v4(484.69, 262.74, 316.25, 1),
	            v4(540.71, 269.47, 268.96, 1),
	            v4(584.4, 276.36, 205.72, 1),
	            v4(572.78, 282.45, 153.24, 1),
	            v4(570.97, 285.09, 129.97, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["312"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["312"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v24";
	Curves["313"] = function () {
	    var Curve_v01 = [[v4(16.84, 1.32, -1.26, 1),
	            v4(17.2, 1.63, -1.31, 1),
	            v4(17.45, 2.66, -1.39, 1),
	            v4(17.76, 4.82, -1.6, 1),
	            v4(18.01, 8.68, -1.41, 1),
	            v4(23.39, 21.12, 1.25, 1),
	            v4(5.7, 84.54, 19.16, 1),
	            v4(102.69, 81.92, 15.69, 1),
	            v4(96.43, 163.8, -55.16, 1),
	            v4(102.34, 184.46, 49.57, 1),
	            v4(174.12, 190.75, 74, 1),
	            v4(239.49, 204.11, 106.8, 1),
	            v4(315.83, 210.23, 100.83, 1),
	            v4(378.92, 219.07, 85.02, 1),
	            v4(426.15, 225.49, 48.75, 1),
	            v4(461.89, 232.74, -0.44, 1),
	            v4(493.25, 239.23, -63.18, 1),
	            v4(503.66, 246.05, -123.22, 1),
	            v4(477.52, 252.78, -166.31, 1),
	            v4(435.04, 259.67, -208.01, 1),
	            v4(383.88, 265.75, -220.15, 1),
	            v4(365.2, 268.39, -232.17, 1),
	        ], [v4(15.95, 1.32, -1.72, 1),
	            v4(15.95, 1.66, -2.21, 1),
	            v4(15.93, 2.8, -2.45, 1),
	            v4(16.2, 4.86, -2.56, 1),
	            v4(16.47, 8.68, -2.18, 1),
	            v4(22.08, 20.53, 0.86, 1),
	            v4(3.59, 84.8, 16.2, 1),
	            v4(100.56, 81.74, 13.74, 1),
	            v4(94.29, 163.8, -57.67, 1),
	            v4(100.16, 184.44, 47.22, 1),
	            v4(171.91, 190.75, 71.61, 1),
	            v4(237.3, 204.1, 104.47, 1),
	            v4(313.65, 210.22, 98.5, 1),
	            v4(384.06, 219.07, 81.78, 1),
	            v4(448.71, 225.48, 43.34, 1),
	            v4(501.34, 232.73, -7.96, 1),
	            v4(539.77, 239.23, -71.58, 1),
	            v4(559.54, 246.04, -143.5, 1),
	            v4(557.68, 252.78, -216.79, 1),
	            v4(535.65, 259.67, -290.43, 1),
	            v4(487.43, 265.75, -314.19, 1),
	            v4(468.15, 268.39, -327.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["313"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["313"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v25";
	Curves["314"] = function () {
	    var Curve_v01 = [[v4(-12.13, -2.74, 9.38, 1),
	            v4(-12.18, -2.55, 9.19, 1),
	            v4(-12.27, -1.58, 8.88, 1),
	            v4(-12.32, 0.45, 8.74, 1),
	            v4(-12.91, 4.32, 8.3, 1),
	            v4(-13.9, 14.81, 8.22, 1),
	            v4(0.11, 48.45, -4.1, 1),
	            v4(32.49, 63.54, 7.32, 1),
	            v4(81.42, 78.26, 7.4, 1),
	            v4(121.38, 79.32, 17.78, 1),
	            v4(175.59, 106.16, 15.3, 1),
	            v4(141.49, 144.19, -10.6, 1),
	            v4(101.32, 155.11, -25.53, 1),
	            v4(63.42, 174.23, -46.52, 1),
	            v4(23.66, 187.16, -65.27, 1),
	            v4(-10.37, 201.86, -90.32, 1),
	            v4(-39.03, 213.52, -122.98, 1),
	            v4(-50.21, 221.73, -167.71, 1),
	            v4(-34.49, 225.5, -201.55, 1),
	            v4(-4.6, 229.66, -225.28, 1),
	            v4(16.42, 232.75, -243.25, 1),
	            v4(25.54, 234.51, -254.4, 1),
	        ], [v4(-12.38, -2.72, 10.26, 1),
	            v4(-12.32, -2.46, 10.48, 1),
	            v4(-12.25, -1.16, 10.81, 1),
	            v4(-12.24, 1.38, 11.57, 1),
	            v4(-13.11, 5.48, 11.28, 1),
	            v4(-13.9, 15.84, 10.65, 1),
	            v4(-0.96, 48.68, -1.75, 1),
	            v4(31.17, 63.99, 8.44, 1),
	            v4(79.78, 78.73, 8.31, 1),
	            v4(120.14, 79.27, 19.06, 1),
	            v4(172.97, 107.78, 15.41, 1),
	            v4(136.85, 144.44, -10.23, 1),
	            v4(97.64, 155.61, -25.13, 1),
	            v4(59.41, 174.47, -46.08, 1),
	            v4(19.93, 187.45, -64.79, 1),
	            v4(-16.25, 202.02, -89.64, 1),
	            v4(-48.13, 213.65, -121.92, 1),
	            v4(-61.1, 221.76, -166.89, 1),
	            v4(-54.35, 225.53, -213.02, 1),
	            v4(-36.82, 229.67, -255.44, 1),
	            v4(-20.08, 232.75, -281.26, 1),
	            v4(-11.07, 234.51, -293.49, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["314"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["314"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v26";
	Curves["315"] = function () {
	    var Curve_v01 = [[v4(-43.15, 0.72, 31.7, 1),
	            v4(-42.96, 1.07, 31.95, 1),
	            v4(-42.76, 2.14, 32.39, 1),
	            v4(-42.68, 3.91, 32.88, 1),
	            v4(-42.54, 6.88, 33.55, 1),
	            v4(-41, 21.18, 36.09, 1),
	            v4(-30.24, 45.87, 34.59, 1),
	            v4(-74.93, 80.23, 42.87, 1),
	            v4(-42.11, 88.8, 102.44, 1),
	            v4(-0.25, 110.34, 94.12, 1),
	            v4(46.58, 125.32, 75.29, 1),
	            v4(31.29, 136.95, 13.31, 1),
	            v4(15.41, 190.72, 33.76, 1),
	            v4(80.19, 195.97, 66.55, 1),
	            v4(33.94, 241.4, 93.86, 1),
	            v4(47.12, 270.56, 39.93, 1),
	            v4(88.32, 275.92, 24.13, 1),
	            v4(132.3, 274.38, 3.81, 1),
	            v4(176.78, 279.07, 13.95, 1),
	            v4(218.54, 281.52, 31.06, 1),
	            v4(247.41, 284.57, 42.92, 1),
	            v4(262.77, 285.78, 43.79, 1),
	        ], [v4(-44, 0.72, 31.08, 1),
	            v4(-44.18, 0.98, 31, 1),
	            v4(-44.4, 1.99, 31.05, 1),
	            v4(-44.4, 3.72, 31.34, 1),
	            v4(-44.15, 6.7, 31.87, 1),
	            v4(-41.93, 21.02, 34.08, 1),
	            v4(-30.62, 45.24, 32.93, 1),
	            v4(-74.28, 80.44, 38.98, 1),
	            v4(-41.84, 88.71, 99.7, 1),
	            v4(0.22, 110.4, 90.76, 1),
	            v4(46.94, 125.3, 72.23, 1),
	            v4(31.67, 136.98, 10.09, 1),
	            v4(15.8, 190.72, 30.66, 1),
	            v4(80.58, 195.98, 63.4, 1),
	            v4(34.3, 241.41, 90.71, 1),
	            v4(47.35, 270.56, 34.87, 1),
	            v4(88.29, 275.92, 16.24, 1),
	            v4(132.21, 274.38, -5.83, 1),
	            v4(179.81, 279.07, -5.08, 1),
	            v4(226.61, 281.52, -2.18, 1),
	            v4(257.66, 284.57, 3.94, 1),
	            v4(273.33, 285.78, 4.18, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["315"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["315"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v27";
	Curves["316"] = function () {
	    var Curve_v01 = [[v4(18.59, -0.87, 3.91, 1),
	            v4(18.83, -0.65, 4, 1),
	            v4(19.51, 0.16, 3.96, 1),
	            v4(20.48, 1.61, 3.72, 1),
	            v4(21.78, 3.95, 3.36, 1),
	            v4(26.91, 15.76, 2.13, 1),
	            v4(32.27, 55.66, 4.01, 1),
	            v4(27.58, 104.81, 15.55, 1),
	            v4(0.09, 129.03, -53.32, 1),
	            v4(56.75, 96.46, -9.7, 1),
	            v4(-0.58, 137.99, 22.56, 1),
	            v4(54.82, 187.11, 27.96, 1),
	            v4(9.65, 192.31, 96.38, 1),
	            v4(10.86, 210.66, 128.29, 1),
	            v4(-24.68, 266.96, 171.52, 1),
	            v4(-8.93, 298.01, 101.63, 1),
	            v4(29.82, 229.89, 114.45, 1),
	            v4(32.65, 240.95, 186.16, 1),
	            v4(12.13, 288.05, 202.82, 1),
	            v4(3.83, 290.22, 269.76, 1),
	            v4(1.5, 271.79, 288.89, 1),
	            v4(0.47, 254.87, 300.22, 1),
	        ], [v4(18.45, -0.87, 3.38, 1),
	            v4(18.55, -0.64, 3.19, 1),
	            v4(18.98, 0.26, 2.83, 1),
	            v4(19.69, 1.75, 2.55, 1),
	            v4(20.78, 4.27, 2.22, 1),
	            v4(25.29, 16.92, 1.2, 1),
	            v4(29.24, 54.26, 3.2, 1),
	            v4(25.77, 105.58, 12.52, 1),
	            v4(-2.15, 128.63, -55.45, 1),
	            v4(54.65, 96.64, -12.02, 1),
	            v4(-2.75, 138.01, 20.25, 1),
	            v4(52.7, 187.19, 25.69, 1),
	            v4(7.45, 192.3, 94.11, 1),
	            v4(8.71, 210.71, 126, 1),
	            v4(-26.85, 267.03, 169.18, 1),
	            v4(-11.04, 297.97, 99.24, 1),
	            v4(22.68, 229.86, 112.33, 1),
	            v4(20.47, 240.98, 181.1, 1),
	            v4(-3.96, 288.06, 196.26, 1),
	            v4(-39.96, 290.22, 266.25, 1),
	            v4(-50.97, 271.78, 287.17, 1),
	            v4(-54.18, 254.87, 299.46, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["316"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["316"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v28";
	Curves["317"] = function () {
	    var Curve_v01 = [[v4(14.08, -3.81, 12.97, 1),
	            v4(14.24, -3.45, 12.92, 1),
	            v4(14.27, -2.24, 12.66, 1),
	            v4(14.14, -0.26, 12.23, 1),
	            v4(14.09, 3.57, 11.58, 1),
	            v4(15.53, 15.56, 10.55, 1),
	            v4(27.24, 44.33, 13.06, 1),
	            v4(35.76, 79.45, 12.23, 1),
	            v4(58.48, 100.45, 67.64, 1),
	            v4(-6.08, 80.09, 62.93, 1),
	            v4(-1.37, 129.51, 30.55, 1),
	            v4(21.45, 177.82, 59.34, 1),
	            v4(61.19, 154.97, 24.48, 1),
	            v4(27.05, 204.59, 19.79, 1),
	            v4(31.24, 243.44, 35.71, 1),
	            v4(3.56, 283.89, 14.26, 1),
	            v4(-34.87, 294.64, 5.54, 1),
	            v4(-74.34, 298.99, -17.35, 1),
	            v4(-106.82, 302.61, -44.35, 1),
	            v4(-132.89, 303.43, -80.55, 1),
	            v4(-142.34, 300.98, -107.83, 1),
	            v4(-144.55, 300.8, -122.26, 1),
	        ], [v4(12.95, -3.81, 12.69, 1),
	            v4(12.63, -3.45, 12.52, 1),
	            v4(12.13, -2.19, 12.1, 1),
	            v4(11.86, -0.21, 11.62, 1),
	            v4(11.79, 3.3, 10.93, 1),
	            v4(13.29, 15.13, 9.45, 1),
	            v4(26.18, 43.71, 10.33, 1),
	            v4(35.07, 78.86, 7.68, 1),
	            v4(57.77, 100.65, 64.48, 1),
	            v4(-6.26, 80, 60.18, 1),
	            v4(-2.5, 128.65, 27.58, 1),
	            v4(20.11, 177.84, 56.04, 1),
	            v4(60.42, 154.97, 22.02, 1),
	            v4(26.33, 204.04, 16.32, 1),
	            v4(30.49, 243.26, 32.84, 1),
	            v4(4.66, 283.69, 10.26, 1),
	            v4(-32.04, 294.67, 0.65, 1),
	            v4(-69.14, 298.95, -22.61, 1),
	            v4(-89.83, 302.62, -48.04, 1),
	            v4(-100.38, 303.43, -81.77, 1),
	            v4(-104.49, 300.99, -107.72, 1),
	            v4(-106.37, 300.8, -121.77, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["317"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["317"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v29";
	Curves["318"] = function () {
	    var Curve_v01 = [[v4(5, -2.33, 26.56, 1),
	            v4(4.99, -2.23, 26.75, 1),
	            v4(4.97, -1.43, 27.12, 1),
	            v4(4.97, 0.5, 27.39, 1),
	            v4(4.87, 4.29, 27.57, 1),
	            v4(4.74, 22.99, 35.65, 1),
	            v4(-3.83, 87.44, 30.66, 1),
	            v4(-3.16, 84.8, 128.28, 1),
	            v4(67.84, 166.68, 124.08, 1),
	            v4(-37.01, 187.34, 126.95, 1),
	            v4(-63.52, 193.63, 197.99, 1),
	            v4(-98.21, 206.99, 262.38, 1),
	            v4(-94.46, 213.1, 338.87, 1),
	            v4(-79.78, 221.95, 409.73, 1),
	            v4(-43.23, 228.36, 475.46, 1),
	            v4(6.52, 235.62, 529.54, 1),
	            v4(69, 242.11, 569.8, 1),
	            v4(140.31, 248.93, 591.64, 1),
	            v4(213.61, 255.66, 591.9, 1),
	            v4(287.86, 262.55, 572.02, 1),
	            v4(313.01, 268.63, 524.52, 1),
	            v4(326.69, 271.27, 505.62, 1),
	        ], [v4(5.05, -2.17, 25.83, 1),
	            v4(5.07, -1.87, 25.62, 1),
	            v4(5.06, -0.73, 25.46, 1),
	            v4(4.99, 1.43, 25.58, 1),
	            v4(6.2, 4.59, 28.21, 1),
	            v4(5.14, 22.71, 34.43, 1),
	            v4(-0.8, 87.7, 28.32, 1),
	            v4(-1.15, 84.62, 126.21, 1),
	            v4(70.41, 166.68, 122.01, 1),
	            v4(-34.61, 187.32, 124.84, 1),
	            v4(-61.08, 193.63, 195.85, 1),
	            v4(-95.81, 206.98, 260.25, 1),
	            v4(-92.06, 213.1, 336.74, 1),
	            v4(-77.43, 221.95, 407.49, 1),
	            v4(-42.35, 228.36, 465.98, 1),
	            v4(4.56, 235.61, 506.1, 1),
	            v4(63.72, 242.11, 532.49, 1),
	            v4(122.77, 248.92, 534.92, 1),
	            v4(172.32, 255.65, 506.54, 1),
	            v4(222.84, 262.55, 464.08, 1),
	            v4(240.31, 268.63, 415.23, 1),
	            v4(253.76, 271.27, 398.99, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["318"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["318"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v30";
	Curves["319"] = function () {
	    var Curve_v01 = [[v4(21.35, -5.42, 28.18, 1),
	            v4(21.39, -4.97, 28.56, 1),
	            v4(21.44, -3.56, 28.91, 1),
	            v4(21.47, -0.56, 28.99, 1),
	            v4(21.47, 4.45, 29.03, 1),
	            v4(19.85, 17.48, 30.91, 1),
	            v4(7.77, 48.29, 43.81, 1),
	            v4(-23.63, 62.78, 33.74, 1),
	            v4(-72.55, 77.51, 35.06, 1),
	            v4(-112.79, 78.57, 25.83, 1),
	            v4(-166.9, 105.4, 29.87, 1),
	            v4(-132.07, 143.44, 54.78, 1),
	            v4(-91.5, 154.36, 68.55, 1),
	            v4(-53.01, 173.48, 88.44, 1),
	            v4(-12.74, 186.41, 106.03, 1),
	            v4(21.67, 201.1, 129.64, 1),
	            v4(50.72, 212.77, 160.73, 1),
	            v4(62.97, 220.98, 204.88, 1),
	            v4(50.2, 224.75, 242.25, 1),
	            v4(24.08, 228.9, 271.7, 1),
	            v4(4.89, 231.99, 292.47, 1),
	            v4(-7.88, 233.75, 299.75, 1),
	        ], [v4(21.22, -5.42, 26.88, 1),
	            v4(21.19, -5.04, 26.52, 1),
	            v4(21.15, -3.65, 26.11, 1),
	            v4(21.15, -0.61, 25.99, 1),
	            v4(21.14, 4.36, 25.95, 1),
	            v4(19.95, 17.25, 27.96, 1),
	            v4(9.17, 48.35, 41.59, 1),
	            v4(-22.34, 63.23, 32.58, 1),
	            v4(-70.94, 77.97, 34.11, 1),
	            v4(-111.58, 78.51, 24.51, 1),
	            v4(-164.28, 107.03, 29.67, 1),
	            v4(-127.45, 143.69, 54.27, 1),
	            v4(-87.83, 154.86, 68.04, 1),
	            v4(-49.01, 173.72, 87.89, 1),
	            v4(-9.02, 186.7, 105.46, 1),
	            v4(27.86, 201.27, 129.26, 1),
	            v4(60.65, 212.9, 160.62, 1),
	            v4(74.91, 221.01, 205.19, 1),
	            v4(69.48, 224.78, 251.5, 1),
	            v4(53.18, 228.91, 294.41, 1),
	            v4(37.18, 232, 320.69, 1),
	            v4(28.53, 233.75, 333.17, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["319"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["319"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v31";
	Curves["320"] = function () {
	    var Curve_v01 = [[v4(34.64, -4.71, 16.74, 1),
	            v4(34.25, -3.96, 16.92, 1),
	            v4(33.63, -2.01, 16.73, 1),
	            v4(33.07, 0.48, 16.38, 1),
	            v4(32.36, 4.3, 15.96, 1),
	            v4(30.67, 17.68, 15.36, 1),
	            v4(32.7, 42.92, 18.54, 1),
	            v4(20.26, 66.51, -29.91, 1),
	            v4(-35.64, 83.12, 6.14, 1),
	            v4(-23.07, 112.84, 41.42, 1),
	            v4(0.46, 136.97, 81.87, 1),
	            v4(60.55, 143.75, 58.33, 1),
	            v4(38.58, 193.38, 33.51, 1),
	            v4(12.6, 212.92, 98.65, 1),
	            v4(-19.3, 248.12, 46.77, 1),
	            v4(37.56, 278.16, 47.64, 1),
	            v4(60.31, 291.65, 84.43, 1),
	            v4(86.56, 298.95, 125.22, 1),
	            v4(81.7, 313.61, 169.64, 1),
	            v4(69.27, 325.96, 213.4, 1),
	            v4(60.25, 335.64, 242.92, 1),
	            v4(60.79, 340.14, 257.83, 1),
	        ], [v4(35.14, -4.89, 15.9, 1),
	            v4(35.2, -4.34, 15.46, 1),
	            v4(34.93, -2.53, 14.95, 1),
	            v4(34.49, 0.12, 14.63, 1),
	            v4(33.86, 4.42, 14.34, 1),
	            v4(32.61, 17.85, 14.47, 1),
	            v4(34.26, 42.5, 17.59, 1),
	            v4(24.19, 66.77, -29.71, 1),
	            v4(-32.88, 83.03, 6.15, 1),
	            v4(-19.68, 112.93, 41.53, 1),
	            v4(3.54, 136.95, 81.91, 1),
	            v4(63.79, 143.79, 58.37, 1),
	            v4(41.71, 193.39, 33.58, 1),
	            v4(15.77, 212.94, 98.7, 1),
	            v4(-16.14, 248.14, 46.81, 1),
	            v4(40.75, 278.17, 47.7, 1),
	            v4(63.48, 291.66, 84.49, 1),
	            v4(90.05, 298.96, 125.33, 1),
	            v4(99.77, 313.62, 171.89, 1),
	            v4(110.59, 325.97, 219.09, 1),
	            v4(111.49, 335.65, 250.07, 1),
	            v4(113.35, 340.15, 265.18, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["320"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["320"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v32";
	Curves["321"] = function () {
	    var Curve_v01 = [[v4(-15.61, -4.48, 17.27, 1),
	            v4(-15.47, -4.23, 17.03, 1),
	            v4(-15.32, -3.42, 16.76, 1),
	            v4(-15.25, -1.71, 16.66, 1),
	            v4(-15.26, 1.71, 17.12, 1),
	            v4(-15.56, 15.13, 19.85, 1),
	            v4(-17.49, 42.58, 28.25, 1),
	            v4(-28.85, 82.43, 26.47, 1),
	            v4(-29.16, 126.58, 37.39, 1),
	            v4(-26.83, 169.33, 48.93, 1),
	            v4(-26.32, 208.62, 72.15, 1),
	            v4(-32.97, 240.11, 103.35, 1),
	            v4(-46.62, 265.74, 137.86, 1),
	            v4(-72.63, 284.44, 170.18, 1),
	            v4(-110.06, 293.06, 194.31, 1),
	            v4(-152.27, 296.49, 209.22, 1),
	            v4(-196.77, 297.87, 215.63, 1),
	            v4(-241.59, 299.47, 211.33, 1),
	            v4(-283.97, 302.52, 196.61, 1),
	            v4(-323.08, 307.78, 175.45, 1),
	            v4(-346.79, 313.2, 157.91, 1),
	            v4(-357.08, 318.06, 148.23, 1),
	        ], [v4(-16.06, -4.48, 18.02, 1),
	            v4(-16.24, -4.09, 18.32, 1),
	            v4(-16.43, -2.75, 18.64, 1),
	            v4(-16.48, -0.66, 18.76, 1),
	            v4(-16.49, 2.52, 18.92, 1),
	            v4(-16.33, 15.83, 19.71, 1),
	            v4(-15.66, 43.3, 24.07, 1),
	            v4(-26.8, 83.33, 25.63, 1),
	            v4(-26.59, 127.43, 34.94, 1),
	            v4(-24.46, 170.05, 47.47, 1),
	            v4(-23.94, 209.19, 70.37, 1),
	            v4(-30.73, 240.5, 101.86, 1),
	            v4(-44.46, 266.03, 136.18, 1),
	            v4(-70.62, 284.59, 168.46, 1),
	            v4(-107.57, 293.11, 191.91, 1),
	            v4(-144.33, 296.5, 201.19, 1),
	            v4(-181.41, 297.88, 199.95, 1),
	            v4(-221.79, 299.48, 191.61, 1),
	            v4(-252.59, 302.54, 171.43, 1),
	            v4(-278.54, 307.79, 145.58, 1),
	            v4(-299.04, 313.2, 128.35, 1),
	            v4(-310.18, 318.06, 120.04, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["321"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["321"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v33";
	Curves["322"] = function () {
	    var Curve_v01 = [[v4(-19.24, -2.93, 33.67, 1),
	            v4(-19.2, -2.55, 34, 1),
	            v4(-19.15, -1.48, 34.41, 1),
	            v4(-19.13, 0.58, 34.57, 1),
	            v4(-19.11, 4.23, 34.66, 1),
	            v4(-17.86, 16, 37.1, 1),
	            v4(-20.16, 54.44, 45.94, 1),
	            v4(-31.13, 101.77, 41.1, 1),
	            v4(38.51, 125.99, 15.62, 1),
	            v4(-6.75, 93.42, 70.99, 1),
	            v4(-37.33, 134.96, 12.74, 1),
	            v4(-44.33, 184.07, 67.97, 1),
	            v4(-111.41, 189.27, 20.83, 1),
	            v4(-143.34, 207.62, 21.11, 1),
	            v4(-185.52, 263.92, -15.67, 1),
	            v4(-116.12, 294.97, 2.1, 1),
	            v4(-130.06, 226.85, 35.46, 1),
	            v4(-198.81, 237.91, 31.26, 1),
	            v4(-213.5, 283.81, 14.56, 1),
	            v4(-278.94, 286.03, 25.74, 1),
	            v4(-299.53, 268.45, 29, 1),
	            v4(-312.46, 252.13, 30.46, 1),
	        ], [v4(-19.49, -3.21, 31.52, 1),
	            v4(-19.53, -2.9, 31.19, 1),
	            v4(-19.58, -1.93, 30.8, 1),
	            v4(-19.59, 0.22, 30.66, 1),
	            v4(-19.59, 4.29, 30.62, 1),
	            v4(-16.91, 17.29, 33.74, 1),
	            v4(-19.23, 53.39, 42.96, 1),
	            v4(-28.06, 102.55, 39.38, 1),
	            v4(40.7, 125.59, 13.45, 1),
	            v4(-4.37, 93.6, 68.96, 1),
	            v4(-34.96, 134.97, 10.65, 1),
	            v4(-42, 184.15, 65.92, 1),
	            v4(-109.08, 189.26, 18.7, 1),
	            v4(-140.99, 207.67, 19.03, 1),
	            v4(-183.12, 263.99, -17.77, 1),
	            v4(-113.67, 294.93, 0.07, 1),
	            v4(-127.74, 226.83, 33.39, 1),
	            v4(-196.41, 237.94, 29.18, 1),
	            v4(-210.53, 285.02, 5.36, 1),
	            v4(-277.54, 287.18, -26.58, 1),
	            v4(-297.57, 268.74, -36.43, 1),
	            v4(-309.63, 251.83, -39.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["322"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["322"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v34";
	Curves["323"] = function () {
	    var Curve_v01 = [[v4(2.84, -5.76, 30.23, 1),
	            v4(2.61, -5.31, 30.5, 1),
	            v4(2.42, -3.29, 30.76, 1),
	            v4(2.41, -0.26, 30.81, 1),
	            v4(2.89, 4.94, 31.46, 1),
	            v4(0.75, 16.58, 33.75, 1),
	            v4(-7.23, 43.84, 42.42, 1),
	            v4(-10.21, 77.51, 50.07, 1),
	            v4(-69.9, 98.5, 45.33, 1),
	            v4(-36.56, 78.15, -10.15, 1),
	            v4(-9.79, 127.56, 8.67, 1),
	            v4(-45.78, 175.87, 16.04, 1),
	            v4(-32.62, 153.03, 67.23, 1),
	            v4(-13.02, 202.64, 38.89, 1),
	            v4(-29.12, 241.5, 35.44, 1),
	            v4(2.51, 281.95, 20.42, 1),
	            v4(27.65, 292.69, -9.94, 1),
	            v4(65.89, 297.05, -34.83, 1),
	            v4(104.63, 300.66, -51.63, 1),
	            v4(148.71, 301.49, -58.55, 1),
	            v4(177.32, 299.04, -54.67, 1),
	            v4(191.19, 298.86, -50.13, 1),
	        ], [v4(3.41, -5.76, 29.62, 1),
	            v4(3.68, -5.23, 29.33, 1),
	            v4(3.92, -3.25, 29.08, 1),
	            v4(3.97, -0.09, 29.04, 1),
	            v4(4.61, 4.86, 29.81, 1),
	            v4(2.76, 16.5, 32.57, 1),
	            v4(-4.27, 43.4, 42.8, 1),
	            v4(-5.84, 76.91, 51.51, 1),
	            v4(-66.77, 98.7, 46.13, 1),
	            v4(-34.02, 78.05, -9.07, 1),
	            v4(-6.64, 126.71, 8.99, 1),
	            v4(-42.24, 175.89, 16.33, 1),
	            v4(-30.08, 153.03, 67.65, 1),
	            v4(-9.6, 202.1, 39.8, 1),
	            v4(-26.22, 241.31, 35.99, 1),
	            v4(5.51, 281.74, 21.24, 1),
	            v4(30.58, 292.72, -9.21, 1),
	            v4(68.19, 297.01, -32.74, 1),
	            v4(101.44, 300.67, -38.4, 1),
	            v4(138.01, 301.48, -29.95, 1),
	            v4(163.71, 299.04, -20.13, 1),
	            v4(177.21, 298.86, -14.77, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["323"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["323"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v35";
	Curves["324"] = function () {
	    var Curve_v01 = [[v4(-8.18, -0.87, 46.39, 1),
	            v4(-7.23, -0.1, 45.44, 1),
	            v4(-6.33, 1.75, 44.05, 1),
	            v4(-5.44, 4.67, 42.71, 1),
	            v4(-4.61, 8.2, 41.56, 1),
	            v4(-1.18, 26.91, 37.94, 1),
	            v4(3.27, 89.02, 45.83, 1),
	            v4(59.83, 86.41, -32.46, 1),
	            v4(0.08, 168.3, -71.04, 1),
	            v4(86.35, 188.96, -11.38, 1),
	            v4(149.72, 195.24, -53.01, 1),
	            v4(215.76, 208.6, -84.44, 1),
	            v4(257.95, 214.72, -148.35, 1),
	            v4(288, 223.57, -214.18, 1),
	            v4(297.37, 229.98, -288.81, 1),
	            v4(289.21, 237.23, -361.84, 1),
	            v4(262.61, 243.72, -431.24, 1),
	            v4(218.01, 250.54, -491.01, 1),
	            v4(159.04, 257.27, -534.55, 1),
	            v4(87.4, 264.16, -562.4, 1),
	            v4(39.04, 270.24, -538.95, 1),
	            v4(16.83, 272.89, -531.81, 1),
	        ], [v4(-8.96, -0.87, 46.65, 1),
	            v4(-8.99, -0.16, 46.07, 1),
	            v4(-8.14, 1.66, 44.71, 1),
	            v4(-7.13, 4.54, 43.39, 1),
	            v4(-6.15, 7.96, 42.27, 1),
	            v4(-2.33, 26.14, 38.6, 1),
	            v4(-0.58, 89.29, 45.97, 1),
	            v4(56.98, 86.23, -31.99, 1),
	            v4(-3.22, 168.29, -70.9, 1),
	            v4(83.16, 188.93, -11.1, 1),
	            v4(146.48, 195.24, -52.73, 1),
	            v4(212.57, 208.59, -84.14, 1),
	            v4(254.76, 214.72, -148.05, 1),
	            v4(284.68, 226.3, -212.81, 1),
	            v4(293.7, 239.25, -284.88, 1),
	            v4(285.2, 252.83, -355.43, 1),
	            v4(258.46, 261.97, -423.81, 1),
	            v4(213.8, 273.13, -481.85, 1),
	            v4(154.68, 291.18, -520.9, 1),
	            v4(82.86, 310.34, -543.88, 1),
	            v4(34.42, 321.32, -518.48, 1),
	            v4(12.2, 324.61, -511.08, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["324"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["324"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v36";
	Curves["325"] = function () {
	    var Curve_v01 = [[v4(2.49, -2.01, 48.99, 1),
	            v4(2.65, -1.52, 48.69, 1),
	            v4(2.8, -0.14, 48.42, 1),
	            v4(2.83, 2.07, 48.36, 1),
	            v4(2.85, 5.24, 48.32, 1),
	            v4(6.29, 17.14, 48.21, 1),
	            v4(20.97, 50.96, 35.95, 1),
	            v4(50.95, 66.19, 53.34, 1),
	            v4(99.01, 80.92, 62.51, 1),
	            v4(136.35, 81.98, 80.12, 1),
	            v4(190.08, 108.81, 87.74, 1),
	            v4(161.38, 146.84, 55.96, 1),
	            v4(124.68, 157.76, 33.84, 1),
	            v4(91.33, 176.88, 6.18, 1),
	            v4(55.74, 189.8, -19.63, 1),
	            v4(26.45, 204.31, -50.72, 1),
	            v4(3.43, 215.68, -88.37, 1),
	            v4(1.86, 223.75, -132.57, 1),
	            v4(27.05, 227.64, -162.16, 1),
	            v4(61.67, 232.07, -184.32, 1),
	            v4(84.72, 235.33, -201.75, 1),
	            v4(97.23, 237.14, -207.39, 1),
	        ], [v4(1.6, -2.01, 50.59, 1),
	            v4(1.45, -1.59, 50.87, 1),
	            v4(1.29, -0.31, 51.17, 1),
	            v4(1.23, 1.94, 51.26, 1),
	            v4(1.83, 5.43, 52.18, 1),
	            v4(5.92, 17.55, 50.89, 1),
	            v4(19.49, 51.19, 38.08, 1),
	            v4(49.44, 66.64, 54.2, 1),
	            v4(97.23, 81.38, 63.09, 1),
	            v4(134.89, 81.92, 81.15, 1),
	            v4(187.48, 110.44, 87.37, 1),
	            v4(156.75, 147.09, 55.47, 1),
	            v4(120.99, 158.27, 33.55, 1),
	            v4(87.31, 177.13, 5.86, 1),
	            v4(51.99, 190.1, -19.85, 1),
	            v4(21.05, 204.68, -50.98, 1),
	            v4(-4.28, 216.3, -88.62, 1),
	            v4(-8.68, 224.41, -135.21, 1),
	            v4(6.52, 228.18, -179.28, 1),
	            v4(31.62, 232.32, -217.72, 1),
	            v4(52.85, 235.4, -239.98, 1),
	            v4(63.98, 237.16, -250.32, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["325"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["325"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v37";
	Curves["326"] = function () {
	    var Curve_v01 = [[v4(36.7, -1.63, 55.92, 1),
	            v4(37.08, -1.11, 55.44, 1),
	            v4(37.46, 1.01, 55.04, 1),
	            v4(37.59, 3.96, 54.94, 1),
	            v4(37.73, 9.92, 54.81, 1),
	            v4(38.48, 22.62, 52.26, 1),
	            v4(29.06, 45.72, 53.81, 1),
	            v4(44.75, 77.41, 92.7, 1),
	            v4(96.6, 85.98, 48.67, 1),
	            v4(80.11, 107.52, 9.3, 1),
	            v4(52.33, 122.51, -32.84, 1),
	            v4(-5.37, 134.13, -5.52, 1),
	            v4(17.84, 187.9, 5.97, 1),
	            v4(37.07, 193.16, -64.04, 1),
	            v4(73.04, 238.58, -24.15, 1),
	            v4(18.6, 267.75, -26.39, 1),
	            v4(-3.53, 273.1, -63.7, 1),
	            v4(-31.42, 271.57, -102.74, 1),
	            v4(-31.29, 276.25, -145.75, 1),
	            v4(-20.96, 278.7, -184.53, 1),
	            v4(-12.05, 281.75, -211.76, 1),
	            v4(-12.68, 282.96, -226.69, 1),
	        ], [v4(35.97, -1.63, 56.86, 1),
	            v4(35.66, -1.21, 57.28, 1),
	            v4(35.37, 0.66, 57.7, 1),
	            v4(35.36, 3.39, 57.74, 1),
	            v4(35.41, 9.25, 57.67, 1),
	            v4(36.77, 22.11, 53.59, 1),
	            v4(27.26, 45, 54.29, 1),
	            v4(40.81, 77.63, 92.83, 1),
	            v4(93.86, 85.9, 48.95, 1),
	            v4(76.72, 107.59, 9.51, 1),
	            v4(49.26, 122.48, -32.58, 1),
	            v4(-8.59, 134.17, -5.25, 1),
	            v4(14.72, 187.9, 6.21, 1),
	            v4(33.91, 193.16, -63.79, 1),
	            v4(69.89, 238.59, -23.88, 1),
	            v4(12.57, 267.75, -25.55, 1),
	            v4(-13.84, 273.1, -61.97, 1),
	            v4(-44.21, 271.57, -100.61, 1),
	            v4(-52.95, 276.25, -147.41, 1),
	            v4(-59.42, 278.7, -193.84, 1),
	            v4(-59.61, 281.75, -225.5, 1),
	            v4(-62.49, 282.96, -240.9, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["326"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["326"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v38";
	Curves["327"] = function () {
	    var Curve_v01 = [[v4(-31.27, 5.93, 56.81, 1),
	            v4(-31.53, 6.22, 56.73, 1),
	            v4(-31.85, 7.36, 56.62, 1),
	            v4(-31.89, 9.2, 56.54, 1),
	            v4(-31.77, 12.51, 56.37, 1),
	            v4(-29.78, 25.62, 55.9, 1),
	            v4(-23.29, 52.93, 50.26, 1),
	            v4(-15.17, 92.84, 58.43, 1),
	            v4(-8.46, 136.99, 49.79, 1),
	            v4(-3.52, 179.74, 39.11, 1),
	            v4(9.79, 219.03, 20.08, 1),
	            v4(33.6, 250.52, -1.15, 1),
	            v4(65.01, 276.15, -20.92, 1),
	            v4(105.1, 294.86, -31.61, 1),
	            v4(149.54, 303.47, -28.95, 1),
	            v4(192.41, 306.9, -16.03, 1),
	            v4(232.09, 308.28, 5.11, 1),
	            v4(265.7, 309.89, 35.08, 1),
	            v4(291.18, 312.93, 72, 1),
	            v4(310.22, 318.19, 112.19, 1),
	            v4(318.98, 323.61, 140.34, 1),
	            v4(321.55, 328.48, 154.24, 1),
	        ], [v4(-30.44, 5.93, 57.09, 1),
	            v4(-30.09, 6.41, 57.21, 1),
	            v4(-29.78, 7.95, 57.31, 1),
	            v4(-29.68, 10.21, 57.28, 1),
	            v4(-29.58, 13.64, 57.18, 1),
	            v4(-29.22, 26.8, 56.39, 1),
	            v4(-27.13, 54.08, 52.61, 1),
	            v4(-17.31, 93.74, 57.89, 1),
	            v4(-11.98, 137.84, 50.26, 1),
	            v4(-6.29, 180.47, 38.89, 1),
	            v4(6.82, 219.61, 20.12, 1),
	            v4(30.91, 250.91, -1.27, 1),
	            v4(62.28, 276.45, -20.84, 1),
	            v4(102.45, 295, -31.41, 1),
	            v4(146.38, 303.52, -28.39, 1),
	            v4(184.36, 306.91, -12.97, 1),
	            v4(217.36, 308.29, 11.56, 1),
	            v4(246.72, 309.9, 43.15, 1),
	            v4(259.64, 312.95, 80.32, 1),
	            v4(264.19, 318.2, 119.44, 1),
	            v4(268.6, 323.62, 146.37, 1),
	            v4(271.42, 328.48, 159.66, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["327"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["327"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v39";
	Curves["328"] = function () {
	    var Curve_v01 = [[v4(2.6, 12.39, -25.71, 1),
	            v4(2.94, 12.7, -25.73, 1),
	            v4(3.35, 13.92, -25.79, 1),
	            v4(3.51, 16.36, -25.87, 1),
	            v4(3.61, 20.53, -25.98, 1),
	            v4(5.62, 23.81, -17.94, 1),
	            v4(10.15, 61.5, -20.13, 1),
	            v4(16.07, 108.25, -9.86, 1),
	            v4(-55.16, 132.47, -30.48, 1),
	            v4(14.06, 99.9, -48.39, 1),
	            v4(4.3, 141.43, 16.67, 1),
	            v4(42.6, 190.55, -23.73, 1),
	            v4(68.83, 195.75, 53.94, 1),
	            v4(94.76, 214.1, 72.59, 1),
	            v4(107.04, 270.4, 127.19, 1),
	            v4(61.56, 301.45, 71.84, 1),
	            v4(92.53, 233.33, 53.17, 1),
	            v4(145.49, 244.39, 97.19, 1),
	            v4(146.31, 291.49, 120.32, 1),
	            v4(202.11, 293.66, 159.9, 1),
	            v4(218.47, 275.23, 172.15, 1),
	            v4(227.84, 258.31, 179.94, 1),
	        ], [v4(1.73, 12.39, -25.71, 1),
	            v4(1.41, 12.68, -25.72, 1),
	            v4(1.04, 13.85, -25.78, 1),
	            v4(0.95, 16.03, -25.89, 1),
	            v4(0.96, 20.21, -26.05, 1),
	            v4(3.71, 23.78, -17.05, 1),
	            v4(7.57, 59.92, -18.39, 1),
	            v4(12.57, 109.02, -10.29, 1),
	            v4(-58.22, 132.07, -30.02, 1),
	            v4(10.95, 100.08, -48.15, 1),
	            v4(1.15, 141.45, 16.96, 1),
	            v4(39.5, 190.63, -23.46, 1),
	            v4(65.7, 195.74, 54.28, 1),
	            v4(91.63, 214.15, 72.87, 1),
	            v4(103.85, 270.47, 127.47, 1),
	            v4(58.38, 301.41, 72.02, 1),
	            v4(89.42, 233.3, 53.46, 1),
	            v4(142.33, 244.42, 97.45, 1),
	            v4(140.03, 291.5, 124.53, 1),
	            v4(177.5, 293.66, 187.14, 1),
	            v4(188.5, 275.22, 206.12, 1),
	            v4(196.55, 258.31, 215.56, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["328"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["328"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v40";
	Curves["329"] = function () {
	    var Curve_v01 = [[v4(-46.29, 14.44, -31.6, 1),
	            v4(-46.17, 14.85, -31.82, 1),
	            v4(-46.5, 16.7, -32.08, 1),
	            v4(-47.05, 19.83, -32.34, 1),
	            v4(-47.32, 24.67, -32.95, 1),
	            v4(-46.36, 36.42, -35.03, 1),
	            v4(-37.89, 63.62, -42.23, 1),
	            v4(-33.45, 97.7, -49.25, 1),
	            v4(24.23, 118.7, -33.14, 1),
	            v4(-19.15, 98.34, 14.91, 1),
	            v4(-41.8, 147.76, -8.7, 1),
	            v4(-5.06, 196.07, -9.02, 1),
	            v4(-8.16, 173.22, -61.79, 1),
	            v4(-32.83, 222.84, -37.74, 1),
	            v4(-17.68, 261.74, -31.2, 1),
	            v4(-51.1, 303.73, -20.33, 1),
	            v4(-81.03, 316.18, 7.08, 1),
	            v4(-123.04, 321.43, 25.44, 1),
	            v4(-164.54, 324.27, 33.38, 1),
	            v4(-209.74, 323.26, 29.07, 1),
	            v4(-237.42, 319.74, 18.25, 1),
	            v4(-250.28, 319.22, 10.65, 1),
	        ], [v4(-46.98, 14.44, -31.06, 1),
	            v4(-47.42, 14.87, -30.85, 1),
	            v4(-48.26, 16.61, -30.68, 1),
	            v4(-48.91, 19.55, -30.9, 1),
	            v4(-49.32, 24.16, -31.56, 1),
	            v4(-48.66, 35.93, -34.1, 1),
	            v4(-40.71, 63.13, -43.15, 1),
	            v4(-37.46, 97.1, -51.5, 1),
	            v4(21.31, 118.9, -34.52, 1),
	            v4(-21.43, 98.25, 13.36, 1),
	            v4(-44.83, 146.9, -9.63, 1),
	            v4(-8.49, 196.09, -9.99, 1),
	            v4(-10.57, 173.22, -62.7, 1),
	            v4(-36.01, 222.29, -39.3, 1),
	            v4(-20.43, 261.51, -32.36, 1),
	            v4(-54.41, 301.94, -23.98, 1),
	            v4(-84.85, 312.91, 1.09, 1),
	            v4(-126.25, 317.2, 16.35, 1),
	            v4(-159.67, 320.87, 10.6, 1),
	            v4(-193.54, 321.68, -11.46, 1),
	            v4(-216.72, 319.24, -28.65, 1),
	            v4(-228.92, 319.05, -36.85, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["329"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["329"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v41";
	Curves["330"] = function () {
	    var Curve_v01 = [[v4(149.27, -3.15, -6.03, 1),
	            v4(149.44, -2.84, -5.49, 1),
	            v4(149.8, -1.26, -4.86, 1),
	            v4(150.09, 1.47, -4.92, 1),
	            v4(150.53, 7.06, -5.06, 1),
	            v4(151.08, 19.93, -4.62, 1),
	            v4(150.26, 47.18, -6.71, 1),
	            v4(144.61, 84.82, -13.85, 1),
	            v4(147.04, 129.98, -5.08, 1),
	            v4(151.72, 173.63, 1.11, 1),
	            v4(151.67, 215.8, 18.58, 1),
	            v4(142.03, 252.08, 43.07, 1),
	            v4(124.2, 283.68, 69.86, 1),
	            v4(94.07, 309.17, 92.54, 1),
	            v4(53.53, 324.43, 105.94, 1),
	            v4(9.75, 333.59, 110.01, 1),
	            v4(-34.6, 339.65, 105.61, 1),
	            v4(-76.88, 344.32, 90.77, 1),
	            v4(-114.35, 348.65, 66.29, 1),
	            v4(-146.98, 353.9, 36.08, 1),
	            v4(-165.46, 358.58, 12.94, 1),
	            v4(-172.75, 362.77, 0.58, 1),
	        ], [v4(148.58, -3.04, -9.02, 1),
	            v4(148.46, -2.49, -9.86, 1),
	            v4(148.5, -0.63, -10.79, 1),
	            v4(148.8, 2.3, -11.22, 1),
	            v4(149.41, 7.7, -11.7, 1),
	            v4(150.87, 20.51, -12.21, 1),
	            v4(152.99, 47.27, -11.85, 1),
	            v4(146.89, 85.4, -17.7, 1),
	            v4(150.16, 130.23, -6.96, 1),
	            v4(154.42, 173.93, 0.17, 1),
	            v4(154.43, 215.9, 17.35, 1),
	            v4(144.57, 252.06, 42.11, 1),
	            v4(126.7, 283.54, 68.71, 1),
	            v4(96.42, 308.88, 91.33, 1),
	            v4(56.14, 324.02, 104.29, 1),
	            v4(15.24, 333.13, 105.07, 1),
	            v4(-25.18, 339.16, 96.2, 1),
	            v4(-64.94, 343.83, 79.01, 1),
	            v4(-90.7, 348.15, 49.13, 1),
	            v4(-107.36, 353.4, 12.77, 1),
	            v4(-119.35, 358.07, -12.3, 1),
	            v4(-125.75, 362.25, -24.63, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["330"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["330"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v42";
	Curves["331"] = function () {
	    var Curve_v01 = [[v4(6.44, 3.17, -4.85, 1),
	            v4(6.44, 3.57, -5.17, 1),
	            v4(6.54, 4.84, -5.78, 1),
	            v4(6.82, 6.99, -6.3, 1),
	            v4(7.41, 10.76, -6.73, 1),
	            v4(8.04, 21.24, -6.26, 1),
	            v4(14.79, 49.54, 4.69, 1),
	            v4(21.96, 84.43, 10.47, 1),
	            v4(-11.98, 106.23, 61.36, 1),
	            v4(-44.72, 85.57, 6.16, 1),
	            v4(-15.73, 134.23, -9.21, 1),
	            v4(-26.36, 183.41, 25.55, 1),
	            v4(24.51, 160.55, 39.49, 1),
	            v4(9.89, 209.62, 8.17, 1),
	            v4(-1.32, 248.83, 20.93, 1),
	            v4(4.44, 289.26, -13.63, 1),
	            v4(-6.47, 300.24, -49.83, 1),
	            v4(-6.86, 304.53, -94.33, 1),
	            v4(5.24, 308.19, -129.6, 1),
	            v4(29.78, 309, -162.49, 1),
	            v4(49.47, 306.56, -182.32, 1),
	            v4(59.93, 306.38, -191.92, 1),
	        ], [v4(6.73, 2.97, -3.61, 1),
	            v4(6.82, 3.31, -3.55, 1),
	            v4(7.01, 4.42, -3.7, 1),
	            v4(7.27, 6.41, -4.06, 1),
	            v4(7.73, 9.78, -4.43, 1),
	            v4(8.19, 20.59, -4.22, 1),
	            v4(13.01, 49.42, 6.97, 1),
	            v4(18.6, 85.03, 13.62, 1),
	            v4(-14.18, 106.02, 63.73, 1),
	            v4(-46.88, 85.67, 7.87, 1),
	            v4(-17.53, 135.08, -6.6, 1),
	            v4(-28.32, 183.39, 28.52, 1),
	            v4(22.92, 160.55, 41.51, 1),
	            v4(7.44, 210.16, 10.73, 1),
	            v4(-3.3, 249.02, 23.2, 1),
	            v4(-1.32, 289.47, -11.76, 1),
	            v4(-15.91, 300.21, -48.38, 1),
	            v4(-19.41, 304.57, -93.87, 1),
	            v4(-15.57, 308.18, -135.92, 1),
	            v4(-0.51, 309.01, -177.92, 1),
	            v4(16.62, 306.56, -201.16, 1),
	            v4(27.25, 306.38, -211.16, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["331"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["331"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v43";
	Curves["332"] = function () {
	    var Curve_v01 = [[v4(-9.25, 0.76, -0.14, 1),
	            v4(-8.96, 1.25, 0.05, 1),
	            v4(-8.54, 2.47, 0.61, 1),
	            v4(-8.13, 4.44, 1.46, 1),
	            v4(-7.69, 7.18, 2.5, 1),
	            v4(-4.79, 19.89, 6.53, 1),
	            v4(-6.3, 56.45, 10.54, 1),
	            v4(-15.9, 107.22, 8.35, 1),
	            v4(47.79, 130.27, -28.3, 1),
	            v4(12.24, 98.28, 33.74, 1),
	            v4(-27.32, 139.65, -18.89, 1),
	            v4(-25.38, 188.83, 36.79, 1),
	            v4(-99.19, 193.93, 0.98, 1),
	            v4(-130.63, 212.35, 6.44, 1),
	            v4(-178.13, 268.67, -23.11, 1),
	            v4(-106.71, 299.61, -16.68, 1),
	            v4(-115.24, 231.5, 15.71, 1),
	            v4(-183.7, 242.62, 20.39, 1),
	            v4(-201.41, 289.7, 0.69, 1),
	            v4(-272.39, 291.86, -16.27, 1),
	            v4(-293.66, 273.42, -22.37, 1),
	            v4(-306.04, 256.51, -23.48, 1),
	        ], [v4(-9.93, 0.76, 0.14, 1),
	            v4(-9.92, 1.14, 0.5, 1),
	            v4(-9.67, 2.23, 1.33, 1),
	            v4(-9.2, 4.12, 2.44, 1),
	            v4(-8.68, 6.72, 3.7, 1),
	            v4(-5.48, 18.68, 8.29, 1),
	            v4(-6.69, 57.7, 13.65, 1),
	            v4(-18.65, 106.45, 10.55, 1),
	            v4(45.98, 130.67, -25.8, 1),
	            v4(10.23, 98.1, 36.13, 1),
	            v4(-29.33, 139.63, -16.44, 1),
	            v4(-27.36, 188.75, 39.19, 1),
	            v4(-101.15, 193.95, 3.45, 1),
	            v4(-132.61, 212.3, 8.87, 1),
	            v4(-180.17, 268.6, -20.65, 1),
	            v4(-108.81, 299.65, -14.27, 1),
	            v4(-117.2, 231.53, 20.9, 1),
	            v4(-185.72, 242.59, 27.81, 1),
	            v4(-204.02, 289.69, 11.82, 1),
	            v4(-273.42, 291.86, 35.54, 1),
	            v4(-292.14, 273.43, 46.36, 1),
	            v4(-303.34, 256.51, 51.62, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["332"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["332"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v44";
	Curves["333"] = function () {
	    var Curve_v01 = [[v4(16.13, 7.06, -12.8, 1),
	            v4(15.95, 7.29, -12.72, 1),
	            v4(15.74, 8.05, -12.62, 1),
	            v4(15.61, 9.42, -12.57, 1),
	            v4(15.57, 11.75, -12.55, 1),
	            v4(16.85, 28.66, -13.2, 1),
	            v4(3.14, 49.95, -1.29, 1),
	            v4(-7.85, 90.91, 2.12, 1),
	            v4(-6.15, 135.01, 11.27, 1),
	            v4(-2.02, 177.63, 23.3, 1),
	            v4(2.17, 216.77, 45.81, 1),
	            v4(0.53, 248.08, 77.99, 1),
	            v4(-7.5, 273.61, 114.07, 1),
	            v4(-28.12, 292.17, 150.13, 1),
	            v4(-61.13, 300.69, 179.41, 1),
	            v4(-99.46, 304.08, 196.5, 1),
	            v4(-141.06, 305.46, 203.97, 1),
	            v4(-184.45, 307.06, 203.26, 1),
	            v4(-217.61, 310.12, 185.37, 1),
	            v4(-244.99, 315.37, 159.26, 1),
	            v4(-265.57, 320.78, 142.61, 1),
	            v4(-276.7, 325.64, 135.14, 1),
	        ], [v4(17.1, 7.2, -13.23, 1),
	            v4(17.27, 7.45, -13.3, 1),
	            v4(17.47, 8.17, -13.39, 1),
	            v4(17.62, 9.62, -13.45, 1),
	            v4(17.65, 12.06, -13.47, 1),
	            v4(17.74, 28.34, -13.36, 1),
	            v4(2.05, 49.16, 3.2, 1),
	            v4(-9.74, 90.01, 3.28, 1),
	            v4(-8.28, 134.16, 14.11, 1),
	            v4(-4.13, 176.91, 25.12, 1),
	            v4(0.11, 216.2, 47.96, 1),
	            v4(-1.43, 247.69, 79.82, 1),
	            v4(-9.35, 273.32, 116.08, 1),
	            v4(-29.83, 292.02, 152.16, 1),
	            v4(-62.88, 300.64, 181.99, 1),
	            v4(-102.15, 304.07, 203.51, 1),
	            v4(-145.04, 305.45, 216.99, 1),
	            v4(-189.97, 307.05, 219.95, 1),
	            v4(-234.16, 310.1, 212.24, 1),
	            v4(-276.17, 315.36, 197.65, 1),
	            v4(-302.39, 320.78, 184.16, 1),
	            v4(-314.11, 325.64, 176.25, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["333"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["333"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v45";
	Curves["334"] = function () {
	    var Curve_v01 = [[v4(11.56, 0.79, -0.89, 1),
	            v4(11.51, 1.11, -1.08, 1),
	            v4(11.45, 2.08, -1.3, 1),
	            v4(11.41, 3.69, -1.36, 1),
	            v4(11.36, 6.62, -1.34, 1),
	            v4(8.01, 20.97, 1.29, 1),
	            v4(16.97, 50.69, 4.07, 1),
	            v4(-28.31, 83.72, -5.01, 1),
	            v4(-23.16, 89.28, 61.7, 1),
	            v4(15.32, 113.28, 73.03, 1),
	            v4(65.75, 124.38, 80.72, 1),
	            v4(79.75, 140.58, 18.45, 1),
	            v4(61.04, 194.75, 36.8, 1),
	            v4(92.35, 195.93, 95.4, 1),
	            v4(40.39, 247.05, 87.7, 1),
	            v4(85.82, 270.03, 50.59, 1),
	            v4(128.61, 276.42, 58.72, 1),
	            v4(177.72, 274.17, 63.62, 1),
	            v4(222.22, 278.72, 79.32, 1),
	            v4(265.71, 281.46, 103.11, 1),
	            v4(291.07, 284.58, 121.16, 1),
	            v4(302.44, 286.52, 136.92, 1),
	        ], [v4(11.79, 0.76, 0.15, 1),
	            v4(11.83, 1, 0.33, 1),
	            v4(11.87, 1.66, 0.53, 1),
	            v4(11.89, 2.95, 0.69, 1),
	            v4(11.89, 5.37, 0.75, 1),
	            v4(7.47, 20.06, 3.42, 1),
	            v4(16.84, 50.59, 6.17, 1),
	            v4(-30.37, 83.04, -2.76, 1),
	            v4(-25.36, 89.36, 63.34, 1),
	            v4(12.78, 112.91, 75.54, 1),
	            v4(63.3, 124.47, 83.38, 1),
	            v4(77.96, 140.08, 21.31, 1),
	            v4(58.79, 194.64, 38.68, 1),
	            v4(90.47, 195.76, 97.67, 1),
	            v4(38.43, 246.77, 90.37, 1),
	            v4(83.47, 270.02, 53.07, 1),
	            v4(126.46, 276.4, 61.11, 1),
	            v4(175.15, 274.18, 66.41, 1),
	            v4(204.52, 279.32, 101.28, 1),
	            v4(224.66, 281.46, 142.44, 1),
	            v4(237.09, 284.58, 171.33, 1),
	            v4(239.63, 285.78, 185.68, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["334"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["334"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v46";
	Curves["335"] = function () {
	    var Curve_v01 = [[v4(-1.37, 5.15, -12.08, 1),
	            v4(-1.59, 5.46, -12.33, 1),
	            v4(-1.86, 6.44, -12.96, 1),
	            v4(-1.99, 8.32, -13.66, 1),
	            v4(-2.05, 11.73, -14.2, 1),
	            v4(-3.42, 22.35, -9.92, 1),
	            v4(-3.65, 56.61, 9.08, 1),
	            v4(-36.28, 72.13, 19.19, 1),
	            v4(-76.13, 86.87, 47.04, 1),
	            v4(-115.4, 87.41, 61.24, 1),
	            v4(-156.7, 115.93, 94.38, 1),
	            v4(-112.41, 152.58, 94.83, 1),
	            v4(-71.71, 163.76, 84.69, 1),
	            v4(-28.35, 182.61, 80.08, 1),
	            v4(14.73, 195.59, 72.91, 1),
	            v4(58.63, 210.17, 72.66, 1),
	            v4(103.23, 221.79, 80.99, 1),
	            v4(139.55, 229.9, 110.51, 1),
	            v4(160.32, 233.67, 152.24, 1),
	            v4(170.14, 237.81, 197.08, 1),
	            v4(171.12, 240.89, 227.83, 1),
	            v4(170.71, 242.65, 243.02, 1),
	        ], [v4(-0.37, 5.16, -12.08, 1),
	            v4(-0.19, 5.56, -12.39, 1),
	            v4(-0.06, 6.61, -13.03, 1),
	            v4(-0.07, 8.48, -13.7, 1),
	            v4(-0.1, 11.58, -14.21, 1),
	            v4(-1.75, 22.67, -7.74, 1),
	            v4(-3.19, 56.39, 11.64, 1),
	            v4(-36.73, 71.68, 20.86, 1),
	            v4(-76.96, 86.41, 48.72, 1),
	            v4(-115.69, 87.47, 62.99, 1),
	            v4(-158.79, 114.3, 95.97, 1),
	            v4(-116.01, 152.33, 97.78, 1),
	            v4(-74.5, 163.25, 87.12, 1),
	            v4(-31.4, 182.37, 82.72, 1),
	            v4(12, 195.3, 75.38, 1),
	            v4(55.9, 210, 75.07, 1),
	            v4(100.72, 221.66, 83.18, 1),
	            v4(136.69, 229.87, 112.36, 1),
	            v4(142.76, 233.64, 148.38, 1),
	            v4(130.32, 237.8, 184.61, 1),
	            v4(122.04, 240.89, 211.84, 1),
	            v4(120.38, 242.65, 226.58, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["335"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["335"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v47";
	Curves["336"] = function () {
	    var Curve_v01 = [[v4(-5, 11.03, -25.23, 1),
	            v4(-4.91, 11.35, -25.29, 1),
	            v4(-4.82, 12.08, -25.35, 1),
	            v4(-4.74, 13.47, -25.36, 1),
	            v4(-4.71, 15.45, -25.32, 1),
	            v4(-3.04, 31.02, -10.79, 1),
	            v4(-11.08, 92.36, 1.48, 1),
	            v4(4.73, 89.19, 100.73, 1),
	            v4(74.68, 171.25, 85.07, 1),
	            v4(-28.52, 191.89, 104.76, 1),
	            v4(-43.22, 198.2, 179.1, 1),
	            v4(-67.14, 211.55, 248.25, 1),
	            v4(-51.14, 217.68, 323.13, 1),
	            v4(-27.48, 226.52, 384.32, 1),
	            v4(13.89, 232.94, 428.04, 1),
	            v4(66.57, 240.19, 458.62, 1),
	            v4(132.58, 246.68, 482.12, 1),
	            v4(195.21, 253.5, 482.18, 1),
	            v4(240.29, 260.23, 448.92, 1),
	            v4(283.87, 267.12, 402.68, 1),
	            v4(293.89, 273.21, 354.74, 1),
	            v4(304.67, 275.85, 337.3, 1),
	        ], [v4(-6.31, 10.79, -23.82, 1),
	            v4(-6.39, 11.06, -23.74, 1),
	            v4(-6.48, 11.77, -23.64, 1),
	            v4(-6.55, 13.05, -23.56, 1),
	            v4(-6.56, 14.93, -23.54, 1),
	            v4(-3.02, 31.02, -9.56, 1),
	            v4(-13.81, 92.09, 3.81, 1),
	            v4(3.08, 89.38, 103.09, 1),
	            v4(72.47, 171.26, 87.53, 1),
	            v4(-30.55, 191.92, 107.23, 1),
	            v4(-45.29, 198.2, 181.61, 1),
	            v4(-69.17, 211.56, 250.73, 1),
	            v4(-53.16, 217.68, 325.63, 1),
	            v4(-27.27, 226.53, 393.2, 1),
	            v4(19.38, 232.94, 452.19, 1),
	            v4(77.18, 240.19, 497.57, 1),
	            v4(145.32, 246.68, 527.25, 1),
	            v4(219.21, 253.5, 537.34, 1),
	            v4(291.61, 260.23, 525.8, 1),
	            v4(361.69, 267.12, 494.24, 1),
	            v4(378.87, 273.21, 443.31, 1),
	            v4(389.34, 275.85, 422.46, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 21;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["336"].animation = [[6585.995, -1], [6586, 1], [7124, -1]];
	Curves["336"].divisions = "|MAEmodelsPrevis|ShootingStarsEnd_30000_300_2_242_256_256_1000_50_100_100_100_0|_61_1_v48";
	Curves.numCurves = 337;
	Curves["337"] = function () {
	    var Curve_v01 = [[v4(-33.72, 44.28, 14.41, 1),
	            v4(-33.29, 41.2, 14.41, 1),
	            v4(-31.58, 35.04, 14.41, 1),
	            v4(-29.85, 25.8, 14.41, 1),
	            v4(-29.85, 16.57, 14.41, 1),
	            v4(-31.58, 7.33, 14.41, 1),
	            v4(-33.29, 1.17, 14.41, 1),
	            v4(-33.72, -1.91, 14.41, 1),
	        ], [v4(0.94, 44.28, 16.28, 1),
	            v4(1.37, 41.2, 16.28, 1),
	            v4(3.08, 35.04, 16.28, 1),
	            v4(4.8, 25.8, 16.28, 1),
	            v4(4.8, 16.57, 16.28, 1),
	            v4(3.08, 7.33, 16.28, 1),
	            v4(1.37, 1.17, 16.28, 1),
	            v4(0.94, -1.91, 16.28, 1),
	        ], [v4(38.45, 44.28, 14.41, 1),
	            v4(38.89, 41.2, 14.41, 1),
	            v4(40.59, 35.04, 14.41, 1),
	            v4(42.32, 25.8, 14.41, 1),
	            v4(42.32, 16.57, 14.41, 1),
	            v4(40.59, 7.33, 14.41, 1),
	            v4(38.89, 1.17, 14.41, 1),
	            v4(38.45, -1.91, 14.41, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["337"].animation = [[2765, 1], [2920.995, -1], [3065.995, -1], [3205.995, -1], [3206, 1], [3333.995, -1], [3478.995, -1], [3619, -1]];
	Curves["337"].divisions = "|MAEmodelsPrevis|DustPlaneA_1000_1_1_124_202_247_40_0_100_100_5_20|_21_5_v313";
	Curves["338"] = function () {
	    var Curve_v01 = [[v4(-35.55, 63.45, 7, 1),
	            v4(-36.91, 60.37, 7, 1),
	            v4(-39.29, 54.21, 7, 1),
	            v4(-41.27, 44.98, 7, 1),
	            v4(-41.27, 35.74, 7, 1),
	            v4(-39.29, 26.5, 7, 1),
	            v4(-36.91, 20.34, 7, 1),
	            v4(-35.55, 17.27, 7, 1),
	        ], [v4(-0.89, 63.45, 8.86, 1),
	            v4(-2.25, 60.37, 8.86, 1),
	            v4(-4.63, 54.21, 8.86, 1),
	            v4(-6.61, 44.98, 8.86, 1),
	            v4(-6.61, 35.74, 8.86, 1),
	            v4(-4.63, 26.5, 8.86, 1),
	            v4(-2.25, 20.34, 8.86, 1),
	            v4(-0.89, 17.27, 8.86, 1),
	        ], [v4(36.62, 63.45, 7, 1),
	            v4(35.26, 60.37, 7, 1),
	            v4(32.88, 54.21, 7, 1),
	            v4(30.9, 44.98, 7, 1),
	            v4(30.9, 35.74, 7, 1),
	            v4(32.88, 26.5, 7, 1),
	            v4(35.26, 20.34, 7, 1),
	            v4(36.62, 17.27, 7, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["338"].animation = [[2765, 1], [2920.995, -1], [3065.995, -1], [3205.995, -1], [3206, 1], [3333.995, -1], [3478.995, -1], [3619, -1]];
	Curves["338"].divisions = "|MAEmodelsPrevis|DustPlaneA_1000_1_1_124_202_247_40_0_100_100_5_20|_21_5_v328";
	Curves.numCurves = 339;
	Curves["339"] = function () {
	    var Curve_v01 = [[v4(24.11, 79.91, 8.79, 1),
	            v4(23.55, 76.83, 8.79, 1),
	            v4(22.05, 70.67, 8.79, 1),
	            v4(19.82, 61.43, 11.51, 1),
	            v4(19.82, 52.2, 14.64, 1),
	            v4(22.05, 42.96, 14.69, 1),
	            v4(24.26, 36.8, 14.69, 1),
	            v4(24.82, 33.72, 14.69, 1),
	        ], [v4(2.11, 79.91, 10.6, 1),
	            v4(1.55, 76.83, 10.6, 1),
	            v4(0.06, 70.67, 10.6, 1),
	            v4(-2.18, 61.43, 13.32, 1),
	            v4(-2.18, 52.2, 16.45, 1),
	            v4(0.06, 42.96, 16.51, 1),
	            v4(2.26, 36.8, 16.51, 1),
	            v4(2.82, 33.72, 16.51, 1),
	        ], [v4(-19.88, 79.91, 8.79, 1),
	            v4(-20.45, 76.83, 8.79, 1),
	            v4(-21.94, 70.67, 8.79, 1),
	            v4(-24.17, 61.43, 11.51, 1),
	            v4(-24.17, 52.2, 14.64, 1),
	            v4(-21.94, 42.96, 14.69, 1),
	            v4(-19.73, 36.8, 14.69, 1),
	            v4(-19.17, 33.72, 14.69, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["339"].animation = [[3517, 1], [3662.415, -1], [3788.43, -1], [3932, -1], [3932.005, 1], [4058.015, -1]];
	Curves["339"].divisions = "|MAEmodelsPrevis|DustPlaneB_1000_1_1_124_202_247_60_50_100_100_4_20|_21_5_v314";
	Curves["340"] = function () {
	    var Curve_v01 = [[v4(22.5, 99.08, 2.56, 1),
	            v4(23.18, 96, 2.56, 1),
	            v4(26.92, 89.84, 3.05, 1),
	            v4(31.25, 80.61, 4.65, 1),
	            v4(31.43, 71.37, 6.49, 1),
	            v4(27.45, 62.13, 8.01, 1),
	            v4(23.85, 55.97, 8.46, 1),
	            v4(23.21, 52.89, 8.46, 1),
	        ], [v4(0.5, 99.08, 4.37, 1),
	            v4(1.18, 96, 4.37, 1),
	            v4(4.92, 89.84, 4.86, 1),
	            v4(9.25, 80.61, 6.46, 1),
	            v4(9.43, 71.37, 8.31, 1),
	            v4(5.45, 62.13, 9.83, 1),
	            v4(1.85, 55.97, 10.27, 1),
	            v4(1.21, 52.89, 10.27, 1),
	        ], [v4(-21.49, 99.08, 2.56, 1),
	            v4(-20.81, 96, 2.56, 1),
	            v4(-17.08, 89.84, 3.05, 1),
	            v4(-12.74, 80.61, 4.65, 1),
	            v4(-12.56, 71.37, 6.49, 1),
	            v4(-16.55, 62.13, 8.01, 1),
	            v4(-20.14, 55.97, 8.46, 1),
	            v4(-20.79, 52.89, 8.46, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["340"].animation = [[3517, 1], [3662.415, -1], [3788.43, -1], [3932, -1], [3932.005, 1], [4058.015, -1]];
	Curves["340"].divisions = "|MAEmodelsPrevis|DustPlaneB_1000_1_1_124_202_247_60_50_100_100_4_20|_21_5_v327";
	Curves.numCurves = 341;
	Curves["341"] = function () {
	    var Curve_v01 = [[v4(-18.3, 117.36, 14.84, 1),
	            v4(-17.96, 114.28, 14.84, 1),
	            v4(-16.72, 108.12, 14.84, 1),
	            v4(-15.47, 98.88, 14.76, 1),
	            v4(-15.47, 89.65, 11.57, 1),
	            v4(-16.72, 80.41, 8.93, 1),
	            v4(-17.96, 74.25, 8.93, 1),
	            v4(-18.3, 71.17, 8.93, 1),
	        ], [v4(0.79, 117.36, 16.62, 1),
	            v4(1.13, 114.28, 16.62, 1),
	            v4(2.37, 108.12, 16.62, 1),
	            v4(3.61, 98.88, 16.54, 1),
	            v4(3.61, 89.65, 13.35, 1),
	            v4(2.37, 80.41, 10.71, 1),
	            v4(1.13, 74.25, 10.71, 1),
	            v4(0.79, 71.17, 10.71, 1),
	        ], [v4(20.62, 117.36, 14.84, 1),
	            v4(20.96, 114.28, 14.84, 1),
	            v4(22.2, 108.12, 14.84, 1),
	            v4(23.45, 98.88, 14.76, 1),
	            v4(23.45, 89.65, 11.57, 1),
	            v4(22.2, 80.41, 8.93, 1),
	            v4(20.96, 74.25, 8.93, 1),
	            v4(20.62, 71.17, 8.93, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["341"].animation = [[3883, -1], [4013, -1], [4135, -1], [4135.005, 1], [4253, -1], [4375, -1]];
	Curves["341"].divisions = "|MAEmodelsPrevis|DustPlaneC_1000_1_1_124_247_237_180_200_1000_100_4_20|_21_5_v315";
	Curves.numCurves = 342;
	Curves["342"] = function () {
	    var Curve_v01 = [[v4(10.19, 152.99, 14.84, 1),
	            v4(9.66, 149.91, 14.84, 1),
	            v4(7.6, 143.75, 14.84, 1),
	            v4(5.52, 134.51, 14.84, 1),
	            v4(6.22, 125.28, 14.84, 1),
	            v4(9.17, 116.04, 14.84, 1),
	            v4(10.33, 109.88, 14.84, 1),
	            v4(10.85, 106.8, 14.84, 1),
	        ], [v4(1.37, 152.99, 16.69, 1),
	            v4(0.85, 149.91, 16.69, 1),
	            v4(-1.21, 143.75, 16.69, 1),
	            v4(-3.29, 134.51, 16.69, 1),
	            v4(-2.6, 125.28, 16.69, 1),
	            v4(0.35, 116.04, 16.69, 1),
	            v4(1.51, 109.88, 16.69, 1),
	            v4(2.04, 106.8, 16.69, 1),
	        ], [v4(-5.93, 152.99, 14.84, 1),
	            v4(-6.46, 149.91, 14.84, 1),
	            v4(-8.52, 143.75, 14.84, 1),
	            v4(-10.6, 134.51, 14.84, 1),
	            v4(-9.9, 125.28, 14.84, 1),
	            v4(-6.95, 116.04, 14.84, 1),
	            v4(-5.79, 109.88, 14.84, 1),
	            v4(-5.27, 106.8, 14.84, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["342"].animation = [[4267, -1], [4392.855, -1], [4392.91, 1], [4492.55, -1], [4603.755, -1], [4703.425, -1]];
	Curves["342"].divisions = "|MAEmodelsPrevis|DustPlaneD_2000_1_1_189_247_224_100_1000_400_100_3_20|_81_5_v1";
	Curves["343"] = function () {
	    var Curve_v01 = [[v4(8.07, 172.16, 8.61, 1),
	            v4(8.28, 169.08, 8.61, 1),
	            v4(11, 162.92, 8.61, 1),
	            v4(15.45, 153.69, 8.61, 1),
	            v4(15.38, 144.45, 8.61, 1),
	            v4(10.96, 135.21, 8.61, 1),
	            v4(8.45, 129.05, 8.61, 1),
	            v4(8.59, 125.98, 8.61, 1),
	        ], [v4(-0.74, 172.16, 10.46, 1),
	            v4(-0.54, 169.08, 10.46, 1),
	            v4(2.18, 162.92, 10.46, 1),
	            v4(6.63, 153.69, 10.46, 1),
	            v4(6.57, 144.45, 10.46, 1),
	            v4(2.14, 135.21, 10.46, 1),
	            v4(-0.37, 129.05, 10.46, 1),
	            v4(-0.22, 125.98, 10.46, 1),
	        ], [v4(-8.05, 172.16, 8.61, 1),
	            v4(-7.84, 169.08, 8.61, 1),
	            v4(-5.12, 162.92, 8.61, 1),
	            v4(-0.67, 153.69, 8.61, 1),
	            v4(-0.74, 144.45, 8.61, 1),
	            v4(-5.16, 135.21, 8.61, 1),
	            v4(-7.67, 129.05, 8.61, 1),
	            v4(-7.53, 125.98, 8.61, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["343"].animation = [[4267, -1], [4392.855, -1], [4392.91, 1], [4492.55, -1], [4603.755, -1], [4703.425, -1]];
	Curves["343"].divisions = "|MAEmodelsPrevis|DustPlaneD_2000_1_1_189_247_224_100_1000_400_100_3_20|_81_5_v2";
	Curves.numCurves = 344;
	Curves["344"] = function () {
	    var Curve_v01 = [[v4(-6.8, 193.97, 9.67, 1),
	            v4(-6.35, 190.89, 9.67, 1),
	            v4(-4.55, 184.73, 9.67, 1),
	            v4(-2.73, 175.5, 11.82, 1),
	            v4(-2.73, 166.26, 14.36, 1),
	            v4(-4.55, 157.02, 14.41, 1),
	            v4(-6.35, 150.87, 14.41, 1),
	            v4(-6.8, 147.79, 14.41, 1),
	        ], [v4(0.89, 193.97, 12.18, 1),
	            v4(1.34, 190.89, 12.18, 1),
	            v4(3.14, 184.73, 12.18, 1),
	            v4(4.96, 175.5, 14.33, 1),
	            v4(4.96, 166.26, 16.87, 1),
	            v4(3.14, 157.02, 16.92, 1),
	            v4(1.34, 150.87, 16.92, 1),
	            v4(0.89, 147.79, 16.92, 1),
	        ], [v4(9.14, 193.97, 9.67, 1),
	            v4(9.6, 190.89, 9.67, 1),
	            v4(11.39, 184.73, 9.67, 1),
	            v4(13.22, 175.5, 11.82, 1),
	            v4(13.22, 166.26, 14.36, 1),
	            v4(11.39, 157.02, 14.41, 1),
	            v4(9.6, 150.87, 14.41, 1),
	            v4(9.14, 147.79, 14.41, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["344"].animation = [[4648, 1], [4765.265, -1], [4858.155, -1], [4961.7, -1], [4961.73, 1], [5054.6, -1]];
	Curves["344"].divisions = "|MAEmodelsPrevis|DustPlaneE_4000_1_1_240_239_151_60_0_100_100_3_40|_61_5_v325";
	Curves["345"] = function () {
	    var Curve_v01 = [[v4(-7.99, 213.14, 3.44, 1),
	            v4(-7.81, 210.06, 3.44, 1),
	            v4(-11.28, 203.91, 3.84, 1),
	            v4(-16.48, 194.67, 5.12, 1),
	            v4(-16.4, 185.43, 6.6, 1),
	            v4(-11.14, 176.2, 7.82, 1),
	            v4(-7.7, 170.04, 8.18, 1),
	            v4(-7.95, 166.96, 8.18, 1),
	        ], [v4(-0.3, 213.14, 5.95, 1),
	            v4(-0.12, 210.06, 5.95, 1),
	            v4(-3.59, 203.91, 6.35, 1),
	            v4(-8.79, 194.67, 7.63, 1),
	            v4(-8.71, 185.43, 9.11, 1),
	            v4(-3.45, 176.2, 10.33, 1),
	            v4(-0.01, 170.04, 10.69, 1),
	            v4(-0.27, 166.96, 10.69, 1),
	        ], [v4(7.95, 213.14, 3.44, 1),
	            v4(8.13, 210.06, 3.44, 1),
	            v4(4.66, 203.91, 3.84, 1),
	            v4(-0.54, 194.67, 5.12, 1),
	            v4(-0.46, 185.43, 6.6, 1),
	            v4(4.8, 176.2, 7.82, 1),
	            v4(8.24, 170.04, 8.18, 1),
	            v4(7.99, 166.96, 8.18, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["345"].animation = [[4648, 1], [4765.265, -1], [4858.155, -1], [4961.7, -1], [4961.73, 1], [5054.6, -1]];
	Curves["345"].divisions = "|MAEmodelsPrevis|DustPlaneE_4000_1_1_240_239_151_60_0_100_100_3_40|_61_5_v326";
	Curves.numCurves = 346;
	Curves["346"] = function () {
	    var Curve_v01 = [[v4(11.51, 229.6, 14.12, 1),
	            v4(11.06, 226.52, 14.12, 1),
	            v4(9.3, 220.36, 14.12, 1),
	            v4(7.51, 211.13, 14.07, 1),
	            v4(7.51, 201.89, 11.54, 1),
	            v4(9.3, 192.65, 9.39, 1),
	            v4(11.06, 186.49, 9.39, 1),
	            v4(11.51, 183.42, 9.39, 1),
	        ], [v4(2.94, 229.6, 16.91, 1),
	            v4(2.49, 226.52, 16.91, 1),
	            v4(0.73, 220.36, 16.91, 1),
	            v4(-1.06, 211.13, 16.86, 1),
	            v4(-1.06, 201.89, 14.32, 1),
	            v4(0.73, 192.65, 12.18, 1),
	            v4(2.49, 186.49, 12.18, 1),
	            v4(2.94, 183.42, 12.18, 1),
	        ], [v4(-4.61, 229.6, 14.12, 1),
	            v4(-5.06, 226.52, 14.12, 1),
	            v4(-6.82, 220.36, 14.12, 1),
	            v4(-8.61, 211.13, 14.07, 1),
	            v4(-8.61, 201.89, 11.54, 1),
	            v4(-6.82, 192.65, 9.39, 1),
	            v4(-5.06, 186.49, 9.39, 1),
	            v4(-4.61, 183.42, 9.39, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["346"].animation = [[4906, -1], [5023.265, -1], [5116.155, -1], [5219.7, -1], [5219.73, 1], [5314, -1]];
	Curves["346"].divisions = "|MAEmodelsPrevis|DustPlaneF_1000_1_1_240_239_196_35_300_500_100_2_20|_41_5_v312";
	Curves["347"] = function () {
	    var Curve_v01 = [[v4(6.07, 248.77, 3.15, 1),
	            v4(5.62, 245.69, 3.15, 1),
	            v4(8.47, 239.54, 4.02, 1),
	            v4(12.25, 230.3, 6.03, 1),
	            v4(12.34, 221.06, 4.84, 1),
	            v4(8.64, 211.83, 3.56, 1),
	            v4(5.74, 205.67, 3.16, 1),
	            v4(6.11, 202.59, 3.16, 1),
	        ], [v4(1.19, 248.77, 5.94, 1),
	            v4(0.74, 245.69, 5.94, 1),
	            v4(3.59, 239.54, 6.81, 1),
	            v4(7.37, 230.3, 8.82, 1),
	            v4(7.46, 221.06, 7.62, 1),
	            v4(3.76, 211.83, 6.34, 1),
	            v4(0.86, 205.67, 5.95, 1),
	            v4(1.23, 202.59, 5.95, 1),
	        ], [v4(0.62, 248.77, 3.15, 1),
	            v4(0.16, 245.69, 3.15, 1),
	            v4(3.01, 239.54, 4.02, 1),
	            v4(6.8, 230.3, 6.03, 1),
	            v4(6.89, 221.06, 4.84, 1),
	            v4(3.19, 211.83, 3.56, 1),
	            v4(0.29, 205.67, 3.16, 1),
	            v4(0.66, 202.59, 3.16, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["347"].animation = [[4906, -1], [5023.265, -1], [5116.155, -1], [5219.7, -1], [5219.73, 1], [5314, -1]];
	Curves["347"].divisions = "|MAEmodelsPrevis|DustPlaneF_1000_1_1_240_239_196_35_300_500_100_2_20|_41_5_v313";
	Curves.numCurves = 348;
	Curves["348"] = function () {
	    var Curve_v01 = [[v4(-19.91, 273.51, 7.19, 1),
	            v4(-18.11, 270.84, 7.19, 1),
	            v4(-12.88, 266.05, 7.74, 1),
	            v4(-11.47, 257.99, 8.18, 1),
	            v4(-8.18, 249.05, 7.89, 1),
	            v4(-6.08, 238.68, 11.12, 1),
	            v4(-5.09, 232.05, 13.57, 1),
	            v4(-3.64, 229.04, 13.96, 1),
	        ], [v4(5.97, 272.88, 14.64, 1),
	            v4(5.86, 269.82, 14.49, 1),
	            v4(5.45, 263.97, 14.3, 1),
	            v4(4.58, 255.87, 13.37, 1),
	            v4(4.37, 246.73, 12.65, 1),
	            v4(4.9, 236.91, 14.92, 1),
	            v4(4.2, 230.89, 16.4, 1),
	            v4(3.71, 228.01, 16.53, 1),
	        ], [v4(22.53, 272.88, 9.2, 1),
	            v4(22.01, 269.82, 9.2, 1),
	            v4(20.1, 263.97, 9.19, 1),
	            v4(18.61, 255.87, 8.44, 1),
	            v4(15.87, 246.9, 7.89, 1),
	            v4(14.99, 237.02, 11.12, 1),
	            v4(11.68, 230.89, 13.57, 1),
	            v4(9.42, 228.01, 13.96, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["348"].animation = [[5304, -1], [5405.985, -1], [5514.155, -1], [5514.18, 1], [5617.7, -1], [5712, -1]];
	Curves["348"].divisions = "|MAEmodelsPrevis|DustPlaneG_3000_1_1_240_239_196_160_0_100_100_2_10|_21_5_v319";
	Curves["349"] = function () {
	    var Curve_v01 = [[v4(-21.6, 292.68, -5.65, 1),
	            v4(-19.8, 290.02, -5.65, 1),
	            v4(-16.89, 284.51, -4.59, 1),
	            v4(-13.88, 275.76, -1.19, 1),
	            v4(-11.53, 266.64, 0.44, 1),
	            v4(-9.07, 257.36, 1.84, 1),
	            v4(-6.79, 251.22, 2.75, 1),
	            v4(-5.33, 248.21, 3.15, 1),
	        ], [v4(4.28, 292.05, 1.79, 1),
	            v4(4.16, 289, 1.65, 1),
	            v4(4.02, 282.92, 1.35, 1),
	            v4(3.9, 273.87, 2.79, 1),
	            v4(3.7, 264.86, 5, 1),
	            v4(3.2, 255.92, 5.33, 1),
	            v4(2.51, 250.07, 5.59, 1),
	            v4(2.02, 247.18, 5.71, 1),
	        ], [v4(20.84, 292.05, -5.42, 1),
	            v4(20.31, 289, -5.65, 1),
	            v4(19.49, 282.92, -5.49, 1),
	            v4(18.34, 273.87, -3, 1),
	            v4(16.59, 264.86, 0.38, 1),
	            v4(13.5, 255.93, 1.84, 1),
	            v4(9.99, 250.07, 2.75, 1),
	            v4(7.72, 247.18, 3.15, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["349"].animation = [[5304, -1], [5405.985, -1], [5514.155, -1], [5514.18, 1], [5617.7, -1], [5712, -1]];
	Curves["349"].divisions = "|MAEmodelsPrevis|DustPlaneG_3000_1_1_240_239_196_160_0_100_100_2_10|_21_5_v322";
	Curves.numCurves = 350;
	Curves["350"] = function () {
	    var Curve_v01 = [[v4(6.78, 315.13, -4.5, 1),
	            v4(7.68, 316.94, -4.52, 1),
	            v4(10.15, 318.88, -4.54, 1),
	            v4(14.03, 319.77, -4.55, 1),
	            v4(17.96, 319.66, -4.54, 1),
	            v4(21.86, 318.94, -4.5, 1),
	            v4(25.72, 317.79, -4.42, 1),
	            v4(29.55, 316.19, -4.31, 1),
	            v4(33.28, 314.05, -4.15, 1),
	            v4(36.93, 311.33, -3.95, 1),
	            v4(40.3, 307.67, -3.71, 1),
	            v4(43.24, 302.7, -3.42, 1),
	            v4(44.55, 295.52, -3.1, 1),
	            v4(43.37, 288.32, -2.97, 1),
	            v4(40.05, 281.86, -3.01, 1),
	            v4(35.12, 273.52, -3.18, 1),
	            v4(28.8, 257.86, -3.37, 1),
	            v4(21.65, 237.41, -2.04, 1),
	            v4(15.58, 222.31, 0.35, 1),
	            v4(13.4, 213.13, 1.48, 1),
	            v4(13.25, 204.97, 1.16, 1),
	            v4(12.86, 200.39, 0.49, 1),
	            v4(12.65, 198.31, 0.21, 1),
	        ], [v4(0.38, 315.13, 2.33, 1),
	            v4(0.4, 316.64, 2.72, 1),
	            v4(0.44, 319.13, 3.66, 1),
	            v4(0.51, 320, 5.47, 1),
	            v4(0.55, 318.92, 7.07, 1),
	            v4(0.55, 316.96, 8.46, 1),
	            v4(0.51, 314.21, 9.7, 1),
	            v4(0.45, 310.67, 10.96, 1),
	            v4(0.36, 306.09, 12.33, 1),
	            v4(0.24, 300.27, 13.86, 1),
	            v4(0.11, 293.64, 14.84, 1),
	            v4(0.03, 287.35, 14.9, 1),
	            v4(0, 280.36, 14.7, 1),
	            v4(-0.01, 272.54, 14.48, 1),
	            v4(0, 263.06, 14.7, 1),
	            v4(0, 251.5, 15.22, 1),
	            v4(0, 238.69, 15.38, 1),
	            v4(0, 226.84, 14.73, 1),
	            v4(0, 217.8, 13.83, 1),
	            v4(0, 210.07, 13.55, 1),
	            v4(0, 202.38, 13.3, 1),
	            v4(0, 197.94, 12.74, 1),
	            v4(0, 195.86, 12.39, 1),
	        ], [v4(-7.25, 315.13, -3.12, 1),
	            v4(-8.15, 316.95, -3.06, 1),
	            v4(-10.63, 318.89, -2.95, 1),
	            v4(-14.52, 319.77, -2.82, 1),
	            v4(-18.46, 319.65, -2.71, 1),
	            v4(-22.36, 318.94, -2.63, 1),
	            v4(-26.24, 317.77, -2.57, 1),
	            v4(-30.07, 316.16, -2.54, 1),
	            v4(-33.82, 314.02, -2.54, 1),
	            v4(-37.48, 311.28, -2.57, 1),
	            v4(-40.85, 307.59, -2.65, 1),
	            v4(-43.79, 302.56, -2.79, 1),
	            v4(-45.05, 295.32, -3.05, 1),
	            v4(-43.86, 288.15, -3.3, 1),
	            v4(-42, 281.77, -3.48, 1),
	            v4(-39.23, 274.8, -3.59, 1),
	            v4(-34.94, 266.3, -3.67, 1),
	            v4(-28.82, 250.48, -3.14, 1),
	            v4(-21.66, 228.74, -1.23, 1),
	            v4(-16.32, 213.67, 0.41, 1),
	            v4(-14.11, 205.15, 0.66, 1),
	            v4(-13.72, 200.47, 0.24, 1),
	            v4(-13.51, 198.41, -0.01, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["350"].animation = [[5638, -1], [5721.78, -1], [5721.8, 1], [5810.67, -1], [5892.995, -1], [5893, 1], [5954, -1], [6043.995, -1], [6044, 1], [6110, -1], [6156, -1], [6156.005, 1], [6209, -1], [6240, -1], [6240.005, 1], [6293, -1], [6308, -1], [6308.005, 1], [6341, -1], [6357, -1], [6357.005, 1], [6390, -1], [6394, -1], [6394.005, 1], [6425, -1], [6607, -1], [6643, -1], [6651, -1], [6687, -1], [6693, -1], [6714, -1]];
	Curves["350"].divisions = "|MAEmodelsPrevis|DustPlaneH_4000_1_1_240_239_196_80_100_100_100_1_10|_41_9_v1";
	Curves["351"] = function () {
	    var Curve_v01 = [[v4(6.78, 315.13, -8.39, 1),
	            v4(7.68, 316.94, -8.41, 1),
	            v4(10.15, 318.88, -8.43, 1),
	            v4(14.03, 319.77, -8.44, 1),
	            v4(17.96, 319.66, -8.43, 1),
	            v4(21.86, 318.94, -8.39, 1),
	            v4(25.72, 317.79, -8.31, 1),
	            v4(29.55, 316.19, -8.2, 1),
	            v4(33.28, 314.05, -8.04, 1),
	            v4(36.93, 311.33, -7.84, 1),
	            v4(40.3, 307.67, -7.6, 1),
	            v4(43.24, 302.7, -7.31, 1),
	            v4(44.55, 295.52, -6.99, 1),
	            v4(43.37, 288.32, -6.86, 1),
	            v4(40.05, 281.86, -6.9, 1),
	            v4(35.12, 273.52, -7.07, 1),
	            v4(28.8, 257.86, -7.26, 1),
	            v4(21.65, 237.41, -5.93, 1),
	            v4(15.58, 222.31, -3.54, 1),
	            v4(13.4, 213.13, -2.41, 1),
	            v4(13.25, 204.97, -2.73, 1),
	            v4(12.86, 200.39, -3.4, 1),
	            v4(12.65, 198.31, -3.68, 1),
	        ], [v4(0.38, 315.13, -1.56, 1),
	            v4(0.4, 316.64, -1.17, 1),
	            v4(0.44, 319.13, -0.23, 1),
	            v4(0.51, 320, 1.58, 1),
	            v4(0.55, 318.92, 3.18, 1),
	            v4(0.55, 316.96, 4.57, 1),
	            v4(0.51, 314.21, 5.81, 1),
	            v4(0.45, 310.67, 7.07, 1),
	            v4(0.36, 306.09, 8.44, 1),
	            v4(0.24, 300.27, 9.98, 1),
	            v4(0.11, 293.64, 10.95, 1),
	            v4(0.03, 287.35, 11.01, 1),
	            v4(0, 280.36, 10.81, 1),
	            v4(-0.01, 272.54, 10.6, 1),
	            v4(0, 263.06, 10.81, 1),
	            v4(0, 251.5, 11.33, 1),
	            v4(0, 238.69, 11.49, 1),
	            v4(0, 226.84, 10.84, 1),
	            v4(0, 217.8, 9.94, 1),
	            v4(0, 210.07, 9.67, 1),
	            v4(0, 202.38, 9.41, 1),
	            v4(0, 197.94, 8.85, 1),
	            v4(0, 195.86, 8.5, 1),
	        ], [v4(-7.25, 315.13, -7.01, 1),
	            v4(-8.15, 316.95, -6.95, 1),
	            v4(-10.63, 318.89, -6.84, 1),
	            v4(-14.52, 319.77, -6.71, 1),
	            v4(-18.46, 319.65, -6.6, 1),
	            v4(-22.36, 318.94, -6.52, 1),
	            v4(-26.24, 317.77, -6.46, 1),
	            v4(-30.07, 316.16, -6.43, 1),
	            v4(-33.82, 314.02, -6.43, 1),
	            v4(-37.48, 311.28, -6.46, 1),
	            v4(-40.85, 307.59, -6.53, 1),
	            v4(-43.79, 302.56, -6.68, 1),
	            v4(-45.05, 295.32, -6.93, 1),
	            v4(-43.86, 288.15, -7.19, 1),
	            v4(-42, 281.77, -7.36, 1),
	            v4(-39.23, 274.8, -7.47, 1),
	            v4(-34.94, 266.3, -7.56, 1),
	            v4(-28.82, 250.48, -7.03, 1),
	            v4(-21.66, 228.74, -5.11, 1),
	            v4(-16.32, 213.67, -3.48, 1),
	            v4(-14.11, 205.15, -3.23, 1),
	            v4(-13.72, 200.47, -3.65, 1),
	            v4(-13.51, 198.41, -3.89, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["351"].animation = [[5638, -1], [5721.78, -1], [5721.8, 1], [5810.67, -1], [5892.995, -1], [5893, 1], [5954, -1], [6043.995, -1], [6044, 1], [6110, -1], [6156, -1], [6156.005, 1], [6209, -1], [6240, -1], [6240.005, 1], [6293, -1], [6308, -1], [6308.005, 1], [6341, -1], [6357, -1], [6357.005, 1], [6390, -1], [6394, -1], [6394.005, 1], [6425, -1], [6607, -1], [6643, -1], [6651, -1], [6687, -1], [6693, -1], [6714, -1]];
	Curves["351"].divisions = "|MAEmodelsPrevis|DustPlaneH_4000_1_1_240_239_196_80_100_100_100_1_10|_41_9_v8";
	Curves.numCurves = 352;
	Curves["352"] = function () {
	    var Curve_v01 = [[v4(0.04, 0.28, -13.51, 1),
	            v4(-4.41, 0, -0.85, 1),
	            v4(-4.39, -6.57, 19.33, 1),
	            v4(36.39, -45.3, 48.96, 1),
	        ], [v4(0.26, 0.52, -13.52, 1),
	            v4(-3.36, 5.8, -0.86, 1),
	            v4(-12.57, 4.57, 15.35, 1),
	            v4(-71.83, -16.86, 37.26, 1),
	        ], [v4(0.41, 0.35, -13.49, 1),
	            v4(2.96, 1.39, -2.13, 1),
	            v4(4.11, 9.29, 10.16, 1),
	            v4(3, 80.79, 29.49, 1),
	        ], [v4(0.47, 0.17, -13.46, 1),
	            v4(0.84, -1.27, -2.05, 1),
	            v4(4.53, -1.57, 11.27, 1),
	            v4(59.77, 6.87, 44.05, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["352"].animation = [[2393, 1], [2431, -1]];
	Curves["352"].divisions = "|MAEmodelsPrevis|tunnelBurstAExplosion_300_3_1_124_202_247_3000_100_100_100_2_10|_10_10_v3";
	Curves["353"] = function () {
	    var Curve_v01 = [[v4(-3.71, 3.9, -14.64, 1),
	            v4(2.03, 6.71, -2.84, 1),
	            v4(2.08, 12.88, 17.45, 1),
	            v4(-47.03, 26.47, 55.46, 1),
	        ], [v4(-3.78, 3.58, -14.64, 1),
	            v4(4.05, 1.17, -3.05, 1),
	            v4(13.95, 7.3, 11.56, 1),
	            v4(57.16, 56.27, 25.21, 1),
	        ], [v4(-3.99, 3.65, -14.57, 1),
	            v4(-3.74, 1.76, -3.04, 1),
	            v4(1.29, -5.33, 8.76, 1),
	            v4(41.32, -65.97, 23.18, 1),
	        ], [v4(-4.13, 3.77, -14.52, 1),
	            v4(-3.27, 5.12, -3.12, 1),
	            v4(-4.32, 3.86, 10.59, 1),
	            v4(-41.53, -30.47, 51.03, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["353"].animation = [[2393, 1], [2431, -1]];
	Curves["353"].divisions = "|MAEmodelsPrevis|tunnelBurstAExplosion_300_3_1_124_202_247_3000_100_100_100_2_10|_10_10_v4";
	Curves.numCurves = 354;
	Curves["354"] = function () {
	    var Curve_v01 = [[v4(6.76, 36.71, -11.8, 1),
	            v4(4.26, 41.73, -6.52, 1),
	            v4(-3.94, 46.48, 1.13, 1),
	            v4(-37.21, 34.26, 9.75, 1),
	        ], [v4(6.84, 36.57, -11.71, 1),
	            v4(6.91, 40.71, -4.69, 1),
	            v4(3.89, 49.07, 1.31, 1),
	            v4(-1.77, 86.68, -3.04, 1),
	        ], [v4(6.72, 36.51, -11.72, 1),
	            v4(3.98, 37.46, -5.67, 1),
	            v4(4.6, 38.79, 2.61, 1),
	            v4(34.92, 37.66, 32.38, 1),
	        ], [v4(6.62, 36.5, -11.75, 1),
	            v4(3.03, 38.81, -6.71, 1),
	            v4(-1.04, 39.68, 0.04, 1),
	            v4(-14.56, 16.68, 25.93, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["354"].animation = [[3304, 1], [3380, -1]];
	Curves["354"].divisions = "|MAEmodelsPrevis|tunnelBurstBexpToRib_250_300_2_124_247_237_75_100_100_100_2_10|_10_10_v5";
	Curves["355"] = function () {
	    var Curve_v01 = [[v4(9.45, 38.17, -11.82, 1),
	            v4(6.92, 37.38, -4.6, 1),
	            v4(4.9, 41.1, 6.82, 1),
	            v4(10.61, 73.9, 21.72, 1),
	        ], [v4(9.31, 38.23, -11.92, 1),
	            v4(3.92, 36.71, -6.01, 1),
	            v4(1.59, 34.05, 4.11, 1),
	            v4(14.67, 10.14, 30.99, 1),
	        ], [v4(9.36, 38.35, -11.9, 1),
	            v4(5.55, 40.78, -6.96, 1),
	            v4(-1.7, 41.16, -2.7, 1),
	            v4(-41.77, 27.92, -7.75, 1),
	        ], [v4(9.43, 38.42, -11.86, 1),
	            v4(7.13, 40.24, -5.95, 1),
	            v4(3.3, 43.77, 0.03, 1),
	            v4(-17.04, 74.65, 3.87, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["355"].animation = [[3304, 1], [3380, -1]];
	Curves["355"].divisions = "|MAEmodelsPrevis|tunnelBurstBexpToRib_250_300_2_124_247_237_75_100_100_100_2_10|_10_10_v6";
	Curves.numCurves = 356;
	Curves["356"] = function () {
	    var Curve_v01 = [[v4(-3.76, 120.77, -6.27, 1),
	            v4(-3.14, 119.19, 1.67, 1),
	            v4(3.17, 117.78, 12.76, 1),
	            v4(40.23, 124.39, 20.65, 1),
	        ], [v4(-3.8, 120.96, -6.29, 1),
	            v4(-5.51, 121.83, 2.08, 1),
	            v4(-5.53, 117.8, 12.64, 1),
	            v4(-12.55, 82.75, 31.4, 1),
	        ], [v4(-3.66, 120.97, -6.31, 1),
	            v4(-1.44, 123.14, 0.05, 1),
	            v4(-2.79, 127.23, 7.8, 1),
	            v4(-33.63, 154.1, 26.13, 1),
	        ], [v4(-3.55, 120.94, -6.32, 1),
	            v4(-0.92, 121.16, 0.13, 1),
	            v4(2.63, 123.47, 7.34, 1),
	            v4(23.08, 154.56, 19.66, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["356"].animation = [[4261, 1], [4327, -1]];
	Curves["356"].divisions = "|MAEmodelsPrevis|tunnelBurstCribToGal_0_50_1_189_247_224_200_100_100_100_1_10|_10_10_v9";
	Curves["357"] = function () {
	    var Curve_v01 = [[v4(-6.94, 120.26, -6.07, 1),
	            v4(-4.38, 124.63, 0.28, 1),
	            v4(-4.01, 127.96, 12.67, 1),
	            v4(-21.36, 111.5, 42.79, 1),
	        ], [v4(-6.81, 120.11, -6.09, 1),
	            v4(-1.11, 123.54, -0.66, 1),
	            v4(1.78, 131.26, 7.08, 1),
	            v4(-4.01, 170.62, 13.86, 1),
	        ], [v4(-6.91, 120.04, -6.02, 1),
	            v4(-4.09, 120.04, 0.47, 1),
	            v4(2.87, 120.42, 5.95, 1),
	            v4(47.51, 117.8, 2.99, 1),
	        ], [v4(-7.01, 120.03, -5.96, 1),
	            v4(-5.52, 121.51, 0.68, 1),
	            v4(-3.1, 121.23, 8.68, 1),
	            v4(6.56, 92.85, 33.94, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["357"].animation = [[4261, 1], [4327, -1]];
	Curves["357"].divisions = "|MAEmodelsPrevis|tunnelBurstCribToGal_0_50_1_189_247_224_200_100_100_100_1_10|_10_10_v10";
	Curves.numCurves = 358;
	Curves["358"] = function () {
	    var Curve_v01 = [[v4(20.33, 273.33, -362.78, 1),
	            v4(-17.57, 260.95, -313.73, 1),
	            v4(-101.05, 133.58, -81.85, 1),
	            v4(198.24, -312.77, 228.48, 1),
	        ], [v4(21.32, 274.41, -362.31, 1),
	            v4(-13.34, 287.48, -306.66, 1),
	            v4(-167.51, 251.36, -119.42, 1),
	            v4(-779.61, 29.63, -135.96, 1),
	        ], [v4(21.98, 273.56, -362.11, 1),
	            v4(17.2, 266.99, -307.68, 1),
	            v4(2.21, 299.38, -108.53, 1),
	            v4(-77.75, 944.55, 208.1, 1),
	        ], [v4(22.22, 272.71, -362.07, 1),
	            v4(7.82, 255.11, -312.85, 1),
	            v4(4.73, 193.3, -119.11, 1),
	            v4(420.96, 184.84, 357.02, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["358"].animation = [[5439, 1], [5505, -1]];
	Curves["358"].divisions = "|MAEmodelsPrevis|tunnelBurstDgalToFlowerLIVE_0_30_1_240_239_196_200_100_100_100_2_10|_10_10_v1";
	Curves["359"] = function () {
	    var Curve_v01 = [[v4(4.78, 291.91, -369.53, 1),
	            v4(13.59, 292.39, -306.94, 1),
	            v4(-38.78, 320.16, -40.87, 1),
	            v4(-610.06, 396.58, 189.14, 1),
	        ], [v4(4.5, 290.45, -369.93, 1),
	            v4(23.42, 266.64, -310.39, 1),
	            v4(90.01, 273.31, -71.14, 1),
	            v4(443.22, 694.96, 277.54, 1),
	        ], [v4(3.45, 290.75, -369.85, 1),
	            v4(-11.61, 271.01, -320.74, 1),
	            v4(-17.3, 163.76, -158.94, 1),
	            v4(323.65, -461.41, -33.25, 1),
	        ], [v4(2.77, 291.31, -369.71, 1),
	            v4(-9.66, 286.48, -317.15, 1),
	            v4(-76.58, 250.37, -140.1, 1),
	            v4(-535.63, -140.9, 50.18, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["359"].animation = [[5439, 1], [5505, -1]];
	Curves["359"].divisions = "|MAEmodelsPrevis|tunnelBurstDgalToFlowerLIVE_0_30_1_240_239_196_200_100_100_100_2_10|_10_10_v2";
	Curves.numCurves = 360;
	Curves["360"] = function () {
	    var Curve_v01 = [[v4(-1.02, 285.44, -0.43, 1),
	            v4(-0.66, 274.69, 2.16, 1),
	            v4(3.28, 261.03, 12.33, 1),
	            v4(23.56, 260.44, 60.62, 1),
	        ], [v4(-1.26, 285.53, -0.34, 1),
	            v4(-5.49, 274.81, 1.63, 1),
	            v4(-3.59, 259.57, 2.78, 1),
	            v4(24.55, 219.82, -22.7, 1),
	        ], [v4(-1.16, 285.58, -0.19, 1),
	            v4(-3.24, 278.71, 6.23, 1),
	            v4(-10.53, 270.17, 10.66, 1),
	            v4(-68.28, 251.9, 3.17, 1),
	        ], [v4(-1.03, 285.6, -0.1, 1),
	            v4(-0.68, 277.89, 5.42, 1),
	            v4(-2.07, 270.23, 13.72, 1),
	            v4(-22.49, 270.89, 63.04, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["360"].animation = [[5804, 1], [5880, -1]];
	Curves["360"].divisions = "|MAEmodelsPrevis|tunnelBurstEflower_500_100_1_256_256_256_60_100_100_100_2_10|_10_10_v7";
	Curves["361"] = function () {
	    var Curve_v01 = [[v4(-3.04, 284.38, -4.2, 1),
	            v4(-7.22, 278.48, 4.17, 1),
	            v4(-13.41, 263.98, 11.71, 1),
	            v4(-16.24, 215.31, -7.42, 1),
	        ], [v4(-2.77, 284.37, -4.17, 1),
	            v4(-3.24, 279.84, 6.6, 1),
	            v4(-11.12, 273.59, 18.26, 1),
	            v4(-59.97, 279.91, 42.64, 1),
	        ], [v4(-2.78, 284.23, -4.3, 1),
	            v4(-2.06, 276.41, 1.28, 1),
	            v4(1.76, 270.8, 11.27, 1),
	            v4(40.55, 281.8, 57.09, 1),
	        ], [v4(-2.86, 284.13, -4.39, 1),
	            v4(-4.83, 276.47, 0.85, 1),
	            v4(-4.47, 266.52, 6.37, 1),
	            v4(28.09, 224.22, 6.39, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["361"].animation = [[5804, 1], [5880, -1]];
	Curves["361"].divisions = "|MAEmodelsPrevis|tunnelBurstEflower_500_100_1_256_256_256_60_100_100_100_2_10|_10_10_v8";
	Curves.numCurves = 362;
	Curves["362"] = function () {
	    var Curve_v01 = [[v4(11.9, 302.14, 10.58, 1),
	            v4(8.26, 291.76, 11.75, 1),
	            v4(3.1, 277.78, 20.9, 1),
	            v4(-4.18, 272.82, 72.53, 1),
	        ], [v4(11.69, 302.29, 10.55, 1),
	            v4(4.53, 293.17, 8.97, 1),
	            v4(1.78, 278.03, 9.13, 1),
	            v4(28.02, 231.54, -3.97, 1),
	        ], [v4(11.7, 302.32, 10.74, 1),
	            v4(5.09, 296.42, 14.5, 1),
	            v4(-5.29, 290.29, 13.82, 1),
	            v4(-54.12, 288.25, -22.74, 1),
	        ], [v4(11.77, 302.3, 10.88, 1),
	            v4(7.41, 294.92, 14.94, 1),
	            v4(0.24, 288.12, 20.58, 1),
	            v4(-41.1, 295.45, 53.55, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["362"].animation = [[5997, 1], [6073, -1]];
	Curves["362"].divisions = "|MAEmodelsPrevis|tunnelBurstFend_500_500_3_240_239_196_110_70_100_100_2_10|_10_10_v11";
	Curves["363"] = function () {
	    var Curve_v01 = [[v4(11.84, 301.58, 6.21, 1),
	            v4(2.74, 297.24, 10.76, 1),
	            v4(-9.74, 285.15, 12.63, 1),
	            v4(-14.61, 238.65, -10.98, 1),
	        ], [v4(12.05, 301.5, 6.36, 1),
	            v4(5.18, 297.52, 14.95, 1),
	            v4(-8.71, 293.92, 20.52, 1),
	            v4(-59.91, 313.86, 18.77, 1),
	        ], [v4(12.06, 301.36, 6.23, 1),
	            v4(7.96, 293.78, 10.51, 1),
	            v4(4.78, 287.57, 20.37, 1),
	            v4(16.98, 288.66, 80.16, 1),
	        ], [v4(12.02, 301.28, 6.1, 1),
	            v4(5.88, 294.57, 8.8, 1),
	            v4(0.98, 285.04, 12.62, 1),
	            v4(17.6, 235.48, 23.48, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["363"].animation = [[5997, 1], [6073, -1]];
	Curves["363"].divisions = "|MAEmodelsPrevis|tunnelBurstFend_500_500_3_240_239_196_110_70_100_100_2_10|_10_10_v12";
	Curves.numCurves = 364;
	Curves["364"] = function () {
	    var Curve_v01 = [[v4(1.45, 309.36, 4.82, 1),
	            v4(1.02, 298.74, 7.88, 1),
	            v4(6.02, 284.76, 17.09, 1),
	            v4(41.06, 281.44, 55.89, 1),
	        ], [v4(1.27, 309.49, 4.97, 1),
	            v4(-3.63, 299.66, 8.97, 1),
	            v4(-3.8, 284.33, 10.48, 1),
	            v4(7.66, 240.09, -20.06, 1),
	        ], [v4(1.43, 309.53, 5.08, 1),
	            v4(0.61, 303.19, 12.28, 1),
	            v4(-5.97, 296.05, 19.45, 1),
	            v4(-64.94, 287.58, 32.76, 1),
	        ], [v4(1.58, 309.53, 5.12, 1),
	            v4(2.58, 301.94, 10.73, 1),
	            v4(2.93, 294.73, 19.53, 1),
	            v4(0.7, 299.47, 72.66, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["364"].animation = [[6129, 1], [6205, -1]];
	Curves["364"].divisions = "|MAEmodelsPrevis|tunnelBurstGend_500_400_2_240_239_196_170_80_100_100_2_10|_10_10_v13";
	Curves["365"] = function () {
	    var Curve_v01 = [[v4(-1.85, 308.6, 2.01, 1),
	            v4(-3.82, 303.6, 11.68, 1),
	            v4(-9.24, 290.44, 21.83, 1),
	            v4(-25.75, 242.67, 8.11, 1),
	        ], [v4(-1.6, 308.55, 1.95, 1),
	            v4(0.91, 304.31, 12.55, 1),
	            v4(-3.43, 299.62, 26.56, 1),
	            v4(-39.62, 314.35, 65.23, 1),
	        ], [v4(-1.68, 308.41, 1.84, 1),
	            v4(-0.32, 300.66, 7.39, 1),
	            v4(5.74, 294.62, 15.92, 1),
	            v4(58.91, 299.62, 45.47, 1),
	        ], [v4(-1.79, 308.32, 1.78, 1),
	            v4(-3.02, 301.17, 7.9, 1),
	            v4(-2.34, 291.38, 13.67, 1),
	            v4(21.44, 244.24, 5.84, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["365"].animation = [[6129, 1], [6205, -1]];
	Curves["365"].divisions = "|MAEmodelsPrevis|tunnelBurstGend_500_400_2_240_239_196_170_80_100_100_2_10|_10_10_v14";
	Curves.numCurves = 366;
	Curves["366"] = function () {
	    var Curve_v01 = [[v4(5.27, 319.71, 7.95, 1),
	            v4(-1.08, 311.45, 11.65, 1),
	            v4(-7.45, 295.17, 11.54, 1),
	            v4(6.34, 254.42, -18.34, 1),
	        ], [v4(5.5, 319.7, 8.09, 1),
	            v4(1.17, 312.14, 15.89, 1),
	            v4(-9.82, 302.44, 20.59, 1),
	            v4(-64.72, 299.64, 20.38, 1),
	        ], [v4(5.56, 319.6, 7.94, 1),
	            v4(5.08, 310.5, 11.05, 1),
	            v4(5.08, 302.27, 19.89, 1),
	            v4(17.84, 300.21, 79.53, 1),
	        ], [v4(5.56, 319.54, 7.81, 1),
	            v4(2.8, 310.6, 9.42, 1),
	            v4(2.37, 299.47, 11.77, 1),
	            v4(38.2, 260.14, 16.12, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["366"].animation = [[6232, 1], [6308, -1]];
	Curves["366"].divisions = "|MAEmodelsPrevis|tunnelBurstHend_500_200_1_240_239_196_240_90_100_100_2_10|_10_10_v15";
	Curves["367"] = function () {
	    var Curve_v01 = [[v4(3.64, 322.28, 11.14, 1),
	            v4(5.9, 312.21, 15.11, 1),
	            v4(2.76, 297.99, 24.78, 1),
	            v4(-39.43, 286.08, 53.45, 1),
	        ], [v4(3.51, 322.25, 10.91, 1),
	            v4(6.06, 310.84, 10.46, 1),
	            v4(11.61, 298.01, 16.91, 1),
	            v4(53.16, 283.45, 49.81, 1),
	        ], [v4(3.36, 322.27, 11.01, 1),
	            v4(0.37, 313.21, 12.33, 1),
	            v4(-0.41, 301.67, 8.87, 1),
	            v4(10.82, 268.84, -41.35, 1),
	        ], [v4(3.28, 322.29, 11.15, 1),
	            v4(1.6, 313.7, 14.8, 1),
	            v4(-2.71, 303.49, 17.38, 1),
	            v4(-48.7, 278.13, 7.77, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["367"].animation = [[6232, 1], [6308, -1]];
	Curves["367"].divisions = "|MAEmodelsPrevis|tunnelBurstHend_500_200_1_240_239_196_240_90_100_100_2_10|_10_10_v16";
	Curves.numCurves = 368;
	Curves["368"] = function () {
	    var Curve_v01 = [[v4(-1.32, 324.9, -3.27, 1),
	            v4(-3.73, 320.49, 6.58, 1),
	            v4(-10.37, 308.31, 17.22, 1),
	            v4(-31.42, 261.85, 5.34, 1),
	        ], [v4(-1.07, 324.82, -3.33, 1),
	            v4(1.04, 320.77, 7.43, 1),
	            v4(-3.7, 317.07, 21.61, 1),
	            v4(-38.21, 336.69, 59.62, 1),
	        ], [v4(-1.16, 324.68, -3.43, 1),
	            v4(-0.54, 317.06, 2.42, 1),
	            v4(4.94, 310.8, 11.18, 1),
	            v4(58.4, 311.81, 40.59, 1),
	        ], [v4(-1.28, 324.6, -3.49, 1),
	            v4(-3.18, 317.85, 2.9, 1),
	            v4(-3.43, 308.27, 9.04, 1),
	            v4(15.7, 258.79, 3.08, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["368"].animation = [[6322, 1], [6398, -1]];
	Curves["368"].divisions = "|MAEmodelsPrevis|tunnelBurstIend_500_300_1_240_239_196_100_100_100_100_2_10|_10_10_v17";
	Curves["369"] = function () {
	    var Curve_v01 = [[v4(0.54, 328.31, -1.2, 1),
	            v4(3.37, 318.82, 3.73, 1),
	            v4(6.59, 308.52, 17.48, 1),
	            v4(0.67, 318.65, 68.53, 1),
	        ], [v4(0.28, 328.3, -1.24, 1),
	            v4(-0.34, 316.89, 1.26, 1),
	            v4(5.99, 303.9, 6.59, 1),
	            v4(54.64, 278.37, 4.82, 1),
	        ], [v4(0.27, 328.39, -1.08, 1),
	            v4(-2.02, 321.58, 5.33, 1),
	            v4(-7.03, 310.99, 8.25, 1),
	            v4(-44.04, 269.99, -17.72, 1),
	        ], [v4(0.32, 328.46, -0.95, 1),
	            v4(0.72, 321.86, 5.85, 1),
	            v4(-1.61, 314.71, 14.39, 1),
	            v4(-41.49, 309.06, 49.42, 1),
	        ],];
	    var degree1_v01 = 3;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["369"].animation = [[6322, 1], [6398, -1]];
	Curves["369"].divisions = "|MAEmodelsPrevis|tunnelBurstIend_500_300_1_240_239_196_100_100_100_100_2_10|_10_10_v18";
	Curves.numCurves = 370;
	Curves["370"] = function () {
	    var Curve_v01 = [[v4(11.11, 4.51, 8.64, 1),
	            v4(11.23, 5.02, 8.64, 1),
	            v4(14.54, 7.93, 8.72, 1),
	            v4(21.63, 15.64, 9.19, 1),
	            v4(15.9, 30.08, 12.1, 1),
	            v4(17.24, 37.45, 12.1, 1),
	            v4(26.33, 42.16, 9.96, 1),
	            v4(37.71, 42.95, 6.63, 1),
	            v4(46.84, 40.29, 4.75, 1),
	            v4(57.98, 43.06, 4.05, 1),
	        ], [v4(5.06, 2.41, 8.64, 1),
	            v4(4.87, 2.93, 8.64, 1),
	            v4(2.41, 6.05, 8.64, 1),
	            v4(4.13, 17.8, 8.29, 1),
	            v4(6.33, 31.83, 12.1, 1),
	            v4(10.97, 41.33, 12.1, 1),
	            v4(22.06, 45.94, 9.74, 1),
	            v4(35.13, 44, 6.31, 1),
	            v4(44.6, 41.24, 4.4, 1),
	            v4(55.93, 43.99, 4.05, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["370"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["370"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_29_4_v360";
	Curves["371"] = function () {
	    var Curve_v01 = [[v4(-6.86, 17.11, 4.05, 1),
	            v4(-5.05, 20.9, 4.05, 1),
	            v4(-3.23, 28.46, 4.05, 1),
	            v4(-5.97, 34.9, 4.05, 1),
	            v4(-12.34, 43.46, 4.05, 1),
	            v4(-19.97, 54.55, 4.05, 1),
	            v4(-34.48, 61.87, 4.05, 1),
	            v4(-46.33, 65.12, 9.53, 1),
	            v4(-53.01, 65.76, 15.74, 1),
	            v4(-60.21, 65.32, 33.38, 1),
	            v4(-54.47, 63.31, 54.92, 1),
	            v4(-40.23, 57.2, 75.37, 1),
	            v4(-22.49, 57.54, 80.61, 1),
	            v4(-9.53, 60.25, 75.24, 1),
	            v4(4.91, 66.5, 61.67, 1),
	            v4(17.53, 74, 36.25, 1),
	            v4(18.87, 79.57, 21.66, 1),
	            v4(14.18, 83.25, 10.87, 1),
	            v4(10.65, 84.88, 0.21, 1),
	            v4(-0.06, 82.29, -9.49, 1),
	            v4(-7.22, 76.8, -12.35, 1),
	            v4(-9, 68.84, -12.35, 1),
	            v4(-3.96, 60.49, -12.35, 1),
	            v4(9.99, 55.22, -6.79, 1),
	            v4(19.97, 54.54, -0.67, 1),
	            v4(30.77, 54.74, 3.66, 1),
	            v4(36.11, 51.72, 4.05, 1),
	            v4(37.25, 48.62, 4.05, 1),
	            v4(37.81, 47.08, 4.05, 1),
	        ], [v4(-7.23, 7.77, 2.93, 1),
	            v4(-5.09, 12.31, 2.93, 1),
	            v4(-2.13, 23.83, 2.93, 1),
	            v4(-5.12, 31.85, 2.94, 1),
	            v4(-17.26, 40.9, 3.14, 1),
	            v4(-33.07, 50.18, 6.07, 1),
	            v4(-41.34, 53.5, 10.62, 1),
	            v4(-45.36, 54.89, 17.65, 1),
	            v4(-47.82, 55.46, 28.45, 1),
	            v4(-46.06, 54.21, 41.02, 1),
	            v4(-43.6, 51.97, 54.16, 1),
	            v4(-30.54, 49.58, 66.49, 1),
	            v4(-14.21, 49.59, 71.95, 1),
	            v4(3.7, 58.25, 55.63, 1),
	            v4(10.3, 65.57, 40.7, 1),
	            v4(19.6, 71.34, 21.01, 1),
	            v4(16.21, 75.92, 13.52, 1),
	            v4(12.24, 78.25, 5.57, 1),
	            v4(8.14, 78.27, -2.68, 1),
	            v4(3.02, 74.26, -9.07, 1),
	            v4(3.14, 70.8, -10.23, 1),
	            v4(5.09, 65.41, -11.82, 1),
	            v4(11.58, 60.35, -8.78, 1),
	            v4(18.3, 59.54, -6.52, 1),
	            v4(27.12, 58.5, -2.18, 1),
	            v4(32.42, 56.6, 0.19, 1),
	            v4(36.89, 54.87, 2.22, 1),
	            v4(40.34, 51.95, 2.22, 1),
	            v4(41.2, 49.67, 2.22, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 28;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["371"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["371"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_100_4_v45";
	Curves["372"] = function () {
	    var Curve_v01 = [[v4(-1.05, 2.31, -8.72, 1),
	            v4(-1.81, 4.24, -8.67, 1),
	            v4(-3.91, 6.2, -7.37, 1),
	            v4(-7.19, 8.29, -4.2, 1),
	            v4(-13.15, 9.99, 1.17, 1),
	            v4(-18.26, 14.96, 7.49, 1),
	            v4(-17.93, 24.06, 15.62, 1),
	            v4(-19.08, 27.92, 25.84, 1),
	            v4(-19.08, 28.72, 37.63, 1),
	            v4(-17.29, 29.53, 48.34, 1),
	            v4(-13.94, 30.57, 56.84, 1),
	            v4(-7.18, 32.64, 64.12, 1),
	            v4(-1.04, 34.98, 68.88, 1),
	            v4(7.43, 38.43, 70.69, 1),
	            v4(11.14, 44.32, 64.28, 1),
	            v4(10.07, 48.34, 54.24, 1),
	            v4(9.1, 50.54, 47.74, 1),
	            v4(4.8, 51.56, 43.03, 1),
	            v4(-0.26, 52.6, 41.46, 1),
	            v4(-6.21, 53.61, 41.91, 1),
	            v4(-12.39, 56.91, 40.51, 1),
	            v4(-17.95, 60.88, 35.24, 1),
	            v4(-19.99, 64.69, 28.24, 1),
	            v4(-18.97, 68.18, 22.93, 1),
	            v4(-17.39, 71.49, 18.93, 1),
	            v4(-12.84, 74.68, 11.87, 1),
	            v4(-4.93, 78.35, 4.67, 1),
	            v4(-3.33, 83.52, 2, 1),
	            v4(-9.02, 89.04, -0.5, 1),
	            v4(-13.3, 94.17, -4.16, 1),
	            v4(-15.84, 99.16, -3.91, 1),
	            v4(-20.79, 103.66, -1.71, 1),
	            v4(-25.09, 107.78, 0.49, 1),
	            v4(-44.85, 109.23, -0.06, 1),
	            v4(-38.74, 99.66, -3.7, 1),
	            v4(-28.33, 107.8, -14.21, 1),
	            v4(-38.77, 112.03, -16.69, 1),
	            v4(-45.71, 111.22, -11.59, 1),
	            v4(-51.04, 114.94, -12.1, 1),
	            v4(-44.28, 118.55, -8.52, 1),
	            v4(-50.2, 123.89, -16.31, 1),
	            v4(-51.84, 124.34, -9.1, 1),
	            v4(-52.37, 124.49, -6.58, 1),
	        ], [v4(-5.9, 1.34, -8.72, 1),
	            v4(-6.72, 3.27, -8.67, 1),
	            v4(-8.96, 6.2, -7.37, 1),
	            v4(-12.33, 8.29, -4.2, 1),
	            v4(-18.28, 9.99, 1.17, 1),
	            v4(-22.65, 14.5, 7.49, 1),
	            v4(-21.75, 21.62, 15.62, 1),
	            v4(-20.3, 25.26, 25.84, 1),
	            v4(-20.23, 26.06, 37.63, 1),
	            v4(-18.43, 26.87, 48.34, 1),
	            v4(-15.94, 27.58, 56.84, 1),
	            v4(-10.99, 29.06, 64.12, 1),
	            v4(-5.33, 31.02, 68.88, 1),
	            v4(5.19, 33.06, 70.69, 1),
	            v4(9.91, 38, 64.28, 1),
	            v4(8.84, 42.44, 54.09, 1),
	            v4(7.87, 46.43, 46.77, 1),
	            v4(2.66, 48.54, 41.36, 1),
	            v4(-4.06, 51.13, 39.62, 1),
	            v4(-11.76, 53.5, 40.07, 1),
	            v4(-18.85, 56.91, 38.67, 1),
	            v4(-25.44, 60.88, 33.89, 1),
	            v4(-28.45, 64.69, 27.77, 1),
	            v4(-28.2, 68.18, 22.91, 1),
	            v4(-27.23, 71.49, 18.93, 1),
	            v4(-23.32, 74.68, 11.87, 1),
	            v4(-15.72, 78.35, 4.67, 1),
	            v4(-14.12, 83.52, 2, 1),
	            v4(-19.57, 89.04, -0.5, 1),
	            v4(-23.25, 94.17, -4.16, 1),
	            v4(-25.06, 99.16, -3.91, 1),
	            v4(-29.07, 103.66, -1.71, 1),
	            v4(-32.46, 107.78, 0.49, 1),
	            v4(-43.83, 108.12, -0.19, 1),
	            v4(-40.25, 101.31, -4.5, 1),
	            v4(-33.18, 107.8, -14.21, 1),
	            v4(-43.62, 110.13, -16.69, 1),
	            v4(-48.73, 110.21, -11.59, 1),
	            v4(-55.27, 114.96, -9.25, 1),
	            v4(-47.7, 118.78, -8.43, 1),
	            v4(-51.72, 123.7, -13.65, 1),
	            v4(-54.76, 124.04, -6.7, 1),
	            v4(-55.29, 124.18, -4.18, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 42;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["372"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["372"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_100_4_v46";
	Curves["373"] = function () {
	    var Curve_v01 = [[v4(-0.36, 3.42, -12.81, 1),
	            v4(-0.2, 4.85, -12.81, 1),
	            v4(0.95, 6.14, -9.42, 1),
	            v4(3.01, 9.84, -6.51, 1),
	            v4(7.15, 18.94, -6.42, 1),
	            v4(8.49, 31.88, -9.88, 1),
	            v4(4.44, 40.3, -16.28, 1),
	            v4(-4.31, 47.39, -20.86, 1),
	            v4(-19.51, 53.32, -22.87, 1),
	            v4(-32.05, 52.37, -20.31, 1),
	            v4(-42.4, 49.68, -13.17, 1),
	            v4(-47.91, 40.49, -8.2, 1),
	            v4(-49.21, 32.13, 4.05, 1),
	            v4(-32.5, 28.41, 17.21, 1),
	            v4(-19.29, 30.03, 37.64, 1),
	            v4(-6.51, 33.11, 47.73, 1),
	            v4(6.64, 37.39, 42.16, 1),
	            v4(13.45, 39.33, 33.82, 1),
	            v4(19.19, 39.06, 28.27, 1),
	            v4(22.05, 37.44, 22.97, 1),
	            v4(23.42, 35.1, 19.04, 1),
	            v4(22.81, 32.91, 16.67, 1),
	            v4(22.32, 31.73, 16.07, 1),
	        ], [v4(-12.44, 3.69, -12.81, 1),
	            v4(-14.77, 7.82, -12.81, 1),
	            v4(-15.23, 11.8, -9.42, 1),
	            v4(-14.22, 16.81, -6.51, 1),
	            v4(-6.49, 26.46, -6.42, 1),
	            v4(-6.02, 34.1, -9.88, 1),
	            v4(-10.89, 39.4, -16.28, 1),
	            v4(-13.55, 42.08, -20.86, 1),
	            v4(-19.66, 43.97, -22.87, 1),
	            v4(-28.63, 44.7, -20.31, 1),
	            v4(-34.23, 43.08, -13.17, 1),
	            v4(-39.65, 39.23, -8.2, 1),
	            v4(-37.86, 35.06, 4.05, 1),
	            v4(-28.23, 32.04, 17.21, 1),
	            v4(-15.02, 33.66, 37.64, 1),
	            v4(-2.24, 36.75, 47.73, 1),
	            v4(10.06, 40.57, 42.16, 1),
	            v4(18.32, 40.9, 33.25, 1),
	            v4(22.36, 39.48, 28.7, 1),
	            v4(25.21, 37.86, 23.34, 1),
	            v4(26.14, 35.52, 19.36, 1),
	            v4(25.54, 33.33, 16.78, 1),
	            v4(25.05, 32.15, 16.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["373"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["373"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_81_4_v30";
	Curves["374"] = function () {
	    var Curve_v01 = [[v4(7.5, 3.43, 2.4, 1),
	            v4(7.77, 8.61, 1.88, 1),
	            v4(7.85, 22.72, 1.06, 1),
	            v4(4.19, 34.52, 0.78, 1),
	            v4(1.8, 40.66, -1.54, 1),
	            v4(1.07, 44.86, -4.18, 1),
	            v4(1.41, 49.57, -3.76, 1),
	            v4(6.07, 53.27, 3.43, 1),
	            v4(11.55, 52.77, 17.8, 1),
	            v4(10.02, 48.17, 34.41, 1),
	            v4(3.48, 45.97, 37.57, 1),
	            v4(-16.54, 42.9, 39.69, 1),
	            v4(-60.34, 48.06, 5.38, 1),
	            v4(-94.9, 58.27, -30.43, 1),
	            v4(-105.54, 68.61, -64.22, 1),
	            v4(-97.78, 74.99, -78.91, 1),
	            v4(-92.07, 84.54, -87.88, 1),
	            v4(-95.69, 91.96, -79.29, 1),
	            v4(-102.86, 94.13, -64.26, 1),
	            v4(-108.39, 84.45, -53.6, 1),
	            v4(-97.03, 77.26, -58.69, 1),
	            v4(-84.34, 78.12, -63.8, 1),
	            v4(-80.54, 84.11, -68.39, 1),
	            v4(-74.37, 86.94, -67.7, 1),
	            v4(-67.25, 82.82, -64.42, 1),
	            v4(-66.27, 80.08, -62.8, 1),
	            v4(-68.81, 79.31, -61.68, 1),
	            v4(-69.43, 79.94, -61.52, 1),
	            v4(-69.74, 80.26, -61.44, 1),
	        ], [v4(-2.38, 2.45, 2.4, 1),
	            v4(-4.02, 6.59, 1.88, 1),
	            v4(-7.3, 20.94, 1.06, 1),
	            v4(-8.69, 33.9, 0.78, 1),
	            v4(-8.61, 40.56, -1.54, 1),
	            v4(-9.04, 51.6, -4.18, 1),
	            v4(-2.85, 56.61, -3.76, 1),
	            v4(5.3, 60.33, 3.43, 1),
	            v4(15.48, 58.67, 18.32, 1),
	            v4(13.13, 48.56, 35.55, 1),
	            v4(3.71, 44.47, 39.4, 1),
	            v4(-16.79, 39.7, 41.96, 1),
	            v4(-65.91, 45.12, 7.44, 1),
	            v4(-103.75, 62.06, -30.96, 1),
	            v4(-108.93, 75.16, -62.97, 1),
	            v4(-102.75, 78.64, -73.2, 1),
	            v4(-97.26, 84.17, -80.23, 1),
	            v4(-97.34, 88.09, -76.15, 1),
	            v4(-99.27, 89.99, -67.31, 1),
	            v4(-99.9, 85.32, -61.26, 1),
	            v4(-92.93, 82.77, -62.82, 1),
	            v4(-86.23, 83.38, -64.22, 1),
	            v4(-82.07, 87.01, -67.33, 1),
	            v4(-75.17, 89.98, -66.75, 1),
	            v4(-67.42, 86.34, -66.73, 1),
	            v4(-65.93, 80.58, -64.23, 1),
	            v4(-69.54, 78.6, -62.29, 1),
	            v4(-70.37, 79.4, -61.94, 1),
	            v4(-70.8, 79.82, -61.76, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 28;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["374"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["374"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_100_4_v47";
	Curves["375"] = function () {
	    var Curve_v01 = [[v4(0.83, 2.17, -0.61, 1),
	            v4(3.07, 2.84, -0.54, 1),
	            v4(6.58, 4.14, -0.7, 1),
	            v4(9.75, 6.04, -0.4, 1),
	            v4(11.76, 8.27, 2.29, 1),
	            v4(13.25, 11.37, 9.55, 1),
	            v4(14.3, 15.22, 22.67, 1),
	            v4(14.8, 18.61, 40.36, 1),
	            v4(14.65, 20.25, 59.47, 1),
	            v4(13.35, 20.15, 77.72, 1),
	            v4(9.72, 19.79, 93.5, 1),
	            v4(3.01, 21.07, 105.07, 1),
	            v4(-5.32, 25.26, 112.04, 1),
	            v4(-11.55, 32.23, 114.35, 1),
	            v4(-12.39, 40.56, 111.45, 1),
	            v4(-7.95, 48.78, 104.4, 1),
	            v4(-1.46, 56.38, 92.1, 1),
	            v4(3.64, 63.26, 74.59, 1),
	            v4(5.97, 68.8, 55.97, 1),
	            v4(5.76, 72.36, 38.74, 1),
	            v4(4.2, 74.5, 24.09, 1),
	            v4(3.42, 76.77, 13.96, 1),
	            v4(5.52, 80.32, 9.68, 1),
	            v4(10.98, 84.8, 10.15, 1),
	            v4(18.93, 88.84, 12.14, 1),
	            v4(28.18, 92.04, 12.72, 1),
	            v4(33.78, 95.17, 12.93, 1),
	            v4(35.76, 97.83, 13.93, 1),
	        ], [v4(-3.51, 1.63, 0.23, 1),
	            v4(-3.35, 2.3, 0.3, 1),
	            v4(-2.84, 4.42, 0.47, 1),
	            v4(-1.51, 6.33, 0.31, 1),
	            v4(0.02, 7.34, 1.12, 1),
	            v4(2.28, 10.17, 5.65, 1),
	            v4(4.95, 14, 16.6, 1),
	            v4(8.36, 22.34, 35.45, 1),
	            v4(11.14, 24.64, 54.01, 1),
	            v4(12.59, 24.14, 71.62, 1),
	            v4(12.32, 22.15, 88.05, 1),
	            v4(9.61, 21.26, 100.76, 1),
	            v4(4.29, 22.42, 112.15, 1),
	            v4(-6.86, 30.6, 116.32, 1),
	            v4(-10.02, 40.44, 110.59, 1),
	            v4(-6.19, 48.78, 102.45, 1),
	            v4(0.69, 52.01, 90.1, 1),
	            v4(3.21, 62.27, 71.56, 1),
	            v4(3.44, 67.72, 52.65, 1),
	            v4(1.52, 71.23, 36.27, 1),
	            v4(-0.76, 74.55, 23.12, 1),
	            v4(-3.23, 74.56, 14.88, 1),
	            v4(-5.32, 81.79, 6.9, 1),
	            v4(9.38, 86.05, 8.67, 1),
	            v4(16.48, 89.38, 16.75, 1),
	            v4(18.13, 97.1, 13.83, 1),
	            v4(27.96, 95.63, 13.8, 1),
	            v4(32.61, 97.24, 13.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 27;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["375"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["375"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_100_4_v48";
	Curves["376"] = function () {
	    var Curve_v01 = [[v4(-1.01, 5.03, 3.2, 1),
	            v4(-0.9, 8.14, 3.2, 1),
	            v4(0.26, 15.97, 3.2, 1),
	            v4(4.86, 26.91, 2.44, 1),
	            v4(8.07, 29.36, 2.44, 1),
	            v4(22.22, 35.35, 0.12, 1),
	            v4(36.55, 36.84, -6.42, 1),
	            v4(51.01, 42.38, -10.36, 1),
	            v4(57.25, 50.31, -10.26, 1),
	            v4(55.41, 63.61, -5.36, 1),
	            v4(43.09, 68.17, 3.39, 1),
	            v4(29.72, 65.39, 6.69, 1),
	            v4(26.88, 57.14, 7.27, 1),
	            v4(22.3, 57.75, 7.27, 1),
	            v4(19.78, 58.01, 7.27, 1),
	        ], [v4(-4.27, 5.83, 2.22, 1),
	            v4(-4.16, 8.94, 2.22, 1),
	            v4(-3.09, 16.92, 2.22, 1),
	            v4(1.13, 32.19, 1.45, 1),
	            v4(4.15, 36.24, 1.45, 1),
	            v4(17.82, 44.42, -0.86, 1),
	            v4(31.91, 45.92, -7.41, 1),
	            v4(46.34, 49.83, -11.35, 1),
	            v4(51.67, 55, -11.25, 1),
	            v4(51.25, 63.39, -6.35, 1),
	            v4(39.16, 66.14, 2.4, 1),
	            v4(29.53, 64.11, 6.72, 1),
	            v4(26.24, 56.72, 7.29, 1),
	            v4(21.21, 57.23, 7.29, 1),
	            v4(18.7, 57.49, 7.29, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 14;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["376"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["376"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_49_4_v9";
	Curves["377"] = function () {
	    var Curve_v01 = [[v4(-0.81, 5.21, -5.71, 1),
	            v4(-0.28, 6.72, -5.71, 1),
	            v4(0.81, 8.73, -5.51, 1),
	            v4(2.64, 10.4, -5, 1),
	            v4(5.59, 13.76, -4.04, 1),
	            v4(10.8, 20.92, -2.93, 1),
	            v4(15.57, 27.47, -2.74, 1),
	            v4(18.94, 32.44, -3.86, 1),
	            v4(21.52, 37.37, -4.2, 1),
	            v4(23.69, 42.35, -2.86, 1),
	            v4(25.57, 47.43, -0.65, 1),
	            v4(26.53, 52.72, -0.39, 1),
	            v4(26.44, 57.59, -2.34, 1),
	            v4(25.87, 62.08, -5.27, 1),
	            v4(25.93, 66.58, -9.15, 1),
	            v4(25.93, 71.06, -13.88, 1),
	            v4(22.11, 75.34, -17.56, 1),
	            v4(14.7, 79.63, -18.76, 1),
	            v4(5.77, 82.75, -19.13, 1),
	            v4(-4.54, 83.88, -19.76, 1),
	            v4(-15.77, 83.6, -20.37, 1),
	            v4(-26.33, 82.69, -20.89, 1),
	            v4(-36.64, 77.76, -22.44, 1),
	            v4(-45.05, 69.69, -24.95, 1),
	            v4(-36.81, 58.49, -29.66, 1),
	            v4(-11.98, 67.81, -36.03, 1),
	            v4(-29.16, 71.3, -39.74, 1),
	            v4(-22.75, 63.48, -41.46, 1),
	            v4(-12.58, 63.1, -33.23, 1),
	            v4(-22.92, 57.11, -29.78, 1),
	            v4(-32.81, 58.38, -24.86, 1),
	            v4(-33.05, 53.97, -21.56, 1),
	            v4(-31.79, 52.45, -20.31, 1),
	        ], [v4(-11.15, 5.31, -5.71, 1),
	            v4(-12.41, 6.87, -5.71, 1),
	            v4(-16.22, 8.63, -6.2, 1),
	            v4(-16.73, 12.06, -5, 1),
	            v4(-16.55, 15.71, -4.04, 1),
	            v4(-10.77, 23.6, -2.93, 1),
	            v4(-3.12, 30.19, -3.26, 1),
	            v4(1.42, 34.59, -4.13, 1),
	            v4(4.87, 39.55, -4.2, 1),
	            v4(7.39, 44.47, -2.86, 1),
	            v4(9.76, 49.46, -0.65, 1),
	            v4(11.62, 54.42, -0.39, 1),
	            v4(12.96, 58.7, -2.34, 1),
	            v4(13.91, 62.45, -5.27, 1),
	            v4(14.06, 65.87, -9.15, 1),
	            v4(13.23, 69.14, -13.88, 1),
	            v4(9.45, 72.49, -17.56, 1),
	            v4(2.83, 75.3, -18.76, 1),
	            v4(-4.58, 77.21, -19.13, 1),
	            v4(-12.4, 77.33, -19.81, 1),
	            v4(-19.57, 77.02, -20.55, 1),
	            v4(-26.1, 75.77, -21.25, 1),
	            v4(-31.12, 73.77, -23.08, 1),
	            v4(-35.3, 70.44, -25.45, 1),
	            v4(-34.23, 64.24, -29.64, 1),
	            v4(-24.17, 67.97, -36.03, 1),
	            v4(-34.24, 68.26, -39.74, 1),
	            v4(-29.69, 62.7, -41.46, 1),
	            v4(-19.53, 62.32, -33.23, 1),
	            v4(-25.6, 58.43, -29.78, 1),
	            v4(-34.91, 59.9, -24.86, 1),
	            v4(-35.64, 55.78, -21.56, 1),
	            v4(-34.37, 54.26, -20.31, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["377"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["377"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_91_4_v10";
	Curves["378"] = function () {
	    var Curve_v01 = [[v4(0.87, 3.02, 8.6, 1),
	            v4(-5.68, 3.92, 8.61, 1),
	            v4(-21.92, 6.64, 11.56, 1),
	            v4(-45.58, 26.49, 33.16, 1),
	            v4(-41.32, 37.35, 32.45, 1),
	            v4(-28.5, 46.39, 30.88, 1),
	            v4(-12.82, 52.52, 28.79, 1),
	            v4(-4.64, 60.31, 31.08, 1),
	            v4(-10.49, 70.91, 31.08, 1),
	            v4(-20.68, 75.15, 37.35, 1),
	            v4(-33.62, 76.31, 41.86, 1),
	            v4(-39.23, 73.41, 45.83, 1),
	            v4(-42.4, 71.89, 47.44, 1),
	        ], [v4(-3.72, 1.82, 8.01, 1),
	            v4(-10.68, 1.92, 8, 1),
	            v4(-29.18, 5.39, 13.55, 1),
	            v4(-55.06, 24.97, 40.07, 1),
	            v4(-53.65, 38.01, 40.63, 1),
	            v4(-40.65, 47.16, 35.38, 1),
	            v4(-24.37, 53.49, 31.95, 1),
	            v4(-13.25, 59.22, 30.77, 1),
	            v4(-15.2, 70.05, 30.29, 1),
	            v4(-26.39, 74.52, 34.35, 1),
	            v4(-34.11, 75.8, 41.81, 1),
	            v4(-39.57, 73.68, 45.41, 1),
	            v4(-43.53, 72.75, 45.95, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["378"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["378"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_41_4_v62";
	Curves["379"] = function () {
	    var Curve_v01 = [[v4(1.82, 4.19, 4.05, 1),
	            v4(17.73, 4.36, 7.67, 1),
	            v4(50.81, 21.39, 13.44, 1),
	            v4(68.29, 37.13, 5.35, 1),
	            v4(82.48, 47.55, 4.05, 1),
	            v4(113.34, 45.57, 4.05, 1),
	            v4(141.92, 43.23, 4.05, 1),
	            v4(148.3, 52.48, 4.05, 1),
	            v4(151.49, 57.11, 4.05, 1),
	        ], [v4(-0.67, 4.95, 4.05, 1),
	            v4(15.23, 5.13, 4.05, 1),
	            v4(48.31, 22.16, 4.05, 1),
	            v4(65.8, 37.89, 4.05, 1),
	            v4(79.98, 49.9, 4.05, 1),
	            v4(110.85, 48.26, 4.05, 1),
	            v4(139.43, 44, 4.05, 1),
	            v4(145.81, 53.25, 4.05, 1),
	            v4(149, 57.87, 4.05, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["379"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["379"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_25_4_v22";
	Curves["380"] = function () {
	    var Curve_v01 = [[v4(-1.91, 8.44, -7.51, 1),
	            v4(-1.43, 11.69, -8.9, 1),
	            v4(-2.1, 21.37, -12.66, 1),
	            v4(-27.48, 36.63, -21.71, 1),
	            v4(-65.87, 32.51, -28.83, 1),
	            v4(-86.83, 19.58, -36.08, 1),
	            v4(-118.51, 15.84, -46.83, 1),
	            v4(-120.03, 22.27, -46.65, 1),
	            v4(-121.01, 25.48, -46.55, 1),
	        ], [v4(-2.38, 1.68, -7.51, 1),
	            v4(-10.34, 3.75, -8.9, 1),
	            v4(-21.65, 9.66, -12.66, 1),
	            v4(-38.67, 30.11, -21.71, 1),
	            v4(-64.94, 29.93, -28.83, 1),
	            v4(-85.88, 17.02, -36.08, 1),
	            v4(-117.56, 13.27, -46.83, 1),
	            v4(-120.15, 19.7, -46.65, 1),
	            v4(-121.45, 22.91, -46.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["380"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["380"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_25_4_v23";
	Curves["381"] = function () {
	    var Curve_v01 = [[v4(-1.74, 8.4, -7, 1),
	            v4(-3.56, 11.06, -5.48, 1),
	            v4(-8.92, 21.46, -12.58, 1),
	            v4(-20.84, 29.18, 17.48, 1),
	            v4(-34.71, 24.44, 38.49, 1),
	            v4(-41.09, 6.59, 47.01, 1),
	            v4(-38.58, 0.28, 44.44, 1),
	            v4(-36.48, -1.8, 43.32, 1),
	        ], [v4(-2.69, 4.58, -7, 1),
	            v4(-6.23, 6.14, -5.48, 1),
	            v4(-18.57, 12.04, -12.58, 1),
	            v4(-23.44, 23.14, 17.48, 1),
	            v4(-34.32, 19.89, 38.49, 1),
	            v4(-40.45, 2.24, 44.02, 1),
	            v4(-37.52, -3.83, 41.5, 1),
	            v4(-36.31, -5.78, 40.37, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["381"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["381"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_21_4_v29";
	Curves["382"] = function () {
	    var Curve_v01 = [[v4(-0.7, 4.39, -6.41, 1),
	            v4(-9.06, 3.67, -14.31, 1),
	            v4(-29.03, 6.38, -13.32, 1),
	            v4(-66.81, 17.96, -10.87, 1),
	            v4(-121.92, 25.42, 5.32, 1),
	            v4(-157.92, 33.45, -4, 1),
	            v4(-182.64, 41.21, -8.79, 1),
	            v4(-192.85, 39.1, -8.79, 1),
	            v4(-201.11, 37.38, -8.79, 1),
	        ], [v4(-4.51, 2.43, -6.41, 1),
	            v4(-19.66, 2.06, -14.37, 1),
	            v4(-75.93, 5.17, -16.21, 1),
	            v4(-96.32, 9.88, -12.73, 1),
	            v4(-144.75, 18.73, 2.15, 1),
	            v4(-171.46, 27.74, -3.96, 1),
	            v4(-185.97, 37.04, -9.19, 1),
	            v4(-192.95, 37.65, -8.72, 1),
	            v4(-197.75, 37.13, -8.72, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["382"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["382"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_25_4_v24";
	Curves["383"] = function () {
	    var Curve_v01 = [[v4(0.73, 9.93, 4.52, 1),
	            v4(4.12, 17.64, 6.73, 1),
	            v4(15.95, 31.04, 16.71, 1),
	            v4(36.65, 36.11, 35.08, 1),
	            v4(55.68, 34.52, 45.77, 1),
	            v4(69.23, 30.79, 52.02, 1),
	            v4(83.22, 24.35, 58.71, 1),
	            v4(89.18, 18.69, 60.45, 1),
	            v4(92.35, 14.4, 62.52, 1),
	        ], [v4(-1.01, 7.5, 4.52, 1),
	            v4(-3.45, 21.69, 6.73, 1),
	            v4(6.2, 34.02, 16.71, 1),
	            v4(34.28, 37.85, 35.08, 1),
	            v4(53.31, 36.26, 47.66, 1),
	            v4(66.85, 32.53, 53.7, 1),
	            v4(79.96, 26.92, 58.78, 1),
	            v4(85.42, 21.73, 61.17, 1),
	            v4(88.59, 17.44, 62.23, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["383"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["383"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_25_4_v25";
	Curves["384"] = function () {
	    var Curve_v01 = [[v4(-4.53, 2.37, -7.43, 1),
	            v4(-10.66, 3.66, -4.24, 1),
	            v4(-22.46, 7.21, 2.18, 1),
	            v4(-39.78, 14.26, 12.03, 1),
	            v4(-55.91, 23.23, 21.63, 1),
	            v4(-71.61, 34.17, 31.04, 1),
	            v4(-82.88, 50.87, 37.6, 1),
	            v4(-89.54, 71.84, 35.3, 1),
	            v4(-102.29, 87.22, 35.02, 1),
	            v4(-109.89, 101.76, 34.38, 1),
	            v4(-102.86, 106.1, 31.24, 1),
	        ], [v4(-13.19, 2.06, -4.04, 1),
	            v4(-19.42, 3.24, -0.32, 1),
	            v4(-31.36, 6.49, 7.83, 1),
	            v4(-47.48, 13.78, 21.06, 1),
	            v4(-62.6, 23.75, 33.96, 1),
	            v4(-77.01, 36.69, 44.58, 1),
	            v4(-92.6, 52.96, 48.51, 1),
	            v4(-106.39, 69.04, 46.25, 1),
	            v4(-119.98, 88.19, 40.54, 1),
	            v4(-115.04, 101.46, 34.09, 1),
	            v4(-108.67, 105.39, 31.24, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["384"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["384"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_33_4_v23";
	Curves["385"] = function () {
	    var Curve_v01 = [[v4(0.78, 7.02, -14.27, 1),
	            v4(-2.86, 15.49, -13.6, 1),
	            v4(-10.99, 25.61, -22.25, 1),
	            v4(-24.23, 30.45, -49.58, 1),
	            v4(-36.44, 33.23, -77.94, 1),
	            v4(-45.09, 38.66, -99.06, 1),
	            v4(-47.88, 47.16, -111.44, 1),
	            v4(-43.93, 56.85, -118.43, 1),
	            v4(-34.25, 66.55, -123.81, 1),
	            v4(-21.76, 77.46, -129.1, 1),
	            v4(-11.29, 92.32, -135.37, 1),
	            v4(-10.04, 106.51, -142.7, 1),
	            v4(-12.15, 114.95, -148.32, 1),
	        ], [v4(-3.5, 5.59, -14.27, 1),
	            v4(-6.94, 13.62, -13.63, 1),
	            v4(-16.04, 22.87, -23.49, 1),
	            v4(-33.25, 27.03, -53.98, 1),
	            v4(-50.35, 30.26, -84.68, 1),
	            v4(-62.97, 37.43, -105.01, 1),
	            v4(-67.32, 48.65, -112.09, 1),
	            v4(-62.32, 61.31, -111, 1),
	            v4(-50.55, 73.45, -110.94, 1),
	            v4(-36.67, 85.51, -118.64, 1),
	            v4(-24.93, 99.09, -133.86, 1),
	            v4(-20.33, 109.52, -144.72, 1),
	            v4(-19.13, 114.91, -148.8, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["385"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["385"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_41_4_v63";
	Curves["386"] = function () {
	    var Curve_v01 = [[v4(-8.39, 7.69, -10.04, 1),
	            v4(-16.21, 2.49, -11.34, 1),
	            v4(-31.59, -19.07, -15.98, 1),
	            v4(-35.86, -38.48, -18.65, 1),
	            v4(-35.07, -49.55, -20.49, 1),
	            v4(-31.58, -53.96, -19.61, 1),
	            v4(-29.93, -55.9, -18.95, 1),
	        ], [v4(-4.8, 5.24, -8.89, 1),
	            v4(-8.74, 1.09, -8.99, 1),
	            v4(-16.11, -12.8, -10.71, 1),
	            v4(-22, -31.76, -12.12, 1),
	            v4(-24.85, -47.3, -16.06, 1),
	            v4(-23.9, -51.82, -16.83, 1),
	            v4(-23.48, -53.73, -16.97, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["386"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["386"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_17_4_v28";
	Curves["387"] = function () {
	    var Curve_v01 = [[v4(-2.3, 5.43, 15.07, 1),
	            v4(-1.77, 7.78, 15.07, 1),
	            v4(4.03, 11.11, 13.99, 1),
	            v4(12.66, 13.33, 6.01, 1),
	            v4(13.66, 16.55, -2.13, 1),
	            v4(10.33, 18.59, -12.06, 1),
	            v4(-3.49, 22.29, -16.79, 1),
	            v4(-18.67, 24.88, -9.22, 1),
	            v4(-25.7, 29.1, 1.09, 1),
	            v4(-21.16, 33.96, 12.88, 1),
	            v4(-6.13, 36.07, 21.44, 1),
	            v4(9.6, 38.39, 17.61, 1),
	            v4(20.54, 40.03, 4.2, 1),
	            v4(20.63, 43.65, -9.01, 1),
	            v4(8.16, 51.43, -16.69, 1),
	            v4(-2.76, 57.56, -18.64, 1),
	            v4(-13.75, 63.82, -14.83, 1),
	            v4(-18.89, 70, -2.57, 1),
	            v4(-21.33, 73.8, 9.02, 1),
	            v4(-13.4, 78.28, 19.2, 1),
	            v4(-8.57, 83.57, 4.13, 1),
	            v4(1.29, 88.25, -2.09, 1),
	            v4(5.49, 94.21, -4.49, 1),
	        ], [v4(-1.95, 4.83, 15.07, 1),
	            v4(-1.83, 7.58, 15.07, 1),
	            v4(1.18, 13.59, 13.99, 1),
	            v4(7.38, 18.61, 6.01, 1),
	            v4(10.89, 24.15, -2.13, 1),
	            v4(11.58, 29.9, -12.06, 1),
	            v4(-0.72, 34.55, -16.79, 1),
	            v4(-12.67, 37.17, -9.22, 1),
	            v4(-17, 41.24, 1.09, 1),
	            v4(-15.64, 43.98, 12.88, 1),
	            v4(-3.35, 46.4, 21.44, 1),
	            v4(12.7, 49.15, 17.61, 1),
	            v4(23.91, 51.17, 4.2, 1),
	            v4(24.19, 55.04, -9.01, 1),
	            v4(11.89, 60.35, -16.69, 1),
	            v4(1.1, 65.11, -18.64, 1),
	            v4(-9.56, 71.16, -14.83, 1),
	            v4(-14.15, 76.88, -2.57, 1),
	            v4(-16.15, 80.2, 9.02, 1),
	            v4(-7.88, 84.16, 19.2, 1),
	            v4(-3.03, 88.99, 4.13, 1),
	            v4(6.63, 93.4, -2.09, 1),
	            v4(10.57, 99.19, -4.49, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["387"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["387"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_81_4_v31";
	Curves["388"] = function () {
	    var Curve_v01 = [[v4(0.32, 3.16, 3.07, 1),
	            v4(2.17, 3.7, 3.62, 1),
	            v4(3.39, 6.1, 5.14, 1),
	            v4(8.44, 8.28, 12.7, 1),
	            v4(15.67, 9.42, 23.65, 1),
	            v4(27.38, 14.04, 36.54, 1),
	            v4(66.21, 33.62, 49.08, 1),
	            v4(128.63, 75.34, 62.39, 1),
	            v4(142.88, 96.81, 87.84, 1),
	            v4(139.01, 103.6, 109.71, 1),
	        ], [v4(0.34, 3.31, 0.47, 1),
	            v4(0.94, 4.51, 1.23, 1),
	            v4(2.13, 6.93, 2.75, 1),
	            v4(8.02, 13, 10.2, 1),
	            v4(16.49, 14.64, 20.98, 1),
	            v4(28.21, 17.28, 33.86, 1),
	            v4(67.04, 33.62, 46.41, 1),
	            v4(129.46, 75.34, 59.71, 1),
	            v4(143.71, 96.81, 85.17, 1),
	            v4(139.83, 103.6, 107.03, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["388"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["388"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_29_4_v361";
	Curves["389"] = function () {
	    var Curve_v01 = [[v4(-121.99, 21.78, 142.06, 1),
	            v4(-123.98, 30.75, 145.73, 1),
	            v4(-127.55, 53.08, 155.58, 1),
	            v4(-123.53, 66.62, 172.5, 1),
	            v4(-119.5, 68.29, 185.45, 1),
	            v4(-117.83, 65.8, 191.48, 1),
	        ], [v4(-120.25, 20.14, 145.53, 1),
	            v4(-121.94, 27.67, 150.29, 1),
	            v4(-125.62, 42.02, 161.62, 1),
	            v4(-124.42, 59.36, 173.68, 1),
	            v4(-120.03, 63.5, 185.77, 1),
	            v4(-118.42, 61.86, 191.39, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["389"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["389"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_13_4_v42";
	Curves["390"] = function () {
	    var Curve_v01 = [[v4(-2.93, 4.81, 0.12, 1),
	            v4(-3.71, 6.27, 1.31, 1),
	            v4(-4.41, 8.57, 3.42, 1),
	            v4(-11.55, 15.55, 12.88, 1),
	            v4(-11.78, 15.76, 24.88, 1),
	            v4(7.05, 11.17, 56.86, 1),
	            v4(65.88, 17.82, 113.79, 1),
	            v4(185.6, 83.3, 124.18, 1),
	            v4(360.97, 106.25, 93.54, 1),
	            v4(431.72, 125.15, 29.87, 1),
	        ], [v4(-3.25, 2.75, 0.58, 1),
	            v4(-4.06, 4.16, 1.82, 1),
	            v4(-5.13, 6.58, 4.13, 1),
	            v4(-11.09, 12.28, 12.83, 1),
	            v4(-10.6, 9.89, 25.14, 1),
	            v4(10.86, 5.05, 56.94, 1),
	            v4(68.95, 9.41, 112.76, 1),
	            v4(187.21, 76.86, 122.54, 1),
	            v4(367.79, 101.58, 91.7, 1),
	            v4(428.33, 121.46, 34.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["390"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["390"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_29_4_v362";
	Curves["391"] = function () {
	    var Curve_v01 = [[v4(-0.28, 3.96, -5.71, 1),
	            v4(5.58, 0.97, 0.44, 1),
	            v4(15.4, 14.05, 7.7, 1),
	            v4(35.39, 22.15, 16.6, 1),
	            v4(53.85, 16.71, 22.93, 1),
	            v4(76.24, 17.07, 26.39, 1),
	            v4(99.02, 17.19, 25.15, 1),
	            v4(120.64, 20.99, 18.59, 1),
	            v4(141.32, 25.38, 10.11, 1),
	            v4(161.66, 30.79, 0.96, 1),
	            v4(181.85, 36.26, -8.38, 1),
	            v4(201.83, 42.23, -18.08, 1),
	            v4(221.54, 48.51, -28.19, 1),
	            v4(240.92, 55.25, -38.77, 1),
	            v4(259.92, 62.43, -49.89, 1),
	            v4(278.44, 70.14, -61.59, 1),
	            v4(296.43, 78.38, -73.96, 1),
	            v4(313.72, 87.25, -87, 1),
	            v4(330.62, 96.6, -100.5, 1),
	            v4(346.86, 106.59, -114.32, 1),
	            v4(363.24, 117.1, -128.32, 1),
	            v4(378.93, 129.06, -142.33, 1),
	            v4(396.2, 141.95, -156.08, 1),
	            v4(411.18, 157.23, -169.11, 1),
	            v4(430.49, 173.82, -180.19, 1),
	            v4(442.58, 195.54, -187.7, 1),
	            v4(461.47, 209.16, -186.49, 1),
	            v4(459.01, 201.35, -177.51, 1),
	        ], [v4(0.69, 4.83, -4.71, 1),
	            v4(6.68, 2.78, 1.21, 1),
	            v4(16.3, 18.33, 7.84, 1),
	            v4(36.78, 23.48, 18.72, 1),
	            v4(57.84, 17.69, 26.23, 1),
	            v4(79.65, 16.15, 29.86, 1),
	            v4(102.26, 13.81, 28.15, 1),
	            v4(123.87, 16.63, 21.58, 1),
	            v4(144.55, 21.02, 13.1, 1),
	            v4(164.89, 26.43, 3.95, 1),
	            v4(185.08, 31.9, -5.39, 1),
	            v4(205.06, 37.87, -15.09, 1),
	            v4(224.77, 44.15, -25.19, 1),
	            v4(244.15, 50.9, -35.78, 1),
	            v4(263.15, 58.04, -46.94, 1),
	            v4(281.67, 64.85, -59.91, 1),
	            v4(299.66, 71.7, -74.26, 1),
	            v4(316.95, 79.9, -88.23, 1),
	            v4(333.85, 89.26, -101.72, 1),
	            v4(350.09, 99.24, -115.55, 1),
	            v4(366.41, 109.68, -129.55, 1),
	            v4(381.67, 121.07, -143.57, 1),
	            v4(398.16, 133.15, -157.39, 1),
	            v4(412.11, 152.01, -171.2, 1),
	            v4(430.26, 175.39, -183.56, 1),
	            v4(441.72, 200.91, -190.77, 1),
	            v4(460.42, 217.48, -187.69, 1),
	            v4(457.96, 211.17, -177.87, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 27;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["391"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["391"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_100_4_v49";
	Curves["392"] = function () {
	    var Curve_v01 = [[v4(-1.01, 4.22, -6.41, 1),
	            v4(-7.29, 6.47, -6.41, 1),
	            v4(-26.88, 15.59, -7.92, 1),
	            v4(-24.27, 39.21, 9.91, 1),
	            v4(-39.46, 59.47, -1.57, 1),
	            v4(-18.44, 66.13, -23.05, 1),
	            v4(-0.75, 72.44, -33.84, 1),
	            v4(15.78, 84.91, -50.62, 1),
	            v4(21.49, 88.56, -73, 1),
	            v4(31.38, 94.03, -97.93, 1),
	            v4(34.44, 99.83, -115.47, 1),
	            v4(39.6, 107.97, -138.42, 1),
	            v4(35.49, 113.46, -138.44, 1),
	        ], [v4(-8.87, 2.66, -6.41, 1),
	            v4(-14.44, 3.15, -6.41, 1),
	            v4(-40.66, 8.04, -8.33, 1),
	            v4(-33.37, 32.8, 7.06, 1),
	            v4(-47.53, 56.9, 3.54, 1),
	            v4(-31.39, 68.33, -20.05, 1),
	            v4(-13.36, 74.43, -32.93, 1),
	            v4(-0.62, 80.69, -56.31, 1),
	            v4(7.32, 84.54, -78.38, 1),
	            v4(17.16, 90.75, -102.21, 1),
	            v4(25.4, 94.27, -123.81, 1),
	            v4(34.26, 106.76, -138.41, 1),
	            v4(28.74, 114.51, -138.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["392"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["392"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_41_4_v64";
	Curves["393"] = function () {
	    var Curve_v01 = [[v4(-0.66, 4.32, 5.56, 1),
	            v4(-6.59, 6.5, 11.9, 1),
	            v4(-10.51, 6.93, 18.49, 1),
	            v4(-15.04, 6.53, 28.49, 1),
	            v4(-18.01, 3.91, 36.16, 1),
	            v4(-18.9, 1.72, 38.21, 1),
	            v4(-18.96, 0.25, 38.35, 1),
	        ], [v4(4.06, 3.07, 10.45, 1),
	            v4(3.55, 5.25, 24.02, 1),
	            v4(1.56, 5.68, 33.18, 1),
	            v4(-2.96, 5.28, 43.18, 1),
	            v4(-8.95, 3.23, 47.45, 1),
	            v4(-12.51, 0.67, 45.93, 1),
	            v4(-13.84, -1, 43.77, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["393"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["393"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_17_4_v29";
	Curves["394"] = function () {
	    var Curve_v01 = [[v4(-0.94, 2.14, 5.71, 1),
	            v4(3.16, 3.18, 8.76, 1),
	            v4(8.32, -0.03, 13.87, 1),
	            v4(22.45, -10.03, 18.34, 1),
	            v4(23.91, -21.9, 21.2, 1),
	            v4(23.63, -24.98, 21.94, 1),
	            v4(22.75, -26.68, 21.89, 1),
	        ], [v4(2.88, 3.09, 4.54, 1),
	            v4(9.95, 4.13, 3.36, 1),
	            v4(20.21, 3.94, 2.87, 1),
	            v4(37.09, -3.78, 3.96, 1),
	            v4(34.43, -20.29, 9.21, 1),
	            v4(31.81, -24.98, 11.79, 1),
	            v4(30.19, -26.57, 13.47, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["394"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["394"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_17_4_v30";
	Curves["395"] = function () {
	    var Curve_v01 = [[v4(-2.1, 4.06, -3.18, 1),
	            v4(-13.73, 6.15, 0.76, 1),
	            v4(-27.95, 7.94, 3.25, 1),
	            v4(-43.11, 5.28, 4.05, 1),
	            v4(-126.55, 9.29, 4.05, 1),
	            v4(-170.89, 16.44, 4.05, 1),
	            v4(-171.61, 19.19, 4.05, 1),
	            v4(-171.97, 20.4, 4.05, 1),
	        ], [v4(-2.58, 2.83, -3.18, 1),
	            v4(-14.21, 4.04, 0.76, 1),
	            v4(-29.78, 3.67, 2.62, 1),
	            v4(-46.7, -2.48, 2.59, 1),
	            v4(-117.04, 2.87, 2.66, 1),
	            v4(-173.26, 12.24, 3.23, 1),
	            v4(-173.22, 15.68, 3.59, 1),
	            v4(-173.27, 17.16, 3.74, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["395"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["395"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_21_4_v30";
	Curves["396"] = function () {
	    var Curve_v01 = [[v4(-1.18, 3.7, -1.66, 1),
	            v4(-1.83, 5.3, -0.84, 1),
	            v4(-2.97, 7.95, 0.7, 1),
	            v4(-11.27, 15.55, 9.66, 1),
	            v4(-19.1, 15.97, 18.49, 1),
	            v4(-22.56, 19.84, 39.37, 1),
	            v4(-15.02, 26.32, 80.52, 1),
	            v4(17.06, 57.94, 146.53, 1),
	            v4(17.89, 96.39, 169.39, 1),
	            v4(11.37, 117.14, 173.58, 1),
	        ], [v4(-0.19, 3.31, -1.6, 1),
	            v4(-0.85, 4.51, -0.9, 1),
	            v4(-2.17, 6.93, 0.51, 1),
	            v4(-8.4, 12.84, 8.76, 1),
	            v4(-16.12, 10.16, 18.97, 1),
	            v4(-19.58, 13.96, 39.55, 1),
	            v4(-12.25, 20.57, 80.13, 1),
	            v4(19.2, 55.92, 146.14, 1),
	            v4(22.06, 96.64, 169.23, 1),
	            v4(10.95, 122.82, 175, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["396"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["396"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_29_4_v363";
	Curves["397"] = function () {
	    var Curve_v01 = [[v4(-0.58, 2.28, 0.42, 1),
	            v4(-0.35, 2.58, 0.8, 1),
	            v4(0.45, 2.35, 1.3, 1),
	            v4(2.51, 2.58, 4.89, 1),
	            v4(5.49, 5.36, 7.01, 1),
	            v4(16, 8.1, 7.88, 1),
	            v4(38.24, 12.26, -2.22, 1),
	            v4(88.64, 27.16, -67.6, 1),
	            v4(143.21, 36.4, -149.8, 1),
	            v4(135.06, 39.75, -177.25, 1),
	        ], [v4(2.47, 3.75, -0.56, 1),
	            v4(2.71, 4.17, -0.18, 1),
	            v4(3.2, 4.9, 0.42, 1),
	            v4(4.85, 6.23, 3.23, 1),
	            v4(8.13, 6.56, 4.9, 1),
	            v4(17.76, 7.5, 4.77, 1),
	            v4(40.08, 8.65, -5.32, 1),
	            v4(87.55, 20.81, -62.32, 1),
	            v4(146.11, 32.66, -151.47, 1),
	            v4(138.36, 38.64, -175.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["397"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["397"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_29_4_v364";
	Curves["398"] = function () {
	    var Curve_v01 = [[v4(1.92, 2.94, -10.19, 1),
	            v4(14.96, 6.86, -31.01, 1),
	            v4(33.75, 23.13, -96.05, 1),
	            v4(41.38, 39.78, -104.64, 1),
	            v4(28.35, 55.8, -101.31, 1),
	            v4(24.25, 70.93, -85.73, 1),
	            v4(31.94, 76.38, -45.33, 1),
	            v4(76.81, 90.98, -12.4, 1),
	            v4(93.64, 108.38, -91.75, 1),
	            v4(82.29, 115.68, -119.31, 1),
	            v4(81.8, 125.12, -120.58, 1),
	            v4(90.94, 130.77, -110.13, 1),
	            v4(99.4, 134.37, -97.15, 1),
	            v4(99.11, 138.5, -96.38, 1),
	        ], [v4(-2.1, 3.49, -9.23, 1),
	            v4(10.95, 7.41, -13.53, 1),
	            v4(5.65, 23.68, -73.68, 1),
	            v4(13.26, 40.44, -104.64, 1),
	            v4(15.35, 58.73, -101.31, 1),
	            v4(17.38, 77.64, -55.02, 1),
	            v4(28.23, 85.71, -6.77, 1),
	            v4(70.61, 95.48, -19.66, 1),
	            v4(86.18, 107.31, -95.87, 1),
	            v4(78.61, 114.16, -120.58, 1),
	            v4(77.79, 125.67, -120.58, 1),
	            v4(86.92, 131.32, -110.13, 1),
	            v4(97.51, 134.92, -97.15, 1),
	            v4(97.22, 139.05, -96.38, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 13;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["398"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["398"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_45_4_v13";
	Curves["399"] = function () {
	    var Curve_v01 = [[v4(10.75, 1.17, -5.53, 1),
	            v4(21.89, -2.78, -8.89, 1),
	            v4(32.29, -13.71, -12.88, 1),
	            v4(43.88, -36.04, -17.88, 1),
	            v4(46.88, -51.16, -21.62, 1),
	            v4(46.09, -55.86, -22.32, 1),
	            v4(45.61, -59.78, -22.02, 1),
	        ], [v4(0.41, 2.2, -5.86, 1),
	            v4(9.31, 4.63, -10.87, 1),
	            v4(19.98, 0.65, -19.3, 1),
	            v4(38.77, -18.88, -28.81, 1),
	            v4(39.85, -39.69, -29.89, 1),
	            v4(37.9, -50.55, -27.96, 1),
	            v4(40.02, -57.5, -24.55, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["399"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["399"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_17_4_v31";
	Curves["400"] = function () {
	    var Curve_v01 = [[v4(-3.77, 2.06, -4.18, 1),
	            v4(-3.27, 2.86, -4.18, 1),
	            v4(-2.12, 8.05, -4.18, 1),
	            v4(-4.75, 22.21, -4.18, 1),
	            v4(-13.15, 34.25, -4.35, 1),
	            v4(-25.95, 39.53, -3.7, 1),
	            v4(-39.07, 46.19, -2.25, 1),
	            v4(-52.17, 49.09, -2.13, 1),
	            v4(-55, 56.25, -4.31, 1),
	            v4(-48.89, 61.79, -16.8, 1),
	            v4(-39.36, 63.27, -28.32, 1),
	            v4(-36.38, 62.31, -28.32, 1),
	            v4(-34.89, 61.83, -28.32, 1),
	        ], [v4(-9.87, 1.15, -4.18, 1),
	            v4(-12.28, 3.18, -4.18, 1),
	            v4(-18.69, 7.95, -8.48, 1),
	            v4(-29.9, 19.42, -4.18, 1),
	            v4(-40.94, 30.71, -3.96, 1),
	            v4(-44.82, 39.99, -2.36, 1),
	            v4(-57.57, 44.57, -1.24, 1),
	            v4(-65.14, 50.1, -1.98, 1),
	            v4(-65.76, 58.35, -3.96, 1),
	            v4(-59.46, 63.99, -16.78, 1),
	            v4(-49.82, 65.51, -28.32, 1),
	            v4(-46.86, 64.54, -28.32, 1),
	            v4(-45.38, 64.06, -28.32, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["400"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["400"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_41_4_v65";
	Curves["401"] = function () {
	    var Curve_v01 = [[v4(2.69, 2.19, -0.51, 1),
	            v4(6.79, 5.99, 0.13, 1),
	            v4(14.41, 15.34, -1.75, 1),
	            v4(39.27, 21.98, -15.22, 1),
	            v4(80.3, 22.16, -30.52, 1),
	            v4(123.51, 15.03, -40.19, 1),
	            v4(190.46, 17.31, -61.8, 1),
	            v4(192.31, 28.99, -61.07, 1),
	            v4(188.11, 31.01, -58.34, 1),
	            v4(186.01, 32.02, -56.97, 1),
	        ], [v4(1.8, 2.8, -0.51, 1),
	            v4(3.62, 9.71, 0.13, 1),
	            v4(6.55, 23.27, -1.67, 1),
	            v4(24.85, 29.97, -12.58, 1),
	            v4(73.46, 30.22, -28.53, 1),
	            v4(122.88, 16.83, -40.21, 1),
	            v4(189.74, 18.73, -61.8, 1),
	            v4(191.59, 32.29, -63.01, 1),
	            v4(187.39, 34.31, -60.27, 1),
	            v4(185.29, 35.32, -58.91, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["401"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["401"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_29_4_v365";
	Curves["402"] = function () {
	    var Curve_v01 = [[v4(-2.9, 4.98, 4.74, 1),
	            v4(-10.26, 6.2, 15.7, 1),
	            v4(-21.53, 18.16, 48.78, 1),
	            v4(-36.08, 31.1, 57.84, 1),
	            v4(-41.31, 40.62, 61.29, 1),
	            v4(-31.83, 55.34, 54.78, 1),
	            v4(-8.36, 59.33, 36.69, 1),
	            v4(0.88, 73.54, 3.13, 1),
	            v4(-3.49, 83.06, -8.04, 1),
	            v4(1.96, 88.73, -10.5, 1),
	            v4(6.18, 91.75, -11.74, 1),
	        ], [v4(-5.33, 2.54, 4.61, 1),
	            v4(-15.43, 3.29, 15.43, 1),
	            v4(-31.48, 14.35, 48.28, 1),
	            v4(-45.28, 28.3, 59.77, 1),
	            v4(-46, 39.79, 65.03, 1),
	            v4(-35.21, 55.38, 58.71, 1),
	            v4(-11.57, 59.49, 40.64, 1),
	            v4(-2.33, 73.7, 7.09, 1),
	            v4(-6.7, 83.21, -4.08, 1),
	            v4(-1.25, 88.88, -6.55, 1),
	            v4(4.61, 91.71, -7.79, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["402"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["402"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_33_4_v24";
	Curves["403"] = function () {
	    var Curve_v01 = [[v4(2.78, 2.7, 4.1, 1),
	            v4(8.3, 2.95, 5.59, 1),
	            v4(17.55, 9.18, 10.29, 1),
	            v4(96.15, 19.76, 31.86, 1),
	            v4(130.61, 30.28, 40.48, 1),
	            v4(140.35, 38.01, 40.47, 1),
	            v4(135.59, 50.41, 31.46, 1),
	            v4(123.95, 49.66, 27.89, 1),
	            v4(122.8, 47.64, 27.76, 1),
	            v4(122.23, 46.62, 27.76, 1),
	        ], [v4(0.07, 3.84, 7, 1),
	            v4(4.45, 5.36, 7.92, 1),
	            v4(13.36, 10.99, 10.12, 1),
	            v4(70.69, 26.78, 22.98, 1),
	            v4(127.03, 33.17, 39.86, 1),
	            v4(135.13, 39.03, 39.11, 1),
	            v4(133.1, 48.64, 32.4, 1),
	            v4(123.13, 48.81, 28.45, 1),
	            v4(121.99, 46.79, 28.1, 1),
	            v4(121.42, 45.77, 28.1, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["403"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["403"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_29_4_v366";
	Curves["404"] = function () {
	    var Curve_v01 = [[v4(-2.57, 4.62, -1.23, 1),
	            v4(-3.51, 5.91, -1.43, 1),
	            v4(-5.36, 8.57, -1.88, 1),
	            v4(-14.63, 15.55, -3.81, 1),
	            v4(-25.8, 15.76, -7.27, 1),
	            v4(-46.3, 18.5, -0.69, 1),
	            v4(-81.77, 28.23, 27.04, 1),
	            v4(-129.44, 49.91, 75.56, 1),
	            v4(-149.56, 94.05, 100.6, 1),
	            v4(-155.47, 124.8, 99.84, 1),
	        ], [v4(-0.58, 3.31, -0.06, 1),
	            v4(-1.54, 4.51, -0.13, 1),
	            v4(-3.47, 6.93, -0.25, 1),
	            v4(-12.95, 12.84, -0.89, 1),
	            v4(-23.73, 9.89, -7.11, 1),
	            v4(-43.89, 12.16, -0.55, 1),
	            v4(-78.57, 20.11, 27.22, 1),
	            v4(-126.09, 43.24, 75.85, 1),
	            v4(-145.65, 89.83, 103.82, 1),
	            v4(-154.76, 125.2, 101.47, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["404"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["404"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_29_4_v367";
	Curves["405"] = function () {
	    var Curve_v01 = [[v4(-2.64, 5.32, 2.76, 1),
	            v4(0.16, 4.64, 7, 1),
	            v4(5.06, 3.22, 17.49, 1),
	            v4(11.83, 0.37, 40.91, 1),
	            v4(19.37, -4.92, 70.18, 1),
	            v4(23.7, -4.97, 103.9, 1),
	            v4(-6.57, -14.12, 111.96, 1),
	            v4(-49.95, -15.91, 81.78, 1),
	            v4(-54.31, -4.96, 4.86, 1),
	            v4(-52.93, -0.39, -16.32, 1),
	            v4(-39.15, 12.54, -15.25, 1),
	            v4(-28.29, 17.52, -11.86, 1),
	            v4(-24.73, 19.22, -10.71, 1),
	        ], [v4(-2.91, 6.43, 2.85, 1),
	            v4(-0.12, 5.93, 7.09, 1),
	            v4(4.86, 5.19, 17.51, 1),
	            v4(11.91, 3.72, 40.81, 1),
	            v4(19.37, -0.45, 70.1, 1),
	            v4(23.59, -0.04, 103.9, 1),
	            v4(-7.08, -9.14, 112.06, 1),
	            v4(-52.32, -5.27, 87.84, 1),
	            v4(-59.78, 1.65, 14.79, 1),
	            v4(-58.72, 2.25, -6.94, 1),
	            v4(-42.62, 12.09, -7.9, 1),
	            v4(-30.69, 15.92, -5.33, 1),
	            v4(-26.78, 17.33, -4.48, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["405"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["405"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_41_4_v66";
	Curves["406"] = function () {
	    var Curve_v01 = [[v4(-5.8, 2.23, -9.02, 1),
	            v4(-3.67, -0.01, -6.73, 1),
	            v4(1.1, -4.34, -0.45, 1),
	            v4(11.46, -9.57, 22.26, 1),
	            v4(8.38, -14.51, 89.37, 1),
	            v4(-22.65, -15.34, 171.96, 1),
	            v4(-51.83, -3.35, 182.17, 1),
	            v4(-51.38, 15.97, 132.59, 1),
	            v4(-28.01, 35, 4.86, 1),
	            v4(-21.48, 35.39, -16.32, 1),
	            v4(1.92, 30.44, -15.25, 1),
	            v4(12.42, 25.15, -11.86, 1),
	            v4(15.95, 23.44, -10.71, 1),
	        ], [v4(-1.49, 4.77, -8.43, 1),
	            v4(0.82, 2.65, -6.11, 1),
	            v4(6.63, -1.28, 0.41, 1),
	            v4(19.95, -6.04, 20.91, 1),
	            v4(24.69, -11.5, 59.13, 1),
	            v4(-10.17, -13.1, 150.65, 1),
	            v4(-49.03, -1.2, 182.28, 1),
	            v4(-42.7, 20.55, 141.16, 1),
	            v4(-21.69, 40.71, 14.79, 1),
	            v4(-20.55, 40.37, -6.94, 1),
	            v4(-1.24, 33.18, -7.9, 1),
	            v4(7.77, 26.94, -5.33, 1),
	            v4(10.97, 24.94, -4.48, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["406"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["406"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_41_4_v67";
	Curves["407"] = function () {
	    var Curve_v01 = [[v4(-16.75, 11.13, -39.13, 1),
	            v4(-25.78, 10.4, -35.75, 1),
	            v4(-48.67, 9.27, -27.58, 1),
	            v4(-87.44, 7.73, -6.23, 1),
	            v4(-94.55, 7.84, 28.01, 1),
	            v4(-15.84, -17.81, 109.68, 1),
	            v4(36.73, 10.28, 126.59, 1),
	            v4(90.4, 78.37, 72.19, 1),
	            v4(77.38, 31.86, -14.12, 1),
	            v4(59.96, 42.28, -40.22, 1),
	            v4(33.77, 29.76, -36.35, 1),
	            v4(22.77, 20.33, -31.27, 1),
	            v4(19.37, 17.18, -29.49, 1),
	        ], [v4(-14.39, 7.83, -38.25, 1),
	            v4(-23.21, 6.87, -34.84, 1),
	            v4(-45.52, 4.78, -26.6, 1),
	            v4(-83.4, -3.7, -5.25, 1),
	            v4(-91.05, -7.33, 29.07, 1),
	            v4(-15.52, -25.31, 109.71, 1),
	            v4(41.88, -6.93, 127.2, 1),
	            v4(97.66, 32.38, 79.48, 1),
	            v4(82.65, 21.32, -3.96, 1),
	            v4(68.43, 33.68, -36.05, 1),
	            v4(42.64, 24.83, -37.47, 1),
	            v4(27.31, 17.87, -33.68, 1),
	            v4(22.06, 15.35, -32.42, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["407"].animation = [[6805, -1], [6805.005, 1], [7052, -1]];
	Curves["407"].divisions = "|MAEmodelsPrevis|ExplosionAend_25200_1_2_242_256_256_100_200_100_100_50_5|_41_4_v68";
	Curves.numCurves = 408;
	Curves["408"] = function () {
	    var Curve_v01 = [[v4(0.72, 2.96, 0.12, 1),
	            v4(0.68, 3.06, 0.17, 1),
	            v4(0.55, 3.3, 0.32, 1),
	            v4(0.22, 3.57, 0.58, 1),
	            v4(-0.16, 3.64, 0.74, 1),
	            v4(-0.33, 3.4, 0.78, 1),
	            v4(-0.14, 3.06, 0.71, 1),
	            v4(0.22, 2.83, 0.5, 1),
	            v4(0.47, 2.74, 0.34, 1),
	            v4(0.58, 2.7, 0.27, 1),
	        ], [v4(1.24, 2.97, 0, 1),
	            v4(1.37, 3.65, 0, 1),
	            v4(1.03, 4.95, 0, 1),
	            v4(-0.35, 6.55, 0.73, 1),
	            v4(-2.45, 6.82, 3.48, 1),
	            v4(-3.92, 5.4, 3.48, 1),
	            v4(-3.55, 3.34, 0.73, 1),
	            v4(-1.75, 2.36, 0, 1),
	            v4(-0.39, 2.32, 0, 1),
	            v4(0.27, 2.27, 0, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["408"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["408"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v278";
	Curves["409"] = function () {
	    var Curve_v01 = [[v4(0.86, 2.95, 0.27, 1),
	            v4(0.91, 3.31, 0.26, 1),
	            v4(0.67, 4.05, 0.46, 1),
	            v4(-0.06, 4.87, 1.65, 1),
	            v4(-1.1, 5.1, 2.51, 1),
	            v4(-1.81, 4.47, 2.68, 1),
	            v4(-1.52, 3.47, 2.14, 1),
	            v4(-0.68, 2.8, 0.94, 1),
	            v4(0.03, 2.67, 0.59, 1),
	            v4(0.4, 2.68, 0.52, 1),
	        ], [v4(0.73, 3, 0.41, 1),
	            v4(0.71, 3.14, 0.48, 1),
	            v4(0.59, 3.46, 0.74, 1),
	            v4(0.26, 3.83, 1.18, 1),
	            v4(-0.2, 3.91, 1.63, 1),
	            v4(-0.42, 3.59, 1.7, 1),
	            v4(-0.21, 3.14, 1.33, 1),
	            v4(0.17, 2.84, 0.89, 1),
	            v4(0.44, 2.71, 0.61, 1),
	            v4(0.56, 2.66, 0.51, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["409"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["409"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v279";
	Curves["410"] = function () {
	    var Curve_v01 = [[v4(1.04, 2.98, 0, 1),
	            v4(1.14, 3.53, 0.27, 1),
	            v4(0.86, 4.56, 0.46, 1),
	            v4(-0.15, 5.84, 1.43, 1),
	            v4(-1.81, 6.06, 3.48, 1),
	            v4(-2.98, 4.93, 3.48, 1),
	            v4(-2.68, 3.29, 1.76, 1),
	            v4(-1.25, 2.5, 0.33, 1),
	            v4(-0.16, 2.47, 0.33, 1),
	            v4(0.36, 2.43, 0.33, 1),
	        ], [v4(0.81, 2.89, 0.02, 1),
	            v4(0.85, 3.17, 0.12, 1),
	            v4(0.65, 3.74, 0.52, 1),
	            v4(-0.08, 4.37, 1.35, 1),
	            v4(-0.99, 4.54, 1.73, 1),
	            v4(-1.54, 4.06, 1.73, 1),
	            v4(-1.24, 3.29, 1.43, 1),
	            v4(-0.43, 2.78, 0.61, 1),
	            v4(0.17, 2.68, 0.56, 1),
	            v4(0.45, 2.68, 0.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["410"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["410"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v280";
	Curves["411"] = function () {
	    var Curve_v01 = [[v4(0.53, 3.15, -0.59, 1),
	            v4(0.6, 3.47, -0.68, 1),
	            v4(0.65, 4.22, -0.9, 1),
	            v4(1.01, 5.37, -1.56, 1),
	            v4(1.63, 6.1, -1.97, 1),
	            v4(1.96, 5.97, -2.16, 1),
	            v4(1.52, 5.12, -1.88, 1),
	            v4(0.92, 3.91, -1.02, 1),
	            v4(0.66, 3.28, -0.52, 1),
	            v4(0.55, 3.07, -0.38, 1),
	        ], [v4(0.2, 2.97, 0.17, 1),
	            v4(0.26, 3.57, -0.05, 1),
	            v4(0.2, 5.08, -0.66, 1),
	            v4(1.31, 7.36, -2.37, 1),
	            v4(2.88, 8.87, -3.4, 1),
	            v4(3.75, 8.6, -3.84, 1),
	            v4(3.17, 6.87, -3.45, 1),
	            v4(1.78, 4.36, -2.12, 1),
	            v4(1.02, 3.32, -0.74, 1),
	            v4(0.8, 2.96, -0.34, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["411"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["411"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v281";
	Curves["412"] = function () {
	    var Curve_v01 = [[v4(0.41, 3.14, -0.09, 1),
	            v4(0.51, 3.52, -0.19, 1),
	            v4(0.6, 4.5, -0.42, 1),
	            v4(1.16, 5.85, -1.14, 1),
	            v4(1.88, 6.78, -1.6, 1),
	            v4(2.32, 6.64, -1.83, 1),
	            v4(1.89, 5.62, -1.56, 1),
	            v4(1.12, 4.01, -0.99, 1),
	            v4(0.79, 3.3, -0.14, 1),
	            v4(0.67, 3.06, 0.06, 1),
	        ], [v4(0.34, 2.95, 0.24, 1),
	            v4(0.38, 3.44, 0.09, 1),
	            v4(0.4, 4.61, -0.44, 1),
	            v4(1.02, 6.48, -1.7, 1),
	            v4(2.28, 7.7, -2.53, 1),
	            v4(2.99, 7.49, -2.88, 1),
	            v4(2.48, 6.04, -2.52, 1),
	            v4(1.41, 4.21, -1.12, 1),
	            v4(0.88, 3.3, -0.26, 1),
	            v4(0.66, 2.99, -0.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["412"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["412"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v282";
	Curves["413"] = function () {
	    var Curve_v01 = [[v4(0.63, 3.16, 0, 1),
	            v4(-0.17, 3.08, 0, 1),
	            v4(-1.62, 2.67, 0, 1),
	            v4(-2.63, 1.68, 0, 1),
	            v4(-2.11, 0.8, 0, 1),
	            v4(-0.4, 0.51, 0, 1),
	            v4(1.48, 1.03, 0, 1),
	            v4(2.42, 2.15, 0, 1),
	            v4(1.95, 2.88, 0, 1),
	            v4(1.39, 3.12, 0, 1),
	        ], [v4(0.68, 2.76, 0, 1),
	            v4(0.57, 2.75, 0, 1),
	            v4(0.38, 2.7, 0, 1),
	            v4(0.24, 2.56, 0, 1),
	            v4(0.31, 2.45, 0, 1),
	            v4(0.54, 2.41, 0, 1),
	            v4(0.79, 2.48, 0, 1),
	            v4(0.91, 2.63, 0, 1),
	            v4(0.85, 2.72, 0, 1),
	            v4(0.78, 2.76, 0, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["413"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["413"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v283";
	Curves["414"] = function () {
	    var Curve_v01 = [[v4(0.67, 2.91, 0.07, 1),
	            v4(0.26, 2.87, 0.07, 1),
	            v4(-0.5, 2.65, 0.26, 1),
	            v4(-1.03, 2.13, 1.36, 1),
	            v4(-0.75, 1.68, 1.53, 1),
	            v4(0.14, 1.53, 1.68, 1),
	            v4(1.12, 1.8, 1.5, 1),
	            v4(1.61, 2.38, 0.33, 1),
	            v4(1.36, 2.76, 0.1, 1),
	            v4(1.07, 2.89, 0.07, 1),
	        ], [v4(0.71, 2.8, 0.19, 1),
	            v4(0.55, 2.79, 0.38, 1),
	            v4(0.25, 2.7, 0.59, 1),
	            v4(0.04, 2.5, 0.78, 1),
	            v4(0.14, 2.32, 0.99, 1),
	            v4(0.5, 2.26, 0.99, 1),
	            v4(0.89, 2.36, 0.67, 1),
	            v4(1.08, 2.59, 0.26, 1),
	            v4(0.98, 2.75, 0.1, 1),
	            v4(0.87, 2.8, 0.07, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["414"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["414"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v284";
	Curves["415"] = function () {
	    var Curve_v01 = [[v4(0.63, 3, 0.12, 1),
	            v4(-0.01, 2.94, 0.12, 1),
	            v4(-1.18, 2.6, 0.12, 1),
	            v4(-2, 1.81, 0.22, 1),
	            v4(-1.58, 1.16, 0.65, 1),
	            v4(-0.2, 1.11, 1.15, 1),
	            v4(1.32, 1.32, 0.53, 1),
	            v4(2.08, 2.18, 0.13, 1),
	            v4(1.7, 2.78, 0.12, 1),
	            v4(1.24, 2.97, 0.12, 1),
	        ], [v4(0.64, 2.85, 0.15, 1),
	            v4(0.36, 2.82, 0.17, 1),
	            v4(-0.15, 2.69, 0.26, 1),
	            v4(-0.51, 2.39, 0.44, 1),
	            v4(-0.32, 2.13, 0.61, 1),
	            v4(0.28, 2.06, 0.7, 1),
	            v4(0.94, 2.2, 0.57, 1),
	            v4(1.27, 2.53, 0.35, 1),
	            v4(1.1, 2.76, 0.24, 1),
	            v4(0.91, 2.84, 0.2, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["415"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["415"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v285";
	Curves["416"] = function () {
	    var Curve_v01 = [[v4(0.68, 3.43, -5.11, 1),
	            v4(0.24, 3.32, -5.11, 1),
	            v4(-0.77, 3.07, -4.94, 1),
	            v4(-2.27, 2.67, -4.22, 1),
	            v4(-3.6, 2.33, -3.11, 1),
	            v4(-4.59, 2.26, -1.73, 1),
	            v4(-5.07, 2.52, -0.21, 1),
	            v4(-4.95, 2.97, 1.29, 1),
	            v4(-4.31, 3.34, 2.58, 1),
	            v4(-3.38, 3.44, 3.59, 1),
	            v4(-2.3, 3.25, 4.42, 1),
	            v4(-1.07, 2.74, 5, 1),
	            v4(0.25, 2.05, 5.21, 1),
	            v4(1.57, 1.41, 4.87, 1),
	            v4(2.71, 1.11, 4.05, 1),
	            v4(3.58, 1.2, 3.03, 1),
	            v4(4.18, 1.57, 1.91, 1),
	            v4(4.5, 2.15, 0.78, 1),
	            v4(4.53, 2.79, -0.37, 1),
	            v4(4.26, 3.37, -1.52, 1),
	            v4(3.65, 3.73, -2.64, 1),
	            v4(2.79, 3.79, -3.63, 1),
	            v4(1.8, 3.69, -4.47, 1),
	            v4(1.06, 3.53, -4.92, 1),
	            v4(0.68, 3.43, -5.11, 1),
	        ], [v4(0.13, 2.1, -1.42, 1),
	            v4(-0.02, 2.08, -1.41, 1),
	            v4(-0.33, 2.08, -1.37, 1),
	            v4(-0.75, 2.18, -1.18, 1),
	            v4(-1.11, 2.34, -0.92, 1),
	            v4(-1.41, 2.52, -0.6, 1),
	            v4(-1.63, 2.72, -0.23, 1),
	            v4(-1.75, 2.9, 0.21, 1),
	            v4(-1.73, 3.04, 0.68, 1),
	            v4(-1.57, 3.12, 1.13, 1),
	            v4(-1.31, 3.15, 1.55, 1),
	            v4(-0.97, 3.14, 1.9, 1),
	            v4(-0.54, 3.08, 2.16, 1),
	            v4(-0.05, 2.95, 2.24, 1),
	            v4(0.44, 2.78, 2.12, 1),
	            v4(0.86, 2.6, 1.82, 1),
	            v4(1.17, 2.45, 1.4, 1),
	            v4(1.37, 2.37, 0.89, 1),
	            v4(1.42, 2.34, 0.35, 1),
	            v4(1.33, 2.33, -0.19, 1),
	            v4(1.1, 2.31, -0.68, 1),
	            v4(0.78, 2.29, -1.08, 1),
	            v4(0.41, 2.27, -1.41, 1),
	            v4(0.15, 2.26, -1.59, 1),
	            v4(0.01, 2.25, -1.66, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["416"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["416"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v286";
	Curves["417"] = function () {
	    var Curve_v01 = [[v4(0.43, 3.32, -3.45, 1),
	            v4(0.13, 3.19, -3.42, 1),
	            v4(-0.5, 2.98, -3.27, 1),
	            v4(-1.41, 2.82, -2.78, 1),
	            v4(-2.23, 2.8, -2.09, 1),
	            v4(-2.89, 2.91, -1.28, 1),
	            v4(-3.33, 3.13, -0.35, 1),
	            v4(-3.46, 3.38, 0.64, 1),
	            v4(-3.2, 3.57, 1.61, 1),
	            v4(-2.63, 3.64, 2.45, 1),
	            v4(-1.87, 3.59, 3.12, 1),
	            v4(-0.99, 3.42, 3.59, 1),
	            v4(-0.07, 3.13, 3.82, 1),
	            v4(0.86, 2.77, 3.68, 1),
	            v4(1.69, 2.46, 3.16, 1),
	            v4(2.33, 2.32, 2.39, 1),
	            v4(2.77, 2.39, 1.51, 1),
	            v4(3, 2.69, 0.63, 1),
	            v4(3.03, 3.09, -0.22, 1),
	            v4(2.83, 3.46, -1.03, 1),
	            v4(2.41, 3.67, -1.81, 1),
	            v4(1.81, 3.71, -2.5, 1),
	            v4(1.12, 3.64, -3.08, 1),
	            v4(0.61, 3.55, -3.39, 1),
	            v4(0.35, 3.49, -3.52, 1),
	        ], [v4(0.19, 2.81, -1.89, 1),
	            v4(0.01, 2.77, -1.88, 1),
	            v4(-0.36, 2.75, -1.8, 1),
	            v4(-0.86, 2.83, -1.57, 1),
	            v4(-1.31, 2.98, -1.23, 1),
	            v4(-1.67, 3.16, -0.82, 1),
	            v4(-1.95, 3.36, -0.35, 1),
	            v4(-2.08, 3.55, 0.2, 1),
	            v4(-2.04, 3.68, 0.78, 1),
	            v4(-1.83, 3.74, 1.33, 1),
	            v4(-1.49, 3.74, 1.83, 1),
	            v4(-1.03, 3.68, 2.23, 1),
	            v4(-0.49, 3.56, 2.51, 1),
	            v4(0.13, 3.36, 2.55, 1),
	            v4(0.7, 3.12, 2.34, 1),
	            v4(1.17, 2.9, 1.92, 1),
	            v4(1.51, 2.75, 1.38, 1),
	            v4(1.7, 2.71, 0.76, 1),
	            v4(1.72, 2.76, 0.13, 1),
	            v4(1.6, 2.86, -0.47, 1),
	            v4(1.33, 2.94, -1, 1),
	            v4(0.97, 2.99, -1.44, 1),
	            v4(0.54, 3.02, -1.81, 1),
	            v4(0.23, 3.02, -2.01, 1),
	            v4(0.06, 3.02, -2.1, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["417"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["417"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v287";
	Curves["418"] = function () {
	    var Curve_v01 = [[v4(0.53, 3.5, -4.21, 1),
	            v4(0.17, 3.35, -4.19, 1),
	            v4(-0.62, 3.07, -4.03, 1),
	            v4(-1.77, 2.77, -3.42, 1),
	            v4(-2.8, 2.62, -2.54, 1),
	            v4(-3.62, 2.67, -1.49, 1),
	            v4(-4.1, 2.91, -0.31, 1),
	            v4(-4.15, 3.24, 0.91, 1),
	            v4(-3.7, 3.49, 2.06, 1),
	            v4(-2.92, 3.55, 3.02, 1),
	            v4(-1.99, 3.43, 3.74, 1),
	            v4(-0.99, 3.11, 4.23, 1),
	            v4(0.1, 2.63, 4.44, 1),
	            v4(1.21, 2.12, 4.19, 1),
	            v4(2.17, 1.79, 3.5, 1),
	            v4(2.91, 1.76, 2.59, 1),
	            v4(3.41, 2.03, 1.62, 1),
	            v4(3.67, 2.51, 0.67, 1),
	            v4(3.69, 3.04, -0.29, 1),
	            v4(3.47, 3.53, -1.24, 1),
	            v4(2.97, 3.82, -2.17, 1),
	            v4(2.25, 3.87, -3, 1),
	            v4(1.42, 3.78, -3.7, 1),
	            v4(0.81, 3.65, -4.07, 1),
	            v4(0.5, 3.57, -4.23, 1),
	        ], [v4(0.34, 3.05, -2.78, 1),
	            v4(0.09, 2.95, -2.76, 1),
	            v4(-0.43, 2.82, -2.64, 1),
	            v4(-1.17, 2.78, -2.25, 1),
	            v4(-1.81, 2.84, -1.72, 1),
	            v4(-2.34, 2.99, -1.09, 1),
	            v4(-2.72, 3.19, -0.36, 1),
	            v4(-2.86, 3.39, 0.44, 1),
	            v4(-2.71, 3.52, 1.26, 1),
	            v4(-2.3, 3.55, 1.99, 1),
	            v4(-1.72, 3.49, 2.6, 1),
	            v4(-1.01, 3.34, 3.04, 1),
	            v4(-0.21, 3.11, 3.27, 1),
	            v4(0.61, 2.82, 3.19, 1),
	            v4(1.32, 2.54, 2.78, 1),
	            v4(1.86, 2.38, 2.16, 1),
	            v4(2.23, 2.36, 1.42, 1),
	            v4(2.43, 2.53, 0.64, 1),
	            v4(2.45, 2.81, -0.13, 1),
	            v4(2.29, 3.12, -0.84, 1),
	            v4(1.93, 3.35, -1.5, 1),
	            v4(1.43, 3.43, -2.06, 1),
	            v4(0.86, 3.4, -2.54, 1),
	            v4(0.44, 3.32, -2.8, 1),
	            v4(0.22, 3.27, -2.91, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 24;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["418"].animation = [[7335, -1], [7335.005, 1], [7429, -1]];
	Curves["418"].divisions = "|MAEmodelsPrevis|AtomEND_1000_1_1_256_256_256_800_100_1000_100_10_5|_50_5_v288";
	Curves.numCurves = 419;
	Curves["419"] = function () {
	    var Curve_v01 = [[v4(17.29, 181.01, -77.96, 1),
	            v4(21, 185, -76.54, 1),
	            v4(28.6, 192.48, -70.62, 1),
	            v4(37.13, 206.61, -63.56, 1),
	            v4(36.27, 226.9, -63.56, 1),
	            v4(21.54, 243.06, -73.74, 1),
	            v4(9.12, 251.92, -78.02, 1),
	            v4(2.43, 256.82, -78.02, 1),
	            v4(-0.89, 259.92, -78.02, 1),
	        ], [v4(12.04, 181.01, -77.96, 1),
	            v4(15.64, 185, -76.54, 1),
	            v4(21.74, 192.48, -70.62, 1),
	            v4(28.19, 206.61, -63.56, 1),
	            v4(27.33, 226.9, -63.56, 1),
	            v4(15.57, 243.06, -73.74, 1),
	            v4(3.86, 251.92, -78.02, 1),
	            v4(-2.82, 256.82, -78.02, 1),
	            v4(-6.15, 259.92, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["419"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["419"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_25_5_v249";
	Curves["420"] = function () {
	    var Curve_v01 = [[v4(12.03, 231.49, -78.02, 1),
	            v4(11.65, 234.69, -78.02, 1),
	            v4(9.26, 242.01, -78.02, 1),
	            v4(1.38, 247.57, -75.83, 1),
	            v4(-7.03, 254.32, -71.28, 1),
	            v4(-15.02, 260.87, -69.13, 1),
	            v4(-14.14, 274.27, -72.76, 1),
	            v4(-9.75, 282.27, -76.9, 1),
	            v4(-6.1, 286.03, -77.94, 1),
	            v4(-3.66, 288.36, -78.02, 1),
	        ], [v4(7.42, 231.49, -78.02, 1),
	            v4(6.16, 234.69, -78.02, 1),
	            v4(1.07, 242.01, -78.02, 1),
	            v4(-8.8, 247.57, -75.83, 1),
	            v4(-17.21, 254.32, -71.28, 1),
	            v4(-25.2, 260.87, -69.13, 1),
	            v4(-21.42, 274.27, -72.76, 1),
	            v4(-13.81, 282.27, -76.9, 1),
	            v4(-9.57, 286.03, -77.94, 1),
	            v4(-7.12, 288.36, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["420"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["420"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_29_5_v250";
	Curves["421"] = function () {
	    var Curve_v01 = [[v4(6.21, 144.34, -79.51, 1),
	            v4(2.53, 148.76, -79.78, 1),
	            v4(1.33, 151.93, -80.56, 1),
	            v4(-4.92, 168.21, -81.72, 1),
	            v4(4.26, 183.38, -84.17, 1),
	            v4(12.68, 192.48, -85.11, 1),
	            v4(21.19, 198.99, -85.64, 1),
	            v4(27.75, 205.66, -85.64, 1),
	            v4(30.82, 212.46, -85.64, 1),
	            v4(32.32, 218.58, -85.38, 1),
	            v4(29.52, 230.05, -84.44, 1),
	            v4(22.54, 238.72, -81.55, 1),
	            v4(14.36, 245.85, -79.07, 1),
	            v4(8.94, 247.9, -78.3, 1),
	        ], [v4(-3.51, 152.19, -79.37, 1),
	            v4(-5.63, 156, -79.63, 1),
	            v4(-7.23, 159, -80.41, 1),
	            v4(-12.5, 166.6, -81.6, 1),
	            v4(-5.2, 185.18, -84.12, 1),
	            v4(2.76, 196.07, -85.11, 1),
	            v4(10.97, 201.35, -85.64, 1),
	            v4(17.12, 206.03, -85.64, 1),
	            v4(20.08, 212.46, -85.64, 1),
	            v4(22.04, 218.58, -85.38, 1),
	            v4(19.84, 227.25, -84.44, 1),
	            v4(16.18, 238.72, -81.55, 1),
	            v4(8.24, 245.85, -79.07, 1),
	            v4(2.83, 247.9, -78.3, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 13;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["421"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["421"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_45_5_v251";
	Curves["422"] = function () {
	    var Curve_v01 = [[v4(29.88, 83.72, -83.23, 1),
	            v4(31.74, 83.27, -84.54, 1),
	            v4(34.73, 83.4, -86.35, 1),
	            v4(39.92, 84.44, -87.56, 1),
	            v4(46.8, 85.32, -87.56, 1),
	            v4(52.31, 87.55, -86.12, 1),
	            v4(54.36, 89.73, -84.34, 1),
	        ], [v4(30.69, 86.41, -83.23, 1),
	            v4(32.71, 85.97, -84.54, 1),
	            v4(36.28, 86.09, -86.35, 1),
	            v4(41.97, 87.44, -87.56, 1),
	            v4(48.83, 89.6, -87.56, 1),
	            v4(53.68, 92.73, -86.12, 1),
	            v4(55.42, 95.09, -84.34, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["422"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["422"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_17_5_v252";
	Curves["423"] = function () {
	    var Curve_v01 = [[v4(30.26, 40.17, -78.02, 1),
	            v4(32.58, 41.53, -78.02, 1),
	            v4(36.03, 45.46, -78.02, 1),
	            v4(38.16, 55.13, -78.02, 1),
	            v4(32.19, 67.39, -78.02, 1),
	            v4(19.58, 74.79, -78.02, 1),
	            v4(10.38, 78.13, -78.02, 1),
	            v4(2.77, 80.55, -78.02, 1),
	            v4(-2.39, 81.94, -78.02, 1),
	            v4(-4.92, 82.76, -78.02, 1),
	        ], [v4(30.61, 48.11, -78.02, 1),
	            v4(31.39, 50.58, -78.02, 1),
	            v4(31.28, 55.42, -78.02, 1),
	            v4(27.86, 62.03, -78.02, 1),
	            v4(22.24, 67.58, -78.02, 1),
	            v4(15.25, 71.78, -78.02, 1),
	            v4(7.62, 74.64, -78.02, 1),
	            v4(0.11, 76.72, -78.02, 1),
	            v4(-4.6, 78.26, -78.02, 1),
	            v4(-6.84, 79.27, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["423"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["423"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_29_5_v253";
	Curves["424"] = function () {
	    var Curve_v01 = [[v4(-4.58, 15.54, -47.75, 1),
	            v4(-2.66, 16.06, -47.75, 1),
	            v4(2.06, 18.15, -47.75, 1),
	            v4(11.65, 24.51, -47.75, 1),
	            v4(20.11, 33.18, -49.08, 1),
	            v4(24.09, 43.72, -53.67, 1),
	            v4(23.44, 53, -59.44, 1),
	            v4(23.4, 57.56, -65.2, 1),
	            v4(23.11, 60.58, -70.12, 1),
	            v4(21.59, 63.48, -73.51, 1),
	            v4(20.31, 64.99, -74.84, 1),
	            v4(19.72, 65.54, -75.25, 1),
	        ], [v4(-9.69, 16.8, -47.75, 1),
	            v4(-7.81, 17.3, -47.75, 1),
	            v4(-3.17, 19.31, -47.75, 1),
	            v4(6.52, 25.71, -47.75, 1),
	            v4(15.46, 35.05, -49.08, 1),
	            v4(19.19, 46.38, -53.67, 1),
	            v4(18.33, 55.67, -59.44, 1),
	            v4(18.24, 59.88, -65.2, 1),
	            v4(17.94, 63.01, -70.12, 1),
	            v4(16.42, 65.91, -73.51, 1),
	            v4(15.14, 67.42, -74.84, 1),
	            v4(14.56, 67.97, -75.25, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 11;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["424"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["424"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_37_5_v254";
	Curves["425"] = function () {
	    var Curve_v01 = [[v4(26.52, 48.63, -71.44, 1),
	            v4(26.8, 49.14, -71.44, 1),
	            v4(27.63, 50.79, -71.44, 1),
	            v4(28.42, 53.11, -71.69, 1),
	            v4(28.35, 56.51, -72.74, 1),
	            v4(27.7, 59.74, -74.26, 1),
	            v4(25.67, 63.23, -76.12, 1),
	            v4(23.02, 66.79, -77.64, 1),
	            v4(20.54, 69.08, -78.02, 1),
	            v4(18.94, 70.33, -78.02, 1),
	        ], [v4(21.95, 48.63, -71.44, 1),
	            v4(22.31, 49.14, -71.44, 1),
	            v4(23.36, 50.79, -71.44, 1),
	            v4(24.4, 53.11, -71.69, 1),
	            v4(24.62, 56.51, -72.74, 1),
	            v4(24.06, 59.74, -74.26, 1),
	            v4(22.04, 63.23, -76.12, 1),
	            v4(19.22, 66.79, -77.64, 1),
	            v4(16.43, 69.08, -78.02, 1),
	            v4(14.59, 70.33, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["425"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["425"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_29_5_v255";
	Curves["426"] = function () {
	    var Curve_v01 = [[v4(-6.94, 94.57, -75.24, 1),
	            v4(-4.85, 93.77, -74.74, 1),
	            v4(-1.71, 92.91, -74.12, 1),
	            v4(3.32, 92.11, -73.69, 1),
	            v4(8.05, 91.86, -73.69, 1),
	            v4(13.58, 93, -72.97, 1),
	            v4(18.35, 95.62, -71.41, 1),
	            v4(21.91, 98.96, -71.15, 1),
	            v4(23.89, 102.57, -72.67, 1),
	            v4(24.26, 107.39, -75.29, 1),
	            v4(23.74, 112.37, -77.33, 1),
	            v4(23, 117.36, -78.02, 1),
	            v4(21.68, 121.59, -78.02, 1),
	            v4(19.05, 125.7, -78.02, 1),
	            v4(16.23, 129.7, -78.02, 1),
	            v4(12.27, 132.44, -78.02, 1),
	            v4(6.67, 136.94, -78.02, 1),
	            v4(0.65, 139.05, -78.02, 1),
	            v4(-3.57, 138.6, -78.02, 1),
	        ], [v4(-11.31, 95.63, -75.24, 1),
	            v4(-9.38, 95.02, -74.74, 1),
	            v4(-6.63, 94.57, -74.12, 1),
	            v4(-2.04, 94.21, -73.69, 1),
	            v4(2.67, 93.96, -73.68, 1),
	            v4(8.78, 94.45, -72.88, 1),
	            v4(14.01, 96.48, -71.35, 1),
	            v4(17.57, 99.66, -71.13, 1),
	            v4(19.83, 102.83, -72.58, 1),
	            v4(20.71, 106.96, -75.07, 1),
	            v4(20.3, 111.63, -77.13, 1),
	            v4(19.22, 116.73, -78.02, 1),
	            v4(17.42, 121.25, -78.02, 1),
	            v4(14.71, 125.25, -78.02, 1),
	            v4(11.89, 129.06, -78.02, 1),
	            v4(7.93, 131.66, -78.02, 1),
	            v4(2.33, 135.95, -78.02, 1),
	            v4(-3.69, 137.97, -78.02, 1),
	            v4(-7.91, 137.53, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 18;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["426"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["426"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_50_5_v256";
	Curves["427"] = function () {
	    var Curve_v01 = [[v4(13.17, 88.58, -74.88, 1),
	            v4(14.45, 88.74, -74.24, 1),
	            v4(17.05, 89.24, -72.78, 1),
	            v4(20.89, 89.79, -71.03, 1),
	            v4(24.8, 91.11, -70.52, 1),
	            v4(31.8, 95.74, -70.77, 1),
	            v4(33.01, 107.98, -72.51, 1),
	            v4(30.44, 115.74, -74.8, 1),
	            v4(28.57, 118.87, -75.09, 1),
	            v4(26.75, 122.21, -75.09, 1),
	            v4(23.8, 126.11, -74.62, 1),
	            v4(18.91, 130.56, -72.83, 1),
	            v4(13.39, 136.11, -69.54, 1),
	            v4(6.9, 143.12, -64.92, 1),
	            v4(-0.58, 150.2, -62.44, 1),
	            v4(-3.72, 157.67, -64.01, 1),
	            v4(-4.12, 161.29, -65.56, 1),
	        ], [v4(6.38, 88.58, -74.88, 1),
	            v4(7.66, 88.74, -74.24, 1),
	            v4(10.26, 89.24, -72.78, 1),
	            v4(14.1, 89.79, -71.03, 1),
	            v4(18.01, 91.11, -70.52, 1),
	            v4(25.01, 95.74, -70.77, 1),
	            v4(26.22, 107.98, -72.51, 1),
	            v4(23.65, 115.74, -74.8, 1),
	            v4(21.78, 118.87, -75.09, 1),
	            v4(19.96, 122.21, -75.09, 1),
	            v4(17.02, 126.11, -74.45, 1),
	            v4(12.12, 130.56, -72.27, 1),
	            v4(6.6, 136.11, -68.89, 1),
	            v4(0.11, 143.12, -64.77, 1),
	            v4(-7.37, 150.2, -62.44, 1),
	            v4(-10.51, 157.67, -64.01, 1),
	            v4(-10.91, 161.29, -65.56, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 16;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["427"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["427"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_50_5_v257";
	Curves["428"] = function () {
	    var Curve_v01 = [[v4(9.6, 138.37, -74.24, 1),
	            v4(9.48, 140.77, -73.48, 1),
	            v4(8.12, 147.12, -72.1, 1),
	            v4(2.61, 163.24, -71.07, 1),
	            v4(7.3, 177.78, -72.16, 1),
	            v4(12.61, 182.34, -73.81, 1),
	            v4(14.54, 184.59, -74.64, 1),
	        ], [v4(1.41, 151.84, -74.24, 1),
	            v4(0.84, 153.47, -73.48, 1),
	            v4(-0.34, 157.36, -72.1, 1),
	            v4(-1.16, 164.49, -71.07, 1),
	            v4(0.68, 171.51, -72.16, 1),
	            v4(3.01, 175.34, -73.81, 1),
	            v4(4.21, 176.75, -74.64, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["428"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["428"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_17_5_v258";
	Curves["429"] = function () {
	    var Curve_v01 = [[v4(3.46, 77.65, -69.34, 1),
	            v4(2.04, 78.4, -69.34, 1),
	            v4(-0.25, 79.25, -69.34, 1),
	            v4(-3.89, 80.42, -68.88, 1),
	            v4(-9.27, 82.42, -68.25, 1),
	            v4(-15.38, 87.74, -67.82, 1),
	            v4(-18.1, 97.25, -74.9, 1),
	            v4(-13.41, 101.2, -77.55, 1),
	            v4(-11.23, 102.49, -78, 1),
	            v4(-10.13, 103, -78.02, 1),
	        ], [v4(-1.53, 76.14, -69.34, 1),
	            v4(-2.94, 76.69, -69.34, 1),
	            v4(-5.31, 77.14, -69.34, 1),
	            v4(-10.23, 78.8, -68.88, 1),
	            v4(-18.27, 80, -68.25, 1),
	            v4(-25.84, 84.99, -67.82, 1),
	            v4(-24.04, 96.78, -74.9, 1),
	            v4(-17.6, 101.19, -77.55, 1),
	            v4(-15.39, 102.49, -78, 1),
	            v4(-14.29, 103, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["429"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["429"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_29_5_v259";
	Curves["430"] = function () {
	    var Curve_v01 = [[v4(34.95, 28.24, -67.3, 1),
	            v4(35.89, 29.56, -67.3, 1),
	            v4(37.37, 31.53, -67.41, 1),
	            v4(40.08, 35.82, -68.07, 1),
	            v4(42.18, 44.7, -69.17, 1),
	            v4(37.01, 70.76, -71.52, 1),
	            v4(18.39, 79.72, -69.24, 1),
	            v4(6.12, 80.04, -67.54, 1),
	            v4(0, 81.18, -67.22, 1),
	            v4(-6.13, 82.73, -66.6, 1),
	            v4(-10.94, 85.09, -67.67, 1),
	            v4(-12.89, 88.89, -67.82, 1),
	            v4(-13.78, 93.6, -68.96, 1),
	            v4(-11.17, 101.04, -75.13, 1),
	            v4(-3.58, 104.05, -77.92, 1),
	            v4(-0.13, 101.96, -77.99, 1),
	        ], [v4(36.17, 36.3, -67.3, 1),
	            v4(36.21, 37.97, -67.3, 1),
	            v4(36.34, 40.39, -67.41, 1),
	            v4(36.59, 45.3, -68.07, 1),
	            v4(35.77, 51.98, -69.17, 1),
	            v4(29.08, 67.29, -71.33, 1),
	            v4(12.13, 76.6, -69.09, 1),
	            v4(2.07, 77.99, -67.44, 1),
	            v4(-4.76, 79.61, -67.37, 1),
	            v4(-12.33, 81.48, -66.79, 1),
	            v4(-17.7, 85.02, -67.73, 1),
	            v4(-19.58, 89.3, -67.82, 1),
	            v4(-19.92, 94.51, -68.96, 1),
	            v4(-15.14, 102.46, -75.13, 1),
	            v4(-6.52, 106.35, -78.02, 1),
	            v4(-3.07, 104.13, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 15;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["430"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["430"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_50_5_v260";
	Curves["431"] = function () {
	    var Curve_v01 = [[v4(18.42, 19.06, -46.3, 1),
	            v4(19.6, 19.58, -46.3, 1),
	            v4(22.12, 20.93, -46.35, 1),
	            v4(26.62, 24.34, -46.66, 1),
	            v4(31.23, 31.55, -47.2, 1),
	            v4(35.81, 42.3, -48.11, 1),
	            v4(36.04, 52.65, -49.07, 1),
	            v4(32.86, 61.53, -51.8, 1),
	            v4(28.85, 66.03, -56.1, 1),
	            v4(26.7, 67.87, -59.54, 1),
	            v4(25.53, 68.78, -61.44, 1),
	        ], [v4(12.91, 22.94, -46.3, 1),
	            v4(14.11, 23.48, -46.3, 1),
	            v4(16.91, 24.99, -46.35, 1),
	            v4(23.57, 30.06, -46.66, 1),
	            v4(28.59, 39.14, -47.2, 1),
	            v4(30.78, 50.54, -48.11, 1),
	            v4(28.54, 59.01, -49.07, 1),
	            v4(25.28, 64.89, -51.8, 1),
	            v4(22.35, 68.12, -56.1, 1),
	            v4(20.19, 69.97, -59.54, 1),
	            v4(19.03, 70.88, -61.44, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["431"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["431"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_33_5_v261";
	Curves["432"] = function () {
	    var Curve_v01 = [[v4(7.36, 53.3, -49.92, 1),
	            v4(5.95, 51.99, -48.79, 1),
	            v4(5.01, 47.85, -47.75, 1),
	            v4(7.69, 45.33, -47.75, 1),
	            v4(8.92, 44.84, -47.75, 1),
	        ], [v4(10.25, 52.72, -49.92, 1),
	            v4(8.84, 51.41, -48.79, 1),
	            v4(7.9, 47.27, -47.75, 1),
	            v4(10.58, 44.75, -47.75, 1),
	            v4(11.81, 44.26, -47.75, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["432"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["432"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v262";
	Curves["433"] = function () {
	    var Curve_v01 = [[v4(15.06, 55.23, -49.06, 1),
	            v4(14.24, 54.87, -47.96, 1),
	            v4(12.78, 54.36, -46.46, 1),
	            v4(9.26, 53.16, -44.67, 1),
	            v4(9.61, 49.26, -42.42, 1),
	            v4(10.67, 47.7, -42.21, 1),
	        ], [v4(18.35, 52.98, -49.06, 1),
	            v4(17.53, 52.62, -47.96, 1),
	            v4(16.06, 52.11, -46.46, 1),
	            v4(12.55, 50.91, -44.67, 1),
	            v4(12.9, 47.01, -42.42, 1),
	            v4(13.96, 45.45, -42.21, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["433"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["433"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_13_5_v263";
	Curves["434"] = function () {
	    var Curve_v01 = [[v4(15.69, 53.49, -63.81, 1),
	            v4(15.53, 52.96, -63.69, 1),
	            v4(14.5, 52.14, -63.37, 1),
	            v4(12.06, 51.49, -63.11, 1),
	            v4(13.11, 49.78, -63.11, 1),
	            v4(13.63, 49.37, -63.11, 1),
	        ], [v4(17.76, 52.52, -63.81, 1),
	            v4(17.6, 51.98, -63.69, 1),
	            v4(16.57, 51.16, -63.37, 1),
	            v4(14.13, 50.51, -63.11, 1),
	            v4(15.18, 48.8, -63.11, 1),
	            v4(15.7, 48.39, -63.11, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["434"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["434"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_13_5_v264";
	Curves["435"] = function () {
	    var Curve_v01 = [[v4(15.05, 63.51, -71.71, 1),
	            v4(15.05, 61.44, -70.56, 1),
	            v4(15.05, 59.38, -69.78, 1),
	            v4(15.05, 57.32, -69.5, 1),
	        ], [v4(17.68, 61.92, -71.71, 1),
	            v4(17.68, 59.85, -70.56, 1),
	            v4(17.68, 57.79, -69.78, 1),
	            v4(17.68, 55.73, -69.5, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["435"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["435"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v265";
	Curves["436"] = function () {
	    var Curve_v01 = [[v4(38.67, 65.29, -59.44, 1),
	            v4(38.74, 66.49, -59.44, 1),
	            v4(38.58, 68.35, -59.49, 1),
	            v4(37.55, 71.82, -59.91, 1),
	            v4(34.72, 75.91, -60.95, 1),
	            v4(29.93, 79.84, -64.47, 1),
	            v4(23.2, 82.46, -70.04, 1),
	            v4(13.59, 84.02, -75.85, 1),
	            v4(4.73, 85.88, -77.32, 1),
	            v4(-2.31, 88.95, -70.75, 1),
	            v4(-5.97, 93.23, -67.82, 1),
	            v4(-8.82, 97.15, -70.01, 1),
	            v4(-8.45, 100.76, -72.96, 1),
	            v4(-7.56, 102.3, -74.24, 1),
	        ], [v4(36.68, 62.92, -59.44, 1),
	            v4(36.75, 64.1, -59.44, 1),
	            v4(36.59, 65.92, -59.49, 1),
	            v4(35.56, 69.28, -59.91, 1),
	            v4(32.74, 73.18, -60.95, 1),
	            v4(27.94, 76.81, -64.47, 1),
	            v4(19.66, 79.21, -70.04, 1),
	            v4(9.68, 80.78, -75.85, 1),
	            v4(0.44, 82.77, -77.32, 1),
	            v4(-6.85, 85.87, -70.75, 1),
	            v4(-10.51, 90.21, -67.82, 1),
	            v4(-13.28, 94.17, -70.01, 1),
	            v4(-12.77, 97.89, -72.96, 1),
	            v4(-11.79, 99.48, -74.24, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 13;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["436"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["436"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_45_5_v266";
	Curves["437"] = function () {
	    var Curve_v01 = [[v4(-1.98, 95.84, -78.02, 1),
	            v4(-1.18, 97, -78.02, 1),
	            v4(0.47, 102.63, -78.02, 1),
	            v4(-10.18, 103.28, -78.02, 1),
	            v4(-11.3, 100.29, -78.02, 1),
	        ], [v4(-4.99, 93.37, -78.02, 1),
	            v4(-4.28, 94.45, -78.02, 1),
	            v4(-2.69, 99.78, -78.02, 1),
	            v4(-12.24, 100.27, -78.02, 1),
	            v4(-13.24, 97.49, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["437"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["437"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v267";
	Curves["438"] = function () {
	    var Curve_v01 = [[v4(-3.51, 111, -71.75, 1),
	            v4(-2.52, 110.62, -71.75, 1),
	            v4(0.35, 109.1, -71.72, 1),
	            v4(3.57, 104.69, -71.61, 1),
	            v4(2.11, 101.12, -71.54, 1),
	            v4(-0.17, 100.14, -71.54, 1),
	        ], [v4(-0.4, 106.94, -71.75, 1),
	            v4(0.59, 106.56, -71.75, 1),
	            v4(3.46, 105.04, -71.72, 1),
	            v4(6.68, 100.63, -71.61, 1),
	            v4(5.22, 97.06, -71.54, 1),
	            v4(2.94, 96.08, -71.54, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["438"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["438"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_13_5_v268";
	Curves["439"] = function () {
	    var Curve_v01 = [[v4(8.69, 93.25, -73.69, 1),
	            v4(7.17, 92.14, -73.69, 1),
	            v4(3.31, 91.05, -73.69, 1),
	            v4(-1.96, 92.05, -74.17, 1),
	            v4(-5.09, 92.77, -74.82, 1),
	            v4(-6.64, 92.95, -75.18, 1),
	        ], [v4(5.38, 90.31, -73.69, 1),
	            v4(3.86, 89.2, -73.69, 1),
	            v4(-0.01, 88.11, -73.69, 1),
	            v4(-5.2, 89.11, -74.17, 1),
	            v4(-8.23, 89.83, -74.82, 1),
	            v4(-9.76, 90.01, -75.18, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["439"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["439"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_13_5_v269";
	Curves["440"] = function () {
	    var Curve_v01 = [[v4(7.44, 85.82, -71.93, 1),
	            v4(9.19, 85.51, -71.6, 1),
	            v4(12.77, 84.97, -70.81, 1),
	            v4(18.33, 85.35, -69.82, 1),
	            v4(24.3, 87.24, -69.67, 1),
	            v4(30.3, 90.14, -70.55, 1),
	            v4(36.54, 93.74, -72.6, 1),
	            v4(41.11, 96.62, -74.81, 1),
	            v4(44.49, 99.1, -76.62, 1),
	            v4(45.84, 100.44, -77.38, 1),
	            v4(46.45, 101.45, -77.7, 1),
	        ], [v4(3.71, 88.45, -71.93, 1),
	            v4(5.46, 88.14, -71.6, 1),
	            v4(9.36, 87.55, -70.67, 1),
	            v4(15.82, 88.04, -69.36, 1),
	            v4(22.58, 90.38, -69.08, 1),
	            v4(29.12, 93.9, -70.08, 1),
	            v4(35.68, 98.09, -72.41, 1),
	            v4(40.35, 101.18, -74.81, 1),
	            v4(43.71, 103.64, -76.67, 1),
	            v4(45.02, 104.93, -77.41, 1),
	            v4(45.63, 105.95, -77.72, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["440"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["440"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_33_5_v270";
	Curves["441"] = function () {
	    var Curve_v01 = [[v4(7.69, 86.29, -72.15, 1),
	            v4(10.75, 86.52, -70.77, 1),
	            v4(14.73, 87.6, -70.62, 1),
	            v4(18.91, 90.55, -74.02, 1),
	            v4(20.29, 92.08, -75.84, 1),
	            v4(20.94, 93.07, -76.78, 1),
	        ], [v4(9.85, 90.94, -72.2, 1),
	            v4(12.92, 91.16, -71.04, 1),
	            v4(16.9, 92.24, -71.31, 1),
	            v4(21.07, 95.19, -74.64, 1),
	            v4(22.45, 96.72, -76.22, 1),
	            v4(23.11, 97.71, -77.01, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["441"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["441"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_13_5_v271";
	Curves["442"] = function () {
	    var Curve_v01 = [[v4(17.95, 112.58, -78.02, 1),
	            v4(18.22, 115.24, -78.02, 1),
	            v4(17.64, 119.9, -78.02, 1),
	            v4(14.01, 124.51, -78.02, 1),
	            v4(11.46, 128.24, -78.02, 1),
	            v4(6.21, 130.92, -78.02, 1),
	            v4(1.1, 133.57, -78.02, 1),
	            v4(-4.97, 135.48, -78.02, 1),
	            v4(-11.6, 138.28, -78.02, 1),
	            v4(-14.8, 143.37, -78.02, 1),
	            v4(-15.17, 146.48, -78.02, 1),
	        ], [v4(15.86, 108.27, -78.02, 1),
	            v4(17.16, 110.93, -78.02, 1),
	            v4(16.57, 115.62, -78.02, 1),
	            v4(12.94, 119.39, -78.02, 1),
	            v4(10.39, 123.17, -78.02, 1),
	            v4(5.14, 126.13, -78.02, 1),
	            v4(0.03, 130.02, -78.02, 1),
	            v4(-6.03, 131.77, -78.02, 1),
	            v4(-12.67, 134.31, -78.02, 1),
	            v4(-15.87, 139.16, -78.02, 1),
	            v4(-16.24, 142.14, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["442"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["442"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_33_5_v272";
	Curves["443"] = function () {
	    var Curve_v01 = [[v4(-8.67, 79.97, -78.02, 1),
	            v4(-10.34, 79.88, -78, 1),
	            v4(-13.38, 80.03, -77.02, 1),
	            v4(-19.11, 81.58, -71.97, 1),
	            v4(-24.37, 86.12, -67.82, 1),
	            v4(-25.1, 94.1, -73.05, 1),
	            v4(-20.45, 96.68, -76.1, 1),
	            v4(-18.39, 96.81, -76.82, 1),
	        ], [v4(-9.85, 79.41, -78.02, 1),
	            v4(-11.52, 79.31, -78.01, 1),
	            v4(-14.56, 79.47, -77.13, 1),
	            v4(-20.29, 81.14, -72.17, 1),
	            v4(-25.55, 85.97, -67.82, 1),
	            v4(-26.29, 94.48, -73.59, 1),
	            v4(-21.64, 97.23, -76.59, 1),
	            v4(-19.57, 97.37, -77.2, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["443"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["443"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_21_5_v273";
	Curves["444"] = function () {
	    var Curve_v01 = [[v4(11.94, 82.94, -81.91, 1),
	            v4(13.21, 82.71, -81.91, 1),
	            v4(15.65, 82.33, -82.02, 1),
	            v4(19.39, 82, -82.75, 1),
	            v4(23.03, 82.02, -83.71, 1),
	            v4(26.91, 82.27, -84.09, 1),
	            v4(31.36, 83.39, -83.27, 1),
	            v4(36.64, 84.61, -81.91, 1),
	            v4(40.16, 91.56, -81.21, 1),
	            v4(35.01, 94.94, -82.01, 1),
	            v4(32.55, 95.02, -82.63, 1),
	        ], [v4(8.65, 84.02, -81.91, 1),
	            v4(9.82, 83.81, -81.91, 1),
	            v4(12.07, 83.48, -82, 1),
	            v4(15.51, 83.2, -82.63, 1),
	            v4(18.85, 83.22, -83.55, 1),
	            v4(22.42, 83.44, -84.21, 1),
	            v4(26.51, 84.41, -83.88, 1),
	            v4(31.37, 85.46, -82.66, 1),
	            v4(34.6, 91.49, -81.8, 1),
	            v4(29.86, 94.42, -82.72, 1),
	            v4(27.61, 94.49, -83.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["444"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["444"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_33_5_v274";
	Curves["445"] = function () {
	    var Curve_v01 = [[v4(1.09, 86.48, -80.32, 1),
	            v4(2.34, 86.01, -79.98, 1),
	            v4(5.07, 85.15, -79.38, 1),
	            v4(10.16, 83.59, -79.01, 1),
	            v4(17.09, 81.12, -79.01, 1),
	            v4(24.98, 79.22, -79.41, 1),
	            v4(31.04, 79.74, -80.49, 1),
	            v4(35.33, 80.66, -81.24, 1),
	            v4(38.35, 81.84, -81.13, 1),
	            v4(41.4, 83.97, -80.45, 1),
	            v4(44.4, 89.34, -78.99, 1),
	            v4(40.78, 105.47, -78.02, 1),
	            v4(34.77, 115.68, -78.02, 1),
	            v4(29.36, 117.99, -78.02, 1),
	        ], [v4(-3.18, 87.7, -80.31, 1),
	            v4(-1.93, 87.26, -79.98, 1),
	            v4(0.7, 86.5, -79.38, 1),
	            v4(4.56, 85.78, -79.01, 1),
	            v4(8.95, 84.99, -79.01, 1),
	            v4(13.98, 84.95, -79.41, 1),
	            v4(18.82, 86.19, -80.49, 1),
	            v4(23.11, 87.07, -81.24, 1),
	            v4(26.13, 88.18, -81.14, 1),
	            v4(29.18, 90.2, -80.47, 1),
	            v4(34.13, 94.1, -79.03, 1),
	            v4(36.47, 105.75, -78.03, 1),
	            v4(30.5, 115.41, -78.02, 1),
	            v4(25.09, 117.61, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 13;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["445"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["445"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_45_5_v275";
	Curves["446"] = function () {
	    var Curve_v01 = [[v4(11.11, 134.08, -72.47, 1),
	            v4(9.05, 135.1, -71.84, 1),
	            v4(4.52, 138.04, -70.85, 1),
	            v4(-2.41, 145.15, -68.84, 1),
	            v4(-8.04, 154.05, -67.11, 1),
	            v4(-11.28, 165.57, -67.12, 1),
	            v4(-10.63, 176, -68.47, 1),
	            v4(-7.75, 182.12, -71.35, 1),
	            v4(-3.6, 186.23, -73.37, 1),
	            v4(-1.36, 189.42, -74.11, 1),
	        ], [v4(-4.35, 142.43, -72.47, 1),
	            v4(-6, 144.04, -71.84, 1),
	            v4(-8.93, 147.62, -70.85, 1),
	            v4(-12.13, 153.36, -68.84, 1),
	            v4(-14.47, 159.16, -67.11, 1),
	            v4(-16.24, 164.33, -67.12, 1),
	            v4(-15.95, 169.55, -68.47, 1),
	            v4(-15.07, 175.71, -71.35, 1),
	            v4(-12.45, 179.68, -73.37, 1),
	            v4(-10.52, 181.21, -74.11, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["446"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["446"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_29_5_v276";
	Curves["447"] = function () {
	    var Curve_v01 = [[v4(-20.64, 97.13, -77.17, 1),
	            v4(-19.4, 101.25, -77.17, 1),
	            v4(-13.57, 109.53, -77.17, 1),
	            v4(-1.66, 113.95, -77.17, 1),
	            v4(6.15, 105.78, -77.17, 1),
	            v4(6.37, 97.4, -77.17, 1),
	            v4(4.55, 94.51, -77.17, 1),
	        ], [v4(-21.81, 100.43, -77.17, 1),
	            v4(-20.33, 104.78, -77.17, 1),
	            v4(-13.94, 112.95, -77.17, 1),
	            v4(-0.29, 117.58, -77.17, 1),
	            v4(8.51, 108.3, -77.17, 1),
	            v4(9.11, 99.59, -77.17, 1),
	            v4(7.18, 96.52, -77.17, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 6;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["447"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["447"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_17_5_v277";
	Curves["448"] = function () {
	    var Curve_v01 = [[v4(-12.77, 77.24, -78.01, 1),
	            v4(-14.11, 76.47, -77.83, 1),
	            v4(-18.62, 75.05, -76.1, 1),
	            v4(-25.41, 74.8, -71.49, 1),
	            v4(-38.07, 80.69, -67.82, 1),
	            v4(-42.48, 92.42, -73.24, 1),
	            v4(-33.05, 100.12, -78.02, 1),
	            v4(-22.09, 100.67, -78.02, 1),
	            v4(-17.37, 99.32, -78.02, 1),
	        ], [v4(-16.72, 72.75, -78.02, 1),
	            v4(-18.07, 71.82, -77.92, 1),
	            v4(-22.51, 70.15, -76.46, 1),
	            v4(-29.99, 70.5, -71.71, 1),
	            v4(-44.57, 80.99, -67.82, 1),
	            v4(-48.89, 94.26, -74.26, 1),
	            v4(-37.36, 102.81, -78.02, 1),
	            v4(-25.69, 102.72, -78.02, 1),
	            v4(-20.89, 100.86, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["448"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["448"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_25_5_v278";
	Curves["449"] = function () {
	    var Curve_v01 = [[v4(-22.35, 76.84, -71.62, 1),
	            v4(-24.47, 78.47, -69.61, 1),
	            v4(-26.52, 83.34, -67.71, 1),
	            v4(-25.69, 88.68, -67.71, 1),
	            v4(-25.49, 91.99, -68.46, 1),
	            v4(-24.47, 94.48, -70.04, 1),
	            v4(-22.93, 97.51, -73.04, 1),
	            v4(-20.24, 98.78, -75.52, 1),
	            v4(-18.45, 99.26, -77.07, 1),
	            v4(-17.87, 99.4, -77.56, 1),
	        ], [v4(-27.2, 76.84, -71.62, 1),
	            v4(-29.38, 78.47, -69.61, 1),
	            v4(-31.47, 83.34, -67.71, 1),
	            v4(-30.63, 88.68, -67.71, 1),
	            v4(-30.44, 91.99, -68.46, 1),
	            v4(-29.41, 94.48, -70.04, 1),
	            v4(-27.81, 97.51, -73.04, 1),
	            v4(-25.03, 98.78, -75.52, 1),
	            v4(-23.16, 99.26, -77.07, 1),
	            v4(-22.56, 99.4, -77.56, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["449"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["449"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_29_5_v279";
	Curves["450"] = function () {
	    var Curve_v01 = [[v4(-7.03, 81.62, -70.63, 1),
	            v4(-8.05, 80.12, -70.63, 1),
	            v4(-11.96, 78.05, -70.63, 1),
	            v4(-16.78, 78.85, -70.63, 1),
	            v4(-19.3, 79.18, -70.63, 1),
	            v4(-20.07, 79.26, -70.63, 1),
	        ], [v4(-8.38, 78.23, -70.63, 1),
	            v4(-9.17, 76.74, -70.63, 1),
	            v4(-12.17, 74.67, -70.63, 1),
	            v4(-15.87, 75.46, -70.63, 1),
	            v4(-17.8, 75.79, -70.63, 1),
	            v4(-18.39, 75.88, -70.63, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["450"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["450"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_13_5_v280";
	Curves["451"] = function () {
	    var Curve_v01 = [[v4(-5.24, 78.21, -77.95, 1),
	            v4(-6.75, 76.55, -77.95, 1),
	            v4(-8.26, 74.89, -77.95, 1),
	            v4(-9.76, 73.23, -77.95, 1),
	        ], [v4(-2.7, 76.17, -78.02, 1),
	            v4(-3.68, 75.09, -78.02, 1),
	            v4(-4.67, 74.01, -78.02, 1),
	            v4(-5.65, 72.93, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["451"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["451"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v281";
	Curves["452"] = function () {
	    var Curve_v01 = [[v4(-1.82, 69.43, -76.64, 1),
	            v4(-4.52, 66.81, -76.02, 1),
	            v4(-6.89, 64.48, -75.58, 1),
	            v4(-8.87, 62.52, -75.42, 1),
	        ], [v4(-8.03, 70.35, -76.59, 1),
	            v4(-10.73, 67.72, -75.97, 1),
	            v4(-13.1, 65.39, -75.52, 1),
	            v4(-15.08, 63.43, -75.36, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["452"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["452"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v282";
	Curves["453"] = function () {
	    var Curve_v01 = [[v4(1.09, 73.79, -76.17, 1),
	            v4(1.21, 70.65, -76.01, 1),
	            v4(-0.28, 63.54, -75.25, 1),
	            v4(-5.79, 57.94, -73.39, 1),
	            v4(-9.54, 56.83, -72.93, 1),
	            v4(-11.76, 56.12, -72.93, 1),
	        ], [v4(-4.05, 76.48, -75.97, 1),
	            v4(-3.91, 73.37, -75.81, 1),
	            v4(-5.4, 66.42, -75.05, 1),
	            v4(-10.99, 61.29, -73.19, 1),
	            v4(-14.78, 60.33, -72.73, 1),
	            v4(-17, 59.62, -72.73, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 5;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["453"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["453"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_13_5_v283";
	Curves["454"] = function () {
	    var Curve_v01 = [[v4(-1.76, 74.65, -78.09, 1),
	            v4(-4.66, 71.5, -77.3, 1),
	            v4(-19.71, 62.29, -72.49, 1),
	            v4(-32.62, 59.49, -68.63, 1),
	            v4(-35.71, 60.74, -68.63, 1),
	        ], [v4(-15.15, 76.43, -77.84, 1),
	            v4(-19.57, 72.54, -77.04, 1),
	            v4(-26.05, 67.35, -72.24, 1),
	            v4(-35.03, 66.45, -68.38, 1),
	            v4(-39.66, 66.99, -68.38, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["454"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["454"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v284";
	Curves["455"] = function () {
	    var Curve_v01 = [[v4(8.59, 105.9, -75.72, 1),
	            v4(7.34, 106.19, -75.72, 1),
	            v4(3.09, 105.33, -75.72, 1),
	            v4(4.02, 99.43, -75.72, 1),
	            v4(5.94, 98.49, -75.72, 1),
	        ], [v4(11.68, 100.56, -75.85, 1),
	            v4(10.99, 100.72, -75.85, 1),
	            v4(8.63, 100.24, -75.85, 1),
	            v4(9.14, 96.96, -75.85, 1),
	            v4(10.21, 96.43, -75.85, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["455"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["455"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v285";
	Curves["456"] = function () {
	    var Curve_v01 = [[v4(10.07, 102.09, -78.02, 1),
	            v4(9.38, 101.4, -78.02, 1),
	            v4(8.69, 100.71, -78.02, 1),
	            v4(8, 100.02, -78.02, 1),
	        ], [v4(13.76, 100.19, -78.13, 1),
	            v4(13.07, 99.5, -78.13, 1),
	            v4(12.38, 98.81, -78.13, 1),
	            v4(11.7, 98.12, -78.13, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["456"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["456"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v286";
	Curves["457"] = function () {
	    var Curve_v01 = [[v4(6.75, 106.99, -75.16, 1),
	            v4(8.85, 107.61, -75.16, 1),
	            v4(14.04, 104.02, -75.16, 1),
	            v4(11.13, 99.76, -75.16, 1),
	            v4(9.65, 99.11, -75.16, 1),
	        ], [v4(12.67, 107.91, -75.11, 1),
	            v4(14.76, 108.53, -75.11, 1),
	            v4(19.96, 104.94, -75.11, 1),
	            v4(17.04, 100.69, -75.11, 1),
	            v4(15.57, 100.03, -75.11, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["457"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["457"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v287";
	Curves["458"] = function () {
	    var Curve_v01 = [[v4(5.89, 104.25, -69.33, 1),
	            v4(7.72, 102.87, -69.33, 1),
	            v4(9.56, 101.5, -69.33, 1),
	            v4(11.39, 100.12, -69.33, 1),
	        ], [v4(8.59, 106.21, -69.21, 1),
	            v4(10.43, 104.84, -69.21, 1),
	            v4(12.26, 103.46, -69.21, 1),
	            v4(14.09, 102.09, -69.21, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["458"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["458"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v288";
	Curves["459"] = function () {
	    var Curve_v01 = [[v4(5.76, 104.44, -78.02, 1),
	            v4(5.27, 105.42, -78.02, 1),
	            v4(4.78, 106.41, -78.02, 1),
	            v4(4.29, 107.39, -78.02, 1),
	        ], [v4(3.69, 105.45, -78.02, 1),
	            v4(3.2, 106.43, -78.02, 1),
	            v4(2.71, 107.41, -78.02, 1),
	            v4(2.21, 108.39, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["459"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["459"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v289";
	Curves["460"] = function () {
	    var Curve_v01 = [[v4(11.03, 108.18, -76.15, 1),
	            v4(11.05, 109.24, -76.15, 1),
	            v4(9.74, 112.33, -76.15, 1),
	            v4(5.48, 111.43, -76.15, 1),
	            v4(4.63, 109.96, -76.15, 1),
	        ], [v4(8.76, 103.79, -76.34, 1),
	            v4(8.78, 104.66, -76.34, 1),
	            v4(7.7, 107.22, -76.34, 1),
	            v4(4.16, 106.48, -76.34, 1),
	            v4(3.46, 105.26, -76.34, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["460"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["460"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v290";
	Curves["461"] = function () {
	    var Curve_v01 = [[v4(8.2, 107.98, -72.65, 1),
	            v4(7.51, 107.49, -72.65, 1),
	            v4(6.82, 106.99, -72.65, 1),
	            v4(6.13, 106.5, -72.65, 1),
	        ], [v4(9.94, 107.55, -72.65, 1),
	            v4(9.25, 107.06, -72.65, 1),
	            v4(8.56, 106.56, -72.65, 1),
	            v4(7.87, 106.07, -72.65, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["461"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["461"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v291";
	Curves["462"] = function () {
	    var Curve_v01 = [[v4(17.19, 102.69, -78.02, 1),
	            v4(16.7, 103.57, -78.02, 1),
	            v4(16.21, 104.45, -78.02, 1),
	            v4(15.72, 105.34, -78.02, 1),
	        ], [v4(14.88, 103.56, -78.02, 1),
	            v4(14.39, 104.44, -78.02, 1),
	            v4(13.9, 105.33, -78.02, 1),
	            v4(13.41, 106.21, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["462"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["462"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v292";
	Curves["463"] = function () {
	    var Curve_v01 = [[v4(29.75, 81.56, -78.02, 1),
	            v4(30.45, 80.82, -78.02, 1),
	            v4(29.52, 77.86, -78.02, 1),
	            v4(27.5, 78.73, -78.02, 1),
	            v4(27.1, 79.21, -78.02, 1),
	        ], [v4(30.8, 80.63, -78.02, 1),
	            v4(31.82, 79.72, -78.02, 1),
	            v4(30.47, 76.09, -78.02, 1),
	            v4(27.57, 77.16, -78.02, 1),
	            v4(26.99, 77.75, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["463"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["463"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v293";
	Curves["464"] = function () {
	    var Curve_v01 = [[v4(32.12, 78.82, -78.02, 1),
	            v4(32.02, 80.19, -78.02, 1),
	            v4(31.92, 81.57, -78.02, 1),
	            v4(31.82, 82.94, -78.02, 1),
	        ], [v4(34.39, 76.92, -78.02, 1),
	            v4(34.29, 78.3, -78.02, 1),
	            v4(34.19, 79.67, -78.02, 1),
	            v4(34.09, 81.05, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["464"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["464"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v294";
	Curves["465"] = function () {
	    var Curve_v01 = [[v4(6.74, 72.03, -72.55, 1),
	            v4(7.37, 72.02, -72.55, 1),
	            v4(10.04, 71.17, -72.55, 1),
	            v4(6.42, 66.73, -72.55, 1),
	            v4(3.21, 68.42, -72.55, 1),
	            v4(-0.62, 67.02, -72.55, 1),
	            v4(-0.56, 69.82, -72.55, 1),
	            v4(-0.21, 70.67, -72.55, 1),
	        ], [v4(7.54, 71.6, -72.62, 1),
	            v4(8.39, 71.59, -72.62, 1),
	            v4(11.97, 68.42, -72.62, 1),
	            v4(7.11, 62.66, -72.62, 1),
	            v4(2.8, 64.86, -72.62, 1),
	            v4(-2.34, 63.03, -72.62, 1),
	            v4(-2.25, 66.67, -72.62, 1),
	            v4(-1.79, 67.78, -72.62, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["465"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["465"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_21_5_v295";
	Curves["466"] = function () {
	    var Curve_v01 = [[v4(2.99, 74.1, -68.89, 1),
	            v4(2.87, 73.86, -68.88, 1),
	            v4(1.7, 72.74, -68.84, 1),
	            v4(-0.35, 75.53, -68.81, 1),
	            v4(0.05, 75.98, -68.81, 1),
	        ], [v4(10.09, 70.47, -69.04, 1),
	            v4(10.37, 69.43, -69.04, 1),
	            v4(4.4, 63.44, -69.11, 1),
	            v4(-4.16, 71.23, -69.01, 1),
	            v4(-2.63, 72.42, -69.01, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["466"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["466"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v296";
	Curves["467"] = function () {
	    var Curve_v01 = [[v4(16.76, 67.67, -78.02, 1),
	            v4(14.59, 68.1, -78.02, 1),
	            v4(12.42, 68.54, -78.02, 1),
	            v4(10.25, 68.97, -78.02, 1),
	        ], [v4(13.84, 63.7, -78.17, 1),
	            v4(11.67, 64.13, -78.17, 1),
	            v4(9.5, 64.57, -78.17, 1),
	            v4(7.32, 65, -78.17, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["467"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["467"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v297";
	Curves["468"] = function () {
	    var Curve_v01 = [[v4(14.84, 64.21, -78.01, 1),
	            v4(14.08, 64.22, -78.01, 1),
	            v4(12.01, 62.68, -78.01, 1),
	            v4(14.18, 60.51, -78.01, 1),
	            v4(15.14, 60.68, -78.01, 1),
	        ], [v4(10.47, 64.68, -78.02, 1),
	            v4(9.7, 64.69, -78.02, 1),
	            v4(7.63, 63.15, -78.02, 1),
	            v4(9.8, 60.98, -78.02, 1),
	            v4(10.76, 61.15, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["468"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["468"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v298";
	Curves["469"] = function () {
	    var Curve_v01 = [[v4(6.2, 64.97, -78.02, 1),
	            v4(7.45, 61.71, -78.02, 1),
	            v4(8.71, 58.46, -78.02, 1),
	            v4(9.96, 55.21, -78.02, 1),
	        ], [v4(2.39, 64.97, -78.02, 1),
	            v4(3.64, 61.71, -78.02, 1),
	            v4(4.9, 58.46, -78.02, 1),
	            v4(6.15, 55.21, -78.02, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["469"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["469"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v299";
	Curves["470"] = function () {
	    var Curve_v01 = [[v4(19.44, 110.6, -78.06, 1),
	            v4(18.44, 110.39, -78.06, 1),
	            v4(15.96, 112.61, -78.06, 1),
	            v4(18.98, 113.34, -78.06, 1),
	            v4(19.74, 113.06, -78.06, 1),
	        ], [v4(12.19, 107.76, -78.06, 1),
	            v4(10.26, 107.07, -78.06, 1),
	            v4(5.51, 114.27, -78.06, 1),
	            v4(11.31, 116.66, -78.06, 1),
	            v4(12.75, 115.76, -78.06, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 4;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["470"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["470"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_9_5_v300";
	Curves["471"] = function () {
	    var Curve_v01 = [[v4(16.07, 110.33, -74.93, 1),
	            v4(16.07, 111.02, -74.93, 1),
	            v4(16.07, 111.71, -74.93, 1),
	            v4(16.07, 112.39, -74.93, 1),
	        ], [v4(14.15, 109.05, -74.93, 1),
	            v4(14.15, 109.73, -74.93, 1),
	            v4(14.15, 110.42, -74.93, 1),
	            v4(14.15, 111.11, -74.93, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 3;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["471"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["471"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_5_5_v301";
	Curves["472"] = function () {
	    var Curve_v01 = [[v4(-15.85, -5.05, -22.88, 1),
	            v4(-16.12, -3.62, -23.75, 1),
	            v4(-16.24, -0.23, -25.78, 1),
	            v4(-15.09, 4.09, -28.78, 1),
	            v4(-13.21, 6.36, -31.04, 1),
	            v4(-10.5, 8.09, -33.17, 1),
	            v4(-6.66, 9.83, -34.57, 1),
	            v4(1.16, 15, -35.86, 1),
	            v4(9.98, 20.79, -37.87, 1),
	            v4(20.54, 28.73, -42.04, 1),
	            v4(26.59, 40.94, -49.57, 1),
	            v4(28.13, 48.57, -56.75, 1),
	            v4(27.19, 53.16, -59.88, 1),
	        ], [v4(-18.25, -15.3, -23.31, 1),
	            v4(-19.04, -14.28, -24.18, 1),
	            v4(-20.63, -11.34, -26.21, 1),
	            v4(-21.82, -4.91, -29.21, 1),
	            v4(-20.81, 1.33, -31.48, 1),
	            v4(-17.39, 7.55, -33.59, 1),
	            v4(-11.54, 12.03, -34.97, 1),
	            v4(-2.19, 17.62, -36.25, 1),
	            v4(6.31, 24.11, -38.27, 1),
	            v4(16.5, 32.78, -42.25, 1),
	            v4(25.09, 48.02, -48.77, 1),
	            v4(24.05, 57.04, -55.05, 1),
	            v4(23.58, 60.34, -57.87, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["472"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["472"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_41_5_v305";
	Curves["473"] = function () {
	    var Curve_v01 = [[v4(28.37, 123.71, -86.3, 1),
	            v4(21.89, 126.93, -84.99, 1),
	            v4(15.72, 136.06, -79.11, 1),
	            v4(14.21, 147.91, -72.4, 1),
	            v4(13.38, 155.48, -70.23, 1),
	            v4(15.36, 162.29, -66.52, 1),
	            v4(17.1, 168.65, -61.56, 1),
	            v4(18.75, 173.98, -57.77, 1),
	            v4(22.3, 180.03, -55.69, 1),
	            v4(25.61, 183.48, -55.69, 1),
	            v4(27.85, 185.25, -55.69, 1),
	        ], [v4(19.93, 124.91, -86.3, 1),
	            v4(13.45, 127.97, -84.99, 1),
	            v4(7.28, 136.53, -79.28, 1),
	            v4(5.77, 147.94, -72.71, 1),
	            v4(4.94, 155.48, -70.3, 1),
	            v4(6.95, 162.29, -66.52, 1),
	            v4(9.31, 168.65, -61.56, 1),
	            v4(11.87, 173.98, -57.77, 1),
	            v4(16.47, 180.03, -55.69, 1),
	            v4(20.17, 183.48, -55.69, 1),
	            v4(22.48, 185.25, -55.69, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 10;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["473"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["473"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_33_5_v308";
	Curves["474"] = function () {
	    var Curve_v01 = [[v4(-19.21, 102.31, -85.69, 1),
	            v4(-18.54, 102.88, -85.69, 1),
	            v4(-17.2, 104.02, -85.69, 1),
	            v4(-12.12, 104.79, -85.69, 1),
	            v4(-6.74, 103.3, -85.69, 1),
	            v4(-2.37, 99.74, -85.69, 1),
	            v4(-1.78, 95.7, -85.69, 1),
	            v4(-3.12, 92.32, -85.69, 1),
	        ], [v4(-15.47, 106.8, -85.69, 1),
	            v4(-14.72, 107.76, -85.69, 1),
	            v4(-13.23, 109.69, -85.69, 1),
	            v4(-6.21, 112.28, -85.69, 1),
	            v4(1.93, 110.64, -85.69, 1),
	            v4(7.06, 104.24, -85.69, 1),
	            v4(4.72, 97.76, -85.69, 1),
	            v4(0.66, 93.99, -85.69, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 7;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["474"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["474"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_21_5_v312";
	Curves["475"] = function () {
	    var Curve_v01 = [[v4(-8.29, -6.85, -32.99, 1),
	            v4(-8.76, -3.63, -34.96, 1),
	            v4(-6.43, 2.71, -39.05, 1),
	            v4(1.1, 7.98, -39.36, 1),
	            v4(13.3, 16.67, -35.61, 1),
	            v4(23.67, 26.73, -33.79, 1),
	            v4(29.23, 39.42, -36.92, 1),
	            v4(29.36, 48.63, -40.94, 1),
	            v4(29.1, 51.98, -42.74, 1),
	        ], [v4(-16.67, -2.54, -34.22, 1),
	            v4(-16.55, 0.45, -36.19, 1),
	            v4(-12.83, 6.65, -40.28, 1),
	            v4(-3.33, 11.48, -40.86, 1),
	            v4(10.77, 20.15, -37.31, 1),
	            v4(21.83, 30.9, -35.09, 1),
	            v4(26.4, 44.99, -38.45, 1),
	            v4(25.53, 53.79, -42.61, 1),
	            v4(24.86, 56.92, -44.91, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["475"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["475"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_25_5_v315";
	Curves["476"] = function () {
	    var Curve_v01 = [[v4(25.01, 0.56, -27.52, 1),
	            v4(25.9, 3.21, -28.97, 1),
	            v4(27.47, 6.65, -30.76, 1),
	            v4(33.37, 12.65, -33.99, 1),
	            v4(38.1, 17.45, -38.92, 1),
	            v4(40.97, 21.77, -40.89, 1),
	            v4(42.45, 26.41, -44.85, 1),
	            v4(43.35, 32.13, -48.63, 1),
	            v4(43.61, 45.16, -52.39, 1),
	            v4(37.37, 66.23, -59.42, 1),
	            v4(29.32, 73.74, -66.81, 1),
	            v4(26.53, 75.18, -70.38, 1),
	        ], [v4(20.09, -2.27, -27.52, 1),
	            v4(20.98, 0.38, -28.97, 1),
	            v4(22.55, 3.81, -30.76, 1),
	            v4(26.91, 12.58, -33.99, 1),
	            v4(32.59, 17.52, -38.92, 1),
	            v4(34.54, 21.37, -40.89, 1),
	            v4(37.53, 26.02, -44.85, 1),
	            v4(38.52, 33.31, -48.63, 1),
	            v4(38.88, 52.66, -52.39, 1),
	            v4(26.15, 69.95, -59.42, 1),
	            v4(19.51, 74.13, -66.81, 1),
	            v4(16.71, 75.57, -70.38, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 11;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["476"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["476"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_37_5_v314";
	Curves["477"] = function () {
	    var Curve_v01 = [[v4(-5.59, -24.2, -18.39, 1),
	            v4(-6.36, -14.9, -20.15, 1),
	            v4(-3.27, -4.82, -20.51, 1),
	            v4(7.81, 4.87, -21.81, 1),
	            v4(19.26, 11.25, -26.34, 1),
	            v4(29.08, 17.66, -36.13, 1),
	            v4(33.91, 28.82, -45.5, 1),
	            v4(36.19, 39.52, -52.89, 1),
	            v4(36.99, 45.53, -58.1, 1),
	            v4(36.5, 50.24, -61.3, 1),
	            v4(35.73, 53.22, -62.05, 1),
	            v4(35.4, 54.33, -62.16, 1),
	        ], [v4(-7.02, -27.36, -18.39, 1),
	            v4(-8.69, -16.39, -20.15, 1),
	            v4(-6.84, -4.61, -20.51, 1),
	            v4(2.39, 5.42, -21.81, 1),
	            v4(12.5, 11.13, -26.34, 1),
	            v4(23.87, 16.71, -36.13, 1),
	            v4(31.06, 26.95, -45.5, 1),
	            v4(31.41, 41.39, -52.89, 1),
	            v4(30.79, 50.44, -58.1, 1),
	            v4(30.31, 56.56, -61.3, 1),
	            v4(29.58, 59.79, -62.05, 1),
	            v4(29.25, 60.9, -62.16, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 11;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["477"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["477"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_37_5_v313";
	Curves["478"] = function () {
	    var Curve_v01 = [[v4(-15.36, -4.12, -9.75, 1),
	            v4(-15.19, -3.04, -10.53, 1),
	            v4(-14.47, -0.61, -12.16, 1),
	            v4(-11.78, 3.95, -15.43, 1),
	            v4(-7.48, 9.08, -20.68, 1),
	            v4(-4.26, 12.18, -25.81, 1),
	            v4(-2.04, 14.72, -30.13, 1),
	            v4(-0.57, 16.57, -32.48, 1),
	            v4(0.23, 17.55, -33.43, 1),
	        ], [v4(-18.9, -8.4, -8.63, 1),
	            v4(-19.29, -5.97, -10.62, 1),
	            v4(-19.2, -2.04, -14.76, 1),
	            v4(-17.94, 2.85, -20.51, 1),
	            v4(-16.17, 7.39, -25.42, 1),
	            v4(-13.68, 11.01, -29.07, 1),
	            v4(-9.7, 14.07, -31.86, 1),
	            v4(-6.7, 15.7, -33.46, 1),
	            v4(-5.32, 16.41, -34.22, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 8;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["478"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["478"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_26_5_v316";
	Curves["479"] = function () {
	    var Curve_v01 = [[v4(-25.36, -14.07, -30.45, 1),
	            v4(-25.2, -9.34, -31.73, 1),
	            v4(-21.83, -0.5, -34.05, 1),
	            v4(-10.33, 9.96, -36.67, 1),
	            v4(3.82, 19.08, -38.69, 1),
	            v4(16.23, 29.91, -40.74, 1),
	            v4(23.19, 43.92, -43.71, 1),
	            v4(22.51, 58.85, -48.31, 1),
	            v4(16.36, 65.95, -52.58, 1),
	            v4(11.83, 67.73, -54.95, 1),
	        ], [v4(-27.21, -5.3, -30.95, 1),
	            v4(-26.44, -0.43, -32.7, 1),
	            v4(-21.83, 7.1, -35.43, 1),
	            v4(-9.51, 15.17, -38.01, 1),
	            v4(3.91, 23.6, -39.91, 1),
	            v4(13.97, 34.88, -41.83, 1),
	            v4(17.19, 48.74, -44.35, 1),
	            v4(12.47, 61.93, -48.21, 1),
	            v4(5.21, 67.06, -52.45, 1),
	            v4(1.2, 67.84, -55.25, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["479"].animation = [[3084, -1], [3084.01, 1], [3156.99, -1], [3234.01, -1], [3234.02, 1], [3307, -1], [3381.01, -1], [3381.02, 1], [3454, -1], [3527.01, -1], [3527.015, 1], [3600, -1], [3673.01, -1], [3673.015, 1], [3746, -1], [3819.01, -1], [3819.015, 1], [3892, -1], [3965.01, -1], [3965.015, 1], [4038, -1], [4111.01, -1], [4111.015, 1], [4184, -1], [4257.01, -1], [4257.015, 1], [4330, -1], [4403, -1]];
	Curves["479"].divisions = "|MAEmodelsPrevis|colorRibbonNarrow_4000_1_3_124_230_247_200_40_100_100_100_40|_29_5_v317";
	Curves.numCurves = 480;
	Curves["480"] = function () {
	    var Curve_v01 = [[v4(2.3, -2.03, -20.87, 1),
	            v4(4.11, -0.7, -20.88, 1),
	            v4(7.82, 1.81, -21.32, 1),
	            v4(13.34, 5.34, -22.95, 1),
	            v4(18.6, 8.89, -25.28, 1),
	            v4(23.46, 12.65, -28.13, 1),
	            v4(27.7, 16.77, -31.38, 1),
	            v4(31.12, 21.34, -34.97, 1),
	            v4(33.56, 26.34, -38.78, 1),
	            v4(35.08, 31.64, -42.67, 1),
	            v4(35.85, 37.14, -46.52, 1),
	            v4(36.02, 42.76, -50.26, 1),
	            v4(35.69, 48.43, -53.92, 1),
	            v4(34.88, 54.01, -57.63, 1),
	            v4(33.6, 59.33, -61.59, 1),
	            v4(31.79, 64.2, -65.93, 1),
	            v4(29.21, 68.48, -70.51, 1),
	            v4(25.48, 72.06, -74.86, 1),
	            v4(20.39, 74.92, -78.32, 1),
	            v4(14.28, 77.35, -80.24, 1),
	            v4(7.93, 79.81, -80.07, 1),
	            v4(2.33, 82.85, -77.75, 1),
	            v4(-1.76, 86.74, -74.32, 1),
	            v4(-4.24, 91.22, -71.57, 1),
	            v4(-5.49, 95.77, -70.58, 1),
	            v4(-5.54, 100.08, -71.28, 1),
	            v4(-3.9, 103.99, -73.32, 1),
	            v4(-0.21, 106.97, -76.85, 1),
	            v4(4.67, 107.88, -81.49, 1),
	            v4(8.46, 106.02, -84.84, 1),
	            v4(9.19, 102.46, -84.06, 1),
	            v4(7.88, 100.32, -80.9, 1),
	            v4(7.21, 99.56, -79.3, 1),
	        ], [v4(-19.79, -12.32, -6.09, 1),
	            v4(-18.64, -9.87, -6.11, 1),
	            v4(-16.28, -5.02, -6.74, 1),
	            v4(-11.99, 1.58, -8.65, 1),
	            v4(-6.76, 7.27, -11.07, 1),
	            v4(-0.94, 12.26, -13.8, 1),
	            v4(4.92, 17.09, -16.71, 1),
	            v4(10.46, 22.2, -19.73, 1),
	            v4(15.48, 27.78, -22.86, 1),
	            v4(19.75, 33.85, -26.18, 1),
	            v4(22.91, 40.39, -29.82, 1),
	            v4(24.73, 47.13, -33.98, 1),
	            v4(25.26, 53.55, -38.95, 1),
	            v4(24.69, 59.14, -44.85, 1),
	            v4(23.04, 63.58, -51.53, 1),
	            v4(19.9, 66.79, -58.51, 1),
	            v4(14.77, 69.18, -64.51, 1),
	            v4(7.45, 71.67, -67.46, 1),
	            v4(-1.71, 75.11, -66.4, 1),
	            v4(-10.04, 79.9, -63.08, 1),
	            v4(-15.94, 85.23, -60.42, 1),
	            v4(-19.7, 90.89, -60.02, 1),
	            v4(-21.85, 97.19, -61.69, 1),
	            v4(-22.31, 103.55, -64.55, 1),
	            v4(-20.17, 110.12, -68.02, 1),
	            v4(-15.54, 115.43, -72.13, 1),
	            v4(-9.89, 117.99, -77.03, 1),
	            v4(-4.23, 116.73, -82.3, 1),
	            v4(0.37, 111.68, -86.78, 1),
	            v4(3.19, 105.2, -88.79, 1),
	            v4(4.42, 99.3, -86.56, 1),
	            v4(4.3, 97.27, -82.1, 1),
	            v4(3.99, 97.22, -79.55, 1),
	        ], [v4(-29.84, -22.73, -20.87, 1),
	            v4(-30.11, -19.85, -20.88, 1),
	            v4(-29.59, -14.15, -21.67, 1),
	            v4(-26.29, -6.44, -24.06, 1),
	            v4(-21.35, 0.22, -26.92, 1),
	            v4(-15.57, 6.04, -29.95, 1),
	            v4(-9.43, 11.3, -33.13, 1),
	            v4(-3.1, 16.21, -36.47, 1),
	            v4(3.25, 20.96, -40.02, 1),
	            v4(9.35, 25.87, -43.83, 1),
	            v4(14.77, 31.31, -48.02, 1),
	            v4(18.8, 37.43, -52.77, 1),
	            v4(20.63, 43.93, -58.25, 1),
	            v4(19.65, 50.15, -64.26, 1),
	            v4(15.77, 55.62, -69.9, 1),
	            v4(9.47, 60.21, -73.85, 1),
	            v4(1.83, 63.95, -75.32, 1),
	            v4(-5.67, 66.87, -74.48, 1),
	            v4(-11.96, 69.09, -71.94, 1),
	            v4(-17.16, 71, -68.66, 1),
	            v4(-22.3, 73.46, -66.3, 1),
	            v4(-28, 77.48, -66.44, 1),
	            v4(-33.27, 83.54, -69.09, 1),
	            v4(-35.89, 90.75, -72.89, 1),
	            v4(-34.54, 97.11, -76.57, 1),
	            v4(-30.29, 101.31, -79.67, 1),
	            v4(-25.34, 103.75, -82.31, 1),
	            v4(-20.72, 105.38, -84.78, 1),
	            v4(-16.07, 106.25, -87.02, 1),
	            v4(-11.25, 105.49, -88.02, 1),
	            v4(-7.25, 102.64, -86.15, 1),
	            v4(-5.79, 100.07, -82.53, 1),
	            v4(-5.36, 98.93, -80.34, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["480"].animation = [[2859, 1], [3051, 0.3862176645], [3140, 0.2670583093], [4202, 0.02916583781], [4269, -0.5167973122], [4307, -1]];
	Curves["480"].divisions = "|MAEmodelsPrevis|RibbonWideREDO_2000_1_2_124_202_247_100_100_300_300_200_20|_61_5_v4";
	Curves["481"] = function () {
	    var Curve_v01 = [[v4(4.83, -8.41, -23.99, 1),
	            v4(6.79, -7, -24, 1),
	            v4(10.82, -4.41, -24.43, 1),
	            v4(16.88, -0.79, -26.03, 1),
	            v4(22.69, 2.85, -28.36, 1),
	            v4(28.08, 6.7, -31.27, 1),
	            v4(32.9, 10.89, -34.66, 1),
	            v4(36.98, 15.47, -38.47, 1),
	            v4(40.18, 20.47, -42.59, 1),
	            v4(42.49, 25.79, -46.91, 1),
	            v4(44.03, 31.35, -51.27, 1),
	            v4(44.91, 37.09, -55.58, 1),
	            v4(45.22, 42.97, -59.77, 1),
	            v4(44.96, 48.92, -63.87, 1),
	            v4(44.07, 54.82, -67.95, 1),
	            v4(42.47, 60.54, -72.09, 1),
	            v4(40, 65.89, -76.32, 1),
	            v4(36.49, 70.66, -80.48, 1),
	            v4(31.81, 74.66, -84.29, 1),
	            v4(26, 77.74, -87.43, 1),
	            v4(19.42, 79.9, -89.61, 1),
	            v4(12.74, 81.34, -90.37, 1),
	            v4(6.75, 82.39, -89.14, 1),
	            v4(2.19, 83.64, -85.83, 1),
	            v4(-0.71, 85.99, -81.32, 1),
	            v4(-2.34, 90.24, -76.98, 1),
	            v4(-3.19, 96.67, -73.85, 1),
	            v4(-2.67, 104.06, -72.97, 1),
	            v4(0.33, 109.28, -75.53, 1),
	            v4(5.14, 109.14, -80.6, 1),
	            v4(8.91, 103.6, -84.04, 1),
	            v4(8.89, 99.03, -82.54, 1),
	            v4(8.02, 97.68, -80.72, 1),
	        ], [v4(-22.2, -19.78, -7.67, 1),
	            v4(-20.86, -16.91, -7.69, 1),
	            v4(-17.9, -11.4, -8.39, 1),
	            v4(-12.47, -4.07, -10.67, 1),
	            v4(-6.15, 2.32, -13.64, 1),
	            v4(0.63, 8.12, -17.02, 1),
	            v4(7.29, 13.86, -20.69, 1),
	            v4(13.29, 20.03, -24.66, 1),
	            v4(18.32, 26.83, -28.95, 1),
	            v4(22.15, 34.12, -33.64, 1),
	            v4(24.69, 41.57, -38.94, 1),
	            v4(25.9, 48.67, -45.15, 1),
	            v4(25.72, 55.01, -52.41, 1),
	            v4(23.88, 60.39, -60.28, 1),
	            v4(19.91, 64.79, -67.57, 1),
	            v4(13.56, 68.29, -72.73, 1),
	            v4(5.33, 71.07, -74.72, 1),
	            v4(-3.5, 73.48, -73.65, 1),
	            v4(-11.63, 75.89, -70.72, 1),
	            v4(-18.18, 78.69, -67.56, 1),
	            v4(-23.14, 81.91, -65.49, 1),
	            v4(-26.67, 85.74, -64.92, 1),
	            v4(-28.26, 90.99, -65.68, 1),
	            v4(-27.38, 98.45, -66.81, 1),
	            v4(-24.27, 107.32, -67.98, 1),
	            v4(-19.55, 114.75, -70.18, 1),
	            v4(-13.25, 118.86, -73.92, 1),
	            v4(-5.96, 118.63, -79.08, 1),
	            v4(0.12, 113.8, -84.77, 1),
	            v4(3.09, 105.67, -89.05, 1),
	            v4(2.99, 97.59, -89.36, 1),
	            v4(1.53, 95.1, -85.93, 1),
	            v4(0.64, 95.48, -83.24, 1),
	        ], [v4(-36.97, -31.14, -23.99, 1),
	            v4(-37.62, -28.09, -24.01, 1),
	            v4(-37.85, -21.9, -24.96, 1),
	            v4(-35.4, -13.31, -27.93, 1),
	            v4(-30.98, -5.76, -31.61, 1),
	            v4(-25.47, 0.84, -35.57, 1),
	            v4(-19.43, 6.73, -39.7, 1),
	            v4(-13.1, 12.15, -44.03, 1),
	            v4(-6.71, 17.34, -48.55, 1),
	            v4(-0.57, 22.67, -53.29, 1),
	            v4(4.92, 28.49, -58.3, 1),
	            v4(9.17, 35.06, -63.71, 1),
	            v4(11.19, 42.3, -69.56, 1),
	            v4(9.83, 49.62, -75.25, 1),
	            v4(4.7, 56.04, -79.37, 1),
	            v4(-3.23, 60.84, -80.76, 1),
	            v4(-12.21, 64.09, -79.69, 1),
	            v4(-21.22, 66.4, -77.36, 1),
	            v4(-29.84, 69.07, -74.69, 1),
	            v4(-36.91, 73.13, -72.39, 1),
	            v4(-42.74, 78.63, -71.75, 1),
	            v4(-46.89, 85.88, -74.18, 1),
	            v4(-47.32, 93.91, -78.98, 1),
	            v4(-43.64, 100.11, -83.47, 1),
	            v4(-37.97, 103.68, -86.07, 1),
	            v4(-32.52, 104.83, -87.53, 1),
	            v4(-28.06, 104.25, -88.96, 1),
	            v4(-23.31, 102.85, -90.63, 1),
	            v4(-17.21, 100.9, -92.28, 1),
	            v4(-10.44, 98.49, -93.06, 1),
	            v4(-4.87, 95.5, -91.2, 1),
	            v4(-3.41, 93.58, -87.37, 1),
	            v4(-3.43, 92.96, -84.92, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["481"].animation = [[2859, 1], [3051, 0.3862176645], [3140, 0.2670583093], [4202, 0.02916583781], [4269, -0.5167973122], [4307, -1]];
	Curves["481"].divisions = "|MAEmodelsPrevis|RibbonWideREDO_2000_1_2_124_202_247_100_100_300_300_200_20|_61_5_v3";
	Curves.numCurves = 482;
	Curves["482"] = function () {
	    var Curve_v01 = [[v4(-11.85, 101.47, -82.96, 1),
	            v4(-10.59, 100.37, -80.73, 1),
	            v4(-5.5, 98.83, -78.46, 1),
	            v4(2.25, 98.2, -76.25, 1),
	            v4(10.28, 97.28, -75.07, 1),
	            v4(18.72, 101.98, -73.77, 1),
	            v4(13.01, 110.22, -70.94, 1),
	            v4(7.57, 114.95, -69.33, 1),
	            v4(0.07, 120.96, -67.61, 1),
	            v4(-6.92, 126.4, -66.24, 1),
	            v4(-12.93, 132.7, -64.87, 1),
	            v4(-17.43, 139.32, -63.64, 1),
	            v4(-20.82, 146.79, -62.4, 1),
	            v4(-20.93, 154.96, -61.24, 1),
	            v4(-17.23, 162.94, -60.33, 1),
	            v4(-11.53, 169.89, -59.83, 1),
	            v4(-5.68, 175.9, -59.68, 1),
	            v4(0.46, 181.31, -59.8, 1),
	            v4(6.82, 186.45, -60.15, 1),
	            v4(13.13, 191.63, -60.71, 1),
	            v4(18.96, 197.33, -61.52, 1),
	            v4(23.87, 203.83, -62.59, 1),
	            v4(27.25, 211.27, -63.8, 1),
	            v4(27.58, 219.59, -64.86, 1),
	            v4(24.3, 227.24, -65.45, 1),
	            v4(19.13, 233.59, -65.82, 1),
	            v4(13.2, 239.24, -66.12, 1),
	            v4(6.89, 244.43, -66.47, 1),
	            v4(0.58, 249.62, -66.94, 1),
	            v4(-5.43, 255.13, -67.71, 1),
	            v4(-10.83, 261.16, -69.05, 1),
	            v4(-13.62, 265.66, -70.5, 1),
	            v4(-14.66, 268.02, -71.38, 1),
	        ], [v4(-14.99, 96.73, -81.82, 1),
	            v4(-13.95, 95.91, -79.09, 1),
	            v4(-10.33, 94.27, -74.09, 1),
	            v4(-2.62, 92.84, -69.37, 1),
	            v4(6.09, 91.52, -66.11, 1),
	            v4(15.14, 92.32, -64.96, 1),
	            v4(24.4, 93.51, -66.58, 1),
	            v4(30.82, 100.81, -70.81, 1),
	            v4(24.54, 109.82, -70.33, 1),
	            v4(18.42, 115.42, -68.99, 1),
	            v4(10.38, 122.12, -67.62, 1),
	            v4(2.6, 128.52, -66.25, 1),
	            v4(-4.06, 135.7, -64.91, 1),
	            v4(-8.92, 143.3, -63.45, 1),
	            v4(-11.99, 151.94, -61.76, 1),
	            v4(-10.75, 161.17, -59.95, 1),
	            v4(-4.47, 169.29, -58.53, 1),
	            v4(2.98, 175.91, -57.67, 1),
	            v4(10.06, 181.82, -57.27, 1),
	            v4(17.1, 187.72, -57.27, 1),
	            v4(23.26, 194.61, -57.72, 1),
	            v4(27.9, 202.52, -58.59, 1),
	            v4(30.58, 211.36, -59.77, 1),
	            v4(29.79, 220.62, -61.04, 1),
	            v4(25.58, 228.87, -62.06, 1),
	            v4(19.65, 235.86, -62.79, 1),
	            v4(12.97, 242.17, -63.36, 1),
	            v4(6.04, 248.17, -63.9, 1),
	            v4(-0.86, 254.21, -64.57, 1),
	            v4(-7.34, 260.66, -65.54, 1),
	            v4(-12.72, 268.03, -67.12, 1),
	            v4(-14.62, 273.71, -68.79, 1),
	            v4(-14.98, 276.6, -69.76, 1),
	        ], [v4(-15.14, 92.82, -80.5, 1),
	            v4(-13.92, 91.89, -77.56, 1),
	            v4(-9.37, 89.64, -73.13, 1),
	            v4(-0.39, 86.59, -70.1, 1),
	            v4(9.15, 84.88, -68.85, 1),
	            v4(19.2, 85.3, -69.92, 1),
	            v4(27.97, 88.96, -71.77, 1),
	            v4(36.59, 93.61, -74.3, 1),
	            v4(40.19, 103.78, -76.1, 1),
	            v4(32.73, 111.84, -74.98, 1),
	            v4(24.62, 117.62, -74.27, 1),
	            v4(14.8, 123.89, -73.25, 1),
	            v4(6.81, 130.31, -72.24, 1),
	            v4(0.45, 137.82, -70.94, 1),
	            v4(-4.07, 146.4, -69.42, 1),
	            v4(-4.61, 156.15, -67.66, 1),
	            v4(0.17, 165.59, -65.81, 1),
	            v4(7.5, 173, -64.17, 1),
	            v4(14.75, 179.42, -62.89, 1),
	            v4(22.07, 185.87, -61.96, 1),
	            v4(29.03, 192.78, -61.35, 1),
	            v4(33.91, 201.46, -61.29, 1),
	            v4(35.18, 211.32, -61.95, 1),
	            v4(33.57, 221.01, -63.11, 1),
	            v4(28.94, 229.69, -64.32, 1),
	            v4(22.68, 237.16, -65.39, 1),
	            v4(15.4, 243.69, -66.31, 1),
	            v4(7.81, 249.79, -67.19, 1),
	            v4(0.28, 256.02, -68.13, 1),
	            v4(-6.67, 262.81, -69.32, 1),
	            v4(-12.23, 270.84, -71.03, 1),
	            v4(-13.7, 277.12, -72.73, 1),
	            v4(-13.71, 280.25, -73.67, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["482"].animation = [[2859, -1], [3140, -0.102], [4202, 0.191], [4269, 0.517], [4307, 1]];
	Curves["482"].divisions = "|MAEmodelsPrevis|RibbonWideREDOtop_2000_1_2_124_202_247_100_100_100_100_120_20|_61_5_v1";
	Curves["483"] = function () {
	    var Curve_v01 = [[v4(-13.23, 100.58, -87.04, 1),
	            v4(-12.58, 99.75, -84.56, 1),
	            v4(-7.61, 98.66, -82.39, 1),
	            v4(-0.86, 99, -80.54, 1),
	            v4(7.34, 101.52, -80.66, 1),
	            v4(9.3, 109.06, -78.61, 1),
	            v4(4.84, 115.7, -76.54, 1),
	            v4(-0.05, 121.97, -75.6, 1),
	            v4(-6.15, 127.73, -73.76, 1),
	            v4(-11.05, 133.44, -71.97, 1),
	            v4(-15.31, 139.37, -70.04, 1),
	            v4(-18.85, 145.73, -68.29, 1),
	            v4(-21.57, 152.57, -66.66, 1),
	            v4(-22.14, 159.91, -65.32, 1),
	            v4(-20.01, 167.39, -64.38, 1),
	            v4(-15.92, 174.43, -63.95, 1),
	            v4(-11.2, 180.69, -63.95, 1),
	            v4(-6.12, 186.22, -64.26, 1),
	            v4(-0.52, 191.18, -64.81, 1),
	            v4(5.25, 195.91, -65.54, 1),
	            v4(10.88, 200.8, -66.45, 1),
	            v4(16.01, 206.17, -67.51, 1),
	            v4(19.65, 212.77, -68.7, 1),
	            v4(20.09, 220.4, -69.65, 1),
	            v4(17.53, 227.54, -70.13, 1),
	            v4(13.42, 233.83, -70.35, 1),
	            v4(8.52, 239.52, -70.48, 1),
	            v4(3.26, 244.86, -70.7, 1),
	            v4(-2.08, 250.11, -71.13, 1),
	            v4(-7.21, 255.52, -71.93, 1),
	            v4(-11.77, 261.35, -73.28, 1),
	            v4(-14.07, 265.61, -74.65, 1),
	            v4(-14.94, 267.81, -75.45, 1),
	        ], [v4(-13.09, 95.61, -85.98, 1),
	            v4(-12.54, 94.61, -83.24, 1),
	            v4(-9.45, 92.22, -77.94, 1),
	            v4(-0.98, 89.21, -73.35, 1),
	            v4(8.71, 86.53, -70.71, 1),
	            v4(18.57, 86, -70.6, 1),
	            v4(27.69, 86.91, -72.59, 1),
	            v4(34.24, 93.78, -75.7, 1),
	            v4(29.33, 103.69, -75.58, 1),
	            v4(22.58, 111.39, -74.52, 1),
	            v4(13.11, 120.12, -73.14, 1),
	            v4(4.15, 128.04, -71.49, 1),
	            v4(-2.43, 135.63, -69.65, 1),
	            v4(-6.87, 143.01, -67.64, 1),
	            v4(-9.78, 151.18, -65.57, 1),
	            v4(-9.66, 159.88, -63.64, 1),
	            v4(-5.8, 168.46, -62.23, 1),
	            v4(-0.22, 176.19, -61.47, 1),
	            v4(5.5, 183.04, -61.3, 1),
	            v4(11.55, 189.49, -61.54, 1),
	            v4(17.38, 196.13, -62.16, 1),
	            v4(22.44, 203.35, -63.13, 1),
	            v4(25.47, 211.7, -64.4, 1),
	            v4(25.13, 220.62, -65.68, 1),
	            v4(21.7, 228.83, -66.64, 1),
	            v4(16.45, 235.96, -67.28, 1),
	            v4(10.34, 242.34, -67.75, 1),
	            v4(3.87, 248.35, -68.2, 1),
	            v4(-2.57, 254.4, -68.79, 1),
	            v4(-8.53, 260.88, -69.72, 1),
	            v4(-13.29, 268.25, -71.28, 1),
	            v4(-14.85, 273.79, -72.91, 1),
	            v4(-15.11, 276.58, -73.83, 1),
	        ], [v4(-16.07, 91.61, -85.88, 1),
	            v4(-15.82, 89.57, -82.68, 1),
	            v4(-11.76, 85.13, -77.65, 1),
	            v4(-1.93, 80.19, -74.95, 1),
	            v4(8.04, 77.07, -74.23, 1),
	            v4(18.34, 75.32, -75.02, 1),
	            v4(28.53, 75.03, -77.03, 1),
	            v4(39.14, 76.21, -78.18, 1),
	            v4(48.3, 84.52, -79.06, 1),
	            v4(48.57, 97.81, -79.92, 1),
	            v4(43.24, 108.01, -79.89, 1),
	            v4(35.01, 115.72, -79.52, 1),
	            v4(24.91, 122.32, -78.83, 1),
	            v4(15.26, 128.31, -77.84, 1),
	            v4(7.14, 134.83, -76.44, 1),
	            v4(0.43, 142.88, -74.77, 1),
	            v4(-1.88, 152.88, -72.53, 1),
	            v4(2.39, 163.2, -70.09, 1),
	            v4(8.46, 172.01, -68.08, 1),
	            v4(15.04, 180.09, -66.53, 1),
	            v4(21.9, 187.97, -65.51, 1),
	            v4(28.17, 196.43, -65.05, 1),
	            v4(32.41, 206.18, -65.4, 1),
	            v4(33.15, 216.77, -66.59, 1),
	            v4(30.02, 226.84, -68.2, 1),
	            v4(24.26, 235.57, -69.64, 1),
	            v4(16.98, 243.12, -70.75, 1),
	            v4(9.05, 249.95, -71.53, 1),
	            v4(1.03, 256.72, -72.3, 1),
	            v4(-6.39, 264.09, -73.33, 1),
	            v4(-12.3, 272.76, -75.06, 1),
	            v4(-13.72, 279.55, -76.88, 1),
	            v4(-13.56, 282.91, -77.88, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 32;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["483"].animation = [[2859, -1], [3140, -0.102], [4202, 0.191], [4269, 0.517], [4307, 1]];
	Curves["483"].divisions = "|MAEmodelsPrevis|RibbonWideREDOtop_2000_1_2_124_202_247_100_100_100_100_120_20|_61_5_v2";
	Curves.numCurves = 484;
	Curves["484"] = function () {
	    var Curve_v01 = [[v4(-11.63, 90.52, -76.75, 1),
	            v4(-10.01, 89.73, -76.48, 1),
	            v4(-6.69, 88.59, -75.39, 1),
	            v4(-1.6, 87.46, -73.58, 1),
	            v4(3.65, 86.78, -71.84, 1),
	            v4(9.29, 86.52, -70.86, 1),
	            v4(15.04, 86.84, -71.33, 1),
	            v4(20.48, 87.66, -72.52, 1),
	            v4(25.72, 89.08, -73.84, 1),
	            v4(30.12, 90.99, -76.26, 1),
	            v4(33.01, 92.96, -79.86, 1),
	            v4(34.16, 94.19, -82.55, 1),
	            v4(34.59, 94.8, -83.95, 1),
	        ], [v4(-9.06, 88.54, -75.43, 1),
	            v4(-7.6, 87.51, -75.18, 1),
	            v4(-4.53, 85.94, -73.93, 1),
	            v4(0.2, 84.19, -71.78, 1),
	            v4(5.15, 82.88, -69.63, 1),
	            v4(10.69, 81.89, -68.25, 1),
	            v4(16.58, 81.43, -68.69, 1),
	            v4(22.14, 81.54, -70.12, 1),
	            v4(27.49, 82.23, -71.96, 1),
	            v4(32.02, 83.46, -74.78, 1),
	            v4(35.26, 84.96, -78.49, 1),
	            v4(36.68, 86.04, -81.25, 1),
	            v4(37.24, 86.58, -82.67, 1),
	        ], [v4(-7.52, 85.9, -76.75, 1),
	            v4(-6.37, 84.71, -76.48, 1),
	            v4(-3.76, 82.71, -75.39, 1),
	            v4(0.49, 80.27, -73.56, 1),
	            v4(5.12, 78.23, -71.8, 1),
	            v4(10.31, 76.48, -70.84, 1),
	            v4(15.81, 75.23, -71.37, 1),
	            v4(21.21, 74.5, -72.56, 1),
	            v4(26.68, 74.34, -73.88, 1),
	            v4(31.56, 74.86, -76.32, 1),
	            v4(35.07, 75.85, -79.89, 1),
	            v4(36.66, 76.67, -82.56, 1),
	            v4(37.32, 77.11, -83.95, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["484"].animation = [[2859, 1], [3140, 0.1017039777], [4202, -0.1913066127], [4269, -0.5167973122], [4307, -1]];
	Curves["484"].divisions = "|MAEmodelsPrevis|RibbonWideREDOflareOut_2000_2_2_124_202_247_50_50_300_300_80_20|_21_5_v336";
	Curves["485"] = function () {
	    var Curve_v01 = [[v4(-10.07, 90.94, -82.24, 1),
	            v4(-8.96, 90.01, -81.6, 1),
	            v4(-6.76, 88.53, -79.81, 1),
	            v4(-3.36, 86.78, -76.92, 1),
	            v4(0.29, 85.43, -74.01, 1),
	            v4(4.62, 84.47, -71.54, 1),
	            v4(9.61, 83.81, -70.18, 1),
	            v4(14.65, 83.28, -69.47, 1),
	            v4(19.69, 82.92, -68.87, 1),
	            v4(24.46, 83.03, -69.39, 1),
	            v4(28.36, 83.71, -71.31, 1),
	            v4(30.38, 84.4, -73.07, 1),
	            v4(31.29, 84.78, -74.03, 1),
	        ], [v4(-7.11, 88.96, -80.52, 1),
	            v4(-6.15, 87.86, -79.95, 1),
	            v4(-4.27, 86.05, -78.14, 1),
	            v4(-1.34, 83.81, -75.11, 1),
	            v4(1.84, 81.94, -71.99, 1),
	            v4(5.79, 80.32, -69.31, 1),
	            v4(10.6, 78.96, -67.99, 1),
	            v4(15.5, 77.8, -67.56, 1),
	            v4(20.44, 76.81, -67.5, 1),
	            v4(25.13, 76.33, -68.43, 1),
	            v4(29.15, 76.52, -70.41, 1),
	            v4(31.36, 77, -72.17, 1),
	            v4(32.37, 77.28, -73.11, 1),
	        ], [v4(-6.09, 86.24, -82.06, 1),
	            v4(-5.42, 85.04, -81.58, 1),
	            v4(-3.92, 82.93, -80.06, 1),
	            v4(-1.38, 80.18, -77.48, 1),
	            v4(1.54, 77.72, -74.83, 1),
	            v4(5.17, 75.5, -72.66, 1),
	            v4(9.46, 73.6, -71.62, 1),
	            v4(13.84, 71.93, -71.16, 1),
	            v4(18.32, 70.38, -70.79, 1),
	            v4(22.81, 69.29, -71.44, 1),
	            v4(26.76, 68.93, -73.34, 1),
	            v4(29, 69.1, -75.01, 1),
	            v4(30.04, 69.27, -75.91, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["485"].animation = [[2859, 1], [3140, 0.1017039777], [4202, -0.1913066127], [4269, -0.5167973122], [4307, -1]];
	Curves["485"].divisions = "|MAEmodelsPrevis|RibbonWideREDOflareOut_2000_2_2_124_202_247_50_50_300_300_80_20|_21_5_v337";
	Curves["486"] = function () {
	    var Curve_v01 = [[v4(-16.21, 80.41, -72.32, 1),
	            v4(-16.08, 79.83, -72.04, 1),
	            v4(-16.65, 78.76, -71.52, 1),
	            v4(-19.56, 77.46, -71.15, 1),
	            v4(-24.38, 76.68, -71.63, 1),
	            v4(-30.43, 76.78, -72.46, 1),
	            v4(-36.17, 77.22, -73.41, 1),
	            v4(-40.82, 77.7, -74.79, 1),
	            v4(-42.9, 78.02, -75.97, 1),
	            v4(-43.55, 78.14, -76.62, 1),
	        ], [v4(-11.07, 76.74, -69.88, 1),
	            v4(-11.18, 76.08, -69.57, 1),
	            v4(-11.86, 74.68, -69.01, 1),
	            v4(-14.33, 72.47, -68.56, 1),
	            v4(-18.24, 70.3, -69, 1),
	            v4(-23.38, 68.86, -70.18, 1),
	            v4(-29.21, 68.42, -71.29, 1),
	            v4(-34.18, 68.18, -72.76, 1),
	            v4(-36.37, 68.12, -73.95, 1),
	            v4(-37.07, 68.12, -74.59, 1),
	        ], [v4(-2.51, 75.65, -71.97, 1),
	            v4(-2.11, 75.14, -71.78, 1),
	            v4(-1.89, 73.94, -71.44, 1),
	            v4(-3.06, 71.78, -71.16, 1),
	            v4(-5.57, 69.36, -71.44, 1),
	            v4(-9.29, 67.03, -72.46, 1),
	            v4(-13.93, 65.19, -73.47, 1),
	            v4(-18.34, 63.64, -74.41, 1),
	            v4(-20.53, 62.81, -75.15, 1),
	            v4(-21.35, 62.47, -75.55, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["486"].animation = [[2859, 1], [3140, 0.1017039777], [4202, -0.1913066127], [4269, -0.5167973122], [4307, -1]];
	Curves["486"].divisions = "|MAEmodelsPrevis|RibbonWideREDOflareOut_2000_2_2_124_202_247_50_50_300_300_80_20|_15_5_v2";
	Curves["487"] = function () {
	    var Curve_v01 = [[v4(-10.2, 74.59, -69.73, 1),
	            v4(-9.82, 74.2, -69.16, 1),
	            v4(-9.42, 73.31, -68.02, 1),
	            v4(-9.86, 71.54, -66.51, 1),
	            v4(-11.34, 69.18, -65.52, 1),
	            v4(-13.92, 66.33, -65.36, 1),
	            v4(-17.46, 63.61, -65.83, 1),
	            v4(-21.29, 61.4, -66.54, 1),
	            v4(-23.43, 60.12, -67.4, 1),
	            v4(-24.29, 59.56, -67.93, 1),
	        ], [v4(-5.8, 75.29, -68.62, 1),
	            v4(-5.41, 74.89, -68.01, 1),
	            v4(-4.76, 73.82, -66.82, 1),
	            v4(-4.35, 71.35, -65.28, 1),
	            v4(-4.72, 67.82, -64.36, 1),
	            v4(-6.14, 63.48, -64.46, 1),
	            v4(-8.65, 59.3, -65.09, 1),
	            v4(-11.43, 55.82, -65.64, 1),
	            v4(-12.81, 53.96, -66.28, 1),
	            v4(-13.3, 53.22, -66.66, 1),
	        ], [v4(-1.58, 76.53, -71.44, 1),
	            v4(-0.79, 76.58, -71.03, 1),
	            v4(0.46, 76.43, -70.21, 1),
	            v4(1.62, 75.51, -69.06, 1),
	            v4(2.32, 73.86, -68.1, 1),
	            v4(2.66, 71.42, -67.54, 1),
	            v4(2.56, 68.25, -67.61, 1),
	            v4(1.85, 64.64, -68.27, 1),
	            v4(0.96, 62.19, -68.8, 1),
	            v4(0.43, 61, -69.03, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 9;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["487"].animation = [[2859, 1], [3140, 0.1017039777], [4202, -0.1913066127], [4269, -0.5167973122], [4307, -1]];
	Curves["487"].divisions = "|MAEmodelsPrevis|RibbonWideREDOflareOut_2000_2_2_124_202_247_50_50_300_300_80_20|_15_5_v1";
	Curves.numCurves = 488;
	Curves["488"] = function () {
	    var Curve_v01 = [[v4(17.52, 21.16, -38.74, 1),
	            v4(18.9, 22.41, -40.39, 1),
	            v4(21.67, 24.9, -43.67, 1),
	            v4(26.19, 28.89, -48.1, 1),
	            v4(30.5, 33.98, -51.51, 1),
	            v4(33.75, 39.91, -54.71, 1),
	            v4(35.55, 46.45, -57.95, 1),
	            v4(35.34, 53.16, -61.33, 1),
	            v4(33.58, 59.43, -65.01, 1),
	            v4(31.19, 65.07, -69.29, 1),
	            v4(28.23, 69.91, -74.16, 1),
	            v4(23.75, 73.8, -78.82, 1),
	            v4(17.64, 76.74, -82.08, 1),
	            v4(10.71, 79.72, -83.05, 1),
	            v4(4.43, 83.52, -81.63, 1),
	            v4(-0.57, 88.56, -78.65, 1),
	            v4(-3.83, 94.13, -75.57, 1),
	            v4(-6.27, 101.8, -73.58, 1),
	            v4(-3.13, 108.42, -77.32, 1),
	            v4(1.61, 111.31, -81.61, 1),
	            v4(9.02, 109.64, -88.12, 1),
	            v4(7.92, 104.41, -84.23, 1),
	            v4(6.96, 103.35, -82.1, 1),
	        ], [v4(18.92, 28.72, -27.53, 1),
	            v4(20.68, 30.49, -29.11, 1),
	            v4(24.13, 34.16, -32.21, 1),
	            v4(28.6, 40.8, -36.16, 1),
	            v4(30.37, 48.62, -40.34, 1),
	            v4(28.76, 55.83, -45.48, 1),
	            v4(25.46, 61.68, -51.33, 1),
	            v4(21.74, 66.1, -58.08, 1),
	            v4(17.33, 69.23, -65.22, 1),
	            v4(9.9, 71.9, -69.89, 1),
	            v4(1.4, 75.1, -70.04, 1),
	            v4(-6.16, 79.34, -68.14, 1),
	            v4(-12.73, 84.84, -65.65, 1),
	            v4(-17.95, 91.95, -63.98, 1),
	            v4(-21.32, 100.31, -65.03, 1),
	            v4(-21.38, 108.74, -68.54, 1),
	            v4(-17.79, 115.84, -72.73, 1),
	            v4(-11.69, 120.48, -77.78, 1),
	            v4(-4.62, 119.82, -83.83, 1),
	            v4(0.73, 114.46, -88.71, 1),
	            v4(4.21, 105.28, -90.1, 1),
	            v4(4.25, 101.18, -84.73, 1),
	            v4(3.86, 101.12, -81.67, 1),
	        ], [v4(17.65, 29.42, -46.56, 1),
	            v4(19.05, 30.82, -48.39, 1),
	            v4(21.8, 33.74, -52.04, 1),
	            v4(25.56, 38.97, -56.99, 1),
	            v4(27.04, 45.36, -62.09, 1),
	            v4(24.51, 51.3, -67.36, 1),
	            v4(19.58, 56.05, -71.79, 1),
	            v4(13.4, 59.98, -75.33, 1),
	            v4(6.43, 63.47, -77.74, 1),
	            v4(-1.05, 66.66, -78.39, 1),
	            v4(-8.61, 69.47, -76.74, 1),
	            v4(-15.48, 71.63, -73.05, 1),
	            v4(-22.51, 75, -70.28, 1),
	            v4(-28.5, 80.82, -71.1, 1),
	            v4(-32.44, 87.54, -73.37, 1),
	            v4(-34.22, 94.98, -76.51, 1),
	            v4(-32.91, 102.37, -79.89, 1),
	            v4(-28.2, 108.49, -83.22, 1),
	            v4(-22.22, 112.68, -86.08, 1),
	            v4(-14.62, 115.24, -89.93, 1),
	            v4(-7, 110.65, -89.17, 1),
	            v4(-5.58, 106.4, -84.94, 1),
	            v4(-5.18, 104.81, -83.05, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["488"].animation = [[2859, 1], [3140, 0.1017039777], [4202, -0.1913066127], [4269, -0.5167973122], [4307, -1]];
	Curves["488"].divisions = "|MAEmodelsPrevis|tunnelRibbonWideREDO_2000_1_3_124_202_247_60_100_100_100_70_20|_41_5_v306";
	Curves["489"] = function () {
	    var Curve_v01 = [[v4(28.86, 38.73, -51.89, 1),
	            v4(29.54, 40.1, -53.31, 1),
	            v4(31.01, 42.8, -56.18, 1),
	            v4(33.95, 47.25, -59.56, 1),
	            v4(36.15, 52.63, -62.04, 1),
	            v4(37.26, 58.26, -64.65, 1),
	            v4(36.84, 63.9, -67.55, 1),
	            v4(34.76, 68.72, -71.12, 1),
	            v4(31.98, 72.48, -75.33, 1),
	            v4(28.53, 75.44, -79.71, 1),
	            v4(24.17, 77.67, -83.68, 1),
	            v4(18.99, 79.32, -86.95, 1),
	            v4(13.18, 80.71, -89.07, 1),
	            v4(6.78, 82, -89.31, 1),
	            v4(1.26, 84.01, -86.13, 1),
	            v4(-1.65, 88.07, -81.55, 1),
	            v4(-2.92, 93.9, -78.3, 1),
	            v4(-2.99, 100.25, -76.61, 1),
	            v4(-0.99, 106.9, -77.63, 1),
	            v4(3.91, 108.63, -82.23, 1),
	            v4(8.18, 103.92, -86.02, 1),
	            v4(8.68, 99.1, -85.2, 1),
	            v4(7.74, 97.67, -83.36, 1),
	        ], [v4(27.34, 43.69, -43.73, 1),
	            v4(28.29, 45.75, -45.31, 1),
	            v4(30.02, 49.83, -48.3, 1),
	            v4(31.32, 57.07, -52.47, 1),
	            v4(28.24, 62.6, -58.09, 1),
	            v4(23.53, 65.65, -64.05, 1),
	            v4(18.26, 67.98, -69.9, 1),
	            v4(11.3, 69.81, -74.06, 1),
	            v4(3.25, 71.58, -75.21, 1),
	            v4(-4.6, 73.58, -74.34, 1),
	            v4(-12.25, 76.01, -72.28, 1),
	            v4(-19, 79.28, -69.84, 1),
	            v4(-25.49, 84.3, -67.44, 1),
	            v4(-27.83, 93.12, -67.97, 1),
	            v4(-25.45, 102.14, -68.94, 1),
	            v4(-21.72, 110.52, -70.43, 1),
	            v4(-16.33, 117.05, -73.53, 1),
	            v4(-9.5, 120.19, -78.33, 1),
	            v4(-2.84, 117.76, -84.04, 1),
	            v4(1.37, 111.71, -88.77, 1),
	            v4(2.83, 100.87, -92.01, 1),
	            v4(1.17, 96.66, -87.93, 1),
	            v4(0.3, 96.86, -85.16, 1),
	        ], [v4(24.99, 44.48, -57.55, 1),
	            v4(25.51, 46.18, -59.49, 1),
	            v4(26.6, 49.51, -63.25, 1),
	            v4(25.75, 55.51, -68.84, 1),
	            v4(19.31, 58.39, -73.29, 1),
	            v4(12.39, 59.79, -76.23, 1),
	            v4(4.77, 60.95, -78.14, 1),
	            v4(-2.88, 62.23, -78.84, 1),
	            v4(-10.66, 63.78, -78.5, 1),
	            v4(-19.51, 65.3, -77.32, 1),
	            v4(-28.97, 68.23, -75.74, 1),
	            v4(-37.69, 73.89, -74.82, 1),
	            v4(-43.72, 82.05, -76.33, 1),
	            v4(-45.55, 90.58, -79.92, 1),
	            v4(-43.49, 97.58, -84.17, 1),
	            v4(-38.26, 102.51, -87.81, 1),
	            v4(-31.08, 104.26, -89.97, 1),
	            v4(-24.39, 102.94, -92.03, 1),
	            v4(-18.06, 101.28, -93.81, 1),
	            v4(-11.67, 99.7, -94.43, 1),
	            v4(-5.41, 97.26, -93.17, 1),
	            v4(-3.26, 94.68, -89.53, 1),
	            v4(-3.27, 93.69, -87.16, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["489"].animation = [[2859, 1], [3140, 0.1017039777], [4202, -0.1913066127], [4269, -0.5167973122], [4307, -1]];
	Curves["489"].divisions = "|MAEmodelsPrevis|tunnelRibbonWideREDO_2000_1_3_124_202_247_60_100_100_100_70_20|_41_5_v307";
	Curves["490"] = function () {
	    var Curve_v01 = [[v4(0.13, 19.54, -34.55, 1),
	            v4(2.19, 20.44, -36.2, 1),
	            v4(6.47, 22.29, -39.34, 1),
	            v4(12.67, 25.63, -43.53, 1),
	            v4(17.99, 29.9, -47.24, 1),
	            v4(22.32, 35.37, -51.5, 1),
	            v4(25.09, 42.31, -56.67, 1),
	            v4(25.29, 50.24, -62.13, 1),
	            v4(22.88, 57.78, -67.53, 1),
	            v4(18.72, 63.68, -72.47, 1),
	            v4(13.5, 67.72, -76.52, 1),
	            v4(7.13, 70.53, -78.92, 1),
	            v4(-0.71, 73.02, -79.71, 1),
	            v4(-9.37, 75.99, -79.61, 1),
	            v4(-18.07, 79.84, -77.93, 1),
	            v4(-25.45, 84.74, -74.98, 1),
	            v4(-29.77, 90.61, -73.41, 1),
	            v4(-29.81, 96.45, -74.2, 1),
	            v4(-25.13, 100.73, -77.48, 1),
	            v4(-16.45, 102.48, -83.27, 1),
	            v4(-7.37, 101.47, -87.63, 1),
	            v4(-4.48, 99.54, -86.45, 1),
	            v4(-4.56, 98.57, -84.36, 1),
	        ], [v4(2.9, 21.79, -38.03, 1),
	            v4(5.48, 22.91, -39.98, 1),
	            v4(10.45, 25.75, -43.6, 1),
	            v4(16.66, 31.93, -48.57, 1),
	            v4(21.44, 39.91, -54.22, 1),
	            v4(22.94, 49.42, -59.84, 1),
	            v4(19.92, 58.68, -64.67, 1),
	            v4(13.53, 65.55, -68.09, 1),
	            v4(5.59, 69.68, -69.45, 1),
	            v4(-2.72, 72.42, -69.14, 1),
	            v4(-11.29, 75.07, -68.13, 1),
	            v4(-19.89, 78.17, -65.97, 1),
	            v4(-28.36, 81.99, -62.93, 1),
	            v4(-35.96, 86.88, -60.64, 1),
	            v4(-41.44, 92.98, -60.41, 1),
	            v4(-43.3, 99.96, -62.98, 1),
	            v4(-40.55, 106.7, -68.54, 1),
	            v4(-34.06, 111.12, -75.88, 1),
	            v4(-25.51, 111.55, -83.48, 1),
	            v4(-16.99, 107.88, -89.12, 1),
	            v4(-10.37, 102.26, -90.3, 1),
	            v4(-8.07, 99.94, -86.93, 1),
	            v4(-7.67, 99.98, -83.92, 1),
	        ], [v4(3.62, 26.29, -41.32, 1),
	            v4(5.44, 26.98, -42.79, 1),
	            v4(9.29, 28.65, -45.75, 1),
	            v4(14.35, 32.19, -50.3, 1),
	            v4(17.74, 36.79, -55.24, 1),
	            v4(18.57, 42.42, -60.72, 1),
	            v4(16.21, 48.52, -66.42, 1),
	            v4(10.81, 54, -71.16, 1),
	            v4(3.26, 58.11, -73.61, 1),
	            v4(-5.17, 61.23, -74.1, 1),
	            v4(-13.59, 64.42, -73.97, 1),
	            v4(-22.47, 67.8, -73.02, 1),
	            v4(-31.59, 71.58, -71.24, 1),
	            v4(-39.85, 76.22, -69.93, 1),
	            v4(-46.09, 81.96, -70.11, 1),
	            v4(-49.24, 88.69, -72.24, 1),
	            v4(-48.53, 95.72, -76.22, 1),
	            v4(-44.04, 101.7, -80.96, 1),
	            v4(-36.33, 105.35, -85.61, 1),
	            v4(-26.9, 105.87, -88.94, 1),
	            v4(-17.87, 103.41, -89.38, 1),
	            v4(-13.68, 100.52, -87.15, 1),
	            v4(-12.43, 99.03, -85.3, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["490"].animation = [[2859, 1], [3140, 0.1017039777], [4202, -0.1913066127], [4269, -0.5167973122], [4307, -1]];
	Curves["490"].divisions = "|MAEmodelsPrevis|tunnelRibbonWideREDO_2000_1_3_124_202_247_60_100_100_100_70_20|_41_5_v308";
	Curves.numCurves = 491;
	Curves["491"] = function () {
	    var Curve_v01 = [[v4(-12.78, 100.34, -91.67, 1),
	            v4(-12.1, 99.48, -89.22, 1),
	            v4(-7.4, 98.43, -86.77, 1),
	            v4(-0.15, 98.87, -85.95, 1),
	            v4(7.26, 102.61, -85.16, 1),
	            v4(7.51, 110.76, -83.42, 1),
	            v4(3.08, 116.78, -81.98, 1),
	            v4(-1.82, 122.24, -80.69, 1),
	            v4(-7.11, 127.4, -79.28, 1),
	            v4(-11.88, 132.92, -77.6, 1),
	            v4(-16.11, 138.87, -75.83, 1),
	            v4(-19.48, 145.37, -74.16, 1),
	            v4(-21.38, 152.55, -72.68, 1),
	            v4(-20.72, 160.06, -71.56, 1),
	            v4(-17.8, 167, -70.94, 1),
	            v4(-13.62, 173.24, -70.75, 1),
	            v4(-8.69, 178.89, -70.9, 1),
	            v4(-3.17, 183.98, -71.13, 1),
	            v4(2.87, 188.42, -71.24, 1),
	            v4(9.11, 192.56, -71.21, 1),
	            v4(15.17, 196.98, -71.21, 1),
	            v4(18.98, 200.21, -71.28, 1),
	            v4(20.84, 201.88, -71.33, 1),
	        ], [v4(-12.53, 95.38, -90.01, 1),
	            v4(-11.94, 94.34, -87.32, 1),
	            v4(-8.51, 92, -82.53, 1),
	            v4(-0.25, 88.93, -78.15, 1),
	            v4(9.4, 86.57, -76.25, 1),
	            v4(18.8, 86.03, -76.39, 1),
	            v4(27.86, 87.97, -78.23, 1),
	            v4(31.98, 96.26, -80.52, 1),
	            v4(27, 105.06, -80.34, 1),
	            v4(19.93, 112.28, -79.39, 1),
	            v4(11.52, 119.61, -78.11, 1),
	            v4(3.7, 126.75, -76.69, 1),
	            v4(-2.83, 134.03, -75.06, 1),
	            v4(-7.3, 141.38, -73.22, 1),
	            v4(-9.62, 149.54, -71.28, 1),
	            v4(-8.74, 158.05, -69.57, 1),
	            v4(-5.09, 165.8, -68.41, 1),
	            v4(-0.04, 172.73, -67.8, 1),
	            v4(5.76, 179.06, -67.77, 1),
	            v4(11.68, 185.23, -68.25, 1),
	            v4(17.26, 191.72, -68.84, 1),
	            v4(20.79, 196.2, -69.21, 1),
	            v4(22.52, 198.47, -69.38, 1),
	        ], [v4(-15.53, 91.63, -90.62, 1),
	            v4(-15.26, 89.51, -87.42, 1),
	            v4(-10.75, 85.02, -82.7, 1),
	            v4(-0.86, 80.15, -80.33, 1),
	            v4(9.24, 77.06, -80.08, 1),
	            v4(19.59, 75.48, -81.16, 1),
	            v4(29.91, 75.55, -82.58, 1),
	            v4(40.6, 78.73, -83.91, 1),
	            v4(47.18, 89.73, -84.9, 1),
	            v4(44.55, 102.51, -85.23, 1),
	            v4(37.92, 111.77, -85.06, 1),
	            v4(29.47, 118.41, -84.54, 1),
	            v4(20.5, 123.82, -83.81, 1),
	            v4(11.55, 129.42, -82.81, 1),
	            v4(3.52, 136.13, -81.46, 1),
	            v4(-1.92, 145.42, -79.49, 1),
	            v4(-1.07, 156.11, -77.15, 1),
	            v4(4.42, 165.11, -75.21, 1),
	            v4(11.6, 172.62, -73.53, 1),
	            v4(18.53, 180.44, -71.76, 1),
	            v4(23.15, 190.02, -70.85, 1),
	            v4(25.98, 196.38, -70.62, 1),
	            v4(27.36, 199.64, -70.53, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["491"].animation = [[2859, -1], [3140, -0.102], [4202, 0.191], [4269, 0.517], [4307, 1]];
	Curves["491"].divisions = "|MAEmodelsPrevis|tunnelRibbonWideREDOtop_2000_1_3_124_202_247_60_100_100_100_70_20|_41_5_v309";
	Curves["492"] = function () {
	    var Curve_v01 = [[v4(-11.38, 101.44, -87.51, 1),
	            v4(-10.31, 100.71, -85.75, 1),
	            v4(-6.78, 99.76, -83.36, 1),
	            v4(-0.48, 99.53, -81.68, 1),
	            v4(5.66, 100.42, -80.52, 1),
	            v4(11.68, 103.23, -79.3, 1),
	            v4(13.98, 109.48, -77.52, 1),
	            v4(11.53, 115.49, -75.94, 1),
	            v4(7.79, 120.44, -74.65, 1),
	            v4(3.3, 124.95, -73.53, 1),
	            v4(-1.24, 129.31, -72.54, 1),
	            v4(-5.63, 133.9, -71.6, 1),
	            v4(-9.67, 138.79, -70.67, 1),
	            v4(-13.26, 144.01, -69.73, 1),
	            v4(-16, 149.78, -68.81, 1),
	            v4(-16.96, 156.14, -68, 1),
	            v4(-15.56, 162.51, -67.5, 1),
	            v4(-12.31, 168.04, -67.4, 1),
	            v4(-8.31, 173.1, -68.03, 1),
	            v4(-3.09, 176.73, -69.02, 1),
	            v4(2.56, 179.73, -69.41, 1),
	            v4(6.25, 181.85, -69.69, 1),
	            v4(8.11, 182.9, -69.81, 1),
	        ], [v4(-14.48, 96.69, -85.86, 1),
	            v4(-13.57, 95.99, -83.62, 1),
	            v4(-10.63, 94.65, -79.67, 1),
	            v4(-4.51, 93.15, -75.42, 1),
	            v4(2.44, 92.29, -72.58, 1),
	            v4(9.93, 92.43, -71.2, 1),
	            v4(17.29, 94.14, -71.31, 1),
	            v4(23.67, 98.58, -72.87, 1),
	            v4(25.28, 106.29, -74.53, 1),
	            v4(22.15, 113.39, -74.73, 1),
	            v4(17.55, 119.28, -74.15, 1),
	            v4(12.22, 124.56, -73.18, 1),
	            v4(6.8, 129.65, -72.14, 1),
	            v4(1.48, 134.9, -71.18, 1),
	            v4(-3.59, 140.36, -70.19, 1),
	            v4(-8.19, 146.24, -69.06, 1),
	            v4(-11.56, 152.87, -67.66, 1),
	            v4(-12.02, 160.56, -66.24, 1),
	            v4(-7.86, 167.09, -65.02, 1),
	            v4(-3.86, 173.18, -67.26, 1),
	            v4(2.36, 177.62, -67.97, 1),
	            v4(6.44, 180.38, -68.21, 1),
	            v4(8.57, 181.75, -68.31, 1),
	        ], [v4(-14.62, 92.98, -85.36, 1),
	            v4(-13.57, 92.19, -82.98, 1),
	            v4(-9.94, 90.29, -79.24, 1),
	            v4(-2.73, 87.71, -76.36, 1),
	            v4(5.13, 86.02, -75.13, 1),
	            v4(13.29, 85.83, -75.19, 1),
	            v4(21.18, 87.75, -76.2, 1),
	            v4(28.06, 91.9, -77.66, 1),
	            v4(33.04, 98.43, -79.09, 1),
	            v4(33.76, 106.84, -79.75, 1),
	            v4(30.15, 114.29, -79.43, 1),
	            v4(24.7, 120.25, -78.7, 1),
	            v4(18.47, 125.34, -77.81, 1),
	            v4(12.01, 130.17, -76.91, 1),
	            v4(5.81, 135.16, -75.97, 1),
	            v4(-0.17, 140.72, -74.95, 1),
	            v4(-5.02, 146.81, -73.73, 1),
	            v4(-8.83, 154.4, -72.34, 1),
	            v4(-7.25, 162.15, -70.32, 1),
	            v4(-3.36, 169.28, -68.67, 1),
	            v4(2.14, 175.13, -69.23, 1),
	            v4(6.63, 178.34, -69.2, 1),
	            v4(8.74, 179.93, -69.26, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["492"].animation = [[2859, -1], [3140, -0.102], [4202, 0.191], [4269, 0.517], [4307, 1]];
	Curves["492"].divisions = "|MAEmodelsPrevis|tunnelRibbonWideREDOtop_2000_1_3_124_202_247_60_100_100_100_70_20|_41_5_v310";
	Curves["493"] = function () {
	    var Curve_v01 = [[v4(-8.35, 99.18, -83.62, 1),
	            v4(-6.62, 98.64, -81.35, 1),
	            v4(-2.27, 98.11, -77.45, 1),
	            v4(5.2, 98.95, -73.09, 1),
	            v4(12.04, 101.28, -69.83, 1),
	            v4(16.96, 104.8, -67.38, 1),
	            v4(19.23, 109.01, -65.56, 1),
	            v4(18.79, 113.33, -64.33, 1),
	            v4(16.17, 117.2, -63.73, 1),
	            v4(12.23, 120.38, -63.73, 1),
	            v4(7.78, 122.98, -64.21, 1),
	            v4(3.46, 125.42, -64.86, 1),
	            v4(-0.37, 128.18, -65.39, 1),
	            v4(-3.47, 131.59, -65.6, 1),
	            v4(-5.67, 135.68, -65.49, 1),
	            v4(-6.8, 140.26, -65.22, 1),
	            v4(-6.71, 145.06, -64.99, 1),
	            v4(-5.39, 149.83, -64.98, 1),
	            v4(-3.01, 154.49, -65.24, 1),
	            v4(0.08, 159.04, -65.72, 1),
	            v4(3.38, 163.55, -66.28, 1),
	            v4(5.36, 166.61, -66.6, 1),
	            v4(6.21, 168.17, -66.71, 1),
	        ], [v4(-12.45, 97.33, -78.83, 1),
	            v4(-10.65, 95.77, -75.83, 1),
	            v4(-6.36, 93.77, -70.54, 1),
	            v4(1.06, 93.3, -64.75, 1),
	            v4(8.61, 94.67, -61.05, 1),
	            v4(15.45, 97.41, -59.17, 1),
	            v4(20.72, 101.18, -58.66, 1),
	            v4(23.76, 105.65, -58.97, 1),
	            v4(24.37, 110.35, -59.64, 1),
	            v4(22.87, 114.7, -60.32, 1),
	            v4(19.9, 118.21, -60.86, 1),
	            v4(16.15, 120.76, -61.18, 1),
	            v4(12.12, 122.64, -61.22, 1),
	            v4(8.17, 124.5, -60.99, 1),
	            v4(4.6, 127, -60.57, 1),
	            v4(1.66, 130.55, -60.15, 1),
	            v4(-0.36, 135.19, -60.02, 1),
	            v4(-1.19, 140.68, -60.41, 1),
	            v4(-0.68, 146.64, -61.37, 1),
	            v4(1.08, 152.78, -62.74, 1),
	            v4(3.69, 158.88, -64.18, 1),
	            v4(5.61, 162.84, -64.88, 1),
	            v4(6.51, 164.78, -65.09, 1),
	        ], [v4(-13.11, 94.68, -82.45, 1),
	            v4(-12.16, 93.58, -80.05, 1),
	            v4(-9.16, 91.66, -75.62, 1),
	            v4(-2.19, 89.93, -70.44, 1),
	            v4(6.34, 89.55, -66.88, 1),
	            v4(15.28, 90.64, -64.92, 1),
	            v4(23.31, 93.27, -64.25, 1),
	            v4(29.2, 97.36, -64.42, 1),
	            v4(32.21, 102.61, -64.93, 1),
	            v4(32.33, 108.43, -65.5, 1),
	            v4(30.2, 114.03, -66.05, 1),
	            v4(26.79, 118.73, -66.68, 1),
	            v4(22.97, 122.2, -67.44, 1),
	            v4(19.06, 124.82, -68.24, 1),
	            v4(14.85, 127.53, -68.86, 1),
	            v4(10.65, 130.78, -69.07, 1),
	            v4(6.85, 134.84, -68.78, 1),
	            v4(4.11, 139.46, -68.12, 1),
	            v4(2.6, 144.59, -67.3, 1),
	            v4(2.72, 149.79, -66.57, 1),
	            v4(4.74, 154.54, -66.09, 1),
	            v4(6.52, 157.98, -66.03, 1),
	            v4(7.3, 159.9, -66.08, 1),
	        ],];
	    var degree1_v01 = 2;
	    var degree2_v01 = 22;
	    var knots1_v01 = [0, 0, 0, 1, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["493"].animation = [[2859, -1], [3140, -0.102], [4202, 0.191], [4269, 0.517], [4307, 1]];
	Curves["493"].divisions = "|MAEmodelsPrevis|tunnelRibbonWideREDOtop_2000_1_3_124_202_247_60_100_100_100_70_20|_41_5_v311";
	Curves.numCurves = 494;
	Curves["494"] = function () {
	    var Curve_v01 = [[v4(-1.01, 2.29, 2.92, 1),
	            v4(-0.46, 2.84, 3.17, 1),
	            v4(0.6, 3.86, 3.7, 1),
	            v4(2.15, 5.68, 4.52, 1),
	            v4(3.15, 8.27, 5.18, 1),
	            v4(3.83, 11.2, 5.42, 1),
	            v4(3.65, 14.26, 5.1, 1),
	            v4(2.6, 17.66, 4.59, 1),
	            v4(1.48, 21.29, 4.23, 1),
	            v4(2.87, 25.37, 3.64, 1),
	            v4(6.82, 28.67, 2.62, 1),
	            v4(9.25, 29.84, 1.57, 1),
	            v4(10.16, 30.21, 0.88, 1),
	        ], [v4(0.71, 2.29, 0.54, 1),
	            v4(1.24, 2.84, 0.71, 1),
	            v4(2.27, 3.86, 1.13, 1),
	            v4(4.06, 5.62, 2.05, 1),
	            v4(5, 8.17, 2.93, 1),
	            v4(5.39, 10.9, 3.52, 1),
	            v4(5.26, 13.83, 3.69, 1),
	            v4(4.05, 17.75, 3.52, 1),
	            v4(2.93, 22.54, 3.27, 1),
	            v4(6.47, 26.66, 2.7, 1),
	            v4(9.78, 29.06, 1.56, 1),
	            v4(10.97, 30.08, 0.63, 1),
	            v4(11.65, 30.46, 0.08, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["494"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["494"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v1";
	Curves["495"] = function () {
	    var Curve_v01 = [[v4(5.97, 21.67, -4.14, 1),
	            v4(5.44, 22.16, -4.41, 1),
	            v4(4.42, 23.48, -5.14, 1),
	            v4(5.09, 25.7, -6.42, 1),
	            v4(7.03, 27.18, -7.56, 1),
	            v4(9.33, 28.37, -8.85, 1),
	            v4(11.79, 29.48, -10.29, 1),
	            v4(14.16, 30.67, -11.77, 1),
	            v4(16.36, 32, -13.13, 1),
	            v4(18.28, 33.46, -14.28, 1),
	            v4(19.94, 35, -15.19, 1),
	            v4(20.89, 36.06, -15.7, 1),
	            v4(21.32, 36.6, -15.94, 1),
	        ], [v4(7.49, 20.53, -3.38, 1),
	            v4(6.96, 21.02, -3.64, 1),
	            v4(5.97, 22.37, -4.39, 1),
	            v4(6.92, 24.71, -5.89, 1),
	            v4(9.19, 26.47, -7.52, 1),
	            v4(11.71, 28.03, -9.32, 1),
	            v4(14.08, 29.45, -11, 1),
	            v4(15.9, 30.59, -12.2, 1),
	            v4(17.37, 31.61, -13.1, 1),
	            v4(18.7, 32.68, -13.86, 1),
	            v4(20.03, 33.94, -14.59, 1),
	            v4(20.92, 34.94, -15.06, 1),
	            v4(21.36, 35.48, -15.3, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["495"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["495"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v2";
	Curves["496"] = function () {
	    var Curve_v01 = [[v4(-2.59, 2.97, -0.84, 1),
	            v4(-4.23, 3.63, -1.41, 1),
	            v4(-7.22, 4.74, -1.95, 1),
	            v4(-11.23, 6.78, -1.18, 1),
	            v4(-13.79, 10.08, 0.54, 1),
	            v4(-15.31, 15.72, 0.89, 1),
	            v4(-13.57, 21.25, -1.49, 1),
	            v4(-10.96, 23.98, -3.64, 1),
	            v4(-8.11, 26.39, -5.44, 1),
	            v4(-4.52, 28.29, -6.68, 1),
	            v4(0.24, 29.97, -7.12, 1),
	            v4(3.59, 30.87, -7.36, 1),
	            v4(5.25, 31.3, -7.46, 1),
	        ], [v4(-2.35, 4.13, -1.39, 1),
	            v4(-3.91, 4.74, -1.74, 1),
	            v4(-6.63, 5.81, -1.8, 1),
	            v4(-10.07, 7.84, -0.78, 1),
	            v4(-12.29, 10.9, 0.66, 1),
	            v4(-13.5, 16.07, 0.8, 1),
	            v4(-11.08, 21.56, -1.67, 1),
	            v4(-7.83, 24.26, -3.91, 1),
	            v4(-4.55, 26.74, -5.74, 1),
	            v4(-0.69, 28.73, -6.81, 1),
	            v4(4.1, 30.48, -7.25, 1),
	            v4(7.42, 31.41, -7.49, 1),
	            v4(9.07, 31.84, -7.6, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["496"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["496"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v3";
	Curves["497"] = function () {
	    var Curve_v01 = [[v4(0.2, 2.77, 0.43, 1),
	            v4(-0.71, 2.89, 0.67, 1),
	            v4(-2.54, 3.4, 1.32, 1),
	            v4(-4.49, 5.21, 2.53, 1),
	            v4(-5.74, 7.43, 3.84, 1),
	            v4(-6.57, 9.87, 4.76, 1),
	            v4(-6.91, 12.32, 5.1, 1),
	            v4(-6.92, 15.12, 4.78, 1),
	            v4(-5.81, 18.8, 3.96, 1),
	            v4(-2.43, 22.69, 2.69, 1),
	            v4(1.19, 24.91, 1.02, 1),
	            v4(2.83, 25.55, -0.08, 1),
	            v4(3.65, 25.84, -0.66, 1),
	        ], [v4(0.87, 3.1, 3.87, 1),
	            v4(0.03, 3.22, 4.21, 1),
	            v4(-1.5, 3.76, 4.97, 1),
	            v4(-2.83, 5.56, 6.05, 1),
	            v4(-3.58, 7.69, 7.04, 1),
	            v4(-4.19, 9.99, 7.77, 1),
	            v4(-4.71, 12.37, 8.05, 1),
	            v4(-4.59, 14.99, 7.73, 1),
	            v4(-3.21, 18.12, 7.1, 1),
	            v4(-1.12, 21.25, 6.19, 1),
	            v4(1.39, 23.58, 4.8, 1),
	            v4(2.82, 24.58, 3.7, 1),
	            v4(3.56, 25.05, 3.11, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["497"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["497"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v4";
	Curves["498"] = function () {
	    var Curve_v01 = [[v4(0.04, 2.39, 0.85, 1),
	            v4(0.47, 2.62, 0.92, 1),
	            v4(1.38, 3.09, 1.09, 1),
	            v4(2.83, 3.91, 1.5, 1),
	            v4(4.34, 5.37, 2.09, 1),
	            v4(5.69, 7.45, 2.76, 1),
	            v4(6.36, 10.03, 3.08, 1),
	            v4(6.31, 12.78, 2.77, 1),
	            v4(5.47, 15.39, 2.25, 1),
	            v4(4.59, 17.65, 2.04, 1),
	            v4(3.83, 19.58, 1.75, 1),
	            v4(3.18, 20.69, 1.4, 1),
	            v4(2.84, 21.13, 1.2, 1),
	        ], [v4(2.19, 2.91, -0.08, 1),
	            v4(2.6, 3.14, -0.01, 1),
	            v4(3.37, 3.61, 0.15, 1),
	            v4(4.5, 4.38, 0.48, 1),
	            v4(5.61, 5.61, 0.94, 1),
	            v4(6.65, 7.23, 1.5, 1),
	            v4(7.48, 9.15, 1.95, 1),
	            v4(7.82, 11.37, 2.09, 1),
	            v4(7.37, 13.76, 1.78, 1),
	            v4(6.36, 16.19, 1.3, 1),
	            v4(5.23, 18.41, 1.1, 1),
	            v4(4.45, 19.55, 0.97, 1),
	            v4(4.06, 20.03, 0.86, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["498"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["498"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v5";
	Curves["499"] = function () {
	    var Curve_v01 = [[v4(-1.23, 26.78, -3.09, 1),
	            v4(-0.64, 27.17, -3.33, 1),
	            v4(0.66, 27.95, -3.79, 1),
	            v4(2.87, 29.09, -4.43, 1),
	            v4(5.29, 30.26, -5.06, 1),
	            v4(7.8, 31.49, -5.69, 1),
	            v4(10.31, 32.77, -6.35, 1),
	            v4(12.72, 34.09, -7.04, 1),
	            v4(14.86, 35.53, -7.81, 1),
	            v4(16.56, 37.1, -8.68, 1),
	            v4(17.38, 39.14, -9.88, 1),
	            v4(16.44, 40.4, -10.64, 1),
	            v4(15.92, 40.85, -10.9, 1),
	        ], [v4(0.47, 26.78, -1.78, 1),
	            v4(1.13, 27.04, -1.94, 1),
	            v4(2.53, 27.49, -2.23, 1),
	            v4(4.81, 28.27, -2.71, 1),
	            v4(7.29, 29.31, -3.3, 1),
	            v4(9.94, 30.51, -3.94, 1),
	            v4(12.62, 31.72, -4.57, 1),
	            v4(15.02, 33.16, -5.31, 1),
	            v4(16.89, 34.91, -6.24, 1),
	            v4(18.15, 36.88, -7.31, 1),
	            v4(18.44, 39.42, -8.75, 1),
	            v4(17.21, 40.94, -9.64, 1),
	            v4(16.61, 41.44, -9.94, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["499"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["499"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v6";
	Curves["500"] = function () {
	    var Curve_v01 = [[v4(-7.28, 7.6, 1.72, 1),
	            v4(-7.97, 8.23, 2.08, 1),
	            v4(-9.16, 9.67, 2.71, 1),
	            v4(-10.4, 12.35, 3.16, 1),
	            v4(-11.04, 15.63, 2.8, 1),
	            v4(-10.77, 19.19, 1.99, 1),
	            v4(-8.55, 22.54, 0.91, 1),
	            v4(-3.86, 25.42, -0.43, 1),
	            v4(2.11, 27.48, -2.07, 1),
	            v4(7.05, 29.22, -4.26, 1),
	            v4(10.5, 30.88, -6.04, 1),
	            v4(12.29, 31.98, -6.79, 1),
	            v4(13.15, 32.63, -7.02, 1),
	        ], [v4(-5.62, 6.6, 2.93, 1),
	            v4(-6.32, 7.23, 3.27, 1),
	            v4(-7.54, 8.87, 3.91, 1),
	            v4(-8.9, 12.19, 4.45, 1),
	            v4(-9.34, 15.97, 4.08, 1),
	            v4(-7.63, 19.55, 3.26, 1),
	            v4(-4.2, 22.84, 2.27, 1),
	            v4(0.78, 25.5, 1.09, 1),
	            v4(5.66, 27.54, -0.48, 1),
	            v4(9.01, 29.25, -2.54, 1),
	            v4(11.62, 30.8, -4.4, 1),
	            v4(13.4, 31.93, -5.29, 1),
	            v4(14.24, 32.57, -5.61, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["500"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["500"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v8";
	Curves["501"] = function () {
	    var Curve_v01 = [[v4(3.41, 3.65, -1.35, 1),
	            v4(3.92, 4.35, -1.42, 1),
	            v4(5.16, 5.36, -1.34, 1),
	            v4(6.68, 6.98, -1, 1),
	            v4(7.69, 9.04, -0.65, 1),
	            v4(8.13, 11.62, -0.45, 1),
	            v4(7.77, 14.47, -0.76, 1),
	            v4(6.72, 16.74, -1.12, 1),
	            v4(5.34, 18.54, -1.04, 1),
	            v4(3.77, 20.98, -1.09, 1),
	            v4(4.64, 24.84, -1.87, 1),
	            v4(7.16, 26.18, -2.73, 1),
	            v4(8, 26.56, -3.13, 1),
	        ], [v4(2.89, 3, -1.23, 1),
	            v4(3.68, 3.52, -1.41, 1),
	            v4(5.6, 4.24, -1.49, 1),
	            v4(8.07, 6.18, -1.18, 1),
	            v4(9.38, 9.09, -0.72, 1),
	            v4(9.81, 11.87, -0.5, 1),
	            v4(9.39, 14.68, -0.81, 1),
	            v4(8.27, 17.04, -1.18, 1),
	            v4(6.97, 18.98, -1.44, 1),
	            v4(5.44, 20.73, -1.97, 1),
	            v4(5.14, 23.52, -2.8, 1),
	            v4(6.92, 25.16, -3.49, 1),
	            v4(7.58, 25.74, -3.82, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["501"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["501"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v9";
	Curves["502"] = function () {
	    var Curve_v01 = [[v4(7.71, 33.42, -5.86, 1),
	            v4(8.45, 33.6, -6.28, 1),
	            v4(9.91, 34.02, -7.13, 1),
	            v4(12.59, 35.37, -8.71, 1),
	            v4(13.96, 38.43, -10.18, 1),
	            v4(13.34, 41.69, -11.3, 1),
	            v4(11.31, 44.49, -12.38, 1),
	            v4(8.6, 46.49, -13.42, 1),
	            v4(6.29, 48.28, -14.5, 1),
	            v4(4.76, 50.16, -15.61, 1),
	            v4(3.52, 52, -16.74, 1),
	            v4(2.87, 53.3, -17.53, 1),
	            v4(2.58, 53.96, -17.93, 1),
	        ], [v4(8.96, 32.96, -5.2, 1),
	            v4(9.68, 33.18, -5.62, 1),
	            v4(11.14, 33.68, -6.46, 1),
	            v4(13.77, 34.99, -7.95, 1),
	            v4(15.53, 37.98, -9.43, 1),
	            v4(15.25, 41.53, -10.57, 1),
	            v4(13.44, 44.61, -11.58, 1),
	            v4(10.84, 46.8, -12.51, 1),
	            v4(8.41, 48.38, -13.42, 1),
	            v4(6.65, 49.9, -14.34, 1),
	            v4(5.19, 51.43, -15.28, 1),
	            v4(4.42, 52.57, -15.97, 1),
	            v4(4.07, 53.15, -16.33, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["502"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["502"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v10";
	Curves["503"] = function () {
	    var Curve_v01 = [[v4(-0.37, 3.22, 2.69, 1),
	            v4(0.05, 3.97, 3.13, 1),
	            v4(0.76, 5.58, 4.36, 1),
	            v4(0.82, 8.33, 6.27, 1),
	            v4(0.66, 11.03, 7.08, 1),
	            v4(0.26, 13.74, 7.08, 1),
	            v4(-0.62, 16.25, 7.08, 1),
	            v4(-1.2, 18.88, 6.26, 1),
	            v4(-0.97, 21.65, 4.15, 1),
	            v4(0.28, 24.15, 1.6, 1),
	            v4(2.68, 25.68, 0.32, 1),
	            v4(4.37, 26.4, -0.04, 1),
	            v4(5.26, 26.78, -0.09, 1),
	        ], [v4(0.58, 3.22, 0.31, 1),
	            v4(1.01, 3.98, 0.74, 1),
	            v4(1.8, 5.52, 1.96, 1),
	            v4(2.15, 8.24, 3.92, 1),
	            v4(2.21, 10.98, 4.75, 1),
	            v4(2.07, 13.79, 4.75, 1),
	            v4(1.34, 16.4, 4.75, 1),
	            v4(0.77, 19.05, 3.9, 1),
	            v4(1.11, 21.88, 1.56, 1),
	            v4(2.5, 24.45, -1.12, 1),
	            v4(5.04, 26.03, -2.23, 1),
	            v4(6.77, 26.77, -2.42, 1),
	            v4(7.65, 27.16, -2.42, 1),
	        ],];
	    var degree1_v01 = 1;
	    var degree2_v01 = 12;
	    var knots1_v01 = [0, 0, 1, 1,];
	    var knots2_v01 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,];
	    var nurbsSurface_v01 = new THREE.NURBSSurface(degree1_v01, degree2_v01, knots1_v01, knots2_v01, Curve_v01);
	    return function (u, v) { return nurbsSurface_v01.getPoint(v, u); };
	};
	Curves["503"].animation = [[2332, 1], [2361, 0.8206172089], [2388, 1], [2409, 0.2262382265], [2473, -1], [2473.005, 1], [2595.99, -1], [2619, -1], [2619.005, 1], [2741.99, -1], [2765, -1], [2765.005, 1], [2887.99, -1], [2911, -1], [2911.005, 1], [3033.99, -1], [3057, -1], [3057.005, 1], [3179.99, -1], [3203, -1], [3203.005, 1], [3325.99, -1], [3354, -1]];
	Curves["503"].divisions = "|MAEmodelsPrevis|ExplosionStrands_5000_3_3_124_230_247_200_40_100_100_100_40|_41_2_v11";
	Curves.numCurves = 504;
	var Anim = (function () {
	    function Anim() {
	        this.curves = Curves;
	    }
	    return Anim;
	}());
	exports.Anim = Anim;
	//# sourceMappingURL=Curves.js.map

/***/ },
/* 79 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Class Manager
	 */
	var Manager = (function (_super) {
	    __extends(Manager, _super);
	    function Manager() {
	        _super.call(this);
	        this.onLoad = function () {
	            // console.log('start Loading');
	        };
	        this.onError = function () {
	            // console.log('failed loading');
	        };
	        this.onProgress = function () {
	            // console.log('finished loading');
	        };
	    }
	    Manager.prototype.boot = function (app) {
	    };
	    Manager.prototype.update = function (time, delta) {
	    };
	    return Manager;
	}(THREE.LoadingManager));
	exports.Manager = Manager;
	//# sourceMappingURL=Manager.js.map

/***/ },
/* 80 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Browser Class
	 */
	var Mouse = (function () {
	    function Mouse(app) {
	        this.ratio = new THREE.Vector2();
	        this.normalized = new THREE.Vector2();
	        this.screen = new THREE.Vector2();
	        window.addEventListener('mousemove', this.move.bind(this), false);
	    }
	    Mouse.prototype.boot = function (_a) {
	        var browser = _a.browser;
	        this.browser = browser;
	    };
	    /**
	     * On Screen Resize
	     */
	    Mouse.prototype.move = function (event) {
	        this.x = event.clientX;
	        this.y = event.clientY;
	        /**
	         * Normalized
	         * @type {number}
	         */
	        var x = -1 + (event.clientX / this.browser.width) * 2, y = 1 - (event.clientY / this.browser.height) * 2;
	        this.normalized.set(x, y);
	        this.ratio.x = event.clientX / this.browser.width;
	        this.ratio.y = event.clientY / this.browser.height;
	        /**
	         * Screen
	         */
	        this.screen.set(event.clientX - this.browser.window.half.x, event.clientY - this.browser.window.half.y);
	    };
	    Mouse.prototype.click = function (callback) {
	        window.addEventListener('dblclick', function (event) { return callback(); });
	    };
	    Mouse.prototype.update = function (time, delta) {
	    };
	    return Mouse;
	}());
	exports.Mouse = Mouse;
	//# sourceMappingURL=Mouse.js.map

/***/ },
/* 81 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Class Renderer
	 */
	var Renderer = (function (_super) {
	    __extends(Renderer, _super);
	    function Renderer(_a) {
	        var canvas = _a.canvas;
	        _super.call(this, {
	            antialias: true,
	            alpha: true,
	        });
	        canvas.appendChild(this.domElement);
	    }
	    Renderer.prototype.boot = function (_a) {
	        var scene = _a.scene, camera = _a.camera, browser = _a.browser, canvas = _a.canvas;
	        this.scene = scene;
	        this.camera = camera;
	        this.browser = browser;
	        this.setSize(canvas.offsetWidth, canvas.offsetHeight);
	        this.setPixelRatio(this.browser.pixelRatio);
	    };
	    Renderer.prototype.update = function (time, delta) {
	        this.render(this.scene, this.camera);
	    };
	    return Renderer;
	}(THREE.WebGLRenderer));
	exports.Renderer = Renderer;
	//# sourceMappingURL=Renderer.js.map

/***/ },
/* 82 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * Scene Class
	 */
	var Scene = (function (_super) {
	    __extends(Scene, _super);
	    function Scene() {
	        _super.call(this);
	    }
	    Scene.prototype.boot = function (app) {
	    };
	    Scene.prototype.update = function (time, delta) {
	    };
	    return Scene;
	}(THREE.Scene));
	exports.Scene = Scene;
	//# sourceMappingURL=Scene.js.map

/***/ }
/******/ ]);