/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.l = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };

/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};

/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};

/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports) {

eval("// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout.call(null, cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout.call(null, timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var arguments$1 = arguments;\n\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments$1[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout.call(null, drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzPzgzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhY2hlZFNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaXMgbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBpcyBub3QgZGVmaW5lZCcpO1xuICAgIH1cbiAgfVxufSAoKSlcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgdGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n  'use strict';\n  var isElectron = typeof module === 'object' && process && process.versions && process.versions.electron;\n  if (!isElectron && typeof module === 'object') {\n    module.exports = factory;\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n        return factory;\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {\n    root.MediumEditorTable = factory;\n  }\n}(this, function () {\n\n  'use strict';\n\nfunction extend(dest, source) {\n    var prop;\n    dest = dest || {};\n    for (prop in source) {\n        if (source.hasOwnProperty(prop) && !dest.hasOwnProperty(prop)) {\n            dest[prop] = source[prop];\n        }\n    }\n    return dest;\n}\n\nfunction getSelectionText(doc) {\n    if (doc.getSelection) {\n        return doc.getSelection().toString();\n    }\n    if (doc.selection && doc.selection.type !== 'Control') {\n        return doc.selection.createRange().text;\n    }\n    return '';\n}\n\nfunction getSelectionStart(doc) {\n    var node = doc.getSelection().anchorNode,\n        startNode = (node && node.nodeType === 3 ? node.parentNode : node);\n\n    return startNode;\n}\n\nfunction placeCaretAtNode(doc, node, before) {\n    if (doc.getSelection !== undefined && node) {\n        var range = doc.createRange(),\n            selection = doc.getSelection();\n\n        if (before) {\n            range.setStartBefore(node);\n        } else {\n            range.setStartAfter(node);\n        }\n\n        range.collapse(true);\n\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n}\n\nfunction isInsideElementOfTag(node, tag) {\n    if (!node) {\n        return false;\n    }\n\n    var parentNode = node.parentNode,\n        tagName = parentNode.tagName.toLowerCase();\n\n    while (tagName !== 'body') {\n        if (tagName === tag) {\n            return true;\n        }\n        parentNode = parentNode.parentNode;\n\n        if (parentNode && parentNode.tagName) {\n            tagName = parentNode.tagName.toLowerCase();\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n\nfunction getParentOf(el, tagTarget) {\n    var tagName = el && el.tagName ? el.tagName.toLowerCase() : false;\n\n    if (!tagName) {\n        return false;\n    }\n    while (tagName && tagName !== 'body') {\n        if (tagName === tagTarget) {\n            return el;\n        }\n        el = el.parentNode;\n        tagName = el && el.tagName ? el.tagName.toLowerCase() : false;\n    }\n}\n\nfunction Grid(el, callback, rows, columns) {\n    return this.init(el, callback, rows, columns);\n}\n\nGrid.prototype = {\n    init: function (el, callback, rows, columns) {\n        this._root = el;\n        this._callback = callback;\n        this.rows = rows;\n        this.columns = columns;\n        return this._render();\n    },\n\n    setCurrentCell: function (cell) {\n        this._currentCell = cell;\n    },\n\n    markCells: function () {\n        [].forEach.call(this._cellsElements, function (el) {\n            var cell = {\n                    column: parseInt(el.dataset.column, 10),\n                    row: parseInt(el.dataset.row, 10)\n                },\n                active = this._currentCell &&\n                         cell.row <= this._currentCell.row &&\n                         cell.column <= this._currentCell.column;\n\n            if (active === true) {\n                el.classList.add('active');\n            } else {\n                el.classList.remove('active');\n            }\n        }.bind(this));\n    },\n\n    _generateCells: function () {\n        var this$1 = this;\n\n        var row = -1;\n\n        this._cells = [];\n\n        for (var i = 0; i < this.rows * this.columns; i++) {\n            var column = i % this$1.columns;\n\n            if (column === 0) {\n                row++;\n            }\n\n            this$1._cells.push({\n                column: column,\n                row: row,\n                active: false\n            });\n        }\n    },\n\n    _html: function () {\n        var width = this.columns * COLUMN_WIDTH + BORDER_WIDTH * 2,\n            height = this.rows * COLUMN_WIDTH + BORDER_WIDTH * 2,\n            html = '<div class=\"medium-editor-table-builder-grid clearfix\" style=\"width:' + width + 'px;height:' + height + 'px;\">';\n        html += this._cellsHTML();\n        html += '</div>';\n        return html;\n    },\n\n    _cellsHTML: function () {\n        var html = '';\n        this._generateCells();\n        this._cells.map(function (cell) {\n            html += '<a href=\"#\" class=\"medium-editor-table-builder-cell' +\n                    (cell.active === true ? ' active' : '') +\n                    '\" ' + 'data-row=\"' + cell.row +\n                    '\" data-column=\"' + cell.column + '\">';\n            html += '</a>';\n        });\n        return html;\n    },\n\n    _render: function () {\n        this._root.innerHTML = this._html();\n        this._cellsElements = this._root.querySelectorAll('a');\n        this._bindEvents();\n    },\n\n    _bindEvents: function () {\n        [].forEach.call(this._cellsElements, function (el) {\n            this._onMouseEnter(el);\n            this._onClick(el);\n        }.bind(this));\n    },\n\n    _onMouseEnter: function (el) {\n        var self = this,\n            timer;\n\n        el.addEventListener('mouseenter', function () {\n            clearTimeout(timer);\n\n            var dataset = this.dataset;\n\n            timer = setTimeout(function () {\n                self._currentCell = {\n                    column: parseInt(dataset.column, 10),\n                    row: parseInt(dataset.row, 10)\n                };\n                self.markCells();\n            }, 50);\n        });\n    },\n\n    _onClick: function (el) {\n        var self = this;\n        el.addEventListener('click', function (e) {\n            e.preventDefault();\n            self._callback(this.dataset.row, this.dataset.column);\n        });\n    }\n};\n\nfunction Builder(options) {\n    return this.init(options);\n}\n\nBuilder.prototype = {\n    init: function (options) {\n        this.options = options;\n        this._doc = options.ownerDocument || document;\n        this._root = this._doc.createElement('div');\n        this._root.className = 'medium-editor-table-builder';\n        this.grid = new Grid(\n          this._root,\n          this.options.onClick,\n          this.options.rows,\n          this.options.columns\n        );\n\n        this._range = null;\n        this._toolbar = this._doc.createElement('div');\n        this._toolbar.className = 'medium-editor-table-builder-toolbar';\n\n        var spanRow = this._doc.createElement('span');\n        spanRow.innerHTML = 'Row:';\n        this._toolbar.appendChild(spanRow);\n        var addRowBefore = this._doc.createElement('button');\n        addRowBefore.title = 'Add row before';\n        addRowBefore.innerHTML = '<i class=\"fa fa-long-arrow-up\"></i>';\n        addRowBefore.onclick = this.addRow.bind(this, true);\n        this._toolbar.appendChild(addRowBefore);\n\n        var addRowAfter = this._doc.createElement('button');\n        addRowAfter.title = 'Add row after';\n        addRowAfter.innerHTML = '<i class=\"fa fa-long-arrow-down\"></i>';\n        addRowAfter.onclick = this.addRow.bind(this, false);\n        this._toolbar.appendChild(addRowAfter);\n\n        var remRow = this._doc.createElement('button');\n        remRow.title = 'Remove row';\n        remRow.innerHTML = '<i class=\"fa fa-close\"></i>';\n        remRow.onclick = this.removeRow.bind(this);\n        this._toolbar.appendChild(remRow);\n\n        var spanCol = this._doc.createElement('span');\n        spanCol.innerHTML = 'Column:';\n        this._toolbar.appendChild(spanCol);\n        var addColumnBefore = this._doc.createElement('button');\n        addColumnBefore.title = 'Add column before';\n        addColumnBefore.innerHTML = '<i class=\"fa fa-long-arrow-left\"></i>';\n        addColumnBefore.onclick = this.addColumn.bind(this, true);\n        this._toolbar.appendChild(addColumnBefore);\n\n        var addColumnAfter = this._doc.createElement('button');\n        addColumnAfter.title = 'Add column after';\n        addColumnAfter.innerHTML = '<i class=\"fa fa-long-arrow-right\"></i>';\n        addColumnAfter.onclick = this.addColumn.bind(this, false);\n        this._toolbar.appendChild(addColumnAfter);\n\n        var remColumn = this._doc.createElement('button');\n        remColumn.title = 'Remove column';\n        remColumn.innerHTML = '<i class=\"fa fa-close\"></i>';\n        remColumn.onclick = this.removeColumn.bind(this);\n        this._toolbar.appendChild(remColumn);\n\n        var remTable = this._doc.createElement('button');\n        remTable.title = 'Remove table';\n        remTable.innerHTML = '<i class=\"fa fa-trash-o\"></i>';\n        remTable.onclick = this.removeTable.bind(this);\n        this._toolbar.appendChild(remTable);\n\n        var grid = this._root.childNodes[0];\n        this._root.insertBefore(this._toolbar, grid);\n    },\n\n    getElement: function () {\n        return this._root;\n    },\n\n    hide: function () {\n        this._root.style.display = '';\n        this.grid.setCurrentCell({ column: -1, row: -1 });\n        this.grid.markCells();\n    },\n\n    show: function (left) {\n        this._root.style.display = 'block';\n        this._root.style.left = left + 'px';\n    },\n\n    setEditor: function (range) {\n        this._range = range;\n        this._toolbar.style.display = 'block';\n    },\n\n    setBuilder: function () {\n        var this$1 = this;\n\n        this._range = null;\n        this._toolbar.style.display = 'none';\n        var elements = this._doc.getElementsByClassName('medium-editor-table-builder-grid');\n        for (var i = 0; i < elements.length; i++) {\n            elements[i].style.height = (COLUMN_WIDTH * this$1.rows + BORDER_WIDTH * 2) + 'px';\n            elements[i].style.width = (COLUMN_WIDTH * this$1.columns + BORDER_WIDTH * 2) + 'px';\n        }\n    },\n\n    addRow: function (before, e) {\n        var this$1 = this;\n\n        e.preventDefault();\n        e.stopPropagation();\n        var tbody = this._range.parentNode.parentNode,\n            tr = this._doc.createElement('tr'),\n            td;\n        for (var i = 0; i < this._range.parentNode.childNodes.length; i++) {\n            td = this$1._doc.createElement('td');\n            td.appendChild(this$1._doc.createElement('br'));\n            tr.appendChild(td);\n        }\n        if (before !== true && this._range.parentNode.nextSibling) {\n            tbody.insertBefore(tr, this._range.parentNode.nextSibling);\n        } else if (before === true) {\n            tbody.insertBefore(tr, this._range.parentNode);\n        } else {\n            tbody.appendChild(tr);\n        }\n        this.options.onClick(0, 0);\n    },\n\n    removeRow: function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this._range.parentNode.parentNode.removeChild(this._range.parentNode);\n        this.options.onClick(0, 0);\n    },\n\n    addColumn: function (before, e) {\n        var this$1 = this;\n\n        e.preventDefault();\n        e.stopPropagation();\n        var cell = Array.prototype.indexOf.call(this._range.parentNode.childNodes, this._range),\n            tbody = this._range.parentNode.parentNode,\n            td;\n\n        for (var i = 0; i < tbody.childNodes.length; i++) {\n            td = this$1._doc.createElement('td');\n            td.appendChild(this$1._doc.createElement('br'));\n            if (before === true) {\n                tbody.childNodes[i].insertBefore(td, tbody.childNodes[i].childNodes[cell]);\n            } else if (this$1._range.parentNode.parentNode.childNodes[i].childNodes[cell].nextSibling) {\n                tbody.childNodes[i].insertBefore(td, tbody.childNodes[i].childNodes[cell].nextSibling);\n            } else {\n                tbody.childNodes[i].appendChild(td);\n            }\n        }\n\n        this.options.onClick(0, 0);\n    },\n\n    removeColumn: function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        var cell = Array.prototype.indexOf.call(this._range.parentNode.childNodes, this._range),\n            tbody = this._range.parentNode.parentNode,\n            rows = tbody.childNodes.length;\n\n        for (var i = 0; i < rows; i++) {\n            tbody.childNodes[i].removeChild(tbody.childNodes[i].childNodes[cell]);\n        }\n        this.options.onClick(0, 0);\n    },\n\n    removeTable: function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        var cell = Array.prototype.indexOf.call(this._range.parentNode.childNodes, this._range),\n            table = this._range.parentNode.parentNode.parentNode;\n\n        table.parentNode.removeChild(table);\n        this.options.onClick(0, 0);\n    }\n};\n\nfunction Table(editor) {\n    return this.init(editor);\n}\n\nvar TAB_KEY_CODE = 9;\n\nTable.prototype = {\n    init: function (editor) {\n        this._editor = editor;\n        this._doc = this._editor.options.ownerDocument;\n        this._bindTabBehavior();\n    },\n\n    insert: function (rows, cols) {\n        var html = this._html(rows, cols);\n\n        this._editor.pasteHTML(\n            '<table class=\"medium-editor-table\" id=\"medium-editor-table\"' +\n            ' width=\"100%\">' +\n            '<tbody>' +\n            html +\n            '</tbody>' +\n            '</table>', {\n                cleanAttrs: [],\n                cleanTags: []\n            }\n        );\n\n        var table = this._doc.getElementById('medium-editor-table');\n        table.removeAttribute('id');\n        placeCaretAtNode(this._doc, table.querySelector('td'), true);\n\n        this._editor.checkSelection();\n    },\n\n    _html: function (rows, cols) {\n        var html = '',\n            x, y,\n            text = getSelectionText(this._doc);\n\n        for (x = 0; x <= rows; x++) {\n            html += '<tr>';\n            for (y = 0; y <= cols; y++) {\n                html += '<td>' + (x === 0 && y === 0 ? text : '<br />') + '</td>';\n            }\n            html += '</tr>';\n        }\n        return html;\n    },\n\n    _bindTabBehavior: function () {\n        var self = this;\n        [].forEach.call(this._editor.elements, function (el) {\n            el.addEventListener('keydown', function (e) {\n                self._onKeyDown(e);\n            });\n        });\n    },\n\n    _onKeyDown: function (e) {\n        var el = getSelectionStart(this._doc),\n            table;\n\n        if (e.which === TAB_KEY_CODE && isInsideElementOfTag(el, 'table')) {\n            e.preventDefault();\n            e.stopPropagation();\n            table = this._getTableElements(el);\n            if (e.shiftKey) {\n                this._tabBackwards(el.previousSibling, table.row);\n            } else {\n                if (this._isLastCell(el, table.row, table.root)) {\n                    this._insertRow(getParentOf(el, 'tbody'), table.row.cells.length);\n                }\n                placeCaretAtNode(this._doc, el);\n            }\n        }\n    },\n\n    _getTableElements: function (el) {\n        return {\n            cell: getParentOf(el, 'td'),\n            row: getParentOf(el, 'tr'),\n            root: getParentOf(el, 'table')\n        };\n    },\n\n    _tabBackwards: function (el, row) {\n        el = el || this._getPreviousRowLastCell(row);\n        placeCaretAtNode(this._doc, el, true);\n    },\n\n    _insertRow: function (tbody, cols) {\n        var tr = document.createElement('tr'),\n            html = '',\n            i;\n\n        for (i = 0; i < cols; i += 1) {\n            html += '<td><br /></td>';\n        }\n        tr.innerHTML = html;\n        tbody.appendChild(tr);\n    },\n\n    _isLastCell: function (el, row, table) {\n        return (\n          (row.cells.length - 1) === el.cellIndex &&\n          (table.rows.length - 1) === row.rowIndex\n        );\n    },\n\n    _getPreviousRowLastCell: function (row) {\n        row = row.previousSibling;\n        if (row) {\n            return row.cells[row.cells.length - 1];\n        }\n    }\n};\n\nvar COLUMN_WIDTH = 16,\n    BORDER_WIDTH = 1,\n    MediumEditorTable;\n\nMediumEditorTable = MediumEditor.extensions.form.extend({\n    name: 'table',\n\n    aria: 'create table',\n    action: 'table',\n    contentDefault: 'TBL',\n    contentFA: '<i class=\"fa fa-table\"></i>',\n\n    handleClick: function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        this[this.isActive() === true ? 'hide' : 'show']();\n    },\n\n    hide: function () {\n        this.setInactive();\n        this.builder.hide();\n    },\n\n    show: function () {\n        this.setActive();\n\n        var range = MediumEditor.selection.getSelectionRange(this.document);\n        if (range.startContainer.nodeName.toLowerCase() === 'td' ||\n          range.endContainer.nodeName.toLowerCase() === 'td' ||\n          MediumEditor.util.getClosestTag(MediumEditor.selection.getSelectedParentElement(range), 'td')) {\n            this.builder.setEditor(MediumEditor.selection.getSelectedParentElement(range));\n        } else {\n            this.builder.setBuilder();\n        }\n        this.builder.show(this.button.offsetLeft);\n    },\n\n    getForm: function () {\n        if (!this.builder) {\n            this.builder = new Builder({\n                onClick: function (rows, columns) {\n                    if (rows > 0 || columns > 0) {\n                        this.table.insert(rows, columns);\n                    }\n                    this.hide();\n                }.bind(this),\n                ownerDocument: this.document,\n                rows: this.rows || 10,\n                columns: this.columns || 10\n            });\n\n            this.table = new Table(this.base);\n        }\n\n        return this.builder.getElement();\n    }\n});\n\n  return MediumEditorTable;\n}()));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvbWVkaXVtLWVkaXRvci10YWJsZXMvZGlzdC9qcy9tZWRpdW0tZWRpdG9yLXRhYmxlcy5qcz9mYjEyIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBpc0VsZWN0cm9uID0gdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb247XG4gIGlmICghaXNFbGVjdHJvbiAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuTWVkaXVtRWRpdG9yVGFibGUgPSBmYWN0b3J5O1xuICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGV4dGVuZChkZXN0LCBzb3VyY2UpIHtcbiAgICB2YXIgcHJvcDtcbiAgICBkZXN0ID0gZGVzdCB8fCB7fTtcbiAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgIWRlc3QuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgIGRlc3RbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvblRleHQoZG9jKSB7XG4gICAgaWYgKGRvYy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGRvYy5nZXRTZWxlY3Rpb24oKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoZG9jLnNlbGVjdGlvbiAmJiBkb2Muc2VsZWN0aW9uLnR5cGUgIT09ICdDb250cm9sJykge1xuICAgICAgICByZXR1cm4gZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uU3RhcnQoZG9jKSB7XG4gICAgdmFyIG5vZGUgPSBkb2MuZ2V0U2VsZWN0aW9uKCkuYW5jaG9yTm9kZSxcbiAgICAgICAgc3RhcnROb2RlID0gKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMyA/IG5vZGUucGFyZW50Tm9kZSA6IG5vZGUpO1xuXG4gICAgcmV0dXJuIHN0YXJ0Tm9kZTtcbn1cblxuZnVuY3Rpb24gcGxhY2VDYXJldEF0Tm9kZShkb2MsIG5vZGUsIGJlZm9yZSkge1xuICAgIGlmIChkb2MuZ2V0U2VsZWN0aW9uICE9PSB1bmRlZmluZWQgJiYgbm9kZSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKSxcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydEJlZm9yZShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcblxuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0luc2lkZUVsZW1lbnRPZlRhZyhub2RlLCB0YWcpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlLFxuICAgICAgICB0YWdOYW1lID0gcGFyZW50Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB3aGlsZSAodGFnTmFtZSAhPT0gJ2JvZHknKSB7XG4gICAgICAgIGlmICh0YWdOYW1lID09PSB0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS50YWdOYW1lKSB7XG4gICAgICAgICAgICB0YWdOYW1lID0gcGFyZW50Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudE9mKGVsLCB0YWdUYXJnZXQpIHtcbiAgICB2YXIgdGFnTmFtZSA9IGVsICYmIGVsLnRhZ05hbWUgPyBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgOiBmYWxzZTtcblxuICAgIGlmICghdGFnTmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlICh0YWdOYW1lICYmIHRhZ05hbWUgIT09ICdib2R5Jykge1xuICAgICAgICBpZiAodGFnTmFtZSA9PT0gdGFnVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICB0YWdOYW1lID0gZWwgJiYgZWwudGFnTmFtZSA/IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA6IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gR3JpZChlbCwgY2FsbGJhY2ssIHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0KGVsLCBjYWxsYmFjaywgcm93cywgY29sdW1ucyk7XG59XG5cbkdyaWQucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChlbCwgY2FsbGJhY2ssIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5fcm9vdCA9IGVsO1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyKCk7XG4gICAgfSxcblxuICAgIHNldEN1cnJlbnRDZWxsOiBmdW5jdGlvbiAoY2VsbCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2VsbCA9IGNlbGw7XG4gICAgfSxcblxuICAgIG1hcmtDZWxsczogZnVuY3Rpb24gKCkge1xuICAgICAgICBbXS5mb3JFYWNoLmNhbGwodGhpcy5fY2VsbHNFbGVtZW50cywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBwYXJzZUludChlbC5kYXRhc2V0LmNvbHVtbiwgMTApLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHBhcnNlSW50KGVsLmRhdGFzZXQucm93LCAxMClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IHRoaXMuX2N1cnJlbnRDZWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5yb3cgPD0gdGhpcy5fY3VycmVudENlbGwucm93ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb2x1bW4gPD0gdGhpcy5fY3VycmVudENlbGwuY29sdW1uO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICBfZ2VuZXJhdGVDZWxsczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm93ID0gLTE7XG5cbiAgICAgICAgdGhpcy5fY2VsbHMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93cyAqIHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gaSAlIHRoaXMuY29sdW1ucztcblxuICAgICAgICAgICAgaWYgKGNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jZWxscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfaHRtbDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNvbHVtbnMgKiBDT0xVTU5fV0lEVEggKyBCT1JERVJfV0lEVEggKiAyLFxuICAgICAgICAgICAgaGVpZ2h0ID0gdGhpcy5yb3dzICogQ09MVU1OX1dJRFRIICsgQk9SREVSX1dJRFRIICogMixcbiAgICAgICAgICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cIm1lZGl1bS1lZGl0b3ItdGFibGUtYnVpbGRlci1ncmlkIGNsZWFyZml4XCIgc3R5bGU9XCJ3aWR0aDonICsgd2lkdGggKyAncHg7aGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7XCI+JztcbiAgICAgICAgaHRtbCArPSB0aGlzLl9jZWxsc0hUTUwoKTtcbiAgICAgICAgaHRtbCArPSAnPC9kaXY+JztcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfSxcblxuICAgIF9jZWxsc0hUTUw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVDZWxscygpO1xuICAgICAgICB0aGlzLl9jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRhYmxlLWJ1aWxkZXItY2VsbCcgK1xuICAgICAgICAgICAgICAgICAgICAoY2VsbC5hY3RpdmUgPT09IHRydWUgPyAnIGFjdGl2ZScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgJyArICdkYXRhLXJvdz1cIicgKyBjZWxsLnJvdyArXG4gICAgICAgICAgICAgICAgICAgICdcIiBkYXRhLWNvbHVtbj1cIicgKyBjZWxsLmNvbHVtbiArICdcIj4nO1xuICAgICAgICAgICAgaHRtbCArPSAnPC9hPic7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuXG4gICAgX3JlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9yb290LmlubmVySFRNTCA9IHRoaXMuX2h0bWwoKTtcbiAgICAgICAgdGhpcy5fY2VsbHNFbGVtZW50cyA9IHRoaXMuX3Jvb3QucXVlcnlTZWxlY3RvckFsbCgnYScpO1xuICAgICAgICB0aGlzLl9iaW5kRXZlbnRzKCk7XG4gICAgfSxcblxuICAgIF9iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFtdLmZvckVhY2guY2FsbCh0aGlzLl9jZWxsc0VsZW1lbnRzLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX29uTW91c2VFbnRlcihlbCk7XG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrKGVsKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgX29uTW91c2VFbnRlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHRpbWVyO1xuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgICAgICAgICB2YXIgZGF0YXNldCA9IHRoaXMuZGF0YXNldDtcblxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9jdXJyZW50Q2VsbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBwYXJzZUludChkYXRhc2V0LmNvbHVtbiwgMTApLFxuICAgICAgICAgICAgICAgICAgICByb3c6IHBhcnNlSW50KGRhdGFzZXQucm93LCAxMClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNlbGYubWFya0NlbGxzKCk7XG4gICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfb25DbGljazogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgc2VsZi5fY2FsbGJhY2sodGhpcy5kYXRhc2V0LnJvdywgdGhpcy5kYXRhc2V0LmNvbHVtbik7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIEJ1aWxkZXIob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmluaXQob3B0aW9ucyk7XG59XG5cbkJ1aWxkZXIucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2RvYyA9IG9wdGlvbnMub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX2RvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcm9vdC5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10YWJsZS1idWlsZGVyJztcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3IEdyaWQoXG4gICAgICAgICAgdGhpcy5fcm9vdCxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25DbGljayxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMucm93cyxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY29sdW1uc1xuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX3JhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdG9vbGJhciA9IHRoaXMuX2RvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fdG9vbGJhci5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10YWJsZS1idWlsZGVyLXRvb2xiYXInO1xuXG4gICAgICAgIHZhciBzcGFuUm93ID0gdGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3BhblJvdy5pbm5lckhUTUwgPSAnUm93Oic7XG4gICAgICAgIHRoaXMuX3Rvb2xiYXIuYXBwZW5kQ2hpbGQoc3BhblJvdyk7XG4gICAgICAgIHZhciBhZGRSb3dCZWZvcmUgPSB0aGlzLl9kb2MuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGFkZFJvd0JlZm9yZS50aXRsZSA9ICdBZGQgcm93IGJlZm9yZSc7XG4gICAgICAgIGFkZFJvd0JlZm9yZS5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmYSBmYS1sb25nLWFycm93LXVwXCI+PC9pPic7XG4gICAgICAgIGFkZFJvd0JlZm9yZS5vbmNsaWNrID0gdGhpcy5hZGRSb3cuYmluZCh0aGlzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdG9vbGJhci5hcHBlbmRDaGlsZChhZGRSb3dCZWZvcmUpO1xuXG4gICAgICAgIHZhciBhZGRSb3dBZnRlciA9IHRoaXMuX2RvYy5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYWRkUm93QWZ0ZXIudGl0bGUgPSAnQWRkIHJvdyBhZnRlcic7XG4gICAgICAgIGFkZFJvd0FmdGVyLmlubmVySFRNTCA9ICc8aSBjbGFzcz1cImZhIGZhLWxvbmctYXJyb3ctZG93blwiPjwvaT4nO1xuICAgICAgICBhZGRSb3dBZnRlci5vbmNsaWNrID0gdGhpcy5hZGRSb3cuYmluZCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3Rvb2xiYXIuYXBwZW5kQ2hpbGQoYWRkUm93QWZ0ZXIpO1xuXG4gICAgICAgIHZhciByZW1Sb3cgPSB0aGlzLl9kb2MuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHJlbVJvdy50aXRsZSA9ICdSZW1vdmUgcm93JztcbiAgICAgICAgcmVtUm93LmlubmVySFRNTCA9ICc8aSBjbGFzcz1cImZhIGZhLWNsb3NlXCI+PC9pPic7XG4gICAgICAgIHJlbVJvdy5vbmNsaWNrID0gdGhpcy5yZW1vdmVSb3cuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdG9vbGJhci5hcHBlbmRDaGlsZChyZW1Sb3cpO1xuXG4gICAgICAgIHZhciBzcGFuQ29sID0gdGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3BhbkNvbC5pbm5lckhUTUwgPSAnQ29sdW1uOic7XG4gICAgICAgIHRoaXMuX3Rvb2xiYXIuYXBwZW5kQ2hpbGQoc3BhbkNvbCk7XG4gICAgICAgIHZhciBhZGRDb2x1bW5CZWZvcmUgPSB0aGlzLl9kb2MuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGFkZENvbHVtbkJlZm9yZS50aXRsZSA9ICdBZGQgY29sdW1uIGJlZm9yZSc7XG4gICAgICAgIGFkZENvbHVtbkJlZm9yZS5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmYSBmYS1sb25nLWFycm93LWxlZnRcIj48L2k+JztcbiAgICAgICAgYWRkQ29sdW1uQmVmb3JlLm9uY2xpY2sgPSB0aGlzLmFkZENvbHVtbi5iaW5kKHRoaXMsIHRydWUpO1xuICAgICAgICB0aGlzLl90b29sYmFyLmFwcGVuZENoaWxkKGFkZENvbHVtbkJlZm9yZSk7XG5cbiAgICAgICAgdmFyIGFkZENvbHVtbkFmdGVyID0gdGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBhZGRDb2x1bW5BZnRlci50aXRsZSA9ICdBZGQgY29sdW1uIGFmdGVyJztcbiAgICAgICAgYWRkQ29sdW1uQWZ0ZXIuaW5uZXJIVE1MID0gJzxpIGNsYXNzPVwiZmEgZmEtbG9uZy1hcnJvdy1yaWdodFwiPjwvaT4nO1xuICAgICAgICBhZGRDb2x1bW5BZnRlci5vbmNsaWNrID0gdGhpcy5hZGRDb2x1bW4uYmluZCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3Rvb2xiYXIuYXBwZW5kQ2hpbGQoYWRkQ29sdW1uQWZ0ZXIpO1xuXG4gICAgICAgIHZhciByZW1Db2x1bW4gPSB0aGlzLl9kb2MuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHJlbUNvbHVtbi50aXRsZSA9ICdSZW1vdmUgY29sdW1uJztcbiAgICAgICAgcmVtQ29sdW1uLmlubmVySFRNTCA9ICc8aSBjbGFzcz1cImZhIGZhLWNsb3NlXCI+PC9pPic7XG4gICAgICAgIHJlbUNvbHVtbi5vbmNsaWNrID0gdGhpcy5yZW1vdmVDb2x1bW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fdG9vbGJhci5hcHBlbmRDaGlsZChyZW1Db2x1bW4pO1xuXG4gICAgICAgIHZhciByZW1UYWJsZSA9IHRoaXMuX2RvYy5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgcmVtVGFibGUudGl0bGUgPSAnUmVtb3ZlIHRhYmxlJztcbiAgICAgICAgcmVtVGFibGUuaW5uZXJIVE1MID0gJzxpIGNsYXNzPVwiZmEgZmEtdHJhc2gtb1wiPjwvaT4nO1xuICAgICAgICByZW1UYWJsZS5vbmNsaWNrID0gdGhpcy5yZW1vdmVUYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl90b29sYmFyLmFwcGVuZENoaWxkKHJlbVRhYmxlKTtcblxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuX3Jvb3QuY2hpbGROb2Rlc1swXTtcbiAgICAgICAgdGhpcy5fcm9vdC5pbnNlcnRCZWZvcmUodGhpcy5fdG9vbGJhciwgZ3JpZCk7XG4gICAgfSxcblxuICAgIGdldEVsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcm9vdC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIHRoaXMuZ3JpZC5zZXRDdXJyZW50Q2VsbCh7IGNvbHVtbjogLTEsIHJvdzogLTEgfSk7XG4gICAgICAgIHRoaXMuZ3JpZC5tYXJrQ2VsbHMoKTtcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgdGhpcy5fcm9vdC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5fcm9vdC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgfSxcblxuICAgIHNldEVkaXRvcjogZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMuX3Rvb2xiYXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfSxcblxuICAgIHNldEJ1aWxkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmFuZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl90b29sYmFyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuX2RvYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdtZWRpdW0tZWRpdG9yLXRhYmxlLWJ1aWxkZXItZ3JpZCcpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBlbGVtZW50c1tpXS5zdHlsZS5oZWlnaHQgPSAoQ09MVU1OX1dJRFRIICogdGhpcy5yb3dzICsgQk9SREVSX1dJRFRIICogMikgKyAncHgnO1xuICAgICAgICAgICAgZWxlbWVudHNbaV0uc3R5bGUud2lkdGggPSAoQ09MVU1OX1dJRFRIICogdGhpcy5jb2x1bW5zICsgQk9SREVSX1dJRFRIICogMikgKyAncHgnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFkZFJvdzogZnVuY3Rpb24gKGJlZm9yZSwgZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciB0Ym9keSA9IHRoaXMuX3JhbmdlLnBhcmVudE5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHRyID0gdGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQoJ3RyJyksXG4gICAgICAgICAgICB0ZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yYW5nZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRkID0gdGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICB0ZC5hcHBlbmRDaGlsZCh0aGlzLl9kb2MuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZm9yZSAhPT0gdHJ1ZSAmJiB0aGlzLl9yYW5nZS5wYXJlbnROb2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB0Ym9keS5pbnNlcnRCZWZvcmUodHIsIHRoaXMuX3JhbmdlLnBhcmVudE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKGJlZm9yZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGJvZHkuaW5zZXJ0QmVmb3JlKHRyLCB0aGlzLl9yYW5nZS5wYXJlbnROb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRib2R5LmFwcGVuZENoaWxkKHRyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMub25DbGljaygwLCAwKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlUm93OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX3JhbmdlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9yYW5nZS5wYXJlbnROb2RlKTtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ2xpY2soMCwgMCk7XG4gICAgfSxcblxuICAgIGFkZENvbHVtbjogZnVuY3Rpb24gKGJlZm9yZSwgZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBjZWxsID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLl9yYW5nZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMsIHRoaXMuX3JhbmdlKSxcbiAgICAgICAgICAgIHRib2R5ID0gdGhpcy5fcmFuZ2UucGFyZW50Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgdGQ7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Ym9keS5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZCA9IHRoaXMuX2RvYy5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgdGQuYXBwZW5kQ2hpbGQodGhpcy5fZG9jLmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRib2R5LmNoaWxkTm9kZXNbaV0uaW5zZXJ0QmVmb3JlKHRkLCB0Ym9keS5jaGlsZE5vZGVzW2ldLmNoaWxkTm9kZXNbY2VsbF0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9yYW5nZS5wYXJlbnROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1tpXS5jaGlsZE5vZGVzW2NlbGxdLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGJvZHkuY2hpbGROb2Rlc1tpXS5pbnNlcnRCZWZvcmUodGQsIHRib2R5LmNoaWxkTm9kZXNbaV0uY2hpbGROb2Rlc1tjZWxsXS5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRib2R5LmNoaWxkTm9kZXNbaV0uYXBwZW5kQ2hpbGQodGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLm9uQ2xpY2soMCwgMCk7XG4gICAgfSxcblxuICAgIHJlbW92ZUNvbHVtbjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgY2VsbCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcy5fcmFuZ2UucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCB0aGlzLl9yYW5nZSksXG4gICAgICAgICAgICB0Ym9keSA9IHRoaXMuX3JhbmdlLnBhcmVudE5vZGUucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIHJvd3MgPSB0Ym9keS5jaGlsZE5vZGVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgdGJvZHkuY2hpbGROb2Rlc1tpXS5yZW1vdmVDaGlsZCh0Ym9keS5jaGlsZE5vZGVzW2ldLmNoaWxkTm9kZXNbY2VsbF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNsaWNrKDAsIDApO1xuICAgIH0sXG5cbiAgICByZW1vdmVUYWJsZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgY2VsbCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcy5fcmFuZ2UucGFyZW50Tm9kZS5jaGlsZE5vZGVzLCB0aGlzLl9yYW5nZSksXG4gICAgICAgICAgICB0YWJsZSA9IHRoaXMuX3JhbmdlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICAgIHRhYmxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFibGUpO1xuICAgICAgICB0aGlzLm9wdGlvbnMub25DbGljaygwLCAwKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBUYWJsZShlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0KGVkaXRvcik7XG59XG5cbnZhciBUQUJfS0VZX0NPREUgPSA5O1xuXG5UYWJsZS5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICB0aGlzLl9lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuX2RvYyA9IHRoaXMuX2VkaXRvci5vcHRpb25zLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuX2JpbmRUYWJCZWhhdmlvcigpO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uIChyb3dzLCBjb2xzKSB7XG4gICAgICAgIHZhciBodG1sID0gdGhpcy5faHRtbChyb3dzLCBjb2xzKTtcblxuICAgICAgICB0aGlzLl9lZGl0b3IucGFzdGVIVE1MKFxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIm1lZGl1bS1lZGl0b3ItdGFibGVcIiBpZD1cIm1lZGl1bS1lZGl0b3ItdGFibGVcIicgK1xuICAgICAgICAgICAgJyB3aWR0aD1cIjEwMCVcIj4nICtcbiAgICAgICAgICAgICc8dGJvZHk+JyArXG4gICAgICAgICAgICBodG1sICtcbiAgICAgICAgICAgICc8L3Rib2R5PicgK1xuICAgICAgICAgICAgJzwvdGFibGU+Jywge1xuICAgICAgICAgICAgICAgIGNsZWFuQXR0cnM6IFtdLFxuICAgICAgICAgICAgICAgIGNsZWFuVGFnczogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgdGFibGUgPSB0aGlzLl9kb2MuZ2V0RWxlbWVudEJ5SWQoJ21lZGl1bS1lZGl0b3ItdGFibGUnKTtcbiAgICAgICAgdGFibGUucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBwbGFjZUNhcmV0QXROb2RlKHRoaXMuX2RvYywgdGFibGUucXVlcnlTZWxlY3RvcigndGQnKSwgdHJ1ZSk7XG5cbiAgICAgICAgdGhpcy5fZWRpdG9yLmNoZWNrU2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIF9odG1sOiBmdW5jdGlvbiAocm93cywgY29scykge1xuICAgICAgICB2YXIgaHRtbCA9ICcnLFxuICAgICAgICAgICAgeCwgeSxcbiAgICAgICAgICAgIHRleHQgPSBnZXRTZWxlY3Rpb25UZXh0KHRoaXMuX2RvYyk7XG5cbiAgICAgICAgZm9yICh4ID0gMDsgeCA8PSByb3dzOyB4KyspIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzx0cj4nO1xuICAgICAgICAgICAgZm9yICh5ID0gMDsgeSA8PSBjb2xzOyB5KyspIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8dGQ+JyArICh4ID09PSAwICYmIHkgPT09IDAgPyB0ZXh0IDogJzxiciAvPicpICsgJzwvdGQ+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh0bWwgKz0gJzwvdHI+JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuXG4gICAgX2JpbmRUYWJCZWhhdmlvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIFtdLmZvckVhY2guY2FsbCh0aGlzLl9lZGl0b3IuZWxlbWVudHMsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb25LZXlEb3duKGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZWwgPSBnZXRTZWxlY3Rpb25TdGFydCh0aGlzLl9kb2MpLFxuICAgICAgICAgICAgdGFibGU7XG5cbiAgICAgICAgaWYgKGUud2hpY2ggPT09IFRBQl9LRVlfQ09ERSAmJiBpc0luc2lkZUVsZW1lbnRPZlRhZyhlbCwgJ3RhYmxlJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB0YWJsZSA9IHRoaXMuX2dldFRhYmxlRWxlbWVudHMoZWwpO1xuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWJCYWNrd2FyZHMoZWwucHJldmlvdXNTaWJsaW5nLCB0YWJsZS5yb3cpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNMYXN0Q2VsbChlbCwgdGFibGUucm93LCB0YWJsZS5yb290KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnRSb3coZ2V0UGFyZW50T2YoZWwsICd0Ym9keScpLCB0YWJsZS5yb3cuY2VsbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGxhY2VDYXJldEF0Tm9kZSh0aGlzLl9kb2MsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0VGFibGVFbGVtZW50czogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjZWxsOiBnZXRQYXJlbnRPZihlbCwgJ3RkJyksXG4gICAgICAgICAgICByb3c6IGdldFBhcmVudE9mKGVsLCAndHInKSxcbiAgICAgICAgICAgIHJvb3Q6IGdldFBhcmVudE9mKGVsLCAndGFibGUnKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBfdGFiQmFja3dhcmRzOiBmdW5jdGlvbiAoZWwsIHJvdykge1xuICAgICAgICBlbCA9IGVsIHx8IHRoaXMuX2dldFByZXZpb3VzUm93TGFzdENlbGwocm93KTtcbiAgICAgICAgcGxhY2VDYXJldEF0Tm9kZSh0aGlzLl9kb2MsIGVsLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgX2luc2VydFJvdzogZnVuY3Rpb24gKHRib2R5LCBjb2xzKSB7XG4gICAgICAgIHZhciB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyksXG4gICAgICAgICAgICBodG1sID0gJycsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2xzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzx0ZD48YnIgLz48L3RkPic7XG4gICAgICAgIH1cbiAgICAgICAgdHIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgdGJvZHkuYXBwZW5kQ2hpbGQodHIpO1xuICAgIH0sXG5cbiAgICBfaXNMYXN0Q2VsbDogZnVuY3Rpb24gKGVsLCByb3csIHRhYmxlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHJvdy5jZWxscy5sZW5ndGggLSAxKSA9PT0gZWwuY2VsbEluZGV4ICYmXG4gICAgICAgICAgKHRhYmxlLnJvd3MubGVuZ3RoIC0gMSkgPT09IHJvdy5yb3dJbmRleFxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBfZ2V0UHJldmlvdXNSb3dMYXN0Q2VsbDogZnVuY3Rpb24gKHJvdykge1xuICAgICAgICByb3cgPSByb3cucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gcm93LmNlbGxzW3Jvdy5jZWxscy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBDT0xVTU5fV0lEVEggPSAxNixcbiAgICBCT1JERVJfV0lEVEggPSAxLFxuICAgIE1lZGl1bUVkaXRvclRhYmxlO1xuXG5NZWRpdW1FZGl0b3JUYWJsZSA9IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvcm0uZXh0ZW5kKHtcbiAgICBuYW1lOiAndGFibGUnLFxuXG4gICAgYXJpYTogJ2NyZWF0ZSB0YWJsZScsXG4gICAgYWN0aW9uOiAndGFibGUnLFxuICAgIGNvbnRlbnREZWZhdWx0OiAnVEJMJyxcbiAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLXRhYmxlXCI+PC9pPicsXG5cbiAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXNbdGhpcy5pc0FjdGl2ZSgpID09PSB0cnVlID8gJ2hpZGUnIDogJ3Nob3cnXSgpO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0SW5hY3RpdmUoKTtcbiAgICAgICAgdGhpcy5idWlsZGVyLmhpZGUoKTtcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldEFjdGl2ZSgpO1xuXG4gICAgICAgIHZhciByYW5nZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5kb2N1bWVudCk7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydENvbnRhaW5lci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGQnIHx8XG4gICAgICAgICAgcmFuZ2UuZW5kQ29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZCcgfHxcbiAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5nZXRDbG9zZXN0VGFnKE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWRQYXJlbnRFbGVtZW50KHJhbmdlKSwgJ3RkJykpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlci5zZXRFZGl0b3IoTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZFBhcmVudEVsZW1lbnQocmFuZ2UpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlci5zZXRCdWlsZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsZGVyLnNob3codGhpcy5idXR0b24ub2Zmc2V0TGVmdCk7XG4gICAgfSxcblxuICAgIGdldEZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1aWxkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlciA9IG5ldyBCdWlsZGVyKHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAocm93cywgY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocm93cyA+IDAgfHwgY29sdW1ucyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGFibGUuaW5zZXJ0KHJvd3MsIGNvbHVtbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICAgICBvd25lckRvY3VtZW50OiB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIHJvd3M6IHRoaXMucm93cyB8fCAxMCxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmNvbHVtbnMgfHwgMTBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnRhYmxlID0gbmV3IFRhYmxlKHRoaXMuYmFzZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5idWlsZGVyLmdldEVsZW1lbnQoKTtcbiAgICB9XG59KTtcblxuICByZXR1cm4gTWVkaXVtRWRpdG9yVGFibGU7XG59KCkpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvbWVkaXVtLWVkaXRvci10YWJsZXMvZGlzdC9qcy9tZWRpdW0tZWRpdG9yLXRhYmxlcy5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_RESULT__;/*global self, document, DOMException */\n\n/*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */\n\n// Full polyfill for browsers with no classList support\nif (!(\"classList\" in document.createElement(\"_\"))) {\n  (function (view) {\n\n  \"use strict\";\n\n  if (!('Element' in view)) return;\n\n  var\n      classListProp = \"classList\"\n    , protoProp = \"prototype\"\n    , elemCtrProto = view.Element[protoProp]\n    , objCtr = Object\n    , strTrim = String[protoProp].trim || function () {\n      return this.replace(/^\\s+|\\s+$/g, \"\");\n    }\n    , arrIndexOf = Array[protoProp].indexOf || function (item) {\n      var this$1 = this;\n\n      var\n          i = 0\n        , len = this.length\n      ;\n      for (; i < len; i++) {\n        if (i in this$1 && this$1[i] === item) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    // Vendors: please allow content code to instantiate DOMExceptions\n    , DOMEx = function (type, message) {\n      this.name = type;\n      this.code = DOMException[type];\n      this.message = message;\n    }\n    , checkTokenAndGetIndex = function (classList, token) {\n      if (token === \"\") {\n        throw new DOMEx(\n            \"SYNTAX_ERR\"\n          , \"An invalid or illegal string was specified\"\n        );\n      }\n      if (/\\s/.test(token)) {\n        throw new DOMEx(\n            \"INVALID_CHARACTER_ERR\"\n          , \"String contains an invalid character\"\n        );\n      }\n      return arrIndexOf.call(classList, token);\n    }\n    , ClassList = function (elem) {\n      var this$1 = this;\n\n      var\n          trimmedClasses = strTrim.call(elem.getAttribute(\"class\") || \"\")\n        , classes = trimmedClasses ? trimmedClasses.split(/\\s+/) : []\n        , i = 0\n        , len = classes.length\n      ;\n      for (; i < len; i++) {\n        this$1.push(classes[i]);\n      }\n      this._updateClassName = function () {\n        elem.setAttribute(\"class\", this.toString());\n      };\n    }\n    , classListProto = ClassList[protoProp] = []\n    , classListGetter = function () {\n      return new ClassList(this);\n    }\n  ;\n  // Most DOMException implementations don't allow calling DOMException's toString()\n  // on non-DOMExceptions. Error's toString() is sufficient here.\n  DOMEx[protoProp] = Error[protoProp];\n  classListProto.item = function (i) {\n    return this[i] || null;\n  };\n  classListProto.contains = function (token) {\n    token += \"\";\n    return checkTokenAndGetIndex(this, token) !== -1;\n  };\n  classListProto.add = function () {\n    var this$1 = this;\n\n    var\n        tokens = arguments\n      , i = 0\n      , l = tokens.length\n      , token\n      , updated = false\n    ;\n    do {\n      token = tokens[i] + \"\";\n      if (checkTokenAndGetIndex(this$1, token) === -1) {\n        this$1.push(token);\n        updated = true;\n      }\n    }\n    while (++i < l);\n\n    if (updated) {\n      this._updateClassName();\n    }\n  };\n  classListProto.remove = function () {\n    var this$1 = this;\n\n    var\n        tokens = arguments\n      , i = 0\n      , l = tokens.length\n      , token\n      , updated = false\n      , index\n    ;\n    do {\n      token = tokens[i] + \"\";\n      index = checkTokenAndGetIndex(this$1, token);\n      while (index !== -1) {\n        this$1.splice(index, 1);\n        updated = true;\n        index = checkTokenAndGetIndex(this$1, token);\n      }\n    }\n    while (++i < l);\n\n    if (updated) {\n      this._updateClassName();\n    }\n  };\n  classListProto.toggle = function (token, force) {\n    token += \"\";\n\n    var\n        result = this.contains(token)\n      , method = result ?\n        force !== true && \"remove\"\n      :\n        force !== false && \"add\"\n    ;\n\n    if (method) {\n      this[method](token);\n    }\n\n    if (force === true || force === false) {\n      return force;\n    } else {\n      return !result;\n    }\n  };\n  classListProto.toString = function () {\n    return this.join(\" \");\n  };\n\n  if (objCtr.defineProperty) {\n    var classListPropDesc = {\n        get: classListGetter\n      , enumerable: true\n      , configurable: true\n    };\n    try {\n      objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n    } catch (ex) { // IE 8 doesn't support enumerable:true\n      if (ex.number === -0x7FF5EC54) {\n        classListPropDesc.enumerable = false;\n        objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\n      }\n    }\n  } else if (objCtr[protoProp].__defineGetter__) {\n    elemCtrProto.__defineGetter__(classListProp, classListGetter);\n  }\n\n  }(self));\n}\n\n/* Blob.js\n * A Blob implementation.\n * 2014-07-24\n *\n * By Eli Grey, http://eligrey.com\n * By Devin Samarin, https://github.com/dsamarin\n * License: X11/MIT\n *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md\n */\n\n/*global self, unescape */\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */\n\n(function (view) {\n  \"use strict\";\n\n  view.URL = view.URL || view.webkitURL;\n\n  if (view.Blob && view.URL) {\n    try {\n      new Blob;\n      return;\n    } catch (e) {}\n  }\n\n  // Internally we use a BlobBuilder implementation to base Blob off of\n  // in order to support older browsers that only have BlobBuilder\n  var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {\n    var\n        get_class = function(object) {\n        return Object.prototype.toString.call(object).match(/^\\[object\\s(.*)\\]$/)[1];\n      }\n      , FakeBlobBuilder = function BlobBuilder() {\n        this.data = [];\n      }\n      , FakeBlob = function Blob(data, type, encoding) {\n        this.data = data;\n        this.size = data.length;\n        this.type = type;\n        this.encoding = encoding;\n      }\n      , FBB_proto = FakeBlobBuilder.prototype\n      , FB_proto = FakeBlob.prototype\n      , FileReaderSync = view.FileReaderSync\n      , FileException = function(type) {\n        this.code = this[this.name = type];\n      }\n      , file_ex_codes = (\n          \"NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR \"\n        + \"NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR\"\n      ).split(\" \")\n      , file_ex_code = file_ex_codes.length\n      , real_URL = view.URL || view.webkitURL || view\n      , real_create_object_URL = real_URL.createObjectURL\n      , real_revoke_object_URL = real_URL.revokeObjectURL\n      , URL = real_URL\n      , btoa = view.btoa\n      , atob = view.atob\n\n      , ArrayBuffer = view.ArrayBuffer\n      , Uint8Array = view.Uint8Array\n\n      , origin = /^[\\w-]+:\\/*\\[?[\\w\\.:-]+\\]?(?::[0-9]+)?/\n    ;\n    FakeBlob.fake = FB_proto.fake = true;\n    while (file_ex_code--) {\n      FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;\n    }\n    // Polyfill URL\n    if (!real_URL.createObjectURL) {\n      URL = view.URL = function(uri) {\n        var\n            uri_info = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n          , uri_origin\n        ;\n        uri_info.href = uri;\n        if (!(\"origin\" in uri_info)) {\n          if (uri_info.protocol.toLowerCase() === \"data:\") {\n            uri_info.origin = null;\n          } else {\n            uri_origin = uri.match(origin);\n            uri_info.origin = uri_origin && uri_origin[1];\n          }\n        }\n        return uri_info;\n      };\n    }\n    URL.createObjectURL = function(blob) {\n      var\n          type = blob.type\n        , data_URI_header\n      ;\n      if (type === null) {\n        type = \"application/octet-stream\";\n      }\n      if (blob instanceof FakeBlob) {\n        data_URI_header = \"data:\" + type;\n        if (blob.encoding === \"base64\") {\n          return data_URI_header + \";base64,\" + blob.data;\n        } else if (blob.encoding === \"URI\") {\n          return data_URI_header + \",\" + decodeURIComponent(blob.data);\n        } if (btoa) {\n          return data_URI_header + \";base64,\" + btoa(blob.data);\n        } else {\n          return data_URI_header + \",\" + encodeURIComponent(blob.data);\n        }\n      } else if (real_create_object_URL) {\n        return real_create_object_URL.call(real_URL, blob);\n      }\n    };\n    URL.revokeObjectURL = function(object_URL) {\n      if (object_URL.substring(0, 5) !== \"data:\" && real_revoke_object_URL) {\n        real_revoke_object_URL.call(real_URL, object_URL);\n      }\n    };\n    FBB_proto.append = function(data/*, endings*/) {\n      var bb = this.data;\n      // decode data to a binary string\n      if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {\n        var\n            str = \"\"\n          , buf = new Uint8Array(data)\n          , i = 0\n          , buf_len = buf.length\n        ;\n        for (; i < buf_len; i++) {\n          str += String.fromCharCode(buf[i]);\n        }\n        bb.push(str);\n      } else if (get_class(data) === \"Blob\" || get_class(data) === \"File\") {\n        if (FileReaderSync) {\n          var fr = new FileReaderSync;\n          bb.push(fr.readAsBinaryString(data));\n        } else {\n          // async FileReader won't work as BlobBuilder is sync\n          throw new FileException(\"NOT_READABLE_ERR\");\n        }\n      } else if (data instanceof FakeBlob) {\n        if (data.encoding === \"base64\" && atob) {\n          bb.push(atob(data.data));\n        } else if (data.encoding === \"URI\") {\n          bb.push(decodeURIComponent(data.data));\n        } else if (data.encoding === \"raw\") {\n          bb.push(data.data);\n        }\n      } else {\n        if (typeof data !== \"string\") {\n          data += \"\"; // convert unsupported types to strings\n        }\n        // decode UTF-16 to binary string\n        bb.push(unescape(encodeURIComponent(data)));\n      }\n    };\n    FBB_proto.getBlob = function(type) {\n      if (!arguments.length) {\n        type = null;\n      }\n      return new FakeBlob(this.data.join(\"\"), type, \"raw\");\n    };\n    FBB_proto.toString = function() {\n      return \"[object BlobBuilder]\";\n    };\n    FB_proto.slice = function(start, end, type) {\n      var args = arguments.length;\n      if (args < 3) {\n        type = null;\n      }\n      return new FakeBlob(\n          this.data.slice(start, args > 1 ? end : this.data.length)\n        , type\n        , this.encoding\n      );\n    };\n    FB_proto.toString = function() {\n      return \"[object Blob]\";\n    };\n    FB_proto.close = function() {\n      this.size = 0;\n      delete this.data;\n    };\n    return FakeBlobBuilder;\n  }(view));\n\n  view.Blob = function(blobParts, options) {\n    var type = options ? (options.type || \"\") : \"\";\n    var builder = new BlobBuilder();\n    if (blobParts) {\n      for (var i = 0, len = blobParts.length; i < len; i++) {\n        if (Uint8Array && blobParts[i] instanceof Uint8Array) {\n          builder.append(blobParts[i].buffer);\n        }\n        else {\n          builder.append(blobParts[i]);\n        }\n      }\n    }\n    var blob = builder.getBlob(type);\n    if (!blob.slice && blob.webkitSlice) {\n      blob.slice = blob.webkitSlice;\n    }\n    return blob;\n  };\n\n  var getPrototypeOf = Object.getPrototypeOf || function(object) {\n    return object.__proto__;\n  };\n  view.Blob.prototype = getPrototypeOf(new view.Blob());\n}(typeof self !== \"undefined\" && self || typeof window !== \"undefined\" && window || this.content || this));\n\n(function (root, factory) {\n    'use strict';\n    var isElectron = typeof module === 'object' && process && process.versions && process.versions.electron;\n    if (!isElectron && typeof module === 'object') {\n        module.exports = factory;\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return factory;\n        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        root.MediumEditor = factory;\n    }\n}(this, function () {\n\n    'use strict';\n\nfunction MediumEditor(elements, options) {\n    'use strict';\n    return this.init(elements, options);\n}\n\nMediumEditor.extensions = {};\n/*jshint unused: true */\n(function (window) {\n    'use strict';\n\n    function copyInto(overwrite, dest) {\n        var prop,\n            sources = Array.prototype.slice.call(arguments, 2);\n        dest = dest || {};\n        for (var i = 0; i < sources.length; i++) {\n            var source = sources[i];\n            if (source) {\n                for (prop in source) {\n                    if (source.hasOwnProperty(prop) &&\n                        typeof source[prop] !== 'undefined' &&\n                        (overwrite || dest.hasOwnProperty(prop) === false)) {\n                        dest[prop] = source[prop];\n                    }\n                }\n            }\n        }\n        return dest;\n    }\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\n    // Some browsers (including phantom) don't return true for Node.contains(child)\n    // if child is a text node.  Detect these cases here and use a fallback\n    // for calls to Util.isDescendant()\n    var nodeContainsWorksWithTextNodes = false;\n    try {\n        var testParent = document.createElement('div'),\n            testText = document.createTextNode(' ');\n        testParent.appendChild(testText);\n        nodeContainsWorksWithTextNodes = testParent.contains(testText);\n    } catch (exc) {}\n\n    var Util = {\n\n        // http://stackoverflow.com/questions/17907445/how-to-detect-ie11#comment30165888_17907562\n        // by rg89\n        isIE: ((navigator.appName === 'Microsoft Internet Explorer') || ((navigator.appName === 'Netscape') && (new RegExp('Trident/.*rv:([0-9]{1,}[.0-9]{0,})').exec(navigator.userAgent) !== null))),\n\n        isEdge: (/Edge\\/\\d+/).exec(navigator.userAgent) !== null,\n\n        // if firefox\n        isFF: (navigator.userAgent.toLowerCase().indexOf('firefox') > -1),\n\n        // http://stackoverflow.com/a/11752084/569101\n        isMac: (window.navigator.platform.toUpperCase().indexOf('MAC') >= 0),\n\n        // https://github.com/jashkenas/underscore\n        // Lonely letter MUST USE the uppercase code\n        keyCode: {\n            BACKSPACE: 8,\n            TAB: 9,\n            ENTER: 13,\n            ESCAPE: 27,\n            SPACE: 32,\n            DELETE: 46,\n            K: 75, // K keycode, and not k\n            M: 77,\n            V: 86\n        },\n\n        /**\n         * Returns true if it's metaKey on Mac, or ctrlKey on non-Mac.\n         * See #591\n         */\n        isMetaCtrlKey: function (event) {\n            if ((Util.isMac && event.metaKey) || (!Util.isMac && event.ctrlKey)) {\n                return true;\n            }\n\n            return false;\n        },\n\n        /**\n         * Returns true if the key associated to the event is inside keys array\n         *\n         * @see : https://github.com/jquery/jquery/blob/0705be475092aede1eddae01319ec931fb9c65fc/src/event.js#L473-L484\n         * @see : http://stackoverflow.com/q/4471582/569101\n         */\n        isKey: function (event, keys) {\n            var keyCode = Util.getKeyCode(event);\n\n            // it's not an array let's just compare strings!\n            if (false === Array.isArray(keys)) {\n                return keyCode === keys;\n            }\n\n            if (-1 === keys.indexOf(keyCode)) {\n                return false;\n            }\n\n            return true;\n        },\n\n        getKeyCode: function (event) {\n            var keyCode = event.which;\n\n            // getting the key code from event\n            if (null === keyCode) {\n                keyCode = event.charCode !== null ? event.charCode : event.keyCode;\n            }\n\n            return keyCode;\n        },\n\n        blockContainerElementNames: [\n            // elements our editor generates\n            'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre', 'ul', 'li', 'ol',\n            // all other known block elements\n            'address', 'article', 'aside', 'audio', 'canvas', 'dd', 'dl', 'dt', 'fieldset',\n            'figcaption', 'figure', 'footer', 'form', 'header', 'hgroup', 'main', 'nav',\n            'noscript', 'output', 'section', 'video',\n            'table', 'thead', 'tbody', 'tfoot', 'tr', 'th', 'td'\n        ],\n\n        emptyElementNames: ['br', 'col', 'colgroup', 'hr', 'img', 'input', 'source', 'wbr'],\n\n        extend: function extend(/* dest, source1, source2, ...*/) {\n            var args = [true].concat(Array.prototype.slice.call(arguments));\n            return copyInto.apply(this, args);\n        },\n\n        defaults: function defaults(/*dest, source1, source2, ...*/) {\n            var args = [false].concat(Array.prototype.slice.call(arguments));\n            return copyInto.apply(this, args);\n        },\n\n        /*\n         * Create a link around the provided text nodes which must be adjacent to each other and all be\n         * descendants of the same closest block container. If the preconditions are not met, unexpected\n         * behavior will result.\n         */\n        createLink: function (document, textNodes, href, target) {\n            var anchor = document.createElement('a');\n            Util.moveTextRangeIntoElement(textNodes[0], textNodes[textNodes.length - 1], anchor);\n            anchor.setAttribute('href', href);\n            if (target) {\n                anchor.setAttribute('target', target);\n            }\n            return anchor;\n        },\n\n        /*\n         * Given the provided match in the format {start: 1, end: 2} where start and end are indices into the\n         * textContent of the provided element argument, modify the DOM inside element to ensure that the text\n         * identified by the provided match can be returned as text nodes that contain exactly that text, without\n         * any additional text at the beginning or end of the returned array of adjacent text nodes.\n         *\n         * The only DOM manipulation performed by this function is splitting the text nodes, non-text nodes are\n         * not affected in any way.\n         */\n        findOrCreateMatchingTextNodes: function (document, element, match) {\n            var treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ALL, null, false),\n                matchedNodes = [],\n                currentTextIndex = 0,\n                startReached = false,\n                currentNode = null,\n                newNode = null;\n\n            while ((currentNode = treeWalker.nextNode()) !== null) {\n                if (currentNode.nodeType > 3) {\n                    continue;\n                } else if (currentNode.nodeType === 3) {\n                    if (!startReached && match.start < (currentTextIndex + currentNode.nodeValue.length)) {\n                        startReached = true;\n                        newNode = Util.splitStartNodeIfNeeded(currentNode, match.start, currentTextIndex);\n                    }\n                    if (startReached) {\n                        Util.splitEndNodeIfNeeded(currentNode, newNode, match.end, currentTextIndex);\n                    }\n                    if (startReached && currentTextIndex === match.end) {\n                        break; // Found the node(s) corresponding to the link. Break out and move on to the next.\n                    } else if (startReached && currentTextIndex > (match.end + 1)) {\n                        throw new Error('PerformLinking overshot the target!'); // should never happen...\n                    }\n\n                    if (startReached) {\n                        matchedNodes.push(newNode || currentNode);\n                    }\n\n                    currentTextIndex += currentNode.nodeValue.length;\n                    if (newNode !== null) {\n                        currentTextIndex += newNode.nodeValue.length;\n                        // Skip the newNode as we'll already have pushed it to the matches\n                        treeWalker.nextNode();\n                    }\n                    newNode = null;\n                } else if (currentNode.tagName.toLowerCase() === 'img') {\n                    if (!startReached && (match.start <= currentTextIndex)) {\n                        startReached = true;\n                    }\n                    if (startReached) {\n                        matchedNodes.push(currentNode);\n                    }\n                }\n            }\n            return matchedNodes;\n        },\n\n        /*\n         * Given the provided text node and text coordinates, split the text node if needed to make it align\n         * precisely with the coordinates.\n         *\n         * This function is intended to be called from Util.findOrCreateMatchingTextNodes.\n         */\n        splitStartNodeIfNeeded: function (currentNode, matchStartIndex, currentTextIndex) {\n            if (matchStartIndex !== currentTextIndex) {\n                return currentNode.splitText(matchStartIndex - currentTextIndex);\n            }\n            return null;\n        },\n\n        /*\n         * Given the provided text node and text coordinates, split the text node if needed to make it align\n         * precisely with the coordinates. The newNode argument should from the result of Util.splitStartNodeIfNeeded,\n         * if that function has been called on the same currentNode.\n         *\n         * This function is intended to be called from Util.findOrCreateMatchingTextNodes.\n         */\n        splitEndNodeIfNeeded: function (currentNode, newNode, matchEndIndex, currentTextIndex) {\n            var textIndexOfEndOfFarthestNode,\n                endSplitPoint;\n            textIndexOfEndOfFarthestNode = currentTextIndex + (newNode || currentNode).nodeValue.length +\n                    (newNode ? currentNode.nodeValue.length : 0) -\n                    1;\n            endSplitPoint = (newNode || currentNode).nodeValue.length -\n                    (textIndexOfEndOfFarthestNode + 1 - matchEndIndex);\n            if (textIndexOfEndOfFarthestNode >= matchEndIndex &&\n                    currentTextIndex !== textIndexOfEndOfFarthestNode &&\n                    endSplitPoint !== 0) {\n                (newNode || currentNode).splitText(endSplitPoint);\n            }\n        },\n\n        /*\n        * Take an element, and break up all of its text content into unique pieces such that:\n         * 1) All text content of the elements are in separate blocks. No piece of text content should span\n         *    across multiple blocks. This means no element return by this function should have\n         *    any blocks as children.\n         * 2) The union of the textcontent of all of the elements returned here covers all\n         *    of the text within the element.\n         *\n         *\n         * EXAMPLE:\n         * In the event that we have something like:\n         *\n         * <blockquote>\n         *   <p>Some Text</p>\n         *   <ol>\n         *     <li>List Item 1</li>\n         *     <li>List Item 2</li>\n         *   </ol>\n         * </blockquote>\n         *\n         * This function would return these elements as an array:\n         *   [ <p>Some Text</p>, <li>List Item 1</li>, <li>List Item 2</li> ]\n         *\n         * Since the <blockquote> and <ol> elements contain blocks within them they are not returned.\n         * Since the <p> and <li>'s don't contain block elements and cover all the text content of the\n         * <blockquote> container, they are the elements returned.\n         */\n        splitByBlockElements: function (element) {\n            if (element.nodeType !== 3 && element.nodeType !== 1) {\n                return [];\n            }\n\n            var toRet = [],\n                blockElementQuery = MediumEditor.util.blockContainerElementNames.join(',');\n\n            if (element.nodeType === 3 || element.querySelectorAll(blockElementQuery).length === 0) {\n                return [element];\n            }\n\n            for (var i = 0; i < element.childNodes.length; i++) {\n                var child = element.childNodes[i];\n                if (child.nodeType === 3) {\n                    toRet.push(child);\n                } else if (child.nodeType === 1) {\n                    var blockElements = child.querySelectorAll(blockElementQuery);\n                    if (blockElements.length === 0) {\n                        toRet.push(child);\n                    } else {\n                        toRet = toRet.concat(MediumEditor.util.splitByBlockElements(child));\n                    }\n                }\n            }\n\n            return toRet;\n        },\n\n        // Find the next node in the DOM tree that represents any text that is being\n        // displayed directly next to the targetNode (passed as an argument)\n        // Text that appears directly next to the current node can be:\n        //  - A sibling text node\n        //  - A descendant of a sibling element\n        //  - A sibling text node of an ancestor\n        //  - A descendant of a sibling element of an ancestor\n        findAdjacentTextNodeWithContent: function findAdjacentTextNodeWithContent(rootNode, targetNode, ownerDocument) {\n            var pastTarget = false,\n                nextNode,\n                nodeIterator = ownerDocument.createNodeIterator(rootNode, NodeFilter.SHOW_TEXT, null, false);\n\n            // Use a native NodeIterator to iterate over all the text nodes that are descendants\n            // of the rootNode.  Once past the targetNode, choose the first non-empty text node\n            nextNode = nodeIterator.nextNode();\n            while (nextNode) {\n                if (nextNode === targetNode) {\n                    pastTarget = true;\n                } else if (pastTarget) {\n                    if (nextNode.nodeType === 3 && nextNode.nodeValue && nextNode.nodeValue.trim().length > 0) {\n                        break;\n                    }\n                }\n                nextNode = nodeIterator.nextNode();\n            }\n\n            return nextNode;\n        },\n\n        // Find an element's previous sibling within a medium-editor element\n        // If one doesn't exist, find the closest ancestor's previous sibling\n        findPreviousSibling: function (node) {\n            if (!node || Util.isMediumEditorElement(node)) {\n                return false;\n            }\n\n            var previousSibling = node.previousSibling;\n            while (!previousSibling && !Util.isMediumEditorElement(node.parentNode)) {\n                node = node.parentNode;\n                previousSibling = node.previousSibling;\n            }\n\n            return previousSibling;\n        },\n\n        isDescendant: function isDescendant(parent, child, checkEquality) {\n            if (!parent || !child) {\n                return false;\n            }\n            if (parent === child) {\n                return !!checkEquality;\n            }\n            // If parent is not an element, it can't have any descendants\n            if (parent.nodeType !== 1) {\n                return false;\n            }\n            if (nodeContainsWorksWithTextNodes || child.nodeType !== 3) {\n                return parent.contains(child);\n            }\n            var node = child.parentNode;\n            while (node !== null) {\n                if (node === parent) {\n                    return true;\n                }\n                node = node.parentNode;\n            }\n            return false;\n        },\n\n        // https://github.com/jashkenas/underscore\n        isElement: function isElement(obj) {\n            return !!(obj && obj.nodeType === 1);\n        },\n\n        // https://github.com/jashkenas/underscore\n        throttle: function (func, wait) {\n            var THROTTLE_INTERVAL = 50,\n                context,\n                args,\n                result,\n                timeout = null,\n                previous = 0,\n                later = function () {\n                    previous = Date.now();\n                    timeout = null;\n                    result = func.apply(context, args);\n                    if (!timeout) {\n                        context = args = null;\n                    }\n                };\n\n            if (!wait && wait !== 0) {\n                wait = THROTTLE_INTERVAL;\n            }\n\n            return function () {\n                var now = Date.now(),\n                    remaining = wait - (now - previous);\n\n                context = this;\n                args = arguments;\n                if (remaining <= 0 || remaining > wait) {\n                    if (timeout) {\n                        clearTimeout(timeout);\n                        timeout = null;\n                    }\n                    previous = now;\n                    result = func.apply(context, args);\n                    if (!timeout) {\n                        context = args = null;\n                    }\n                } else if (!timeout) {\n                    timeout = setTimeout(later, remaining);\n                }\n                return result;\n            };\n        },\n\n        traverseUp: function (current, testElementFunction) {\n            if (!current) {\n                return false;\n            }\n\n            do {\n                if (current.nodeType === 1) {\n                    if (testElementFunction(current)) {\n                        return current;\n                    }\n                    // do not traverse upwards past the nearest containing editor\n                    if (Util.isMediumEditorElement(current)) {\n                        return false;\n                    }\n                }\n\n                current = current.parentNode;\n            } while (current);\n\n            return false;\n        },\n\n        htmlEntities: function (str) {\n            // converts special characters (like <) into their escaped/encoded values (like &lt;).\n            // This allows you to show to display the string without the browser reading it as HTML.\n            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;');\n        },\n\n        // http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div\n        insertHTMLCommand: function (doc, html) {\n            var selection, range, el, fragment, node, lastNode, toReplace,\n                res = false,\n                ecArgs = ['insertHTML', false, html];\n\n            /* Edge's implementation of insertHTML is just buggy right now:\n             * - Doesn't allow leading white space at the beginning of an element\n             * - Found a case when a <font size=\"2\"> tag was inserted when calling alignCenter inside a blockquote\n             *\n             * There are likely other bugs, these are just the ones we found so far.\n             * For now, let's just use the same fallback we did for IE\n             */\n            if (!MediumEditor.util.isEdge && doc.queryCommandSupported('insertHTML')) {\n                try {\n                    return doc.execCommand.apply(doc, ecArgs);\n                } catch (ignore) {}\n            }\n\n            selection = doc.getSelection();\n            if (selection.rangeCount) {\n                range = selection.getRangeAt(0);\n                toReplace = range.commonAncestorContainer;\n\n                // https://github.com/yabwe/medium-editor/issues/748\n                // If the selection is an empty editor element, create a temporary text node inside of the editor\n                // and select it so that we don't delete the editor element\n                if (Util.isMediumEditorElement(toReplace) && !toReplace.firstChild) {\n                    range.selectNode(toReplace.appendChild(doc.createTextNode('')));\n                } else if ((toReplace.nodeType === 3 && range.startOffset === 0 && range.endOffset === toReplace.nodeValue.length) ||\n                        (toReplace.nodeType !== 3 && toReplace.innerHTML === range.toString())) {\n                    // Ensure range covers maximum amount of nodes as possible\n                    // By moving up the DOM and selecting ancestors whose only child is the range\n                    while (!Util.isMediumEditorElement(toReplace) &&\n                            toReplace.parentNode &&\n                            toReplace.parentNode.childNodes.length === 1 &&\n                            !Util.isMediumEditorElement(toReplace.parentNode)) {\n                        toReplace = toReplace.parentNode;\n                    }\n                    range.selectNode(toReplace);\n                }\n                range.deleteContents();\n\n                el = doc.createElement('div');\n                el.innerHTML = html;\n                fragment = doc.createDocumentFragment();\n                while (el.firstChild) {\n                    node = el.firstChild;\n                    lastNode = fragment.appendChild(node);\n                }\n                range.insertNode(fragment);\n\n                // Preserve the selection:\n                if (lastNode) {\n                    range = range.cloneRange();\n                    range.setStartAfter(lastNode);\n                    range.collapse(true);\n                    MediumEditor.selection.selectRange(doc, range);\n                }\n                res = true;\n            }\n\n            // https://github.com/yabwe/medium-editor/issues/992\n            // If we're monitoring calls to execCommand, notify listeners as if a real call had happened\n            if (doc.execCommand.callListeners) {\n                doc.execCommand.callListeners(ecArgs, res);\n            }\n            return res;\n        },\n\n        execFormatBlock: function (doc, tagName) {\n            // Get the top level block element that contains the selection\n            var blockContainer = Util.getTopBlockContainer(MediumEditor.selection.getSelectionStart(doc)),\n                childNodes;\n\n            // Special handling for blockquote\n            if (tagName === 'blockquote') {\n                if (blockContainer) {\n                    childNodes = Array.prototype.slice.call(blockContainer.childNodes);\n                    // Check if the blockquote has a block element as a child (nested blocks)\n                    if (childNodes.some(function (childNode) {\n                        return Util.isBlockContainer(childNode);\n                    })) {\n                        // FF handles blockquote differently on formatBlock\n                        // allowing nesting, we need to use outdent\n                        // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla\n                        return doc.execCommand('outdent', false, null);\n                    }\n                }\n\n                // When IE blockquote needs to be called as indent\n                // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777\n                if (Util.isIE) {\n                    return doc.execCommand('indent', false, tagName);\n                }\n            }\n\n            // If the blockContainer is already the element type being passed in\n            // treat it as 'undo' formatting and just convert it to a <p>\n            if (blockContainer && tagName === blockContainer.nodeName.toLowerCase()) {\n                tagName = 'p';\n            }\n\n            // When IE we need to add <> to heading elements\n            // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie\n            if (Util.isIE) {\n                tagName = '<' + tagName + '>';\n            }\n\n            // When FF, IE and Edge, we have to handle blockquote node seperately as 'formatblock' does not work.\n            // https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand#Commands\n            if (blockContainer && blockContainer.nodeName.toLowerCase() === 'blockquote') {\n                // For IE, just use outdent\n                if (Util.isIE && tagName === '<p>') {\n                    return doc.execCommand('outdent', false, tagName);\n                }\n\n                // For Firefox and Edge, make sure there's a nested block element before calling outdent\n                if ((Util.isFF || Util.isEdge) && tagName === 'p') {\n                    childNodes = Array.prototype.slice.call(blockContainer.childNodes);\n                    // If there are some non-block elements we need to wrap everything in a <p> before we outdent\n                    if (childNodes.some(function (childNode) {\n                        return !Util.isBlockContainer(childNode);\n                    })) {\n                        doc.execCommand('formatBlock', false, tagName);\n                    }\n                    return doc.execCommand('outdent', false, tagName);\n                }\n            }\n\n            return doc.execCommand('formatBlock', false, tagName);\n        },\n\n        /**\n         * Set target to blank on the given el element\n         *\n         * TODO: not sure if this should be here\n         *\n         * When creating a link (using core -> createLink) the selection returned by Firefox will be the parent of the created link\n         * instead of the created link itself (as it is for Chrome for example), so we retrieve all \"a\" children to grab the good one by\n         * using `anchorUrl` to ensure that we are adding target=\"_blank\" on the good one.\n         * This isn't a bulletproof solution anyway ..\n         */\n        setTargetBlank: function (el, anchorUrl) {\n            var i, url = anchorUrl || false;\n            if (el.nodeName.toLowerCase() === 'a') {\n                el.target = '_blank';\n            } else {\n                el = el.getElementsByTagName('a');\n\n                for (i = 0; i < el.length; i += 1) {\n                    if (false === url || url === el[i].attributes.href.value) {\n                        el[i].target = '_blank';\n                    }\n                }\n            }\n        },\n\n        /*\n         * this function is called to explicitly remove the target='_blank' as FF holds on to _blank value even\n         * after unchecking the checkbox on anchor form\n         */\n        removeTargetBlank: function (el, anchorUrl) {\n            var i;\n            if (el.nodeName.toLowerCase() === 'a') {\n                el.removeAttribute('target');\n            } else {\n                el = el.getElementsByTagName('a');\n\n                for (i = 0; i < el.length; i += 1) {\n                    if (anchorUrl === el[i].attributes.href.value) {\n                        el[i].removeAttribute('target');\n                    }\n                }\n            }\n        },\n\n        addClassToAnchors: function (el, buttonClass) {\n            var classes = buttonClass.split(' '),\n                i,\n                j;\n            if (el.nodeName.toLowerCase() === 'a') {\n                for (j = 0; j < classes.length; j += 1) {\n                    el.classList.add(classes[j]);\n                }\n            } else {\n                el = el.getElementsByTagName('a');\n                for (i = 0; i < el.length; i += 1) {\n                    for (j = 0; j < classes.length; j += 1) {\n                        el[i].classList.add(classes[j]);\n                    }\n                }\n            }\n        },\n\n        isListItem: function (node) {\n            if (!node) {\n                return false;\n            }\n            if (node.nodeName.toLowerCase() === 'li') {\n                return true;\n            }\n\n            var parentNode = node.parentNode,\n                tagName = parentNode.nodeName.toLowerCase();\n            while (tagName === 'li' || (!Util.isBlockContainer(parentNode) && tagName !== 'div')) {\n                if (tagName === 'li') {\n                    return true;\n                }\n                parentNode = parentNode.parentNode;\n                if (parentNode) {\n                    tagName = parentNode.nodeName.toLowerCase();\n                } else {\n                    return false;\n                }\n            }\n            return false;\n        },\n\n        cleanListDOM: function (ownerDocument, element) {\n            if (element.nodeName.toLowerCase() !== 'li') {\n                return;\n            }\n\n            var list = element.parentElement;\n\n            if (list.parentElement.nodeName.toLowerCase() === 'p') { // yes we need to clean up\n                Util.unwrap(list.parentElement, ownerDocument);\n\n                // move cursor at the end of the text inside the list\n                // for some unknown reason, the cursor is moved to end of the \"visual\" line\n                MediumEditor.selection.moveCursor(ownerDocument, element.firstChild, element.firstChild.textContent.length);\n            }\n        },\n\n        /* splitDOMTree\n         *\n         * Given a root element some descendant element, split the root element\n         * into its own element containing the descendant element and all elements\n         * on the left or right side of the descendant ('right' is default)\n         *\n         * example:\n         *\n         *         <div>\n         *      /    |   \\\n         *  <span> <span> <span>\n         *   / \\    / \\    / \\\n         *  1   2  3   4  5   6\n         *\n         *  If I wanted to split this tree given the <div> as the root and \"4\" as the leaf\n         *  the result would be (the prime ' marks indicates nodes that are created as clones):\n         *\n         *   SPLITTING OFF 'RIGHT' TREE       SPLITTING OFF 'LEFT' TREE\n         *\n         *     <div>            <div>'              <div>'      <div>\n         *      / \\              / \\                 / \\          |\n         * <span> <span>   <span>' <span>       <span> <span>   <span>\n         *   / \\    |        |      / \\           /\\     /\\       /\\\n         *  1   2   3        4     5   6         1  2   3  4     5  6\n         *\n         *  The above example represents splitting off the 'right' or 'left' part of a tree, where\n         *  the <div>' would be returned as an element not appended to the DOM, and the <div>\n         *  would remain in place where it was\n         *\n        */\n        splitOffDOMTree: function (rootNode, leafNode, splitLeft) {\n            var splitOnNode = leafNode,\n                createdNode = null,\n                splitRight = !splitLeft;\n\n            // loop until we hit the root\n            while (splitOnNode !== rootNode) {\n                var currParent = splitOnNode.parentNode,\n                    newParent = currParent.cloneNode(false),\n                    targetNode = (splitRight ? splitOnNode : currParent.firstChild),\n                    appendLast;\n\n                // Create a new parent element which is a clone of the current parent\n                if (createdNode) {\n                    if (splitRight) {\n                        // If we're splitting right, add previous created element before siblings\n                        newParent.appendChild(createdNode);\n                    } else {\n                        // If we're splitting left, add previous created element last\n                        appendLast = createdNode;\n                    }\n                }\n                createdNode = newParent;\n\n                while (targetNode) {\n                    var sibling = targetNode.nextSibling;\n                    // Special handling for the 'splitNode'\n                    if (targetNode === splitOnNode) {\n                        if (!targetNode.hasChildNodes()) {\n                            targetNode.parentNode.removeChild(targetNode);\n                        } else {\n                            // For the node we're splitting on, if it has children, we need to clone it\n                            // and not just move it\n                            targetNode = targetNode.cloneNode(false);\n                        }\n                        // If the resulting split node has content, add it\n                        if (targetNode.textContent) {\n                            createdNode.appendChild(targetNode);\n                        }\n\n                        targetNode = (splitRight ? sibling : null);\n                    } else {\n                        // For general case, just remove the element and only\n                        // add it to the split tree if it contains something\n                        targetNode.parentNode.removeChild(targetNode);\n                        if (targetNode.hasChildNodes() || targetNode.textContent) {\n                            createdNode.appendChild(targetNode);\n                        }\n\n                        targetNode = sibling;\n                    }\n                }\n\n                // If we had an element we wanted to append at the end, do that now\n                if (appendLast) {\n                    createdNode.appendChild(appendLast);\n                }\n\n                splitOnNode = currParent;\n            }\n\n            return createdNode;\n        },\n\n        moveTextRangeIntoElement: function (startNode, endNode, newElement) {\n            if (!startNode || !endNode) {\n                return false;\n            }\n\n            var rootNode = Util.findCommonRoot(startNode, endNode);\n            if (!rootNode) {\n                return false;\n            }\n\n            if (endNode === startNode) {\n                var temp = startNode.parentNode,\n                    sibling = startNode.nextSibling;\n                temp.removeChild(startNode);\n                newElement.appendChild(startNode);\n                if (sibling) {\n                    temp.insertBefore(newElement, sibling);\n                } else {\n                    temp.appendChild(newElement);\n                }\n                return newElement.hasChildNodes();\n            }\n\n            // create rootChildren array which includes all the children\n            // we care about\n            var rootChildren = [],\n                firstChild,\n                lastChild,\n                nextNode;\n            for (var i = 0; i < rootNode.childNodes.length; i++) {\n                nextNode = rootNode.childNodes[i];\n                if (!firstChild) {\n                    if (Util.isDescendant(nextNode, startNode, true)) {\n                        firstChild = nextNode;\n                    }\n                } else {\n                    if (Util.isDescendant(nextNode, endNode, true)) {\n                        lastChild = nextNode;\n                        break;\n                    } else {\n                        rootChildren.push(nextNode);\n                    }\n                }\n            }\n\n            var afterLast = lastChild.nextSibling,\n                fragment = rootNode.ownerDocument.createDocumentFragment();\n\n            // build up fragment on startNode side of tree\n            if (firstChild === startNode) {\n                firstChild.parentNode.removeChild(firstChild);\n                fragment.appendChild(firstChild);\n            } else {\n                fragment.appendChild(Util.splitOffDOMTree(firstChild, startNode));\n            }\n\n            // add any elements between firstChild & lastChild\n            rootChildren.forEach(function (element) {\n                element.parentNode.removeChild(element);\n                fragment.appendChild(element);\n            });\n\n            // build up fragment on endNode side of the tree\n            if (lastChild === endNode) {\n                lastChild.parentNode.removeChild(lastChild);\n                fragment.appendChild(lastChild);\n            } else {\n                fragment.appendChild(Util.splitOffDOMTree(lastChild, endNode, true));\n            }\n\n            // Add fragment into passed in element\n            newElement.appendChild(fragment);\n\n            if (lastChild.parentNode === rootNode) {\n                // If last child is in the root, insert newElement in front of it\n                rootNode.insertBefore(newElement, lastChild);\n            } else if (afterLast) {\n                // If last child was removed, but it had a sibling, insert in front of it\n                rootNode.insertBefore(newElement, afterLast);\n            } else {\n                // lastChild was removed and was the last actual element just append\n                rootNode.appendChild(newElement);\n            }\n\n            return newElement.hasChildNodes();\n        },\n\n        /* based on http://stackoverflow.com/a/6183069 */\n        depthOfNode: function (inNode) {\n            var theDepth = 0,\n                node = inNode;\n            while (node.parentNode !== null) {\n                node = node.parentNode;\n                theDepth++;\n            }\n            return theDepth;\n        },\n\n        findCommonRoot: function (inNode1, inNode2) {\n            var depth1 = Util.depthOfNode(inNode1),\n                depth2 = Util.depthOfNode(inNode2),\n                node1 = inNode1,\n                node2 = inNode2;\n\n            while (depth1 !== depth2) {\n                if (depth1 > depth2) {\n                    node1 = node1.parentNode;\n                    depth1 -= 1;\n                } else {\n                    node2 = node2.parentNode;\n                    depth2 -= 1;\n                }\n            }\n\n            while (node1 !== node2) {\n                node1 = node1.parentNode;\n                node2 = node2.parentNode;\n            }\n\n            return node1;\n        },\n        /* END - based on http://stackoverflow.com/a/6183069 */\n\n        isElementAtBeginningOfBlock: function (node) {\n            var textVal,\n                sibling;\n            while (!Util.isBlockContainer(node) && !Util.isMediumEditorElement(node)) {\n                sibling = node;\n                while (sibling = sibling.previousSibling) {\n                    textVal = sibling.nodeType === 3 ? sibling.nodeValue : sibling.textContent;\n                    if (textVal.length > 0) {\n                        return false;\n                    }\n                }\n                node = node.parentNode;\n            }\n            return true;\n        },\n\n        isMediumEditorElement: function (element) {\n            return element && element.getAttribute && !!element.getAttribute('data-medium-editor-element');\n        },\n\n        getContainerEditorElement: function (element) {\n            return Util.traverseUp(element, function (node) {\n                return Util.isMediumEditorElement(node);\n            });\n        },\n\n        isBlockContainer: function (element) {\n            return element && element.nodeType !== 3 && Util.blockContainerElementNames.indexOf(element.nodeName.toLowerCase()) !== -1;\n        },\n\n        /* Finds the closest ancestor which is a block container element\n         * If element is within editor element but not within any other block element,\n         * the editor element is returned\n         */\n        getClosestBlockContainer: function (node) {\n            return Util.traverseUp(node, function (node) {\n                return Util.isBlockContainer(node) || Util.isMediumEditorElement(node);\n            });\n        },\n\n        /* Finds highest level ancestor element which is a block container element\n         * If element is within editor element but not within any other block element,\n         * the editor element is returned\n         */\n        getTopBlockContainer: function (element) {\n            var topBlock = Util.isBlockContainer(element) ? element : false;\n            Util.traverseUp(element, function (el) {\n                if (Util.isBlockContainer(el)) {\n                    topBlock = el;\n                }\n                if (!topBlock && Util.isMediumEditorElement(el)) {\n                    topBlock = el;\n                    return true;\n                }\n                return false;\n            });\n            return topBlock;\n        },\n\n        getFirstSelectableLeafNode: function (element) {\n            while (element && element.firstChild) {\n                element = element.firstChild;\n            }\n\n            // We don't want to set the selection to an element that can't have children, this messes up Gecko.\n            element = Util.traverseUp(element, function (el) {\n                return Util.emptyElementNames.indexOf(el.nodeName.toLowerCase()) === -1;\n            });\n            // Selecting at the beginning of a table doesn't work in PhantomJS.\n            if (element.nodeName.toLowerCase() === 'table') {\n                var firstCell = element.querySelector('th, td');\n                if (firstCell) {\n                    element = firstCell;\n                }\n            }\n            return element;\n        },\n\n        // TODO: remove getFirstTextNode AND _getFirstTextNode when jumping in 6.0.0 (no code references)\n        getFirstTextNode: function (element) {\n            Util.warn('getFirstTextNode is deprecated and will be removed in version 6.0.0');\n            return Util._getFirstTextNode(element);\n        },\n\n        _getFirstTextNode: function (element) {\n            if (element.nodeType === 3) {\n                return element;\n            }\n\n            for (var i = 0; i < element.childNodes.length; i++) {\n                var textNode = Util._getFirstTextNode(element.childNodes[i]);\n                if (textNode !== null) {\n                    return textNode;\n                }\n            }\n            return null;\n        },\n\n        ensureUrlHasProtocol: function (url) {\n            if (url.indexOf('://') === -1) {\n                return 'http://' + url;\n            }\n            return url;\n        },\n\n        warn: function () {\n            if (window.console !== undefined && typeof window.console.warn === 'function') {\n                window.console.warn.apply(window.console, arguments);\n            }\n        },\n\n        deprecated: function (oldName, newName, version) {\n            // simple deprecation warning mechanism.\n            var m = oldName + ' is deprecated, please use ' + newName + ' instead.';\n            if (version) {\n                m += ' Will be removed in ' + version;\n            }\n            Util.warn(m);\n        },\n\n        deprecatedMethod: function (oldName, newName, args, version) {\n            // run the replacement and warn when someone calls a deprecated method\n            Util.deprecated(oldName, newName, version);\n            if (typeof this[newName] === 'function') {\n                this[newName].apply(this, args);\n            }\n        },\n\n        cleanupAttrs: function (el, attrs) {\n            attrs.forEach(function (attr) {\n                el.removeAttribute(attr);\n            });\n        },\n\n        cleanupTags: function (el, tags) {\n            tags.forEach(function (tag) {\n                if (el.nodeName.toLowerCase() === tag) {\n                    el.parentNode.removeChild(el);\n                }\n            });\n        },\n\n        // get the closest parent\n        getClosestTag: function (el, tag) {\n            return Util.traverseUp(el, function (element) {\n                return element.nodeName.toLowerCase() === tag.toLowerCase();\n            });\n        },\n\n        unwrap: function (el, doc) {\n            var fragment = doc.createDocumentFragment(),\n                nodes = Array.prototype.slice.call(el.childNodes);\n\n            // cast nodeList to array since appending child\n            // to a different node will alter length of el.childNodes\n            for (var i = 0; i < nodes.length; i++) {\n                fragment.appendChild(nodes[i]);\n            }\n\n            if (fragment.childNodes.length) {\n                el.parentNode.replaceChild(fragment, el);\n            } else {\n                el.parentNode.removeChild(el);\n            }\n        },\n\n        guid: function () {\n            function _s4() {\n                return Math\n                    .floor((1 + Math.random()) * 0x10000)\n                    .toString(16)\n                    .substring(1);\n            }\n\n            return _s4() + _s4() + '-' + _s4() + '-' + _s4() + '-' + _s4() + '-' + _s4() + _s4() + _s4();\n        }\n    };\n\n    MediumEditor.util = Util;\n}(window));\n\n(function () {\n    'use strict';\n\n    var Extension = function (options) {\n        MediumEditor.util.extend(this, options);\n    };\n\n    Extension.extend = function (protoProps) {\n        // magic extender thinger. mostly borrowed from backbone/goog.inherits\n        // place this function on some thing you want extend-able.\n        //\n        // example:\n        //\n        //      function Thing(args){\n        //          this.options = args;\n        //      }\n        //\n        //      Thing.prototype = { foo: \"bar\" };\n        //      Thing.extend = extenderify;\n        //\n        //      var ThingTwo = Thing.extend({ foo: \"baz\" });\n        //\n        //      var thingOne = new Thing(); // foo === \"bar\"\n        //      var thingTwo = new ThingTwo(); // foo === \"baz\"\n        //\n        //      which seems like some simply shallow copy nonsense\n        //      at first, but a lot more is going on there.\n        //\n        //      passing a `constructor` to the extend props\n        //      will cause the instance to instantiate through that\n        //      instead of the parent's constructor.\n\n        var parent = this,\n            child;\n\n        // The constructor function for the new subclass is either defined by you\n        // (the \"constructor\" property in your `extend` definition), or defaulted\n        // by us to simply call the parent's constructor.\n\n        if (protoProps && protoProps.hasOwnProperty('constructor')) {\n            child = protoProps.constructor;\n        } else {\n            child = function () {\n                return parent.apply(this, arguments);\n            };\n        }\n\n        // das statics (.extend comes over, so your subclass can have subclasses too)\n        MediumEditor.util.extend(child, parent);\n\n        // Set the prototype chain to inherit from `parent`, without calling\n        // `parent`'s constructor function.\n        var Surrogate = function () {\n            this.constructor = child;\n        };\n        Surrogate.prototype = parent.prototype;\n        child.prototype = new Surrogate();\n\n        if (protoProps) {\n            MediumEditor.util.extend(child.prototype, protoProps);\n        }\n\n        // todo: $super?\n\n        return child;\n    };\n\n    Extension.prototype = {\n        /* init: [function]\n         *\n         * Called by MediumEditor during initialization.\n         * The .base property will already have been set to\n         * current instance of MediumEditor when this is called.\n         * All helper methods will exist as well\n         */\n        init: function () {},\n\n        /* base: [MediumEditor instance]\n         *\n         * If not overriden, this will be set to the current instance\n         * of MediumEditor, before the init method is called\n         */\n        base: undefined,\n\n        /* name: [string]\n         *\n         * 'name' of the extension, used for retrieving the extension.\n         * If not set, MediumEditor will set this to be the key\n         * used when passing the extension into MediumEditor via the\n         * 'extensions' option\n         */\n        name: undefined,\n\n        /* checkState: [function (node)]\n         *\n         * If implemented, this function will be called one or more times\n         * the state of the editor & toolbar are updated.\n         * When the state is updated, the editor does the following:\n         *\n         * 1) Find the parent node containing the current selection\n         * 2) Call checkState on the extension, passing the node as an argument\n         * 3) Get the parent node of the previous node\n         * 4) Repeat steps #2 and #3 until we move outside the parent contenteditable\n         */\n        checkState: undefined,\n\n        /* destroy: [function ()]\n         *\n         * This method should remove any created html, custom event handlers\n         * or any other cleanup tasks that should be performed.\n         * If implemented, this function will be called when MediumEditor's\n         * destroy method has been called.\n         */\n        destroy: undefined,\n\n        /* As alternatives to checkState, these functions provide a more structured\n         * path to updating the state of an extension (usually a button) whenever\n         * the state of the editor & toolbar are updated.\n         */\n\n        /* queryCommandState: [function ()]\n         *\n         * If implemented, this function will be called once on each extension\n         * when the state of the editor/toolbar is being updated.\n         *\n         * If this function returns a non-null value, the extension will\n         * be ignored as the code climbs the dom tree.\n         *\n         * If this function returns true, and the setActive() function is defined\n         * setActive() will be called\n         */\n        queryCommandState: undefined,\n\n        /* isActive: [function ()]\n         *\n         * If implemented, this function will be called when MediumEditor\n         * has determined that this extension is 'active' for the current selection.\n         * This may be called when the editor & toolbar are being updated,\n         * but only if queryCommandState() or isAlreadyApplied() functions\n         * are implemented, and when called, return true.\n         */\n        isActive: undefined,\n\n        /* isAlreadyApplied: [function (node)]\n         *\n         * If implemented, this function is similar to checkState() in\n         * that it will be called repeatedly as MediumEditor moves up\n         * the DOM to update the editor & toolbar after a state change.\n         *\n         * NOTE: This function will NOT be called if checkState() has\n         * been implemented. This function will NOT be called if\n         * queryCommandState() is implemented and returns a non-null\n         * value when called\n         */\n        isAlreadyApplied: undefined,\n\n        /* setActive: [function ()]\n         *\n         * If implemented, this function is called when MediumEditor knows\n         * that this extension is currently enabled.  Currently, this\n         * function is called when updating the editor & toolbar, and\n         * only if queryCommandState() or isAlreadyApplied(node) return\n         * true when called\n         */\n        setActive: undefined,\n\n        /* setInactive: [function ()]\n         *\n         * If implemented, this function is called when MediumEditor knows\n         * that this extension is currently disabled.  Curently, this\n         * is called at the beginning of each state change for\n         * the editor & toolbar. After calling this, MediumEditor\n         * will attempt to update the extension, either via checkState()\n         * or the combination of queryCommandState(), isAlreadyApplied(node),\n         * isActive(), and setActive()\n         */\n        setInactive: undefined,\n\n        /* getInteractionElements: [function ()]\n         *\n         * If the extension renders any elements that the user can interact with,\n         * this method should be implemented and return the root element or an array\n         * containing all of the root elements. MediumEditor will call this function\n         * during interaction to see if the user clicked on something outside of the editor.\n         * The elements are used to check if the target element of a click or\n         * other user event is a descendant of any extension elements.\n         * This way, the editor can also count user interaction within editor elements as\n         * interactions with the editor, and thus not trigger 'blur'\n         */\n        getInteractionElements: undefined,\n\n        /************************ Helpers ************************\n         * The following are helpers that are either set by MediumEditor\n         * during initialization, or are helper methods which either\n         * route calls to the MediumEditor instance or provide common\n         * functionality for all extensions\n         *********************************************************/\n\n        /* window: [Window]\n         *\n         * If not overriden, this will be set to the window object\n         * to be used by MediumEditor and its extensions.  This is\n         * passed via the 'contentWindow' option to MediumEditor\n         * and is the global 'window' object by default\n         */\n        'window': undefined,\n\n        /* document: [Document]\n         *\n         * If not overriden, this will be set to the document object\n         * to be used by MediumEditor and its extensions. This is\n         * passed via the 'ownerDocument' optin to MediumEditor\n         * and is the global 'document' object by default\n         */\n        'document': undefined,\n\n        /* getEditorElements: [function ()]\n         *\n         * Helper function which returns an array containing\n         * all the contenteditable elements for this instance\n         * of MediumEditor\n         */\n        getEditorElements: function () {\n            return this.base.elements;\n        },\n\n        /* getEditorId: [function ()]\n         *\n         * Helper function which returns a unique identifier\n         * for this instance of MediumEditor\n         */\n        getEditorId: function () {\n            return this.base.id;\n        },\n\n        /* getEditorOptions: [function (option)]\n         *\n         * Helper function which returns the value of an option\n         * used to initialize this instance of MediumEditor\n         */\n        getEditorOption: function (option) {\n            return this.base.options[option];\n        }\n    };\n\n    /* List of method names to add to the prototype of Extension\n     * Each of these methods will be defined as helpers that\n     * just call directly into the MediumEditor instance.\n     *\n     * example for 'on' method:\n     * Extension.prototype.on = function () {\n     *     return this.base.on.apply(this.base, arguments);\n     * }\n     */\n    [\n        // general helpers\n        'execAction',\n\n        // event handling\n        'on',\n        'off',\n        'subscribe',\n        'trigger'\n\n    ].forEach(function (helper) {\n        Extension.prototype[helper] = function () {\n            return this.base[helper].apply(this.base, arguments);\n        };\n    });\n\n    MediumEditor.Extension = Extension;\n})();\n\n(function () {\n    'use strict';\n\n    function filterOnlyParentElements(node) {\n        if (MediumEditor.util.isBlockContainer(node)) {\n            return NodeFilter.FILTER_ACCEPT;\n        } else {\n            return NodeFilter.FILTER_SKIP;\n        }\n    }\n\n    var Selection = {\n        findMatchingSelectionParent: function (testElementFunction, contentWindow) {\n            var selection = contentWindow.getSelection(),\n                range,\n                current;\n\n            if (selection.rangeCount === 0) {\n                return false;\n            }\n\n            range = selection.getRangeAt(0);\n            current = range.commonAncestorContainer;\n\n            return MediumEditor.util.traverseUp(current, testElementFunction);\n        },\n\n        getSelectionElement: function (contentWindow) {\n            return this.findMatchingSelectionParent(function (el) {\n                return MediumEditor.util.isMediumEditorElement(el);\n            }, contentWindow);\n        },\n\n        // http://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html\n        // Tim Down\n        exportSelection: function (root, doc) {\n            if (!root) {\n                return null;\n            }\n\n            var selectionState = null,\n                selection = doc.getSelection();\n\n            if (selection.rangeCount > 0) {\n                var range = selection.getRangeAt(0),\n                    preSelectionRange = range.cloneRange(),\n                    start;\n\n                preSelectionRange.selectNodeContents(root);\n                preSelectionRange.setEnd(range.startContainer, range.startOffset);\n                start = preSelectionRange.toString().length;\n\n                selectionState = {\n                    start: start,\n                    end: start + range.toString().length\n                };\n\n                // Check to see if the selection starts with any images\n                // if so we need to make sure the the beginning of the selection is\n                // set correctly when importing selection\n                if (this.doesRangeStartWithImages(range, doc)) {\n                    selectionState.startsWithImage = true;\n                }\n\n                // Check to see if the selection has any trailing images\n                // if so, this this means we need to look for them when we import selection\n                var trailingImageCount = this.getTrailingImageCount(root, selectionState, range.endContainer, range.endOffset);\n                if (trailingImageCount) {\n                    selectionState.trailingImageCount = trailingImageCount;\n                }\n\n                // If start = 0 there may still be an empty paragraph before it, but we don't care.\n                if (start !== 0) {\n                    var emptyBlocksIndex = this.getIndexRelativeToAdjacentEmptyBlocks(doc, root, range.startContainer, range.startOffset);\n                    if (emptyBlocksIndex !== -1) {\n                        selectionState.emptyBlocksIndex = emptyBlocksIndex;\n                    }\n                }\n            }\n\n            return selectionState;\n        },\n\n        // http://stackoverflow.com/questions/17678843/cant-restore-selection-after-html-modify-even-if-its-the-same-html\n        // Tim Down\n        //\n        // {object} selectionState - the selection to import\n        // {DOMElement} root - the root element the selection is being restored inside of\n        // {Document} doc - the document to use for managing selection\n        // {boolean} [favorLaterSelectionAnchor] - defaults to false. If true, import the cursor immediately\n        //      subsequent to an anchor tag if it would otherwise be placed right at the trailing edge inside the\n        //      anchor. This cursor positioning, even though visually equivalent to the user, can affect behavior\n        //      in MS IE.\n        importSelection: function (selectionState, root, doc, favorLaterSelectionAnchor) {\n            if (!selectionState || !root) {\n                return;\n            }\n\n            var range = doc.createRange();\n            range.setStart(root, 0);\n            range.collapse(true);\n\n            var node = root,\n                nodeStack = [],\n                charIndex = 0,\n                foundStart = false,\n                foundEnd = false,\n                trailingImageCount = 0,\n                stop = false,\n                nextCharIndex,\n                allowRangeToStartAtEndOfNode = false,\n                lastTextNode = null;\n\n            // When importing selection, the start of the selection may lie at the end of an element\n            // or at the beginning of an element.  Since visually there is no difference between these 2\n            // we will try to move the selection to the beginning of an element since this is generally\n            // what users will expect and it's a more predictable behavior.\n            //\n            // However, there are some specific cases when we don't want to do this:\n            //  1) We're attempting to move the cursor outside of the end of an anchor [favorLaterSelectionAnchor = true]\n            //  2) The selection starts with an image, which is special since an image doesn't have any 'content'\n            //     as far as selection and ranges are concerned\n            //  3) The selection starts after a specified number of empty block elements (selectionState.emptyBlocksIndex)\n            //\n            // For these cases, we want the selection to start at a very specific location, so we should NOT\n            // automatically move the cursor to the beginning of the first actual chunk of text\n            if (favorLaterSelectionAnchor || selectionState.startsWithImage || typeof selectionState.emptyBlocksIndex !== 'undefined') {\n                allowRangeToStartAtEndOfNode = true;\n            }\n\n            while (!stop && node) {\n                // Only iterate over elements and text nodes\n                if (node.nodeType > 3) {\n                    node = nodeStack.pop();\n                    continue;\n                }\n\n                // If we hit a text node, we need to add the amount of characters to the overall count\n                if (node.nodeType === 3 && !foundEnd) {\n                    nextCharIndex = charIndex + node.length;\n                    // Check if we're at or beyond the start of the selection we're importing\n                    if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {\n                        // NOTE: We only want to allow a selection to start at the END of an element if\n                        //  allowRangeToStartAtEndOfNode is true\n                        if (allowRangeToStartAtEndOfNode || selectionState.start < nextCharIndex) {\n                            range.setStart(node, selectionState.start - charIndex);\n                            foundStart = true;\n                        }\n                        // We're at the end of a text node where the selection could start but we shouldn't\n                        // make the selection start here because allowRangeToStartAtEndOfNode is false.\n                        // However, we should keep a reference to this node in case there aren't any more\n                        // text nodes after this, so that we have somewhere to import the selection to\n                        else {\n                            lastTextNode = node;\n                        }\n                    }\n                    // We've found the start of the selection, check if we're at or beyond the end of the selection we're importing\n                    if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {\n                        if (!selectionState.trailingImageCount) {\n                            range.setEnd(node, selectionState.end - charIndex);\n                            stop = true;\n                        } else {\n                            foundEnd = true;\n                        }\n                    }\n                    charIndex = nextCharIndex;\n                } else {\n                    if (selectionState.trailingImageCount && foundEnd) {\n                        if (node.nodeName.toLowerCase() === 'img') {\n                            trailingImageCount++;\n                        }\n                        if (trailingImageCount === selectionState.trailingImageCount) {\n                            // Find which index the image is in its parent's children\n                            var endIndex = 0;\n                            while (node.parentNode.childNodes[endIndex] !== node) {\n                                endIndex++;\n                            }\n                            range.setEnd(node.parentNode, endIndex + 1);\n                            stop = true;\n                        }\n                    }\n\n                    if (!stop && node.nodeType === 1) {\n                        // this is an element\n                        // add all its children to the stack\n                        var i = node.childNodes.length - 1;\n                        while (i >= 0) {\n                            nodeStack.push(node.childNodes[i]);\n                            i -= 1;\n                        }\n                    }\n                }\n\n                if (!stop) {\n                    node = nodeStack.pop();\n                }\n            }\n\n            // If we've gone through the entire text but didn't find the beginning of a text node\n            // to make the selection start at, we should fall back to starting the selection\n            // at the END of the last text node we found\n            if (!foundStart && lastTextNode) {\n                range.setStart(lastTextNode, lastTextNode.length);\n                range.setEnd(lastTextNode, lastTextNode.length);\n            }\n\n            if (typeof selectionState.emptyBlocksIndex !== 'undefined') {\n                range = this.importSelectionMoveCursorPastBlocks(doc, root, selectionState.emptyBlocksIndex, range);\n            }\n\n            // If the selection is right at the ending edge of a link, put it outside the anchor tag instead of inside.\n            if (favorLaterSelectionAnchor) {\n                range = this.importSelectionMoveCursorPastAnchor(selectionState, range);\n            }\n\n            this.selectRange(doc, range);\n        },\n\n        // Utility method called from importSelection only\n        importSelectionMoveCursorPastAnchor: function (selectionState, range) {\n            var nodeInsideAnchorTagFunction = function (node) {\n                return node.nodeName.toLowerCase() === 'a';\n            };\n            if (selectionState.start === selectionState.end &&\n                    range.startContainer.nodeType === 3 &&\n                    range.startOffset === range.startContainer.nodeValue.length &&\n                    MediumEditor.util.traverseUp(range.startContainer, nodeInsideAnchorTagFunction)) {\n                var prevNode = range.startContainer,\n                    currentNode = range.startContainer.parentNode;\n                while (currentNode !== null && currentNode.nodeName.toLowerCase() !== 'a') {\n                    if (currentNode.childNodes[currentNode.childNodes.length - 1] !== prevNode) {\n                        currentNode = null;\n                    } else {\n                        prevNode = currentNode;\n                        currentNode = currentNode.parentNode;\n                    }\n                }\n                if (currentNode !== null && currentNode.nodeName.toLowerCase() === 'a') {\n                    var currentNodeIndex = null;\n                    for (var i = 0; currentNodeIndex === null && i < currentNode.parentNode.childNodes.length; i++) {\n                        if (currentNode.parentNode.childNodes[i] === currentNode) {\n                            currentNodeIndex = i;\n                        }\n                    }\n                    range.setStart(currentNode.parentNode, currentNodeIndex + 1);\n                    range.collapse(true);\n                }\n            }\n            return range;\n        },\n\n        // Uses the emptyBlocksIndex calculated by getIndexRelativeToAdjacentEmptyBlocks\n        // to move the cursor back to the start of the correct paragraph\n        importSelectionMoveCursorPastBlocks: function (doc, root, index, range) {\n            var treeWalker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false),\n                startContainer = range.startContainer,\n                startBlock,\n                targetNode,\n                currIndex = 0;\n            index = index || 1; // If index is 0, we still want to move to the next block\n\n            // Chrome counts newlines and spaces that separate block elements as actual elements.\n            // If the selection is inside one of these text nodes, and it has a previous sibling\n            // which is a block element, we want the treewalker to start at the previous sibling\n            // and NOT at the parent of the textnode\n            if (startContainer.nodeType === 3 && MediumEditor.util.isBlockContainer(startContainer.previousSibling)) {\n                startBlock = startContainer.previousSibling;\n            } else {\n                startBlock = MediumEditor.util.getClosestBlockContainer(startContainer);\n            }\n\n            // Skip over empty blocks until we hit the block we want the selection to be in\n            while (treeWalker.nextNode()) {\n                if (!targetNode) {\n                    // Loop through all blocks until we hit the starting block element\n                    if (startBlock === treeWalker.currentNode) {\n                        targetNode = treeWalker.currentNode;\n                    }\n                } else {\n                    targetNode = treeWalker.currentNode;\n                    currIndex++;\n                    // We hit the target index, bail\n                    if (currIndex === index) {\n                        break;\n                    }\n                    // If we find a non-empty block, ignore the emptyBlocksIndex and just put selection here\n                    if (targetNode.textContent.length > 0) {\n                        break;\n                    }\n                }\n            }\n\n            if (!targetNode) {\n                targetNode = startBlock;\n            }\n\n            // We're selecting a high-level block node, so make sure the cursor gets moved into the deepest\n            // element at the beginning of the block\n            range.setStart(MediumEditor.util.getFirstSelectableLeafNode(targetNode), 0);\n\n            return range;\n        },\n\n        // Returns -1 unless the cursor is at the beginning of a paragraph/block\n        // If the paragraph/block is preceeded by empty paragraphs/block (with no text)\n        // it will return the number of empty paragraphs before the cursor.\n        // Otherwise, it will return 0, which indicates the cursor is at the beginning\n        // of a paragraph/block, and not at the end of the paragraph/block before it\n        getIndexRelativeToAdjacentEmptyBlocks: function (doc, root, cursorContainer, cursorOffset) {\n            // If there is text in front of the cursor, that means there isn't only empty blocks before it\n            if (cursorContainer.textContent.length > 0 && cursorOffset > 0) {\n                return -1;\n            }\n\n            // Check if the block that contains the cursor has any other text in front of the cursor\n            var node = cursorContainer;\n            if (node.nodeType !== 3) {\n                node = cursorContainer.childNodes[cursorOffset];\n            }\n            if (node) {\n                // The element isn't at the beginning of a block, so it has content before it\n                if (!MediumEditor.util.isElementAtBeginningOfBlock(node)) {\n                    return -1;\n                }\n\n                var previousSibling = MediumEditor.util.findPreviousSibling(node);\n                // If there is no previous sibling, this is the first text element in the editor\n                if (!previousSibling) {\n                    return -1;\n                }\n                // If the previous sibling has text, then there are no empty blocks before this\n                else if (previousSibling.nodeValue) {\n                    return -1;\n                }\n            }\n\n            // Walk over block elements, counting number of empty blocks between last piece of text\n            // and the block the cursor is in\n            var closestBlock = MediumEditor.util.getClosestBlockContainer(cursorContainer),\n                treeWalker = doc.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, filterOnlyParentElements, false),\n                emptyBlocksCount = 0;\n            while (treeWalker.nextNode()) {\n                var blockIsEmpty = treeWalker.currentNode.textContent === '';\n                if (blockIsEmpty || emptyBlocksCount > 0) {\n                    emptyBlocksCount += 1;\n                }\n                if (treeWalker.currentNode === closestBlock) {\n                    return emptyBlocksCount;\n                }\n                if (!blockIsEmpty) {\n                    emptyBlocksCount = 0;\n                }\n            }\n\n            return emptyBlocksCount;\n        },\n\n        // Returns true if the selection range begins with an image tag\n        // Returns false if the range starts with any non empty text nodes\n        doesRangeStartWithImages: function (range, doc) {\n            if (range.startOffset !== 0 || range.startContainer.nodeType !== 1) {\n                return false;\n            }\n\n            if (range.startContainer.nodeName.toLowerCase() === 'img') {\n                return true;\n            }\n\n            var img = range.startContainer.querySelector('img');\n            if (!img) {\n                return false;\n            }\n\n            var treeWalker = doc.createTreeWalker(range.startContainer, NodeFilter.SHOW_ALL, null, false);\n            while (treeWalker.nextNode()) {\n                var next = treeWalker.currentNode;\n                // If we hit the image, then there isn't any text before the image so\n                // the image is at the beginning of the range\n                if (next === img) {\n                    break;\n                }\n                // If we haven't hit the iamge, but found text that contains content\n                // then the range doesn't start with an image\n                if (next.nodeValue) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n\n        getTrailingImageCount: function (root, selectionState, endContainer, endOffset) {\n            // If the endOffset of a range is 0, the endContainer doesn't contain images\n            // If the endContainer is a text node, there are no trailing images\n            if (endOffset === 0 || endContainer.nodeType !== 1) {\n                return 0;\n            }\n\n            // If the endContainer isn't an image, and doesn't have an image descendants\n            // there are no trailing images\n            if (endContainer.nodeName.toLowerCase() !== 'img' && !endContainer.querySelector('img')) {\n                return 0;\n            }\n\n            var lastNode = endContainer.childNodes[endOffset - 1];\n            while (lastNode.hasChildNodes()) {\n                lastNode = lastNode.lastChild;\n            }\n\n            var node = root,\n                nodeStack = [],\n                charIndex = 0,\n                foundStart = false,\n                foundEnd = false,\n                stop = false,\n                nextCharIndex,\n                trailingImages = 0;\n\n            while (!stop && node) {\n                // Only iterate over elements and text nodes\n                if (node.nodeType > 3) {\n                    node = nodeStack.pop();\n                    continue;\n                }\n\n                if (node.nodeType === 3 && !foundEnd) {\n                    trailingImages = 0;\n                    nextCharIndex = charIndex + node.length;\n                    if (!foundStart && selectionState.start >= charIndex && selectionState.start <= nextCharIndex) {\n                        foundStart = true;\n                    }\n                    if (foundStart && selectionState.end >= charIndex && selectionState.end <= nextCharIndex) {\n                        foundEnd = true;\n                    }\n                    charIndex = nextCharIndex;\n                } else {\n                    if (node.nodeName.toLowerCase() === 'img') {\n                        trailingImages++;\n                    }\n\n                    if (node === lastNode) {\n                        stop = true;\n                    } else if (node.nodeType === 1) {\n                        // this is an element\n                        // add all its children to the stack\n                        var i = node.childNodes.length - 1;\n                        while (i >= 0) {\n                            nodeStack.push(node.childNodes[i]);\n                            i -= 1;\n                        }\n                    }\n                }\n\n                if (!stop) {\n                    node = nodeStack.pop();\n                }\n            }\n\n            return trailingImages;\n        },\n\n        // determine if the current selection contains any 'content'\n        // content being any non-white space text or an image\n        selectionContainsContent: function (doc) {\n            var sel = doc.getSelection();\n\n            // collapsed selection or selection withour range doesn't contain content\n            if (!sel || sel.isCollapsed || !sel.rangeCount) {\n                return false;\n            }\n\n            // if toString() contains any text, the selection contains some content\n            if (sel.toString().trim() !== '') {\n                return true;\n            }\n\n            // if selection contains only image(s), it will return empty for toString()\n            // so check for an image manually\n            var selectionNode = this.getSelectedParentElement(sel.getRangeAt(0));\n            if (selectionNode) {\n                if (selectionNode.nodeName.toLowerCase() === 'img' ||\n                    (selectionNode.nodeType === 1 && selectionNode.querySelector('img'))) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        selectionInContentEditableFalse: function (contentWindow) {\n            // determine if the current selection is exclusively inside\n            // a contenteditable=\"false\", though treat the case of an\n            // explicit contenteditable=\"true\" inside a \"false\" as false.\n            var sawtrue,\n                sawfalse = this.findMatchingSelectionParent(function (el) {\n                    var ce = el && el.getAttribute('contenteditable');\n                    if (ce === 'true') {\n                        sawtrue = true;\n                    }\n                    return el.nodeName !== '#text' && ce === 'false';\n                }, contentWindow);\n\n            return !sawtrue && sawfalse;\n        },\n\n        // http://stackoverflow.com/questions/4176923/html-of-selected-text\n        // by Tim Down\n        getSelectionHtml: function getSelectionHtml(doc) {\n            var i,\n                html = '',\n                sel = doc.getSelection(),\n                len,\n                container;\n            if (sel.rangeCount) {\n                container = doc.createElement('div');\n                for (i = 0, len = sel.rangeCount; i < len; i += 1) {\n                    container.appendChild(sel.getRangeAt(i).cloneContents());\n                }\n                html = container.innerHTML;\n            }\n            return html;\n        },\n\n        /**\n         *  Find the caret position within an element irrespective of any inline tags it may contain.\n         *\n         *  @param {DOMElement} An element containing the cursor to find offsets relative to.\n         *  @param {Range} A Range representing cursor position. Will window.getSelection if none is passed.\n         *  @return {Object} 'left' and 'right' attributes contain offsets from begining and end of Element\n         */\n        getCaretOffsets: function getCaretOffsets(element, range) {\n            var preCaretRange, postCaretRange;\n\n            if (!range) {\n                range = window.getSelection().getRangeAt(0);\n            }\n\n            preCaretRange = range.cloneRange();\n            postCaretRange = range.cloneRange();\n\n            preCaretRange.selectNodeContents(element);\n            preCaretRange.setEnd(range.endContainer, range.endOffset);\n\n            postCaretRange.selectNodeContents(element);\n            postCaretRange.setStart(range.endContainer, range.endOffset);\n\n            return {\n                left: preCaretRange.toString().length,\n                right: postCaretRange.toString().length\n            };\n        },\n\n        // http://stackoverflow.com/questions/15867542/range-object-get-selection-parent-node-chrome-vs-firefox\n        rangeSelectsSingleNode: function (range) {\n            var startNode = range.startContainer;\n            return startNode === range.endContainer &&\n                startNode.hasChildNodes() &&\n                range.endOffset === range.startOffset + 1;\n        },\n\n        getSelectedParentElement: function (range) {\n            if (!range) {\n                return null;\n            }\n\n            // Selection encompasses a single element\n            if (this.rangeSelectsSingleNode(range) && range.startContainer.childNodes[range.startOffset].nodeType !== 3) {\n                return range.startContainer.childNodes[range.startOffset];\n            }\n\n            // Selection range starts inside a text node, so get its parent\n            if (range.startContainer.nodeType === 3) {\n                return range.startContainer.parentNode;\n            }\n\n            // Selection starts inside an element\n            return range.startContainer;\n        },\n\n        getSelectedElements: function (doc) {\n            var selection = doc.getSelection(),\n                range,\n                toRet,\n                currNode;\n\n            if (!selection.rangeCount || selection.isCollapsed || !selection.getRangeAt(0).commonAncestorContainer) {\n                return [];\n            }\n\n            range = selection.getRangeAt(0);\n\n            if (range.commonAncestorContainer.nodeType === 3) {\n                toRet = [];\n                currNode = range.commonAncestorContainer;\n                while (currNode.parentNode && currNode.parentNode.childNodes.length === 1) {\n                    toRet.push(currNode.parentNode);\n                    currNode = currNode.parentNode;\n                }\n\n                return toRet;\n            }\n\n            return [].filter.call(range.commonAncestorContainer.getElementsByTagName('*'), function (el) {\n                return (typeof selection.containsNode === 'function') ? selection.containsNode(el, true) : true;\n            });\n        },\n\n        selectNode: function (node, doc) {\n            var range = doc.createRange();\n            range.selectNodeContents(node);\n            this.selectRange(doc, range);\n        },\n\n        select: function (doc, startNode, startOffset, endNode, endOffset) {\n            var range = doc.createRange();\n            range.setStart(startNode, startOffset);\n            if (endNode) {\n                range.setEnd(endNode, endOffset);\n            } else {\n                range.collapse(true);\n            }\n            this.selectRange(doc, range);\n            return range;\n        },\n\n        /**\n         *  Clear the current highlighted selection and set the caret to the start or the end of that prior selection, defaults to end.\n         *\n         *  @param {DomDocument} doc            Current document\n         *  @param {boolean} moveCursorToStart  A boolean representing whether or not to set the caret to the beginning of the prior selection.\n         */\n        clearSelection: function (doc, moveCursorToStart) {\n            if (moveCursorToStart) {\n                doc.getSelection().collapseToStart();\n            } else {\n                doc.getSelection().collapseToEnd();\n            }\n        },\n\n        /**\n         * Move cursor to the given node with the given offset.\n         *\n         * @param  {DomDocument} doc     Current document\n         * @param  {DomElement}  node    Element where to jump\n         * @param  {integer}     offset  Where in the element should we jump, 0 by default\n         */\n        moveCursor: function (doc, node, offset) {\n            this.select(doc, node, offset);\n        },\n\n        getSelectionRange: function (ownerDocument) {\n            var selection = ownerDocument.getSelection();\n            if (selection.rangeCount === 0) {\n                return null;\n            }\n            return selection.getRangeAt(0);\n        },\n\n        selectRange: function (ownerDocument, range) {\n            var selection = ownerDocument.getSelection();\n\n            selection.removeAllRanges();\n            selection.addRange(range);\n        },\n\n        // http://stackoverflow.com/questions/1197401/how-can-i-get-the-element-the-caret-is-in-with-javascript-when-using-contentedi\n        // by You\n        getSelectionStart: function (ownerDocument) {\n            var node = ownerDocument.getSelection().anchorNode,\n                startNode = (node && node.nodeType === 3 ? node.parentNode : node);\n\n            return startNode;\n        }\n    };\n\n    MediumEditor.selection = Selection;\n}());\n\n(function () {\n    'use strict';\n\n    function isElementDescendantOfExtension(extensions, element) {\n        return extensions.some(function (extension) {\n            if (typeof extension.getInteractionElements !== 'function') {\n                return false;\n            }\n\n            var extensionElements = extension.getInteractionElements();\n            if (!extensionElements) {\n                return false;\n            }\n\n            if (!Array.isArray(extensionElements)) {\n                extensionElements = [extensionElements];\n            }\n            return extensionElements.some(function (el) {\n                return MediumEditor.util.isDescendant(el, element, true);\n            });\n        });\n    }\n\n    var Events = function (instance) {\n        this.base = instance;\n        this.options = this.base.options;\n        this.events = [];\n        this.disabledEvents = {};\n        this.customEvents = {};\n        this.listeners = {};\n    };\n\n    Events.prototype = {\n        InputEventOnContenteditableSupported: !MediumEditor.util.isIE && !MediumEditor.util.isEdge,\n\n        // Helpers for event handling\n\n        attachDOMEvent: function (targets, event, listener, useCapture) {\n            targets = MediumEditor.util.isElement(targets) || [window, document].indexOf(targets) > -1 ? [targets] : targets;\n\n            Array.prototype.forEach.call(targets, function (target) {\n                target.addEventListener(event, listener, useCapture);\n                this.events.push([target, event, listener, useCapture]);\n            }.bind(this));\n        },\n\n        detachDOMEvent: function (targets, event, listener, useCapture) {\n            var index, e;\n            targets = MediumEditor.util.isElement(targets) || [window, document].indexOf(targets) > -1 ? [targets] : targets;\n\n            Array.prototype.forEach.call(targets, function (target) {\n                index = this.indexOfListener(target, event, listener, useCapture);\n                if (index !== -1) {\n                    e = this.events.splice(index, 1)[0];\n                    e[0].removeEventListener(e[1], e[2], e[3]);\n                }\n            }.bind(this));\n        },\n\n        indexOfListener: function (target, event, listener, useCapture) {\n            var this$1 = this;\n\n            var i, n, item;\n            for (i = 0, n = this.events.length; i < n; i = i + 1) {\n                item = this$1.events[i];\n                if (item[0] === target && item[1] === event && item[2] === listener && item[3] === useCapture) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n\n        detachAllDOMEvents: function () {\n            var this$1 = this;\n\n            var e = this.events.pop();\n            while (e) {\n                e[0].removeEventListener(e[1], e[2], e[3]);\n                e = this$1.events.pop();\n            }\n        },\n\n        detachAllEventsFromElement: function (element) {\n            var this$1 = this;\n\n            var filtered = this.events.filter(function (e) {\n                return e && e[0].getAttribute && e[0].getAttribute('medium-editor-index') === element.getAttribute('medium-editor-index');\n            });\n\n            for (var i = 0, len = filtered.length; i < len; i++) {\n                var e = filtered[i];\n                this$1.detachDOMEvent(e[0], e[1], e[2], e[3]);\n            }\n        },\n\n        // Attach all existing handlers to a new element\n        attachAllEventsToElement: function (element) {\n            if (this.listeners['editableInput']) {\n                this.contentCache[element.getAttribute('medium-editor-index')] = element.innerHTML;\n            }\n\n            if (this.eventsCache) {\n                this.eventsCache.forEach(function (e) {\n                    this.attachDOMEvent(element, e['name'], e['handler'].bind(this));\n                }, this);\n            }\n        },\n\n        enableCustomEvent: function (event) {\n            if (this.disabledEvents[event] !== undefined) {\n                delete this.disabledEvents[event];\n            }\n        },\n\n        disableCustomEvent: function (event) {\n            this.disabledEvents[event] = true;\n        },\n\n        // custom events\n        attachCustomEvent: function (event, listener) {\n            this.setupListener(event);\n            if (!this.customEvents[event]) {\n                this.customEvents[event] = [];\n            }\n            this.customEvents[event].push(listener);\n        },\n\n        detachCustomEvent: function (event, listener) {\n            var index = this.indexOfCustomListener(event, listener);\n            if (index !== -1) {\n                this.customEvents[event].splice(index, 1);\n                // TODO: If array is empty, should detach internal listeners via destroyListener()\n            }\n        },\n\n        indexOfCustomListener: function (event, listener) {\n            if (!this.customEvents[event] || !this.customEvents[event].length) {\n                return -1;\n            }\n\n            return this.customEvents[event].indexOf(listener);\n        },\n\n        detachAllCustomEvents: function () {\n            this.customEvents = {};\n            // TODO: Should detach internal listeners here via destroyListener()\n        },\n\n        triggerCustomEvent: function (name, data, editable) {\n            if (this.customEvents[name] && !this.disabledEvents[name]) {\n                this.customEvents[name].forEach(function (listener) {\n                    listener(data, editable);\n                });\n            }\n        },\n\n        // Cleaning up\n\n        destroy: function () {\n            this.detachAllDOMEvents();\n            this.detachAllCustomEvents();\n            this.detachExecCommand();\n\n            if (this.base.elements) {\n                this.base.elements.forEach(function (element) {\n                    element.removeAttribute('data-medium-focused');\n                });\n            }\n        },\n\n        // Listening to calls to document.execCommand\n\n        // Attach a listener to be notified when document.execCommand is called\n        attachToExecCommand: function () {\n            if (this.execCommandListener) {\n                return;\n            }\n\n            // Store an instance of the listener so:\n            // 1) We only attach to execCommand once\n            // 2) We can remove the listener later\n            this.execCommandListener = function (execInfo) {\n                this.handleDocumentExecCommand(execInfo);\n            }.bind(this);\n\n            // Ensure that execCommand has been wrapped correctly\n            this.wrapExecCommand();\n\n            // Add listener to list of execCommand listeners\n            this.options.ownerDocument.execCommand.listeners.push(this.execCommandListener);\n        },\n\n        // Remove our listener for calls to document.execCommand\n        detachExecCommand: function () {\n            var doc = this.options.ownerDocument;\n            if (!this.execCommandListener || !doc.execCommand.listeners) {\n                return;\n            }\n\n            // Find the index of this listener in the array of listeners so it can be removed\n            var index = doc.execCommand.listeners.indexOf(this.execCommandListener);\n            if (index !== -1) {\n                doc.execCommand.listeners.splice(index, 1);\n            }\n\n            // If the list of listeners is now empty, put execCommand back to its original state\n            if (!doc.execCommand.listeners.length) {\n                this.unwrapExecCommand();\n            }\n        },\n\n        // Wrap document.execCommand in a custom method so we can listen to calls to it\n        wrapExecCommand: function () {\n            var doc = this.options.ownerDocument;\n\n            // Ensure all instance of MediumEditor only wrap execCommand once\n            if (doc.execCommand.listeners) {\n                return;\n            }\n\n            // Helper method to call all listeners to execCommand\n            var callListeners = function (args, result) {\n                    if (doc.execCommand.listeners) {\n                        doc.execCommand.listeners.forEach(function (listener) {\n                            listener({\n                                command: args[0],\n                                value: args[2],\n                                args: args,\n                                result: result\n                            });\n                        });\n                    }\n                },\n\n            // Create a wrapper method for execCommand which will:\n            // 1) Call document.execCommand with the correct arguments\n            // 2) Loop through any listeners and notify them that execCommand was called\n            //    passing extra info on the call\n            // 3) Return the result\n                wrapper = function () {\n                    var result = doc.execCommand.orig.apply(this, arguments);\n\n                    if (!doc.execCommand.listeners) {\n                        return result;\n                    }\n\n                    var args = Array.prototype.slice.call(arguments);\n                    callListeners(args, result);\n\n                    return result;\n                };\n\n            // Store a reference to the original execCommand\n            wrapper.orig = doc.execCommand;\n\n            // Attach an array for storing listeners\n            wrapper.listeners = [];\n\n            // Helper for notifying listeners\n            wrapper.callListeners = callListeners;\n\n            // Overwrite execCommand\n            doc.execCommand = wrapper;\n        },\n\n        // Revert document.execCommand back to its original self\n        unwrapExecCommand: function () {\n            var doc = this.options.ownerDocument;\n            if (!doc.execCommand.orig) {\n                return;\n            }\n\n            // Use the reference to the original execCommand to revert back\n            doc.execCommand = doc.execCommand.orig;\n        },\n\n        // Listening to browser events to emit events medium-editor cares about\n        setupListener: function (name) {\n            if (this.listeners[name]) {\n                return;\n            }\n\n            switch (name) {\n                case 'externalInteraction':\n                    // Detecting when user has interacted with elements outside of MediumEditor\n                    this.attachDOMEvent(this.options.ownerDocument.body, 'mousedown', this.handleBodyMousedown.bind(this), true);\n                    this.attachDOMEvent(this.options.ownerDocument.body, 'click', this.handleBodyClick.bind(this), true);\n                    this.attachDOMEvent(this.options.ownerDocument.body, 'focus', this.handleBodyFocus.bind(this), true);\n                    break;\n                case 'blur':\n                    // Detecting when focus is lost\n                    this.setupListener('externalInteraction');\n                    break;\n                case 'focus':\n                    // Detecting when focus moves into some part of MediumEditor\n                    this.setupListener('externalInteraction');\n                    break;\n                case 'editableInput':\n                    // setup cache for knowing when the content has changed\n                    this.contentCache = {};\n                    this.base.elements.forEach(function (element) {\n                        this.contentCache[element.getAttribute('medium-editor-index')] = element.innerHTML;\n                    }, this);\n\n                    // Attach to the 'oninput' event, handled correctly by most browsers\n                    if (this.InputEventOnContenteditableSupported) {\n                        this.attachToEachElement('input', this.handleInput);\n                    }\n\n                    // For browsers which don't support the input event on contenteditable (IE)\n                    // we'll attach to 'selectionchange' on the document and 'keypress' on the editables\n                    if (!this.InputEventOnContenteditableSupported) {\n                        this.setupListener('editableKeypress');\n                        this.keypressUpdateInput = true;\n                        this.attachDOMEvent(document, 'selectionchange', this.handleDocumentSelectionChange.bind(this));\n                        // Listen to calls to execCommand\n                        this.attachToExecCommand();\n                    }\n                    break;\n                case 'editableClick':\n                    // Detecting click in the contenteditables\n                    this.attachToEachElement('click', this.handleClick);\n                    break;\n                case 'editableBlur':\n                    // Detecting blur in the contenteditables\n                    this.attachToEachElement('blur', this.handleBlur);\n                    break;\n                case 'editableKeypress':\n                    // Detecting keypress in the contenteditables\n                    this.attachToEachElement('keypress', this.handleKeypress);\n                    break;\n                case 'editableKeyup':\n                    // Detecting keyup in the contenteditables\n                    this.attachToEachElement('keyup', this.handleKeyup);\n                    break;\n                case 'editableKeydown':\n                    // Detecting keydown on the contenteditables\n                    this.attachToEachElement('keydown', this.handleKeydown);\n                    break;\n                case 'editableKeydownSpace':\n                    // Detecting keydown for SPACE on the contenteditables\n                    this.setupListener('editableKeydown');\n                    break;\n                case 'editableKeydownEnter':\n                    // Detecting keydown for ENTER on the contenteditables\n                    this.setupListener('editableKeydown');\n                    break;\n                case 'editableKeydownTab':\n                    // Detecting keydown for TAB on the contenteditable\n                    this.setupListener('editableKeydown');\n                    break;\n                case 'editableKeydownDelete':\n                    // Detecting keydown for DELETE/BACKSPACE on the contenteditables\n                    this.setupListener('editableKeydown');\n                    break;\n                case 'editableMouseover':\n                    // Detecting mouseover on the contenteditables\n                    this.attachToEachElement('mouseover', this.handleMouseover);\n                    break;\n                case 'editableDrag':\n                    // Detecting dragover and dragleave on the contenteditables\n                    this.attachToEachElement('dragover', this.handleDragging);\n                    this.attachToEachElement('dragleave', this.handleDragging);\n                    break;\n                case 'editableDrop':\n                    // Detecting drop on the contenteditables\n                    this.attachToEachElement('drop', this.handleDrop);\n                    break;\n                // TODO: We need to have a custom 'paste' event separate from 'editablePaste'\n                // Need to think about the way to introduce this without breaking folks\n                case 'editablePaste':\n                    // Detecting paste on the contenteditables\n                    this.attachToEachElement('paste', this.handlePaste);\n                    break;\n            }\n            this.listeners[name] = true;\n        },\n\n        attachToEachElement: function (name, handler) {\n            // build our internal cache to know which element got already what handler attached\n            if (!this.eventsCache) {\n                this.eventsCache = [];\n            }\n\n            this.base.elements.forEach(function (element) {\n                this.attachDOMEvent(element, name, handler.bind(this));\n            }, this);\n\n            this.eventsCache.push({ 'name': name, 'handler': handler });\n        },\n\n        cleanupElement: function (element) {\n            var index = element.getAttribute('medium-editor-index');\n            if (index) {\n                this.detachAllEventsFromElement(element);\n                if (this.contentCache) {\n                    delete this.contentCache[index];\n                }\n            }\n        },\n\n        focusElement: function (element) {\n            element.focus();\n            this.updateFocus(element, { target: element, type: 'focus' });\n        },\n\n        updateFocus: function (target, eventObj) {\n            var hadFocus = this.base.getFocusedElement(),\n                toFocus;\n\n            // For clicks, we need to know if the mousedown that caused the click happened inside the existing focused element\n            // or one of the extension elements.  If so, we don't want to focus another element\n            if (hadFocus &&\n                    eventObj.type === 'click' &&\n                    this.lastMousedownTarget &&\n                    (MediumEditor.util.isDescendant(hadFocus, this.lastMousedownTarget, true) ||\n                     isElementDescendantOfExtension(this.base.extensions, this.lastMousedownTarget))) {\n                toFocus = hadFocus;\n            }\n\n            if (!toFocus) {\n                this.base.elements.some(function (element) {\n                    // If the target is part of an editor element, this is the element getting focus\n                    if (!toFocus && (MediumEditor.util.isDescendant(element, target, true))) {\n                        toFocus = element;\n                    }\n\n                    // bail if we found an element that's getting focus\n                    return !!toFocus;\n                }, this);\n            }\n\n            // Check if the target is external (not part of the editor, toolbar, or any other extension)\n            var externalEvent = !MediumEditor.util.isDescendant(hadFocus, target, true) &&\n                                !isElementDescendantOfExtension(this.base.extensions, target);\n\n            if (toFocus !== hadFocus) {\n                // If element has focus, and focus is going outside of editor\n                // Don't blur focused element if clicking on editor, toolbar, or anchorpreview\n                if (hadFocus && externalEvent) {\n                    // Trigger blur on the editable that has lost focus\n                    hadFocus.removeAttribute('data-medium-focused');\n                    this.triggerCustomEvent('blur', eventObj, hadFocus);\n                }\n\n                // If focus is going into an editor element\n                if (toFocus) {\n                    // Trigger focus on the editable that now has focus\n                    toFocus.setAttribute('data-medium-focused', true);\n                    this.triggerCustomEvent('focus', eventObj, toFocus);\n                }\n            }\n\n            if (externalEvent) {\n                this.triggerCustomEvent('externalInteraction', eventObj);\n            }\n        },\n\n        updateInput: function (target, eventObj) {\n            if (!this.contentCache) {\n                return;\n            }\n            // An event triggered which signifies that the user may have changed someting\n            // Look in our cache of input for the contenteditables to see if something changed\n            var index = target.getAttribute('medium-editor-index'),\n                html = target.innerHTML;\n\n            if (html !== this.contentCache[index]) {\n                // The content has changed since the last time we checked, fire the event\n                this.triggerCustomEvent('editableInput', eventObj, target);\n            }\n            this.contentCache[index] = html;\n        },\n\n        handleDocumentSelectionChange: function (event) {\n            // When selectionchange fires, target and current target are set\n            // to document, since this is where the event is handled\n            // However, currentTarget will have an 'activeElement' property\n            // which will point to whatever element has focus.\n            if (event.currentTarget && event.currentTarget.activeElement) {\n                var activeElement = event.currentTarget.activeElement,\n                    currentTarget;\n                // We can look at the 'activeElement' to determine if the selectionchange has\n                // happened within a contenteditable owned by this instance of MediumEditor\n                this.base.elements.some(function (element) {\n                    if (MediumEditor.util.isDescendant(element, activeElement, true)) {\n                        currentTarget = element;\n                        return true;\n                    }\n                    return false;\n                }, this);\n\n                // We know selectionchange fired within one of our contenteditables\n                if (currentTarget) {\n                    this.updateInput(currentTarget, { target: activeElement, currentTarget: currentTarget });\n                }\n            }\n        },\n\n        handleDocumentExecCommand: function () {\n            // document.execCommand has been called\n            // If one of our contenteditables currently has focus, we should\n            // attempt to trigger the 'editableInput' event\n            var target = this.base.getFocusedElement();\n            if (target) {\n                this.updateInput(target, { target: target, currentTarget: target });\n            }\n        },\n\n        handleBodyClick: function (event) {\n            this.updateFocus(event.target, event);\n        },\n\n        handleBodyFocus: function (event) {\n            this.updateFocus(event.target, event);\n        },\n\n        handleBodyMousedown: function (event) {\n            this.lastMousedownTarget = event.target;\n        },\n\n        handleInput: function (event) {\n            this.updateInput(event.currentTarget, event);\n        },\n\n        handleClick: function (event) {\n            this.triggerCustomEvent('editableClick', event, event.currentTarget);\n        },\n\n        handleBlur: function (event) {\n            this.triggerCustomEvent('editableBlur', event, event.currentTarget);\n        },\n\n        handleKeypress: function (event) {\n            this.triggerCustomEvent('editableKeypress', event, event.currentTarget);\n\n            // If we're doing manual detection of the editableInput event we need\n            // to check for input changes during 'keypress'\n            if (this.keypressUpdateInput) {\n                var eventObj = { target: event.target, currentTarget: event.currentTarget };\n\n                // In IE, we need to let the rest of the event stack complete before we detect\n                // changes to input, so using setTimeout here\n                setTimeout(function () {\n                    this.updateInput(eventObj.currentTarget, eventObj);\n                }.bind(this), 0);\n            }\n        },\n\n        handleKeyup: function (event) {\n            this.triggerCustomEvent('editableKeyup', event, event.currentTarget);\n        },\n\n        handleMouseover: function (event) {\n            this.triggerCustomEvent('editableMouseover', event, event.currentTarget);\n        },\n\n        handleDragging: function (event) {\n            this.triggerCustomEvent('editableDrag', event, event.currentTarget);\n        },\n\n        handleDrop: function (event) {\n            this.triggerCustomEvent('editableDrop', event, event.currentTarget);\n        },\n\n        handlePaste: function (event) {\n            this.triggerCustomEvent('editablePaste', event, event.currentTarget);\n        },\n\n        handleKeydown: function (event) {\n\n            this.triggerCustomEvent('editableKeydown', event, event.currentTarget);\n\n            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.SPACE)) {\n                return this.triggerCustomEvent('editableKeydownSpace', event, event.currentTarget);\n            }\n\n            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER) || (event.ctrlKey && MediumEditor.util.isKey(event, MediumEditor.util.keyCode.M))) {\n                return this.triggerCustomEvent('editableKeydownEnter', event, event.currentTarget);\n            }\n\n            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.TAB)) {\n                return this.triggerCustomEvent('editableKeydownTab', event, event.currentTarget);\n            }\n\n            if (MediumEditor.util.isKey(event, [MediumEditor.util.keyCode.DELETE, MediumEditor.util.keyCode.BACKSPACE])) {\n                return this.triggerCustomEvent('editableKeydownDelete', event, event.currentTarget);\n            }\n        }\n    };\n\n    MediumEditor.Events = Events;\n}());\n\n(function () {\n    'use strict';\n\n    var Button = MediumEditor.Extension.extend({\n\n        /* Button Options */\n\n        /* action: [string]\n         * The action argument to pass to MediumEditor.execAction()\n         * when the button is clicked\n         */\n        action: undefined,\n\n        /* aria: [string]\n         * The value to add as the aria-label attribute of the button\n         * element displayed in the toolbar.\n         * This is also used as the tooltip for the button\n         */\n        aria: undefined,\n\n        /* tagNames: [Array]\n         * NOTE: This is not used if useQueryState is set to true.\n         *\n         * Array of element tag names that would indicate that this\n         * button has already been applied. If this action has already\n         * been applied, the button will be displayed as 'active' in the toolbar\n         *\n         * Example:\n         * For 'bold', if the text is ever within a <b> or <strong>\n         * tag that indicates the text is already bold. So the array\n         * of tagNames for bold would be: ['b', 'strong']\n         */\n        tagNames: undefined,\n\n        /* style: [Object]\n         * NOTE: This is not used if useQueryState is set to true.\n         *\n         * A pair of css property & value(s) that indicate that this\n         * button has already been applied. If this action has already\n         * been applied, the button will be displayed as 'active' in the toolbar\n         * Properties of the object:\n         *   prop [String]: name of the css property\n         *   value [String]: value(s) of the css property\n         *                   multiple values can be separated by a '|'\n         *\n         * Example:\n         * For 'bold', if the text is ever within an element with a 'font-weight'\n         * style property set to '700' or 'bold', that indicates the text\n         * is already bold.  So the style object for bold would be:\n         * { prop: 'font-weight', value: '700|bold' }\n         */\n        style: undefined,\n\n        /* useQueryState: [boolean]\n         * Enables/disables whether this button should use the built-in\n         * document.queryCommandState() method to determine whether\n         * the action has already been applied.  If the action has already\n         * been applied, the button will be displayed as 'active' in the toolbar\n         *\n         * Example:\n         * For 'bold', if this is set to true, the code will call:\n         * document.queryCommandState('bold') which will return true if the\n         * browser thinks the text is already bold, and false otherwise\n         */\n        useQueryState: undefined,\n\n        /* contentDefault: [string]\n         * Default innerHTML to put inside the button\n         */\n        contentDefault: undefined,\n\n        /* contentFA: [string]\n         * The innerHTML to use for the content of the button\n         * if the `buttonLabels` option for MediumEditor is set to 'fontawesome'\n         */\n        contentFA: undefined,\n\n        /* classList: [Array]\n         * An array of classNames (strings) to be added to the button\n         */\n        classList: undefined,\n\n        /* attrs: [object]\n         * A set of key-value pairs to add to the button as custom attributes\n         */\n        attrs: undefined,\n\n        // The button constructor can optionally accept the name of a built-in button\n        // (ie 'bold', 'italic', etc.)\n        // When the name of a button is passed, it will initialize itself with the\n        // configuration for that button\n        constructor: function (options) {\n            if (Button.isBuiltInButton(options)) {\n                MediumEditor.Extension.call(this, this.defaults[options]);\n            } else {\n                MediumEditor.Extension.call(this, options);\n            }\n        },\n\n        init: function () {\n            MediumEditor.Extension.prototype.init.apply(this, arguments);\n\n            this.button = this.createButton();\n            this.on(this.button, 'click', this.handleClick.bind(this));\n        },\n\n        /* getButton: [function ()]\n         *\n         * If implemented, this function will be called when\n         * the toolbar is being created.  The DOM Element returned\n         * by this function will be appended to the toolbar along\n         * with any other buttons.\n         */\n        getButton: function () {\n            return this.button;\n        },\n\n        getAction: function () {\n            return (typeof this.action === 'function') ? this.action(this.base.options) : this.action;\n        },\n\n        getAria: function () {\n            return (typeof this.aria === 'function') ? this.aria(this.base.options) : this.aria;\n        },\n\n        getTagNames: function () {\n            return (typeof this.tagNames === 'function') ? this.tagNames(this.base.options) : this.tagNames;\n        },\n\n        createButton: function () {\n            var button = this.document.createElement('button'),\n                content = this.contentDefault,\n                ariaLabel = this.getAria(),\n                buttonLabels = this.getEditorOption('buttonLabels');\n            // Add class names\n            button.classList.add('medium-editor-action');\n            button.classList.add('medium-editor-action-' + this.name);\n            if (this.classList) {\n                this.classList.forEach(function (className) {\n                    button.classList.add(className);\n                });\n            }\n\n            // Add attributes\n            button.setAttribute('data-action', this.getAction());\n            if (ariaLabel) {\n                button.setAttribute('title', ariaLabel);\n                button.setAttribute('aria-label', ariaLabel);\n            }\n            if (this.attrs) {\n                Object.keys(this.attrs).forEach(function (attr) {\n                    button.setAttribute(attr, this.attrs[attr]);\n                }, this);\n            }\n\n            if (buttonLabels === 'fontawesome' && this.contentFA) {\n                content = this.contentFA;\n            }\n            button.innerHTML = content;\n            return button;\n        },\n\n        handleClick: function (event) {\n            event.preventDefault();\n            event.stopPropagation();\n\n            var action = this.getAction();\n\n            if (action) {\n                this.execAction(action);\n            }\n        },\n\n        isActive: function () {\n            return this.button.classList.contains(this.getEditorOption('activeButtonClass'));\n        },\n\n        setInactive: function () {\n            this.button.classList.remove(this.getEditorOption('activeButtonClass'));\n            delete this.knownState;\n        },\n\n        setActive: function () {\n            this.button.classList.add(this.getEditorOption('activeButtonClass'));\n            delete this.knownState;\n        },\n\n        queryCommandState: function () {\n            var queryState = null;\n            if (this.useQueryState) {\n                queryState = this.base.queryCommandState(this.getAction());\n            }\n            return queryState;\n        },\n\n        isAlreadyApplied: function (node) {\n            var isMatch = false,\n                tagNames = this.getTagNames(),\n                styleVals,\n                computedStyle;\n\n            if (this.knownState === false || this.knownState === true) {\n                return this.knownState;\n            }\n\n            if (tagNames && tagNames.length > 0) {\n                isMatch = tagNames.indexOf(node.nodeName.toLowerCase()) !== -1;\n            }\n\n            if (!isMatch && this.style) {\n                styleVals = this.style.value.split('|');\n                computedStyle = this.window.getComputedStyle(node, null).getPropertyValue(this.style.prop);\n                styleVals.forEach(function (val) {\n                    if (!this.knownState) {\n                        isMatch = (computedStyle.indexOf(val) !== -1);\n                        // text-decoration is not inherited by default\n                        // so if the computed style for text-decoration doesn't match\n                        // don't write to knownState so we can fallback to other checks\n                        if (isMatch || this.style.prop !== 'text-decoration') {\n                            this.knownState = isMatch;\n                        }\n                    }\n                }, this);\n            }\n\n            return isMatch;\n        }\n    });\n\n    Button.isBuiltInButton = function (name) {\n        return (typeof name === 'string') && MediumEditor.extensions.button.prototype.defaults.hasOwnProperty(name);\n    };\n\n    MediumEditor.extensions.button = Button;\n}());\n\n(function () {\n    'use strict';\n\n    /* MediumEditor.extensions.button.defaults: [Object]\n     * Set of default config options for all of the built-in MediumEditor buttons\n     */\n    MediumEditor.extensions.button.prototype.defaults = {\n        'bold': {\n            name: 'bold',\n            action: 'bold',\n            aria: 'bold',\n            tagNames: ['b', 'strong'],\n            style: {\n                prop: 'font-weight',\n                value: '700|bold'\n            },\n            useQueryState: true,\n            contentDefault: '<b>B</b>',\n            contentFA: '<i class=\"fa fa-bold\"></i>'\n        },\n        'italic': {\n            name: 'italic',\n            action: 'italic',\n            aria: 'italic',\n            tagNames: ['i', 'em'],\n            style: {\n                prop: 'font-style',\n                value: 'italic'\n            },\n            useQueryState: true,\n            contentDefault: '<b><i>I</i></b>',\n            contentFA: '<i class=\"fa fa-italic\"></i>'\n        },\n        'underline': {\n            name: 'underline',\n            action: 'underline',\n            aria: 'underline',\n            tagNames: ['u'],\n            style: {\n                prop: 'text-decoration',\n                value: 'underline'\n            },\n            useQueryState: true,\n            contentDefault: '<b><u>U</u></b>',\n            contentFA: '<i class=\"fa fa-underline\"></i>'\n        },\n        'strikethrough': {\n            name: 'strikethrough',\n            action: 'strikethrough',\n            aria: 'strike through',\n            tagNames: ['strike'],\n            style: {\n                prop: 'text-decoration',\n                value: 'line-through'\n            },\n            useQueryState: true,\n            contentDefault: '<s>A</s>',\n            contentFA: '<i class=\"fa fa-strikethrough\"></i>'\n        },\n        'superscript': {\n            name: 'superscript',\n            action: 'superscript',\n            aria: 'superscript',\n            tagNames: ['sup'],\n            /* firefox doesn't behave the way we want it to, so we CAN'T use queryCommandState for superscript\n               https://github.com/guardian/scribe/blob/master/BROWSERINCONSISTENCIES.md#documentquerycommandstate */\n            // useQueryState: true\n            contentDefault: '<b>x<sup>1</sup></b>',\n            contentFA: '<i class=\"fa fa-superscript\"></i>'\n        },\n        'subscript': {\n            name: 'subscript',\n            action: 'subscript',\n            aria: 'subscript',\n            tagNames: ['sub'],\n            /* firefox doesn't behave the way we want it to, so we CAN'T use queryCommandState for subscript\n               https://github.com/guardian/scribe/blob/master/BROWSERINCONSISTENCIES.md#documentquerycommandstate */\n            // useQueryState: true\n            contentDefault: '<b>x<sub>1</sub></b>',\n            contentFA: '<i class=\"fa fa-subscript\"></i>'\n        },\n        'image': {\n            name: 'image',\n            action: 'image',\n            aria: 'image',\n            tagNames: ['img'],\n            contentDefault: '<b>image</b>',\n            contentFA: '<i class=\"fa fa-picture-o\"></i>'\n        },\n        'orderedlist': {\n            name: 'orderedlist',\n            action: 'insertorderedlist',\n            aria: 'ordered list',\n            tagNames: ['ol'],\n            useQueryState: true,\n            contentDefault: '<b>1.</b>',\n            contentFA: '<i class=\"fa fa-list-ol\"></i>'\n        },\n        'unorderedlist': {\n            name: 'unorderedlist',\n            action: 'insertunorderedlist',\n            aria: 'unordered list',\n            tagNames: ['ul'],\n            useQueryState: true,\n            contentDefault: '<b>&bull;</b>',\n            contentFA: '<i class=\"fa fa-list-ul\"></i>'\n        },\n        'indent': {\n            name: 'indent',\n            action: 'indent',\n            aria: 'indent',\n            tagNames: [],\n            contentDefault: '<b>&rarr;</b>',\n            contentFA: '<i class=\"fa fa-indent\"></i>'\n        },\n        'outdent': {\n            name: 'outdent',\n            action: 'outdent',\n            aria: 'outdent',\n            tagNames: [],\n            contentDefault: '<b>&larr;</b>',\n            contentFA: '<i class=\"fa fa-outdent\"></i>'\n        },\n        'justifyCenter': {\n            name: 'justifyCenter',\n            action: 'justifyCenter',\n            aria: 'center justify',\n            tagNames: [],\n            style: {\n                prop: 'text-align',\n                value: 'center'\n            },\n            contentDefault: '<b>C</b>',\n            contentFA: '<i class=\"fa fa-align-center\"></i>'\n        },\n        'justifyFull': {\n            name: 'justifyFull',\n            action: 'justifyFull',\n            aria: 'full justify',\n            tagNames: [],\n            style: {\n                prop: 'text-align',\n                value: 'justify'\n            },\n            contentDefault: '<b>J</b>',\n            contentFA: '<i class=\"fa fa-align-justify\"></i>'\n        },\n        'justifyLeft': {\n            name: 'justifyLeft',\n            action: 'justifyLeft',\n            aria: 'left justify',\n            tagNames: [],\n            style: {\n                prop: 'text-align',\n                value: 'left'\n            },\n            contentDefault: '<b>L</b>',\n            contentFA: '<i class=\"fa fa-align-left\"></i>'\n        },\n        'justifyRight': {\n            name: 'justifyRight',\n            action: 'justifyRight',\n            aria: 'right justify',\n            tagNames: [],\n            style: {\n                prop: 'text-align',\n                value: 'right'\n            },\n            contentDefault: '<b>R</b>',\n            contentFA: '<i class=\"fa fa-align-right\"></i>'\n        },\n        // Known inline elements that are not removed, or not removed consistantly across browsers:\n        // <span>, <label>, <br>\n        'removeFormat': {\n            name: 'removeFormat',\n            aria: 'remove formatting',\n            action: 'removeFormat',\n            contentDefault: '<b>X</b>',\n            contentFA: '<i class=\"fa fa-eraser\"></i>'\n        },\n\n        /***** Buttons for appending block elements (append-<element> action) *****/\n\n        'quote': {\n            name: 'quote',\n            action: 'append-blockquote',\n            aria: 'blockquote',\n            tagNames: ['blockquote'],\n            contentDefault: '<b>&ldquo;</b>',\n            contentFA: '<i class=\"fa fa-quote-right\"></i>'\n        },\n        'pre': {\n            name: 'pre',\n            action: 'append-pre',\n            aria: 'preformatted text',\n            tagNames: ['pre'],\n            contentDefault: '<b>0101</b>',\n            contentFA: '<i class=\"fa fa-code fa-lg\"></i>'\n        },\n        'h1': {\n            name: 'h1',\n            action: 'append-h1',\n            aria: 'header type one',\n            tagNames: ['h1'],\n            contentDefault: '<b>H1</b>',\n            contentFA: '<i class=\"fa fa-header\"><sup>1</sup>'\n        },\n        'h2': {\n            name: 'h2',\n            action: 'append-h2',\n            aria: 'header type two',\n            tagNames: ['h2'],\n            contentDefault: '<b>H2</b>',\n            contentFA: '<i class=\"fa fa-header\"><sup>2</sup>'\n        },\n        'h3': {\n            name: 'h3',\n            action: 'append-h3',\n            aria: 'header type three',\n            tagNames: ['h3'],\n            contentDefault: '<b>H3</b>',\n            contentFA: '<i class=\"fa fa-header\"><sup>3</sup>'\n        },\n        'h4': {\n            name: 'h4',\n            action: 'append-h4',\n            aria: 'header type four',\n            tagNames: ['h4'],\n            contentDefault: '<b>H4</b>',\n            contentFA: '<i class=\"fa fa-header\"><sup>4</sup>'\n        },\n        'h5': {\n            name: 'h5',\n            action: 'append-h5',\n            aria: 'header type five',\n            tagNames: ['h5'],\n            contentDefault: '<b>H5</b>',\n            contentFA: '<i class=\"fa fa-header\"><sup>5</sup>'\n        },\n        'h6': {\n            name: 'h6',\n            action: 'append-h6',\n            aria: 'header type six',\n            tagNames: ['h6'],\n            contentDefault: '<b>H6</b>',\n            contentFA: '<i class=\"fa fa-header\"><sup>6</sup>'\n        }\n    };\n\n})();\n(function () {\n    'use strict';\n\n    /* Base functionality for an extension which will display\n     * a 'form' inside the toolbar\n     */\n    var FormExtension = MediumEditor.extensions.button.extend({\n\n        init: function () {\n            MediumEditor.extensions.button.prototype.init.apply(this, arguments);\n        },\n\n        // default labels for the form buttons\n        formSaveLabel: '&#10003;',\n        formCloseLabel: '&times;',\n\n        /* activeClass: [string]\n         * set class which added to shown form\n         */\n        activeClass: 'medium-editor-toolbar-form-active',\n\n        /* hasForm: [boolean]\n         *\n         * Setting this to true will cause getForm() to be called\n         * when the toolbar is created, so the form can be appended\n         * inside the toolbar container\n         */\n        hasForm: true,\n\n        /* getForm: [function ()]\n         *\n         * When hasForm is true, this function must be implemented\n         * and return a DOM Element which will be appended to\n         * the toolbar container. The form should start hidden, and\n         * the extension can choose when to hide/show it\n         */\n        getForm: function () {},\n\n        /* isDisplayed: [function ()]\n         *\n         * This function should return true/false reflecting\n         * whether the form is currently displayed\n         */\n        isDisplayed: function () {\n            if (this.hasForm) {\n                return this.getForm().classList.contains(this.activeClass);\n            }\n            return false;\n        },\n\n        /* hideForm: [function ()]\n         *\n         * This function should show the form element inside\n         * the toolbar container\n         */\n        showForm: function () {\n            if (this.hasForm) {\n                this.getForm().classList.add(this.activeClass);\n            }\n        },\n\n        /* hideForm: [function ()]\n         *\n         * This function should hide the form element inside\n         * the toolbar container\n         */\n        hideForm: function () {\n            if (this.hasForm) {\n                this.getForm().classList.remove(this.activeClass);\n            }\n        },\n\n        /************************ Helpers ************************\n         * The following are helpers that are either set by MediumEditor\n         * during initialization, or are helper methods which either\n         * route calls to the MediumEditor instance or provide common\n         * functionality for all form extensions\n         *********************************************************/\n\n        /* showToolbarDefaultActions: [function ()]\n         *\n         * Helper method which will turn back the toolbar after canceling\n         * the customized form\n         */\n        showToolbarDefaultActions: function () {\n            var toolbar = this.base.getExtensionByName('toolbar');\n            if (toolbar) {\n                toolbar.showToolbarDefaultActions();\n            }\n        },\n\n        /* hideToolbarDefaultActions: [function ()]\n         *\n         * Helper function which will hide the default contents of the\n         * toolbar, but leave the toolbar container in the same state\n         * to allow a form to display its custom contents inside the toolbar\n         */\n        hideToolbarDefaultActions: function () {\n            var toolbar = this.base.getExtensionByName('toolbar');\n            if (toolbar) {\n                toolbar.hideToolbarDefaultActions();\n            }\n        },\n\n        /* setToolbarPosition: [function ()]\n         *\n         * Helper function which will update the size and position\n         * of the toolbar based on the toolbar content and the current\n         * position of the user's selection\n         */\n        setToolbarPosition: function () {\n            var toolbar = this.base.getExtensionByName('toolbar');\n            if (toolbar) {\n                toolbar.setToolbarPosition();\n            }\n        }\n    });\n\n    MediumEditor.extensions.form = FormExtension;\n})();\n(function () {\n    'use strict';\n\n    var AnchorForm = MediumEditor.extensions.form.extend({\n        /* Anchor Form Options */\n\n        /* customClassOption: [string]  (previously options.anchorButton + options.anchorButtonClass)\n         * Custom class name the user can optionally have added to their created links (ie 'button').\n         * If passed as a non-empty string, a checkbox will be displayed allowing the user to choose\n         * whether to have the class added to the created link or not.\n         */\n        customClassOption: null,\n\n        /* customClassOptionText: [string]\n         * text to be shown in the checkbox when the __customClassOption__ is being used.\n         */\n        customClassOptionText: 'Button',\n\n        /* linkValidation: [boolean]  (previously options.checkLinkFormat)\n         * enables/disables check for common URL protocols on anchor links.\n         */\n        linkValidation: false,\n\n        /* placeholderText: [string]  (previously options.anchorInputPlaceholder)\n         * text to be shown as placeholder of the anchor input.\n         */\n        placeholderText: 'Paste or type a link',\n\n        /* targetCheckbox: [boolean]  (previously options.anchorTarget)\n         * enables/disables displaying a \"Open in new window\" checkbox, which when checked\n         * changes the `target` attribute of the created link.\n         */\n        targetCheckbox: false,\n\n        /* targetCheckboxText: [string]  (previously options.anchorInputCheckboxLabel)\n         * text to be shown in the checkbox enabled via the __targetCheckbox__ option.\n         */\n        targetCheckboxText: 'Open in new window',\n\n        // Options for the Button base class\n        name: 'anchor',\n        action: 'createLink',\n        aria: 'link',\n        tagNames: ['a'],\n        contentDefault: '<b>#</b>',\n        contentFA: '<i class=\"fa fa-link\"></i>',\n\n        init: function () {\n            MediumEditor.extensions.form.prototype.init.apply(this, arguments);\n\n            this.subscribe('editableKeydown', this.handleKeydown.bind(this));\n        },\n\n        // Called when the button the toolbar is clicked\n        // Overrides ButtonExtension.handleClick\n        handleClick: function (event) {\n            event.preventDefault();\n            event.stopPropagation();\n\n            var range = MediumEditor.selection.getSelectionRange(this.document);\n\n            if (range.startContainer.nodeName.toLowerCase() === 'a' ||\n                range.endContainer.nodeName.toLowerCase() === 'a' ||\n                MediumEditor.util.getClosestTag(MediumEditor.selection.getSelectedParentElement(range), 'a')) {\n                return this.execAction('unlink');\n            }\n\n            if (!this.isDisplayed()) {\n                this.showForm();\n            }\n\n            return false;\n        },\n\n        // Called when user hits the defined shortcut (CTRL / COMMAND + K)\n        handleKeydown: function (event) {\n            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.K) && MediumEditor.util.isMetaCtrlKey(event) && !event.shiftKey) {\n                this.handleClick(event);\n            }\n        },\n\n        // Called by medium-editor to append form to the toolbar\n        getForm: function () {\n            if (!this.form) {\n                this.form = this.createForm();\n            }\n            return this.form;\n        },\n\n        getTemplate: function () {\n            var template = [\n                '<input type=\"text\" class=\"medium-editor-toolbar-input\" placeholder=\"', this.placeholderText, '\">'\n            ];\n\n            template.push(\n                '<a href=\"#\" class=\"medium-editor-toolbar-save\">',\n                this.getEditorOption('buttonLabels') === 'fontawesome' ? '<i class=\"fa fa-check\"></i>' : this.formSaveLabel,\n                '</a>'\n            );\n\n            template.push('<a href=\"#\" class=\"medium-editor-toolbar-close\">',\n                this.getEditorOption('buttonLabels') === 'fontawesome' ? '<i class=\"fa fa-times\"></i>' : this.formCloseLabel,\n                '</a>');\n\n            // both of these options are slightly moot with the ability to\n            // override the various form buildup/serialize functions.\n\n            if (this.targetCheckbox) {\n                // fixme: ideally, this targetCheckboxText would be a formLabel too,\n                // figure out how to deprecate? also consider `fa-` icon default implcations.\n                template.push(\n                    '<div class=\"medium-editor-toolbar-form-row\">',\n                    '<input type=\"checkbox\" class=\"medium-editor-toolbar-anchor-target\">',\n                    '<label>',\n                    this.targetCheckboxText,\n                    '</label>',\n                    '</div>'\n                );\n            }\n\n            if (this.customClassOption) {\n                // fixme: expose this `Button` text as a formLabel property, too\n                // and provide similar access to a `fa-` icon default.\n                template.push(\n                    '<div class=\"medium-editor-toolbar-form-row\">',\n                    '<input type=\"checkbox\" class=\"medium-editor-toolbar-anchor-button\">',\n                    '<label>',\n                    this.customClassOptionText,\n                    '</label>',\n                    '</div>'\n                );\n            }\n\n            return template.join('');\n\n        },\n\n        // Used by medium-editor when the default toolbar is to be displayed\n        isDisplayed: function () {\n            return MediumEditor.extensions.form.prototype.isDisplayed.apply(this);\n        },\n\n        hideForm: function () {\n            MediumEditor.extensions.form.prototype.hideForm.apply(this);\n            this.getInput().value = '';\n        },\n\n        showForm: function (opts) {\n            var input = this.getInput(),\n                targetCheckbox = this.getAnchorTargetCheckbox(),\n                buttonCheckbox = this.getAnchorButtonCheckbox();\n\n            opts = opts || { value: '' };\n            // TODO: This is for backwards compatability\n            // We don't need to support the 'string' argument in 6.0.0\n            if (typeof opts === 'string') {\n                opts = {\n                    value: opts\n                };\n            }\n\n            this.base.saveSelection();\n            this.hideToolbarDefaultActions();\n            MediumEditor.extensions.form.prototype.showForm.apply(this);\n            this.setToolbarPosition();\n\n            input.value = opts.value;\n            input.focus();\n\n            // If we have a target checkbox, we want it to be checked/unchecked\n            // based on whether the existing link has target=_blank\n            if (targetCheckbox) {\n                targetCheckbox.checked = opts.target === '_blank';\n            }\n\n            // If we have a custom class checkbox, we want it to be checked/unchecked\n            // based on whether an existing link already has the class\n            if (buttonCheckbox) {\n                var classList = opts.buttonClass ? opts.buttonClass.split(' ') : [];\n                buttonCheckbox.checked = (classList.indexOf(this.customClassOption) !== -1);\n            }\n        },\n\n        // Called by core when tearing down medium-editor (destroy)\n        destroy: function () {\n            if (!this.form) {\n                return false;\n            }\n\n            if (this.form.parentNode) {\n                this.form.parentNode.removeChild(this.form);\n            }\n\n            delete this.form;\n        },\n\n        // core methods\n\n        getFormOpts: function () {\n            // no notion of private functions? wanted `_getFormOpts`\n            var targetCheckbox = this.getAnchorTargetCheckbox(),\n                buttonCheckbox = this.getAnchorButtonCheckbox(),\n                opts = {\n                    value: this.getInput().value.trim()\n                };\n\n            if (this.linkValidation) {\n                opts.value = this.checkLinkFormat(opts.value);\n            }\n\n            opts.target = '_self';\n            if (targetCheckbox && targetCheckbox.checked) {\n                opts.target = '_blank';\n            }\n\n            if (buttonCheckbox && buttonCheckbox.checked) {\n                opts.buttonClass = this.customClassOption;\n            }\n\n            return opts;\n        },\n\n        doFormSave: function () {\n            var opts = this.getFormOpts();\n            this.completeFormSave(opts);\n        },\n\n        completeFormSave: function (opts) {\n            this.base.restoreSelection();\n            this.execAction(this.action, opts);\n            this.base.checkSelection();\n        },\n\n        checkLinkFormat: function (value) {\n            // Matches any alphabetical characters followed by ://\n            // Matches protocol relative \"//\"\n            // Matches common external protocols \"mailto:\" \"tel:\" \"maps:\"\n            var urlSchemeRegex = /^([a-z]+:)?\\/\\/|^(mailto|tel|maps):/i,\n            // var te is a regex for checking if the string is a telephone number\n            telRegex = /^\\+?\\s?\\(?(?:\\d\\s?\\-?\\)?){3,20}$/;\n            if (telRegex.test(value)) {\n                return 'tel:' + value;\n            } else {\n                // Check for URL scheme and default to http:// if none found\n                return (urlSchemeRegex.test(value) ? '' : 'http://') + encodeURI(value);\n            }\n        },\n\n        doFormCancel: function () {\n            this.base.restoreSelection();\n            this.base.checkSelection();\n        },\n\n        // form creation and event handling\n        attachFormEvents: function (form) {\n            var close = form.querySelector('.medium-editor-toolbar-close'),\n                save = form.querySelector('.medium-editor-toolbar-save'),\n                input = form.querySelector('.medium-editor-toolbar-input');\n\n            // Handle clicks on the form itself\n            this.on(form, 'click', this.handleFormClick.bind(this));\n\n            // Handle typing in the textbox\n            this.on(input, 'keyup', this.handleTextboxKeyup.bind(this));\n\n            // Handle close button clicks\n            this.on(close, 'click', this.handleCloseClick.bind(this));\n\n            // Handle save button clicks (capture)\n            this.on(save, 'click', this.handleSaveClick.bind(this), true);\n\n        },\n\n        createForm: function () {\n            var doc = this.document,\n                form = doc.createElement('div');\n\n            // Anchor Form (div)\n            form.className = 'medium-editor-toolbar-form';\n            form.id = 'medium-editor-toolbar-form-anchor-' + this.getEditorId();\n            form.innerHTML = this.getTemplate();\n            this.attachFormEvents(form);\n\n            return form;\n        },\n\n        getInput: function () {\n            return this.getForm().querySelector('input.medium-editor-toolbar-input');\n        },\n\n        getAnchorTargetCheckbox: function () {\n            return this.getForm().querySelector('.medium-editor-toolbar-anchor-target');\n        },\n\n        getAnchorButtonCheckbox: function () {\n            return this.getForm().querySelector('.medium-editor-toolbar-anchor-button');\n        },\n\n        handleTextboxKeyup: function (event) {\n            // For ENTER -> create the anchor\n            if (event.keyCode === MediumEditor.util.keyCode.ENTER) {\n                event.preventDefault();\n                this.doFormSave();\n                return;\n            }\n\n            // For ESCAPE -> close the form\n            if (event.keyCode === MediumEditor.util.keyCode.ESCAPE) {\n                event.preventDefault();\n                this.doFormCancel();\n            }\n        },\n\n        handleFormClick: function (event) {\n            // make sure not to hide form when clicking inside the form\n            event.stopPropagation();\n        },\n\n        handleSaveClick: function (event) {\n            // Clicking Save -> create the anchor\n            event.preventDefault();\n            this.doFormSave();\n        },\n\n        handleCloseClick: function (event) {\n            // Click Close -> close the form\n            event.preventDefault();\n            this.doFormCancel();\n        }\n    });\n\n    MediumEditor.extensions.anchor = AnchorForm;\n}());\n\n(function () {\n    'use strict';\n\n    var AnchorPreview = MediumEditor.Extension.extend({\n        name: 'anchor-preview',\n\n        // Anchor Preview Options\n\n        /* hideDelay: [number]  (previously options.anchorPreviewHideDelay)\n         * time in milliseconds to show the anchor tag preview after the mouse has left the anchor tag.\n         */\n        hideDelay: 500,\n\n        /* previewValueSelector: [string]\n         * the default selector to locate where to put the activeAnchor value in the preview\n         */\n        previewValueSelector: 'a',\n\n        /* showWhenToolbarIsVisible: [boolean]\n         * determines whether the anchor tag preview shows up when the toolbar is visible\n         */\n        showWhenToolbarIsVisible: false,\n\n        /* showOnEmptyLinks: [boolean]\n        * determines whether the anchor tag preview shows up on links with href=\"\" or href=\"#something\"\n        */\n        showOnEmptyLinks: true,\n\n        init: function () {\n            this.anchorPreview = this.createPreview();\n\n            this.getEditorOption('elementsContainer').appendChild(this.anchorPreview);\n\n            this.attachToEditables();\n        },\n\n        getInteractionElements: function () {\n            return this.getPreviewElement();\n        },\n\n        // TODO: Remove this function in 6.0.0\n        getPreviewElement: function () {\n            return this.anchorPreview;\n        },\n\n        createPreview: function () {\n            var el = this.document.createElement('div');\n\n            el.id = 'medium-editor-anchor-preview-' + this.getEditorId();\n            el.className = 'medium-editor-anchor-preview';\n            el.innerHTML = this.getTemplate();\n\n            this.on(el, 'click', this.handleClick.bind(this));\n\n            return el;\n        },\n\n        getTemplate: function () {\n            return '<div class=\"medium-editor-toolbar-anchor-preview\" id=\"medium-editor-toolbar-anchor-preview\">' +\n                '    <a class=\"medium-editor-toolbar-anchor-preview-inner\"></a>' +\n                '</div>';\n        },\n\n        destroy: function () {\n            if (this.anchorPreview) {\n                if (this.anchorPreview.parentNode) {\n                    this.anchorPreview.parentNode.removeChild(this.anchorPreview);\n                }\n                delete this.anchorPreview;\n            }\n        },\n\n        hidePreview: function () {\n            this.anchorPreview.classList.remove('medium-editor-anchor-preview-active');\n            this.activeAnchor = null;\n        },\n\n        showPreview: function (anchorEl) {\n            if (this.anchorPreview.classList.contains('medium-editor-anchor-preview-active') ||\n                    anchorEl.getAttribute('data-disable-preview')) {\n                return true;\n            }\n\n            if (this.previewValueSelector) {\n                this.anchorPreview.querySelector(this.previewValueSelector).textContent = anchorEl.attributes.href.value;\n                this.anchorPreview.querySelector(this.previewValueSelector).href = anchorEl.attributes.href.value;\n            }\n\n            this.anchorPreview.classList.add('medium-toolbar-arrow-over');\n            this.anchorPreview.classList.remove('medium-toolbar-arrow-under');\n\n            if (!this.anchorPreview.classList.contains('medium-editor-anchor-preview-active')) {\n                this.anchorPreview.classList.add('medium-editor-anchor-preview-active');\n            }\n\n            this.activeAnchor = anchorEl;\n\n            this.positionPreview();\n            this.attachPreviewHandlers();\n\n            return this;\n        },\n\n        positionPreview: function (activeAnchor) {\n            activeAnchor = activeAnchor || this.activeAnchor;\n            var buttonHeight = this.anchorPreview.offsetHeight,\n                boundary = activeAnchor.getBoundingClientRect(),\n                middleBoundary = (boundary.left + boundary.right) / 2,\n                diffLeft = this.diffLeft,\n                diffTop = this.diffTop,\n                halfOffsetWidth,\n                defaultLeft;\n\n            halfOffsetWidth = this.anchorPreview.offsetWidth / 2;\n            var toolbarExtension = this.base.getExtensionByName('toolbar');\n            if (toolbarExtension) {\n                diffLeft = toolbarExtension.diffLeft;\n                diffTop = toolbarExtension.diffTop;\n            }\n            defaultLeft = diffLeft - halfOffsetWidth;\n\n            this.anchorPreview.style.top = Math.round(buttonHeight + boundary.bottom - diffTop + this.window.pageYOffset - this.anchorPreview.offsetHeight) + 'px';\n            this.anchorPreview.style.right = 'initial';\n            if (middleBoundary < halfOffsetWidth) {\n                this.anchorPreview.style.left = defaultLeft + halfOffsetWidth + 'px';\n                this.anchorPreview.style.right = 'initial';\n            } else if ((this.window.innerWidth - middleBoundary) < halfOffsetWidth) {\n                this.anchorPreview.style.left = 'auto';\n                this.anchorPreview.style.right = 0;\n            } else {\n                this.anchorPreview.style.left = defaultLeft + middleBoundary + 'px';\n                this.anchorPreview.style.right = 'initial';\n            }\n        },\n\n        attachToEditables: function () {\n            this.subscribe('editableMouseover', this.handleEditableMouseover.bind(this));\n            this.subscribe('positionedToolbar', this.handlePositionedToolbar.bind(this));\n        },\n\n        handlePositionedToolbar: function () {\n            // If the toolbar is visible and positioned, we don't need to hide the preview\n            // when showWhenToolbarIsVisible is true\n            if (!this.showWhenToolbarIsVisible) {\n                this.hidePreview();\n            }\n        },\n\n        handleClick: function (event) {\n            var anchorExtension = this.base.getExtensionByName('anchor'),\n                activeAnchor = this.activeAnchor;\n\n            if (anchorExtension && activeAnchor) {\n                event.preventDefault();\n\n                this.base.selectElement(this.activeAnchor);\n\n                // Using setTimeout + delay because:\n                // We may actually be displaying the anchor form, which should be controlled by delay\n                this.base.delay(function () {\n                    if (activeAnchor) {\n                        var opts = {\n                            value: activeAnchor.attributes.href.value,\n                            target: activeAnchor.getAttribute('target'),\n                            buttonClass: activeAnchor.getAttribute('class')\n                        };\n                        anchorExtension.showForm(opts);\n                        activeAnchor = null;\n                    }\n                }.bind(this));\n            }\n\n            this.hidePreview();\n        },\n\n        handleAnchorMouseout: function () {\n            this.anchorToPreview = null;\n            this.off(this.activeAnchor, 'mouseout', this.instanceHandleAnchorMouseout);\n            this.instanceHandleAnchorMouseout = null;\n        },\n\n        handleEditableMouseover: function (event) {\n            var target = MediumEditor.util.getClosestTag(event.target, 'a');\n\n            if (false === target) {\n                return;\n            }\n\n            // Detect empty href attributes\n            // The browser will make href=\"\" or href=\"#top\"\n            // into absolute urls when accessed as event.target.href, so check the html\n            if (!this.showOnEmptyLinks &&\n                (!/href=[\"']\\S+[\"']/.test(target.outerHTML) || /href=[\"']#\\S+[\"']/.test(target.outerHTML))) {\n                return true;\n            }\n\n            // only show when toolbar is not present\n            var toolbar = this.base.getExtensionByName('toolbar');\n            if (!this.showWhenToolbarIsVisible && toolbar && toolbar.isDisplayed && toolbar.isDisplayed()) {\n                return true;\n            }\n\n            // detach handler for other anchor in case we hovered multiple anchors quickly\n            if (this.activeAnchor && this.activeAnchor !== target) {\n                this.detachPreviewHandlers();\n            }\n\n            this.anchorToPreview = target;\n\n            this.instanceHandleAnchorMouseout = this.handleAnchorMouseout.bind(this);\n            this.on(this.anchorToPreview, 'mouseout', this.instanceHandleAnchorMouseout);\n            // Using setTimeout + delay because:\n            // - We're going to show the anchor preview according to the configured delay\n            //   if the mouse has not left the anchor tag in that time\n            this.base.delay(function () {\n                if (this.anchorToPreview) {\n                    this.showPreview(this.anchorToPreview);\n                }\n            }.bind(this));\n        },\n\n        handlePreviewMouseover: function () {\n            this.lastOver = (new Date()).getTime();\n            this.hovering = true;\n        },\n\n        handlePreviewMouseout: function (event) {\n            if (!event.relatedTarget || !/anchor-preview/.test(event.relatedTarget.className)) {\n                this.hovering = false;\n            }\n        },\n\n        updatePreview: function () {\n            if (this.hovering) {\n                return true;\n            }\n            var durr = (new Date()).getTime() - this.lastOver;\n            if (durr > this.hideDelay) {\n                // hide the preview 1/2 second after mouse leaves the link\n                this.detachPreviewHandlers();\n            }\n        },\n\n        detachPreviewHandlers: function () {\n            // cleanup\n            clearInterval(this.intervalTimer);\n            if (this.instanceHandlePreviewMouseover) {\n                this.off(this.anchorPreview, 'mouseover', this.instanceHandlePreviewMouseover);\n                this.off(this.anchorPreview, 'mouseout', this.instanceHandlePreviewMouseout);\n                if (this.activeAnchor) {\n                    this.off(this.activeAnchor, 'mouseover', this.instanceHandlePreviewMouseover);\n                    this.off(this.activeAnchor, 'mouseout', this.instanceHandlePreviewMouseout);\n                }\n            }\n\n            this.hidePreview();\n\n            this.hovering = this.instanceHandlePreviewMouseover = this.instanceHandlePreviewMouseout = null;\n        },\n\n        // TODO: break up method and extract out handlers\n        attachPreviewHandlers: function () {\n            this.lastOver = (new Date()).getTime();\n            this.hovering = true;\n\n            this.instanceHandlePreviewMouseover = this.handlePreviewMouseover.bind(this);\n            this.instanceHandlePreviewMouseout = this.handlePreviewMouseout.bind(this);\n\n            this.intervalTimer = setInterval(this.updatePreview.bind(this), 200);\n\n            this.on(this.anchorPreview, 'mouseover', this.instanceHandlePreviewMouseover);\n            this.on(this.anchorPreview, 'mouseout', this.instanceHandlePreviewMouseout);\n            this.on(this.activeAnchor, 'mouseover', this.instanceHandlePreviewMouseover);\n            this.on(this.activeAnchor, 'mouseout', this.instanceHandlePreviewMouseout);\n        }\n    });\n\n    MediumEditor.extensions.anchorPreview = AnchorPreview;\n}());\n\n(function () {\n    'use strict';\n\n    var WHITESPACE_CHARS,\n        KNOWN_TLDS_FRAGMENT,\n        LINK_REGEXP_TEXT,\n        KNOWN_TLDS_REGEXP;\n\n    WHITESPACE_CHARS = [' ', '\\t', '\\n', '\\r', '\\u00A0', '\\u2000', '\\u2001', '\\u2002', '\\u2003',\n                                    '\\u2028', '\\u2029'];\n    KNOWN_TLDS_FRAGMENT = 'com|net|org|edu|gov|mil|aero|asia|biz|cat|coop|info|int|jobs|mobi|museum|name|post|pro|tel|travel|' +\n        'xxx|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|' +\n        'bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cs|cu|cv|cx|cy|cz|dd|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|' +\n        'fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|' +\n        'is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|' +\n        'mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|' +\n        'pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|ja|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|' +\n        'tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw';\n\n    LINK_REGEXP_TEXT =\n        '(' +\n        // Version of Gruber URL Regexp optimized for JS: http://stackoverflow.com/a/17733640\n        '((?:(https?://|ftps?://|nntp://)|www\\\\d{0,3}[.]|[a-z0-9.\\\\-]+[.](' + KNOWN_TLDS_FRAGMENT + ')\\\\\\/)\\\\S+(?:[^\\\\s`!\\\\[\\\\]{};:\\'\\\".,?\\u00AB\\u00BB\\u201C\\u201D\\u2018\\u2019]))' +\n        // Addition to above Regexp to support bare domains/one level subdomains with common non-i18n TLDs and without www prefix:\n        ')|(([a-z0-9\\\\-]+\\\\.)?[a-z0-9\\\\-]+\\\\.(' + KNOWN_TLDS_FRAGMENT + '))';\n\n    KNOWN_TLDS_REGEXP = new RegExp('^(' + KNOWN_TLDS_FRAGMENT + ')$', 'i');\n\n    function nodeIsNotInsideAnchorTag(node) {\n        return !MediumEditor.util.getClosestTag(node, 'a');\n    }\n\n    var AutoLink = MediumEditor.Extension.extend({\n        init: function () {\n            MediumEditor.Extension.prototype.init.apply(this, arguments);\n\n            this.disableEventHandling = false;\n            this.subscribe('editableKeypress', this.onKeypress.bind(this));\n            this.subscribe('editableBlur', this.onBlur.bind(this));\n            // MS IE has it's own auto-URL detect feature but ours is better in some ways. Be consistent.\n            this.document.execCommand('AutoUrlDetect', false, false);\n        },\n\n        isLastInstance: function () {\n            var this$1 = this;\n\n            var activeInstances = 0;\n            for (var i = 0; i < this.window._mediumEditors.length; i++) {\n                var editor = this$1.window._mediumEditors[i];\n                if (editor !== null && editor.getExtensionByName('autoLink') !== undefined) {\n                    activeInstances++;\n                }\n            }\n            return activeInstances === 1;\n        },\n\n        destroy: function () {\n            // Turn AutoUrlDetect back on\n            if (this.document.queryCommandSupported('AutoUrlDetect') && this.isLastInstance()) {\n                this.document.execCommand('AutoUrlDetect', false, true);\n            }\n        },\n\n        onBlur: function (blurEvent, editable) {\n            this.performLinking(editable);\n        },\n\n        onKeypress: function (keyPressEvent) {\n            if (this.disableEventHandling) {\n                return;\n            }\n\n            if (MediumEditor.util.isKey(keyPressEvent, [MediumEditor.util.keyCode.SPACE, MediumEditor.util.keyCode.ENTER])) {\n                clearTimeout(this.performLinkingTimeout);\n                // Saving/restoring the selection in the middle of a keypress doesn't work well...\n                this.performLinkingTimeout = setTimeout(function () {\n                    try {\n                        var sel = this.base.exportSelection();\n                        if (this.performLinking(keyPressEvent.target)) {\n                            // pass true for favorLaterSelectionAnchor - this is needed for links at the end of a\n                            // paragraph in MS IE, or MS IE causes the link to be deleted right after adding it.\n                            this.base.importSelection(sel, true);\n                        }\n                    } catch (e) {\n                        if (window.console) {\n                            window.console.error('Failed to perform linking', e);\n                        }\n                        this.disableEventHandling = true;\n                    }\n                }.bind(this), 0);\n            }\n        },\n\n        performLinking: function (contenteditable) {\n            var this$1 = this;\n\n            /*\n            Perform linking on blockElement basis, blockElements are HTML elements with text content and without\n            child element.\n\n            Example:\n            - HTML content\n            <blockquote>\n              <p>link.</p>\n              <p>my</p>\n            </blockquote>\n\n            - blockElements\n            [<p>link.</p>, <p>my</p>]\n\n            otherwise the detection can wrongly find the end of one paragraph and the beginning of another paragraph\n            to constitute a link, such as a paragraph ending \"link.\" and the next paragraph beginning with \"my\" is\n            interpreted into \"link.my\" and the code tries to create a link across blockElements - which doesn't work\n            and is terrible.\n            (Medium deletes the spaces/returns between P tags so the textContent ends up without paragraph spacing)\n            */\n            var blockElements = MediumEditor.util.splitByBlockElements(contenteditable),\n                documentModified = false;\n            if (blockElements.length === 0) {\n                blockElements = [contenteditable];\n            }\n            for (var i = 0; i < blockElements.length; i++) {\n                documentModified = this$1.removeObsoleteAutoLinkSpans(blockElements[i]) || documentModified;\n                documentModified = this$1.performLinkingWithinElement(blockElements[i]) || documentModified;\n            }\n            this.base.events.updateInput(contenteditable, { target: contenteditable, currentTarget: contenteditable });\n            return documentModified;\n        },\n\n        removeObsoleteAutoLinkSpans: function (element) {\n            var this$1 = this;\n\n            if (!element || element.nodeType === 3) {\n                return false;\n            }\n\n            var spans = element.querySelectorAll('span[data-auto-link=\"true\"]'),\n                documentModified = false;\n\n            for (var i = 0; i < spans.length; i++) {\n                var textContent = spans[i].textContent;\n                if (textContent.indexOf('://') === -1) {\n                    textContent = MediumEditor.util.ensureUrlHasProtocol(textContent);\n                }\n                if (spans[i].getAttribute('data-href') !== textContent && nodeIsNotInsideAnchorTag(spans[i])) {\n                    documentModified = true;\n                    var trimmedTextContent = textContent.replace(/\\s+$/, '');\n                    if (spans[i].getAttribute('data-href') === trimmedTextContent) {\n                        var charactersTrimmed = textContent.length - trimmedTextContent.length,\n                            subtree = MediumEditor.util.splitOffDOMTree(spans[i], this$1.splitTextBeforeEnd(spans[i], charactersTrimmed));\n                        spans[i].parentNode.insertBefore(subtree, spans[i].nextSibling);\n                    } else {\n                        // Some editing has happened to the span, so just remove it entirely. The user can put it back\n                        // around just the href content if they need to prevent it from linking\n                        MediumEditor.util.unwrap(spans[i], this$1.document);\n                    }\n                }\n            }\n            return documentModified;\n        },\n\n        splitTextBeforeEnd: function (element, characterCount) {\n            var treeWalker = this.document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, false),\n                lastChildNotExhausted = true;\n\n            // Start the tree walker at the last descendant of the span\n            while (lastChildNotExhausted) {\n                lastChildNotExhausted = treeWalker.lastChild() !== null;\n            }\n\n            var currentNode,\n                currentNodeValue,\n                previousNode;\n            while (characterCount > 0 && previousNode !== null) {\n                currentNode = treeWalker.currentNode;\n                currentNodeValue = currentNode.nodeValue;\n                if (currentNodeValue.length > characterCount) {\n                    previousNode = currentNode.splitText(currentNodeValue.length - characterCount);\n                    characterCount = 0;\n                } else {\n                    previousNode = treeWalker.previousNode();\n                    characterCount -= currentNodeValue.length;\n                }\n            }\n            return previousNode;\n        },\n\n        performLinkingWithinElement: function (element) {\n            var this$1 = this;\n\n            var matches = this.findLinkableText(element),\n                linkCreated = false;\n\n            for (var matchIndex = 0; matchIndex < matches.length; matchIndex++) {\n                var matchingTextNodes = MediumEditor.util.findOrCreateMatchingTextNodes(this$1.document, element,\n                        matches[matchIndex]);\n                if (this$1.shouldNotLink(matchingTextNodes)) {\n                    continue;\n                }\n                this$1.createAutoLink(matchingTextNodes, matches[matchIndex].href);\n            }\n            return linkCreated;\n        },\n\n        shouldNotLink: function (textNodes) {\n            var shouldNotLink = false;\n            for (var i = 0; i < textNodes.length && shouldNotLink === false; i++) {\n                // Do not link if the text node is either inside an anchor or inside span[data-auto-link]\n                shouldNotLink = !!MediumEditor.util.traverseUp(textNodes[i], function (node) {\n                    return node.nodeName.toLowerCase() === 'a' ||\n                        (node.getAttribute && node.getAttribute('data-auto-link') === 'true');\n                });\n            }\n            return shouldNotLink;\n        },\n\n        findLinkableText: function (contenteditable) {\n            var linkRegExp = new RegExp(LINK_REGEXP_TEXT, 'gi'),\n                textContent = contenteditable.textContent,\n                match = null,\n                matches = [];\n\n            while ((match = linkRegExp.exec(textContent)) !== null) {\n                var matchOk = true,\n                    matchEnd = match.index + match[0].length;\n                // If the regexp detected something as a link that has text immediately preceding/following it, bail out.\n                matchOk = (match.index === 0 || WHITESPACE_CHARS.indexOf(textContent[match.index - 1]) !== -1) &&\n                    (matchEnd === textContent.length || WHITESPACE_CHARS.indexOf(textContent[matchEnd]) !== -1);\n                // If the regexp detected a bare domain that doesn't use one of our expected TLDs, bail out.\n                matchOk = matchOk && (match[0].indexOf('/') !== -1 ||\n                    KNOWN_TLDS_REGEXP.test(match[0].split('.').pop().split('?').shift()));\n\n                if (matchOk) {\n                    matches.push({\n                        href: match[0],\n                        start: match.index,\n                        end: matchEnd\n                    });\n                }\n            }\n            return matches;\n        },\n\n        createAutoLink: function (textNodes, href) {\n            href = MediumEditor.util.ensureUrlHasProtocol(href);\n            var anchor = MediumEditor.util.createLink(this.document, textNodes, href, this.getEditorOption('targetBlank') ? '_blank' : null),\n                span = this.document.createElement('span');\n            span.setAttribute('data-auto-link', 'true');\n            span.setAttribute('data-href', href);\n            anchor.insertBefore(span, anchor.firstChild);\n            while (anchor.childNodes.length > 1) {\n                span.appendChild(anchor.childNodes[1]);\n            }\n        }\n\n    });\n\n    MediumEditor.extensions.autoLink = AutoLink;\n}());\n\n(function () {\n    'use strict';\n\n    var CLASS_DRAG_OVER = 'medium-editor-dragover';\n\n    function clearClassNames(element) {\n        var editable = MediumEditor.util.getContainerEditorElement(element),\n            existing = Array.prototype.slice.call(editable.parentElement.querySelectorAll('.' + CLASS_DRAG_OVER));\n\n        existing.forEach(function (el) {\n            el.classList.remove(CLASS_DRAG_OVER);\n        });\n    }\n\n    var FileDragging = MediumEditor.Extension.extend({\n        name: 'fileDragging',\n\n        allowedTypes: ['image'],\n\n        init: function () {\n            MediumEditor.Extension.prototype.init.apply(this, arguments);\n\n            this.subscribe('editableDrag', this.handleDrag.bind(this));\n            this.subscribe('editableDrop', this.handleDrop.bind(this));\n        },\n\n        handleDrag: function (event) {\n            event.preventDefault();\n            event.dataTransfer.dropEffect = 'copy';\n\n            var target = event.target.classList ? event.target : event.target.parentElement;\n\n            // Ensure the class gets removed from anything that had it before\n            clearClassNames(target);\n\n            if (event.type === 'dragover') {\n                target.classList.add(CLASS_DRAG_OVER);\n            }\n        },\n\n        handleDrop: function (event) {\n            // Prevent file from opening in the current window\n            event.preventDefault();\n            event.stopPropagation();\n            // Select the dropping target, and set the selection to the end of the target\n            // https://github.com/yabwe/medium-editor/issues/980\n            this.base.selectElement(event.target);\n            var selection = this.base.exportSelection();\n            selection.start = selection.end;\n            this.base.importSelection(selection);\n            // IE9 does not support the File API, so prevent file from opening in the window\n            // but also don't try to actually get the file\n            if (event.dataTransfer.files) {\n                Array.prototype.slice.call(event.dataTransfer.files).forEach(function (file) {\n                    if (this.isAllowedFile(file)) {\n                        if (file.type.match('image')) {\n                            this.insertImageFile(file);\n                        }\n                    }\n                }, this);\n            }\n\n            // Make sure we remove our class from everything\n            clearClassNames(event.target);\n        },\n\n        isAllowedFile: function (file) {\n            return this.allowedTypes.some(function (fileType) {\n                return !!file.type.match(fileType);\n            });\n        },\n\n        insertImageFile: function (file) {\n            if (typeof FileReader !== 'function') {\n                return;\n            }\n            var fileReader = new FileReader();\n            fileReader.readAsDataURL(file);\n\n            // attach the onload event handler, makes it easier to listen in with jasmine\n            fileReader.addEventListener('load', function (e) {\n                var addImageElement = this.document.createElement('img');\n                addImageElement.src = e.target.result;\n                MediumEditor.util.insertHTMLCommand(this.document, addImageElement.outerHTML);\n            }.bind(this));\n        }\n    });\n\n    MediumEditor.extensions.fileDragging = FileDragging;\n}());\n\n(function () {\n    'use strict';\n\n    var KeyboardCommands = MediumEditor.Extension.extend({\n        name: 'keyboard-commands',\n\n        /* KeyboardCommands Options */\n\n        /* commands: [Array]\n         * Array of objects describing each command and the combination of keys that will trigger it\n         * Required for each object:\n         *   command [String] (argument passed to editor.execAction())\n         *   key [String] (keyboard character that triggers this command)\n         *   meta [boolean] (whether the ctrl/meta key has to be active or inactive)\n         *   shift [boolean] (whether the shift key has to be active or inactive)\n         *   alt [boolean] (whether the alt key has to be active or inactive)\n         */\n        commands: [\n            {\n                command: 'bold',\n                key: 'B',\n                meta: true,\n                shift: false,\n                alt: false\n            },\n            {\n                command: 'italic',\n                key: 'I',\n                meta: true,\n                shift: false,\n                alt: false\n            },\n            {\n                command: 'underline',\n                key: 'U',\n                meta: true,\n                shift: false,\n                alt: false\n            }\n        ],\n\n        init: function () {\n            MediumEditor.Extension.prototype.init.apply(this, arguments);\n\n            this.subscribe('editableKeydown', this.handleKeydown.bind(this));\n            this.keys = {};\n            this.commands.forEach(function (command) {\n                var keyCode = command.key.charCodeAt(0);\n                if (!this.keys[keyCode]) {\n                    this.keys[keyCode] = [];\n                }\n                this.keys[keyCode].push(command);\n            }, this);\n        },\n\n        handleKeydown: function (event) {\n            var keyCode = MediumEditor.util.getKeyCode(event);\n            if (!this.keys[keyCode]) {\n                return;\n            }\n\n            var isMeta = MediumEditor.util.isMetaCtrlKey(event),\n                isShift = !!event.shiftKey,\n                isAlt = !!event.altKey;\n\n            this.keys[keyCode].forEach(function (data) {\n                if (data.meta === isMeta &&\n                    data.shift === isShift &&\n                    (data.alt === isAlt ||\n                     undefined === data.alt)) { // TODO deprecated: remove check for undefined === data.alt when jumping to 6.0.0\n                    event.preventDefault();\n                    event.stopPropagation();\n\n                    // command can be a function to execute\n                    if (typeof data.command === 'function') {\n                        data.command.apply(this);\n                    }\n                    // command can be false so the shortcut is just disabled\n                    else if (false !== data.command) {\n                        this.execAction(data.command);\n                    }\n                }\n            }, this);\n        }\n    });\n\n    MediumEditor.extensions.keyboardCommands = KeyboardCommands;\n}());\n\n(function () {\n    'use strict';\n\n    var FontNameForm = MediumEditor.extensions.form.extend({\n\n        name: 'fontname',\n        action: 'fontName',\n        aria: 'change font name',\n        contentDefault: '&#xB1;', // \n        contentFA: '<i class=\"fa fa-font\"></i>',\n\n        fonts: ['', 'Arial', 'Verdana', 'Times New Roman'],\n\n        init: function () {\n            MediumEditor.extensions.form.prototype.init.apply(this, arguments);\n        },\n\n        // Called when the button the toolbar is clicked\n        // Overrides ButtonExtension.handleClick\n        handleClick: function (event) {\n            event.preventDefault();\n            event.stopPropagation();\n\n            if (!this.isDisplayed()) {\n                // Get FontName of current selection (convert to string since IE returns this as number)\n                var fontName = this.document.queryCommandValue('fontName') + '';\n                this.showForm(fontName);\n            }\n\n            return false;\n        },\n\n        // Called by medium-editor to append form to the toolbar\n        getForm: function () {\n            if (!this.form) {\n                this.form = this.createForm();\n            }\n            return this.form;\n        },\n\n        // Used by medium-editor when the default toolbar is to be displayed\n        isDisplayed: function () {\n            return this.getForm().style.display === 'block';\n        },\n\n        hideForm: function () {\n            this.getForm().style.display = 'none';\n            this.getSelect().value = '';\n        },\n\n        showForm: function (fontName) {\n            var select = this.getSelect();\n\n            this.base.saveSelection();\n            this.hideToolbarDefaultActions();\n            this.getForm().style.display = 'block';\n            this.setToolbarPosition();\n\n            select.value = fontName || '';\n            select.focus();\n        },\n\n        // Called by core when tearing down medium-editor (destroy)\n        destroy: function () {\n            if (!this.form) {\n                return false;\n            }\n\n            if (this.form.parentNode) {\n                this.form.parentNode.removeChild(this.form);\n            }\n\n            delete this.form;\n        },\n\n        // core methods\n\n        doFormSave: function () {\n            this.base.restoreSelection();\n            this.base.checkSelection();\n        },\n\n        doFormCancel: function () {\n            this.base.restoreSelection();\n            this.clearFontName();\n            this.base.checkSelection();\n        },\n\n        // form creation and event handling\n        createForm: function () {\n            var this$1 = this;\n\n            var doc = this.document,\n                form = doc.createElement('div'),\n                select = doc.createElement('select'),\n                close = doc.createElement('a'),\n                save = doc.createElement('a'),\n                option;\n\n            // Font Name Form (div)\n            form.className = 'medium-editor-toolbar-form';\n            form.id = 'medium-editor-toolbar-form-fontname-' + this.getEditorId();\n\n            // Handle clicks on the form itself\n            this.on(form, 'click', this.handleFormClick.bind(this));\n\n            // Add font names\n            for (var i = 0; i<this.fonts.length; i++) {\n                option = doc.createElement('option');\n                option.innerHTML = this$1.fonts[i];\n                option.value = this$1.fonts[i];\n                select.appendChild(option);\n            }\n\n            select.className = 'medium-editor-toolbar-select';\n            form.appendChild(select);\n\n            // Handle typing in the textbox\n            this.on(select, 'change', this.handleFontChange.bind(this));\n\n            // Add save buton\n            save.setAttribute('href', '#');\n            save.className = 'medium-editor-toobar-save';\n            save.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?\n                             '<i class=\"fa fa-check\"></i>' :\n                             '&#10003;';\n            form.appendChild(save);\n\n            // Handle save button clicks (capture)\n            this.on(save, 'click', this.handleSaveClick.bind(this), true);\n\n            // Add close button\n            close.setAttribute('href', '#');\n            close.className = 'medium-editor-toobar-close';\n            close.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?\n                              '<i class=\"fa fa-times\"></i>' :\n                              '&times;';\n            form.appendChild(close);\n\n            // Handle close button clicks\n            this.on(close, 'click', this.handleCloseClick.bind(this));\n\n            return form;\n        },\n\n        getSelect: function () {\n            return this.getForm().querySelector('select.medium-editor-toolbar-select');\n        },\n\n        clearFontName: function () {\n            MediumEditor.selection.getSelectedElements(this.document).forEach(function (el) {\n                if (el.nodeName.toLowerCase() === 'font' && el.hasAttribute('face')) {\n                    el.removeAttribute('face');\n                }\n            });\n        },\n\n        handleFontChange: function () {\n            var font = this.getSelect().value;\n            if (font === '') {\n                this.clearFontName();\n            } else {\n                this.execAction('fontName', { value: font });\n            }\n        },\n\n        handleFormClick: function (event) {\n            // make sure not to hide form when clicking inside the form\n            event.stopPropagation();\n        },\n\n        handleSaveClick: function (event) {\n            // Clicking Save -> create the font size\n            event.preventDefault();\n            this.doFormSave();\n        },\n\n        handleCloseClick: function (event) {\n            // Click Close -> close the form\n            event.preventDefault();\n            this.doFormCancel();\n        }\n    });\n\n    MediumEditor.extensions.fontName = FontNameForm;\n}());\n\n(function () {\n    'use strict';\n\n    var FontSizeForm = MediumEditor.extensions.form.extend({\n\n        name: 'fontsize',\n        action: 'fontSize',\n        aria: 'increase/decrease font size',\n        contentDefault: '&#xB1;', // \n        contentFA: '<i class=\"fa fa-text-height\"></i>',\n\n        init: function () {\n            MediumEditor.extensions.form.prototype.init.apply(this, arguments);\n        },\n\n        // Called when the button the toolbar is clicked\n        // Overrides ButtonExtension.handleClick\n        handleClick: function (event) {\n            event.preventDefault();\n            event.stopPropagation();\n\n            if (!this.isDisplayed()) {\n                // Get fontsize of current selection (convert to string since IE returns this as number)\n                var fontSize = this.document.queryCommandValue('fontSize') + '';\n                this.showForm(fontSize);\n            }\n\n            return false;\n        },\n\n        // Called by medium-editor to append form to the toolbar\n        getForm: function () {\n            if (!this.form) {\n                this.form = this.createForm();\n            }\n            return this.form;\n        },\n\n        // Used by medium-editor when the default toolbar is to be displayed\n        isDisplayed: function () {\n            return this.getForm().style.display === 'block';\n        },\n\n        hideForm: function () {\n            this.getForm().style.display = 'none';\n            this.getInput().value = '';\n        },\n\n        showForm: function (fontSize) {\n            var input = this.getInput();\n\n            this.base.saveSelection();\n            this.hideToolbarDefaultActions();\n            this.getForm().style.display = 'block';\n            this.setToolbarPosition();\n\n            input.value = fontSize || '';\n            input.focus();\n        },\n\n        // Called by core when tearing down medium-editor (destroy)\n        destroy: function () {\n            if (!this.form) {\n                return false;\n            }\n\n            if (this.form.parentNode) {\n                this.form.parentNode.removeChild(this.form);\n            }\n\n            delete this.form;\n        },\n\n        // core methods\n\n        doFormSave: function () {\n            this.base.restoreSelection();\n            this.base.checkSelection();\n        },\n\n        doFormCancel: function () {\n            this.base.restoreSelection();\n            this.clearFontSize();\n            this.base.checkSelection();\n        },\n\n        // form creation and event handling\n        createForm: function () {\n            var doc = this.document,\n                form = doc.createElement('div'),\n                input = doc.createElement('input'),\n                close = doc.createElement('a'),\n                save = doc.createElement('a');\n\n            // Font Size Form (div)\n            form.className = 'medium-editor-toolbar-form';\n            form.id = 'medium-editor-toolbar-form-fontsize-' + this.getEditorId();\n\n            // Handle clicks on the form itself\n            this.on(form, 'click', this.handleFormClick.bind(this));\n\n            // Add font size slider\n            input.setAttribute('type', 'range');\n            input.setAttribute('min', '1');\n            input.setAttribute('max', '7');\n            input.className = 'medium-editor-toolbar-input';\n            form.appendChild(input);\n\n            // Handle typing in the textbox\n            this.on(input, 'change', this.handleSliderChange.bind(this));\n\n            // Add save buton\n            save.setAttribute('href', '#');\n            save.className = 'medium-editor-toobar-save';\n            save.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?\n                             '<i class=\"fa fa-check\"></i>' :\n                             '&#10003;';\n            form.appendChild(save);\n\n            // Handle save button clicks (capture)\n            this.on(save, 'click', this.handleSaveClick.bind(this), true);\n\n            // Add close button\n            close.setAttribute('href', '#');\n            close.className = 'medium-editor-toobar-close';\n            close.innerHTML = this.getEditorOption('buttonLabels') === 'fontawesome' ?\n                              '<i class=\"fa fa-times\"></i>' :\n                              '&times;';\n            form.appendChild(close);\n\n            // Handle close button clicks\n            this.on(close, 'click', this.handleCloseClick.bind(this));\n\n            return form;\n        },\n\n        getInput: function () {\n            return this.getForm().querySelector('input.medium-editor-toolbar-input');\n        },\n\n        clearFontSize: function () {\n            MediumEditor.selection.getSelectedElements(this.document).forEach(function (el) {\n                if (el.nodeName.toLowerCase() === 'font' && el.hasAttribute('size')) {\n                    el.removeAttribute('size');\n                }\n            });\n        },\n\n        handleSliderChange: function () {\n            var size = this.getInput().value;\n            if (size === '4') {\n                this.clearFontSize();\n            } else {\n                this.execAction('fontSize', { value: size });\n            }\n        },\n\n        handleFormClick: function (event) {\n            // make sure not to hide form when clicking inside the form\n            event.stopPropagation();\n        },\n\n        handleSaveClick: function (event) {\n            // Clicking Save -> create the font size\n            event.preventDefault();\n            this.doFormSave();\n        },\n\n        handleCloseClick: function (event) {\n            // Click Close -> close the form\n            event.preventDefault();\n            this.doFormCancel();\n        }\n    });\n\n    MediumEditor.extensions.fontSize = FontSizeForm;\n}());\n(function () {\n    'use strict';\n\n    /* Helpers and internal variables that don't need to be members of actual paste handler */\n\n    var pasteBinDefaultContent = '%ME_PASTEBIN%',\n        lastRange = null,\n        keyboardPasteEditable = null,\n        stopProp = function (event) {\n            event.stopPropagation();\n        };\n\n    /*jslint regexp: true*/\n    /*\n        jslint does not allow character negation, because the negation\n        will not match any unicode characters. In the regexes in this\n        block, negation is used specifically to match the end of an html\n        tag, and in fact unicode characters *should* be allowed.\n    */\n    function createReplacements() {\n        return [\n            // Remove anything but the contents within the BODY element\n            [new RegExp(/^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/g), ''],\n\n            // cleanup comments added by Chrome when pasting html\n            [new RegExp(/<!--StartFragment-->|<!--EndFragment-->/g), ''],\n\n            // Trailing BR elements\n            [new RegExp(/<br>$/i), ''],\n\n            // replace two bogus tags that begin pastes from google docs\n            [new RegExp(/<[^>]*docs-internal-guid[^>]*>/gi), ''],\n            [new RegExp(/<\\/b>(<br[^>]*>)?$/gi), ''],\n\n             // un-html spaces and newlines inserted by OS X\n            [new RegExp(/<span class=\"Apple-converted-space\">\\s+<\\/span>/g), ' '],\n            [new RegExp(/<br class=\"Apple-interchange-newline\">/g), '<br>'],\n\n            // replace google docs italics+bold with a span to be replaced once the html is inserted\n            [new RegExp(/<span[^>]*(font-style:italic;font-weight:bold|font-weight:bold;font-style:italic)[^>]*>/gi), '<span class=\"replace-with italic bold\">'],\n\n            // replace google docs italics with a span to be replaced once the html is inserted\n            [new RegExp(/<span[^>]*font-style:italic[^>]*>/gi), '<span class=\"replace-with italic\">'],\n\n            //[replace google docs bolds with a span to be replaced once the html is inserted\n            [new RegExp(/<span[^>]*font-weight:bold[^>]*>/gi), '<span class=\"replace-with bold\">'],\n\n             // replace manually entered b/i/a tags with real ones\n            [new RegExp(/&lt;(\\/?)(i|b|a)&gt;/gi), '<$1$2>'],\n\n             // replace manually a tags with real ones, converting smart-quotes from google docs\n            [new RegExp(/&lt;a(?:(?!href).)+href=(?:&quot;|&rdquo;|&ldquo;|\"||)(((?!&quot;|&rdquo;|&ldquo;|\"||).)*)(?:&quot;|&rdquo;|&ldquo;|\"||)(?:(?!&gt;).)*&gt;/gi), '<a href=\"$1\">'],\n\n            // Newlines between paragraphs in html have no syntactic value,\n            // but then have a tendency to accidentally become additional paragraphs down the line\n            [new RegExp(/<\\/p>\\n+/gi), '</p>'],\n            [new RegExp(/\\n+<p/gi), '<p'],\n\n            // Microsoft Word makes these odd tags, like <o:p></o:p>\n            [new RegExp(/<\\/?o:[a-z]*>/gi), ''],\n\n            // Microsoft Word adds some special elements around list items\n            [new RegExp(/<!\\[if !supportLists\\]>(((?!<!).)*)<!\\[endif]\\>/gi), '$1']\n        ];\n    }\n    /*jslint regexp: false*/\n\n    /**\n     * Gets various content types out of the Clipboard API. It will also get the\n     * plain text using older IE and WebKit API.\n     *\n     * @param {event} event Event fired on paste.\n     * @param {win} reference to window\n     * @param {doc} reference to document\n     * @return {Object} Object with mime types and data for those mime types.\n     */\n    function getClipboardContent(event, win, doc) {\n        var dataTransfer = event.clipboardData || win.clipboardData || doc.dataTransfer,\n            data = {};\n\n        if (!dataTransfer) {\n            return data;\n        }\n\n        // Use old WebKit/IE API\n        if (dataTransfer.getData) {\n            var legacyText = dataTransfer.getData('Text');\n            if (legacyText && legacyText.length > 0) {\n                data['text/plain'] = legacyText;\n            }\n        }\n\n        if (dataTransfer.types) {\n            for (var i = 0; i < dataTransfer.types.length; i++) {\n                var contentType = dataTransfer.types[i];\n                data[contentType] = dataTransfer.getData(contentType);\n            }\n        }\n\n        return data;\n    }\n\n    var PasteHandler = MediumEditor.Extension.extend({\n        /* Paste Options */\n\n        /* forcePlainText: [boolean]\n         * Forces pasting as plain text.\n         */\n        forcePlainText: true,\n\n        /* cleanPastedHTML: [boolean]\n         * cleans pasted content from different sources, like google docs etc.\n         */\n        cleanPastedHTML: false,\n\n        /* preCleanReplacements: [Array]\n         * custom pairs (2 element arrays) of RegExp and replacement text to use during past when\n         * __forcePlainText__ or __cleanPastedHTML__ are `true` OR when calling `cleanPaste(text)` helper method.\n         * These replacements are executed before any medium editor defined replacements.\n         */\n        preCleanReplacements: [],\n\n        /* cleanReplacements: [Array]\n         * custom pairs (2 element arrays) of RegExp and replacement text to use during paste when\n         * __forcePlainText__ or __cleanPastedHTML__ are `true` OR when calling `cleanPaste(text)` helper method.\n         * These replacements are executed after any medium editor defined replacements.\n         */\n        cleanReplacements: [],\n\n        /* cleanAttrs:: [Array]\n         * list of element attributes to remove during paste when __cleanPastedHTML__ is `true` or when\n         * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.\n         */\n        cleanAttrs: ['class', 'style', 'dir'],\n\n        /* cleanTags: [Array]\n         * list of element tag names to remove during paste when __cleanPastedHTML__ is `true` or when\n         * calling `cleanPaste(text)` or `pasteHTML(html, options)` helper methods.\n         */\n        cleanTags: ['meta'],\n\n        init: function () {\n            MediumEditor.Extension.prototype.init.apply(this, arguments);\n\n            if (this.forcePlainText || this.cleanPastedHTML) {\n                this.subscribe('editableKeydown', this.handleKeydown.bind(this));\n                // We need access to the full event data in paste\n                // so we can't use the editablePaste event here\n                this.getEditorElements().forEach(function (element) {\n                    this.on(element, 'paste', this.handlePaste.bind(this));\n                }, this);\n                this.subscribe('addElement', this.handleAddElement.bind(this));\n            }\n        },\n\n        handleAddElement: function (event, editable) {\n            this.on(editable, 'paste', this.handlePaste.bind(this));\n        },\n\n        destroy: function () {\n            // Make sure pastebin is destroyed in case it's still around for some reason\n            if (this.forcePlainText || this.cleanPastedHTML) {\n                this.removePasteBin();\n            }\n        },\n\n        handlePaste: function (event, editable) {\n            if (event.defaultPrevented) {\n                return;\n            }\n\n            var clipboardContent = getClipboardContent(event, this.window, this.document),\n                pastedHTML = clipboardContent['text/html'],\n                pastedPlain = clipboardContent['text/plain'];\n\n            if (this.window.clipboardData && event.clipboardData === undefined && !pastedHTML) {\n                // If window.clipboardData exists, but event.clipboardData doesn't exist,\n                // we're probably in IE. IE only has two possibilities for clipboard\n                // data format: 'Text' and 'URL'.\n                //\n                // For IE, we'll fallback to 'Text' for text/html\n                pastedHTML = pastedPlain;\n            }\n\n            if (pastedHTML || pastedPlain) {\n                event.preventDefault();\n\n                this.doPaste(pastedHTML, pastedPlain, editable);\n            }\n        },\n\n        doPaste: function (pastedHTML, pastedPlain, editable) {\n            var paragraphs,\n                html = '',\n                p;\n\n            if (this.cleanPastedHTML && pastedHTML) {\n                return this.cleanPaste(pastedHTML);\n            }\n\n            if (!(this.getEditorOption('disableReturn') || (editable && editable.getAttribute('data-disable-return')))) {\n                paragraphs = pastedPlain.split(/[\\r\\n]+/g);\n                // If there are no \\r\\n in data, don't wrap in <p>\n                if (paragraphs.length > 1) {\n                    for (p = 0; p < paragraphs.length; p += 1) {\n                        if (paragraphs[p] !== '') {\n                            html += '<p>' + MediumEditor.util.htmlEntities(paragraphs[p]) + '</p>';\n                        }\n                    }\n                } else {\n                    html = MediumEditor.util.htmlEntities(paragraphs[0]);\n                }\n            } else {\n                html = MediumEditor.util.htmlEntities(pastedPlain);\n            }\n            MediumEditor.util.insertHTMLCommand(this.document, html);\n        },\n\n        handlePasteBinPaste: function (event) {\n            if (event.defaultPrevented) {\n                this.removePasteBin();\n                return;\n            }\n\n            var clipboardContent = getClipboardContent(event, this.window, this.document),\n                pastedHTML = clipboardContent['text/html'],\n                pastedPlain = clipboardContent['text/plain'],\n                editable = keyboardPasteEditable;\n\n            // If we have valid html already, or we're not in cleanPastedHTML mode\n            // we can ignore the paste bin and just paste now\n            if (!this.cleanPastedHTML || pastedHTML) {\n                event.preventDefault();\n                this.removePasteBin();\n                this.doPaste(pastedHTML, pastedPlain, editable);\n\n                // The event handling code listens for paste on the editable element\n                // in order to trigger the editablePaste event.  Since this paste event\n                // is happening on the pastebin, the event handling code never knows about it\n                // So, we have to trigger editablePaste manually\n                this.trigger('editablePaste', { currentTarget: editable, target: editable }, editable);\n                return;\n            }\n\n            // We need to look at the paste bin, so do a setTimeout to let the paste\n            // fall through into the paste bin\n            setTimeout(function () {\n                // Only look for HTML if we're in cleanPastedHTML mode\n                if (this.cleanPastedHTML) {\n                    // If clipboard didn't have HTML, try the paste bin\n                    pastedHTML = this.getPasteBinHtml();\n                }\n\n                // If we needed the paste bin, we're done with it now, remove it\n                this.removePasteBin();\n\n                // Handle the paste with the html from the paste bin\n                this.doPaste(pastedHTML, pastedPlain, editable);\n\n                // The event handling code listens for paste on the editable element\n                // in order to trigger the editablePaste event.  Since this paste event\n                // is happening on the pastebin, the event handling code never knows about it\n                // So, we have to trigger editablePaste manually\n                this.trigger('editablePaste', { currentTarget: editable, target: editable }, editable);\n            }.bind(this), 0);\n        },\n\n        handleKeydown: function (event, editable) {\n            // if it's not Ctrl+V, do nothing\n            if (!(MediumEditor.util.isKey(event, MediumEditor.util.keyCode.V) && MediumEditor.util.isMetaCtrlKey(event))) {\n                return;\n            }\n\n            event.stopImmediatePropagation();\n\n            this.removePasteBin();\n            this.createPasteBin(editable);\n        },\n\n        createPasteBin: function (editable) {\n            var rects,\n                range = MediumEditor.selection.getSelectionRange(this.document),\n                top = this.window.pageYOffset;\n\n            keyboardPasteEditable = editable;\n\n            if (range) {\n                rects = range.getClientRects();\n\n                // on empty line, rects is empty so we grab information from the first container of the range\n                if (rects.length) {\n                    top += rects[0].top;\n                } else {\n                    top += range.startContainer.getBoundingClientRect().top;\n                }\n            }\n\n            lastRange = range;\n\n            var pasteBinElm = this.document.createElement('div');\n            pasteBinElm.id = this.pasteBinId = 'medium-editor-pastebin-' + (+Date.now());\n            pasteBinElm.setAttribute('style', 'border: 1px red solid; position: absolute; top: ' + top + 'px; width: 10px; height: 10px; overflow: hidden; opacity: 0');\n            pasteBinElm.setAttribute('contentEditable', true);\n            pasteBinElm.innerHTML = pasteBinDefaultContent;\n\n            this.document.body.appendChild(pasteBinElm);\n\n            // avoid .focus() to stop other event (actually the paste event)\n            this.on(pasteBinElm, 'focus', stopProp);\n            this.on(pasteBinElm, 'focusin', stopProp);\n            this.on(pasteBinElm, 'focusout', stopProp);\n\n            pasteBinElm.focus();\n\n            MediumEditor.selection.selectNode(pasteBinElm, this.document);\n\n            if (!this.boundHandlePaste) {\n                this.boundHandlePaste = this.handlePasteBinPaste.bind(this);\n            }\n\n            this.on(pasteBinElm, 'paste', this.boundHandlePaste);\n        },\n\n        removePasteBin: function () {\n            if (null !== lastRange) {\n                MediumEditor.selection.selectRange(this.document, lastRange);\n                lastRange = null;\n            }\n\n            if (null !== keyboardPasteEditable) {\n                keyboardPasteEditable = null;\n            }\n\n            var pasteBinElm = this.getPasteBin();\n            if (!pasteBinElm) {\n                return;\n            }\n\n            if (pasteBinElm) {\n                this.off(pasteBinElm, 'focus', stopProp);\n                this.off(pasteBinElm, 'focusin', stopProp);\n                this.off(pasteBinElm, 'focusout', stopProp);\n                this.off(pasteBinElm, 'paste', this.boundHandlePaste);\n                pasteBinElm.parentElement.removeChild(pasteBinElm);\n            }\n        },\n\n        getPasteBin: function () {\n            return this.document.getElementById(this.pasteBinId);\n        },\n\n        getPasteBinHtml: function () {\n            var pasteBinElm = this.getPasteBin();\n\n            if (!pasteBinElm) {\n                return false;\n            }\n\n            // WebKit has a nice bug where it clones the paste bin if you paste from for example notepad\n            // so we need to force plain text mode in this case\n            if (pasteBinElm.firstChild && pasteBinElm.firstChild.id === 'mcepastebin') {\n                return false;\n            }\n\n            var pasteBinHtml = pasteBinElm.innerHTML;\n\n            // If paste bin is empty try using plain text mode\n            // since that is better than nothing right\n            if (!pasteBinHtml || pasteBinHtml === pasteBinDefaultContent) {\n                return false;\n            }\n\n            return pasteBinHtml;\n        },\n\n        cleanPaste: function (text) {\n            var this$1 = this;\n\n            var i, elList, tmp, workEl,\n                multiline = /<p|<br|<div/.test(text),\n                replacements = [].concat(\n                    this.preCleanReplacements || [],\n                    createReplacements(),\n                    this.cleanReplacements || []);\n\n            for (i = 0; i < replacements.length; i += 1) {\n                text = text.replace(replacements[i][0], replacements[i][1]);\n            }\n\n            if (!multiline) {\n                return this.pasteHTML(text);\n            }\n\n            // create a temporary div to cleanup block elements\n            tmp = this.document.createElement('div');\n\n            // double br's aren't converted to p tags, but we want paragraphs.\n            tmp.innerHTML = '<p>' + text.split('<br><br>').join('</p><p>') + '</p>';\n\n            // block element cleanup\n            elList = tmp.querySelectorAll('a,p,div,br');\n            for (i = 0; i < elList.length; i += 1) {\n                workEl = elList[i];\n\n                // Microsoft Word replaces some spaces with newlines.\n                // While newlines between block elements are meaningless, newlines within\n                // elements are sometimes actually spaces.\n                workEl.innerHTML = workEl.innerHTML.replace(/\\n/gi, ' ');\n\n                switch (workEl.nodeName.toLowerCase()) {\n                    case 'p':\n                    case 'div':\n                        this$1.filterCommonBlocks(workEl);\n                        break;\n                    case 'br':\n                        this$1.filterLineBreak(workEl);\n                        break;\n                }\n            }\n\n            this.pasteHTML(tmp.innerHTML);\n        },\n\n        pasteHTML: function (html, options) {\n            var this$1 = this;\n\n            options = MediumEditor.util.defaults({}, options, {\n                cleanAttrs: this.cleanAttrs,\n                cleanTags: this.cleanTags\n            });\n\n            var elList, workEl, i, fragmentBody, pasteBlock = this.document.createDocumentFragment();\n\n            pasteBlock.appendChild(this.document.createElement('body'));\n\n            fragmentBody = pasteBlock.querySelector('body');\n            fragmentBody.innerHTML = html;\n\n            this.cleanupSpans(fragmentBody);\n\n            elList = fragmentBody.querySelectorAll('*');\n            for (i = 0; i < elList.length; i += 1) {\n                workEl = elList[i];\n\n                if ('a' === workEl.nodeName.toLowerCase() && this$1.getEditorOption('targetBlank')) {\n                    MediumEditor.util.setTargetBlank(workEl);\n                }\n\n                MediumEditor.util.cleanupAttrs(workEl, options.cleanAttrs);\n                MediumEditor.util.cleanupTags(workEl, options.cleanTags);\n            }\n\n            MediumEditor.util.insertHTMLCommand(this.document, fragmentBody.innerHTML.replace(/&nbsp;/g, ' '));\n        },\n\n        // TODO (6.0): Make this an internal helper instead of member of paste handler\n        isCommonBlock: function (el) {\n            return (el && (el.nodeName.toLowerCase() === 'p' || el.nodeName.toLowerCase() === 'div'));\n        },\n\n        // TODO (6.0): Make this an internal helper instead of member of paste handler\n        filterCommonBlocks: function (el) {\n            if (/^\\s*$/.test(el.textContent) && el.parentNode) {\n                el.parentNode.removeChild(el);\n            }\n        },\n\n        // TODO (6.0): Make this an internal helper instead of member of paste handler\n        filterLineBreak: function (el) {\n            if (this.isCommonBlock(el.previousElementSibling)) {\n                // remove stray br's following common block elements\n                this.removeWithParent(el);\n            } else if (this.isCommonBlock(el.parentNode) && (el.parentNode.firstChild === el || el.parentNode.lastChild === el)) {\n                // remove br's just inside open or close tags of a div/p\n                this.removeWithParent(el);\n            } else if (el.parentNode && el.parentNode.childElementCount === 1 && el.parentNode.textContent === '') {\n                // and br's that are the only child of elements other than div/p\n                this.removeWithParent(el);\n            }\n        },\n\n        // TODO (6.0): Make this an internal helper instead of member of paste handler\n        // remove an element, including its parent, if it is the only element within its parent\n        removeWithParent: function (el) {\n            if (el && el.parentNode) {\n                if (el.parentNode.parentNode && el.parentNode.childElementCount === 1) {\n                    el.parentNode.parentNode.removeChild(el.parentNode);\n                } else {\n                    el.parentNode.removeChild(el);\n                }\n            }\n        },\n\n        // TODO (6.0): Make this an internal helper instead of member of paste handler\n        cleanupSpans: function (containerEl) {\n            var this$1 = this;\n\n            var i,\n                el,\n                newEl,\n                spans = containerEl.querySelectorAll('.replace-with'),\n                isCEF = function (el) {\n                    return (el && el.nodeName !== '#text' && el.getAttribute('contenteditable') === 'false');\n                };\n\n            for (i = 0; i < spans.length; i += 1) {\n                el = spans[i];\n                newEl = this$1.document.createElement(el.classList.contains('bold') ? 'b' : 'i');\n\n                if (el.classList.contains('bold') && el.classList.contains('italic')) {\n                    // add an i tag as well if this has both italics and bold\n                    newEl.innerHTML = '<i>' + el.innerHTML + '</i>';\n                } else {\n                    newEl.innerHTML = el.innerHTML;\n                }\n                el.parentNode.replaceChild(newEl, el);\n            }\n\n            spans = containerEl.querySelectorAll('span');\n            for (i = 0; i < spans.length; i += 1) {\n                el = spans[i];\n\n                // bail if span is in contenteditable = false\n                if (MediumEditor.util.traverseUp(el, isCEF)) {\n                    return false;\n                }\n\n                // remove empty spans, replace others with their contents\n                MediumEditor.util.unwrap(el, this$1.document);\n            }\n        }\n    });\n\n    MediumEditor.extensions.paste = PasteHandler;\n}());\n\n(function () {\n    'use strict';\n\n    var Placeholder = MediumEditor.Extension.extend({\n        name: 'placeholder',\n\n        /* Placeholder Options */\n\n        /* text: [string]\n         * Text to display in the placeholder\n         */\n        text: 'Type your text',\n\n        /* hideOnClick: [boolean]\n         * Should we hide the placeholder on click (true) or when user starts typing (false)\n         */\n        hideOnClick: true,\n\n        init: function () {\n            MediumEditor.Extension.prototype.init.apply(this, arguments);\n\n            this.initPlaceholders();\n            this.attachEventHandlers();\n        },\n\n        initPlaceholders: function () {\n            this.getEditorElements().forEach(this.initElement, this);\n        },\n\n        handleAddElement: function (event, editable) {\n            this.initElement(editable);\n        },\n\n        initElement: function (el) {\n            if (!el.getAttribute('data-placeholder')) {\n                el.setAttribute('data-placeholder', this.text);\n            }\n            this.updatePlaceholder(el);\n        },\n\n        destroy: function () {\n            this.getEditorElements().forEach(this.cleanupElement, this);\n        },\n\n        handleRemoveElement: function (event, editable) {\n            this.cleanupElement(editable);\n        },\n\n        cleanupElement: function (el) {\n            if (el.getAttribute('data-placeholder') === this.text) {\n                el.removeAttribute('data-placeholder');\n            }\n        },\n\n        showPlaceholder: function (el) {\n            if (el) {\n                // https://github.com/yabwe/medium-editor/issues/234\n                // In firefox, styling the placeholder with an absolutely positioned\n                // pseudo element causes the cursor to appear in a bad location\n                // when the element is completely empty, so apply a different class to\n                // style it with a relatively positioned pseudo element\n                if (MediumEditor.util.isFF && el.childNodes.length === 0) {\n                    el.classList.add('medium-editor-placeholder-relative');\n                    el.classList.remove('medium-editor-placeholder');\n                } else {\n                    el.classList.add('medium-editor-placeholder');\n                    el.classList.remove('medium-editor-placeholder-relative');\n                }\n            }\n        },\n\n        hidePlaceholder: function (el) {\n            if (el) {\n                el.classList.remove('medium-editor-placeholder');\n                el.classList.remove('medium-editor-placeholder-relative');\n            }\n        },\n\n        updatePlaceholder: function (el, dontShow) {\n            // If the element has content, hide the placeholder\n            if (el.querySelector('img, blockquote, ul, ol, table') || (el.textContent.replace(/^\\s+|\\s+$/g, '') !== '')) {\n                return this.hidePlaceholder(el);\n            }\n\n            if (!dontShow) {\n                this.showPlaceholder(el);\n            }\n        },\n\n        attachEventHandlers: function () {\n            if (this.hideOnClick) {\n                // For the 'hideOnClick' option, the placeholder should always be hidden on focus\n                this.subscribe('focus', this.handleFocus.bind(this));\n            }\n\n            // If the editor has content, it should always hide the placeholder\n            this.subscribe('editableInput', this.handleInput.bind(this));\n\n            // When the editor loses focus, check if the placeholder should be visible\n            this.subscribe('blur', this.handleBlur.bind(this));\n\n            // Need to know when elements are added/removed from the editor\n            this.subscribe('addElement', this.handleAddElement.bind(this));\n            this.subscribe('removeElement', this.handleRemoveElement.bind(this));\n        },\n\n        handleInput: function (event, element) {\n            // If the placeholder should be hidden on focus and the\n            // element has focus, don't show the placeholder\n            var dontShow = this.hideOnClick && (element === this.base.getFocusedElement());\n\n            // Editor's content has changed, check if the placeholder should be hidden\n            this.updatePlaceholder(element, dontShow);\n        },\n\n        handleFocus: function (event, element) {\n            // Editor has focus, hide the placeholder\n            this.hidePlaceholder(element);\n        },\n\n        handleBlur: function (event, element) {\n            // Editor has lost focus, check if the placeholder should be shown\n            this.updatePlaceholder(element);\n        }\n    });\n\n    MediumEditor.extensions.placeholder = Placeholder;\n}());\n\n(function () {\n    'use strict';\n\n    var Toolbar = MediumEditor.Extension.extend({\n        name: 'toolbar',\n\n        /* Toolbar Options */\n\n        /* align: ['left'|'center'|'right']\n         * When the __static__ option is true, this aligns the static toolbar\n         * relative to the medium-editor element.\n         */\n        align: 'center',\n\n        /* allowMultiParagraphSelection: [boolean]\n         * enables/disables whether the toolbar should be displayed when\n         * selecting multiple paragraphs/block elements\n         */\n        allowMultiParagraphSelection: true,\n\n        /* buttons: [Array]\n         * the names of the set of buttons to display on the toolbar.\n         */\n        buttons: ['bold', 'italic', 'underline', 'anchor', 'h2', 'h3', 'quote'],\n\n        /* diffLeft: [Number]\n         * value in pixels to be added to the X axis positioning of the toolbar.\n         */\n        diffLeft: 0,\n\n        /* diffTop: [Number]\n         * value in pixels to be added to the Y axis positioning of the toolbar.\n         */\n        diffTop: -10,\n\n        /* firstButtonClass: [string]\n         * CSS class added to the first button in the toolbar.\n         */\n        firstButtonClass: 'medium-editor-button-first',\n\n        /* lastButtonClass: [string]\n         * CSS class added to the last button in the toolbar.\n         */\n        lastButtonClass: 'medium-editor-button-last',\n\n        /* standardizeSelectionStart: [boolean]\n         * enables/disables standardizing how the beginning of a range is decided\n         * between browsers whenever the selected text is analyzed for updating toolbar buttons status.\n         */\n        standardizeSelectionStart: false,\n\n        /* static: [boolean]\n         * enable/disable the toolbar always displaying in the same location\n         * relative to the medium-editor element.\n         */\n        static: false,\n\n        /* sticky: [boolean]\n         * When the __static__ option is true, this enables/disables the toolbar\n         * \"sticking\" to the viewport and staying visible on the screen while\n         * the page scrolls.\n         */\n        sticky: false,\n\n        /* stickyTopOffset: [Number]\n         * Value in pixel of the top offset above the toolbar\n         */\n        stickyTopOffset: 0,\n\n        /* updateOnEmptySelection: [boolean]\n         * When the __static__ option is true, this enables/disables updating\n         * the state of the toolbar buttons even when the selection is collapsed\n         * (there is no selection, just a cursor).\n         */\n        updateOnEmptySelection: false,\n\n        /* relativeContainer: [node]\n         * appending the toolbar to a given node instead of body\n         */\n        relativeContainer: null,\n\n        init: function () {\n            MediumEditor.Extension.prototype.init.apply(this, arguments);\n\n            this.initThrottledMethods();\n\n            if (!this.relativeContainer) {\n                this.getEditorOption('elementsContainer').appendChild(this.getToolbarElement());\n            } else {\n                this.relativeContainer.appendChild(this.getToolbarElement());\n            }\n        },\n\n        // Helper method to execute method for every extension, but ignoring the toolbar extension\n        forEachExtension: function (iterator, context) {\n            return this.base.extensions.forEach(function (command) {\n                if (command === this) {\n                    return;\n                }\n                return iterator.apply(context || this, arguments);\n            }, this);\n        },\n\n        // Toolbar creation/deletion\n\n        createToolbar: function () {\n            var toolbar = this.document.createElement('div');\n\n            toolbar.id = 'medium-editor-toolbar-' + this.getEditorId();\n            toolbar.className = 'medium-editor-toolbar';\n\n            if (this.static) {\n                toolbar.className += ' static-toolbar';\n            } else if (this.relativeContainer) {\n                toolbar.className += ' medium-editor-relative-toolbar';\n            } else {\n                toolbar.className += ' medium-editor-stalker-toolbar';\n            }\n\n            toolbar.appendChild(this.createToolbarButtons());\n\n            // Add any forms that extensions may have\n            this.forEachExtension(function (extension) {\n                if (extension.hasForm) {\n                    toolbar.appendChild(extension.getForm());\n                }\n            });\n\n            this.attachEventHandlers();\n\n            return toolbar;\n        },\n\n        createToolbarButtons: function () {\n            var ul = this.document.createElement('ul'),\n                li,\n                btn,\n                buttons,\n                extension,\n                buttonName,\n                buttonOpts;\n\n            ul.id = 'medium-editor-toolbar-actions' + this.getEditorId();\n            ul.className = 'medium-editor-toolbar-actions';\n            ul.style.display = 'block';\n\n            this.buttons.forEach(function (button) {\n                if (typeof button === 'string') {\n                    buttonName = button;\n                    buttonOpts = null;\n                } else {\n                    buttonName = button.name;\n                    buttonOpts = button;\n                }\n\n                // If the button already exists as an extension, it'll be returned\n                // othwerise it'll create the default built-in button\n                extension = this.base.addBuiltInExtension(buttonName, buttonOpts);\n\n                if (extension && typeof extension.getButton === 'function') {\n                    btn = extension.getButton(this.base);\n                    li = this.document.createElement('li');\n                    if (MediumEditor.util.isElement(btn)) {\n                        li.appendChild(btn);\n                    } else {\n                        li.innerHTML = btn;\n                    }\n                    ul.appendChild(li);\n                }\n            }, this);\n\n            buttons = ul.querySelectorAll('button');\n            if (buttons.length > 0) {\n                buttons[0].classList.add(this.firstButtonClass);\n                buttons[buttons.length - 1].classList.add(this.lastButtonClass);\n            }\n\n            return ul;\n        },\n\n        destroy: function () {\n            if (this.toolbar) {\n                if (this.toolbar.parentNode) {\n                    this.toolbar.parentNode.removeChild(this.toolbar);\n                }\n                delete this.toolbar;\n            }\n        },\n\n        // Toolbar accessors\n\n        getInteractionElements: function () {\n            return this.getToolbarElement();\n        },\n\n        getToolbarElement: function () {\n            if (!this.toolbar) {\n                this.toolbar = this.createToolbar();\n            }\n\n            return this.toolbar;\n        },\n\n        getToolbarActionsElement: function () {\n            return this.getToolbarElement().querySelector('.medium-editor-toolbar-actions');\n        },\n\n        // Toolbar event handlers\n\n        initThrottledMethods: function () {\n            // throttledPositionToolbar is throttled because:\n            // - It will be called when the browser is resizing, which can fire many times very quickly\n            // - For some event (like resize) a slight lag in UI responsiveness is OK and provides performance benefits\n            this.throttledPositionToolbar = MediumEditor.util.throttle(function () {\n                if (this.base.isActive) {\n                    this.positionToolbarIfShown();\n                }\n            }.bind(this));\n        },\n\n        attachEventHandlers: function () {\n            // MediumEditor custom events for when user beings and ends interaction with a contenteditable and its elements\n            this.subscribe('blur', this.handleBlur.bind(this));\n            this.subscribe('focus', this.handleFocus.bind(this));\n\n            // Updating the state of the toolbar as things change\n            this.subscribe('editableClick', this.handleEditableClick.bind(this));\n            this.subscribe('editableKeyup', this.handleEditableKeyup.bind(this));\n\n            // Handle mouseup on document for updating the selection in the toolbar\n            this.on(this.document.documentElement, 'mouseup', this.handleDocumentMouseup.bind(this));\n\n            // Add a scroll event for sticky toolbar\n            if (this.static && this.sticky) {\n                // On scroll (capture), re-position the toolbar\n                this.on(this.window, 'scroll', this.handleWindowScroll.bind(this), true);\n            }\n\n            // On resize, re-position the toolbar\n            this.on(this.window, 'resize', this.handleWindowResize.bind(this));\n        },\n\n        handleWindowScroll: function () {\n            this.positionToolbarIfShown();\n        },\n\n        handleWindowResize: function () {\n            this.throttledPositionToolbar();\n        },\n\n        handleDocumentMouseup: function (event) {\n            // Do not trigger checkState when mouseup fires over the toolbar\n            if (event &&\n                    event.target &&\n                    MediumEditor.util.isDescendant(this.getToolbarElement(), event.target)) {\n                return false;\n            }\n            this.checkState();\n        },\n\n        handleEditableClick: function () {\n            // Delay the call to checkState to handle bug where selection is empty\n            // immediately after clicking inside a pre-existing selection\n            setTimeout(function () {\n                this.checkState();\n            }.bind(this), 0);\n        },\n\n        handleEditableKeyup: function () {\n            this.checkState();\n        },\n\n        handleBlur: function () {\n            // Kill any previously delayed calls to hide the toolbar\n            clearTimeout(this.hideTimeout);\n\n            // Blur may fire even if we have a selection, so we want to prevent any delayed showToolbar\n            // calls from happening in this specific case\n            clearTimeout(this.delayShowTimeout);\n\n            // Delay the call to hideToolbar to handle bug with multiple editors on the page at once\n            this.hideTimeout = setTimeout(function () {\n                this.hideToolbar();\n            }.bind(this), 1);\n        },\n\n        handleFocus: function () {\n            this.checkState();\n        },\n\n        // Hiding/showing toolbar\n\n        isDisplayed: function () {\n            return this.getToolbarElement().classList.contains('medium-editor-toolbar-active');\n        },\n\n        showToolbar: function () {\n            clearTimeout(this.hideTimeout);\n            if (!this.isDisplayed()) {\n                this.getToolbarElement().classList.add('medium-editor-toolbar-active');\n                this.trigger('showToolbar', {}, this.base.getFocusedElement());\n            }\n        },\n\n        hideToolbar: function () {\n            if (this.isDisplayed()) {\n                this.getToolbarElement().classList.remove('medium-editor-toolbar-active');\n                this.trigger('hideToolbar', {}, this.base.getFocusedElement());\n            }\n        },\n\n        isToolbarDefaultActionsDisplayed: function () {\n            return this.getToolbarActionsElement().style.display === 'block';\n        },\n\n        hideToolbarDefaultActions: function () {\n            if (this.isToolbarDefaultActionsDisplayed()) {\n                this.getToolbarActionsElement().style.display = 'none';\n            }\n        },\n\n        showToolbarDefaultActions: function () {\n            this.hideExtensionForms();\n\n            if (!this.isToolbarDefaultActionsDisplayed()) {\n                this.getToolbarActionsElement().style.display = 'block';\n            }\n\n            // Using setTimeout + options.delay because:\n            // We will actually be displaying the toolbar, which should be controlled by options.delay\n            this.delayShowTimeout = this.base.delay(function () {\n                this.showToolbar();\n            }.bind(this));\n        },\n\n        hideExtensionForms: function () {\n            // Hide all extension forms\n            this.forEachExtension(function (extension) {\n                if (extension.hasForm && extension.isDisplayed()) {\n                    extension.hideForm();\n                }\n            });\n        },\n\n        // Responding to changes in user selection\n\n        // Checks for existance of multiple block elements in the current selection\n        multipleBlockElementsSelected: function () {\n            var regexEmptyHTMLTags = /<[^\\/>][^>]*><\\/[^>]+>/gim, // http://stackoverflow.com/questions/3129738/remove-empty-tags-using-regex\n                regexBlockElements = new RegExp('<(' + MediumEditor.util.blockContainerElementNames.join('|') + ')[^>]*>', 'g'),\n                selectionHTML = MediumEditor.selection.getSelectionHtml(this.document).replace(regexEmptyHTMLTags, ''), // Filter out empty blocks from selection\n                hasMultiParagraphs = selectionHTML.match(regexBlockElements); // Find how many block elements are within the html\n\n            return !!hasMultiParagraphs && hasMultiParagraphs.length > 1;\n        },\n\n        modifySelection: function () {\n            var selection = this.window.getSelection(),\n                selectionRange = selection.getRangeAt(0);\n\n            /*\n            * In firefox, there are cases (ie doubleclick of a word) where the selectionRange start\n            * will be at the very end of an element.  In other browsers, the selectionRange start\n            * would instead be at the very beginning of an element that actually has content.\n            * example:\n            *   <span>foo</span><span>bar</span>\n            *\n            * If the text 'bar' is selected, most browsers will have the selectionRange start at the beginning\n            * of the 'bar' span.  However, there are cases where firefox will have the selectionRange start\n            * at the end of the 'foo' span.  The contenteditable behavior will be ok, but if there are any\n            * properties on the 'bar' span, they won't be reflected accurately in the toolbar\n            * (ie 'Bold' button wouldn't be active)\n            *\n            * So, for cases where the selectionRange start is at the end of an element/node, find the next\n            * adjacent text node that actually has content in it, and move the selectionRange start there.\n            */\n            if (this.standardizeSelectionStart &&\n                    selectionRange.startContainer.nodeValue &&\n                    (selectionRange.startOffset === selectionRange.startContainer.nodeValue.length)) {\n                var adjacentNode = MediumEditor.util.findAdjacentTextNodeWithContent(MediumEditor.selection.getSelectionElement(this.window), selectionRange.startContainer, this.document);\n                if (adjacentNode) {\n                    var offset = 0;\n                    while (adjacentNode.nodeValue.substr(offset, 1).trim().length === 0) {\n                        offset = offset + 1;\n                    }\n                    selectionRange = MediumEditor.selection.select(this.document, adjacentNode, offset,\n                        selectionRange.endContainer, selectionRange.endOffset);\n                }\n            }\n        },\n\n        checkState: function () {\n            if (this.base.preventSelectionUpdates) {\n                return;\n            }\n\n            // If no editable has focus OR selection is inside contenteditable = false\n            // hide toolbar\n            if (!this.base.getFocusedElement() ||\n                    MediumEditor.selection.selectionInContentEditableFalse(this.window)) {\n                return this.hideToolbar();\n            }\n\n            // If there's no selection element, selection element doesn't belong to this editor\n            // or toolbar is disabled for this selection element\n            // hide toolbar\n            var selectionElement = MediumEditor.selection.getSelectionElement(this.window);\n            if (!selectionElement ||\n                    this.getEditorElements().indexOf(selectionElement) === -1 ||\n                    selectionElement.getAttribute('data-disable-toolbar')) {\n                return this.hideToolbar();\n            }\n\n            // Now we know there's a focused editable with a selection\n\n            // If the updateOnEmptySelection option is true, show the toolbar\n            if (this.updateOnEmptySelection && this.static) {\n                return this.showAndUpdateToolbar();\n            }\n\n            // If we don't have a 'valid' selection -> hide toolbar\n            if (!MediumEditor.selection.selectionContainsContent(this.document) ||\n                (this.allowMultiParagraphSelection === false && this.multipleBlockElementsSelected())) {\n                return this.hideToolbar();\n            }\n\n            this.showAndUpdateToolbar();\n        },\n\n        // Updating the toolbar\n\n        showAndUpdateToolbar: function () {\n            this.modifySelection();\n            this.setToolbarButtonStates();\n            this.trigger('positionToolbar', {}, this.base.getFocusedElement());\n            this.showToolbarDefaultActions();\n            this.setToolbarPosition();\n        },\n\n        setToolbarButtonStates: function () {\n            this.forEachExtension(function (extension) {\n                if (typeof extension.isActive === 'function' &&\n                    typeof extension.setInactive === 'function') {\n                    extension.setInactive();\n                }\n            });\n\n            this.checkActiveButtons();\n        },\n\n        checkActiveButtons: function () {\n            var manualStateChecks = [],\n                queryState = null,\n                selectionRange = MediumEditor.selection.getSelectionRange(this.document),\n                parentNode,\n                updateExtensionState = function (extension) {\n                    if (typeof extension.checkState === 'function') {\n                        extension.checkState(parentNode);\n                    } else if (typeof extension.isActive === 'function' &&\n                               typeof extension.isAlreadyApplied === 'function' &&\n                               typeof extension.setActive === 'function') {\n                        if (!extension.isActive() && extension.isAlreadyApplied(parentNode)) {\n                            extension.setActive();\n                        }\n                    }\n                };\n\n            if (!selectionRange) {\n                return;\n            }\n\n            // Loop through all extensions\n            this.forEachExtension(function (extension) {\n                // For those extensions where we can use document.queryCommandState(), do so\n                if (typeof extension.queryCommandState === 'function') {\n                    queryState = extension.queryCommandState();\n                    // If queryCommandState returns a valid value, we can trust the browser\n                    // and don't need to do our manual checks\n                    if (queryState !== null) {\n                        if (queryState && typeof extension.setActive === 'function') {\n                            extension.setActive();\n                        }\n                        return;\n                    }\n                }\n                // We can't use queryCommandState for this extension, so add to manualStateChecks\n                manualStateChecks.push(extension);\n            });\n\n            parentNode = MediumEditor.selection.getSelectedParentElement(selectionRange);\n\n            // Make sure the selection parent isn't outside of the contenteditable\n            if (!this.getEditorElements().some(function (element) {\n                    return MediumEditor.util.isDescendant(element, parentNode, true);\n                })) {\n                return;\n            }\n\n            // Climb up the DOM and do manual checks for whether a certain extension is currently enabled for this node\n            while (parentNode) {\n                manualStateChecks.forEach(updateExtensionState);\n\n                // we can abort the search upwards if we leave the contentEditable element\n                if (MediumEditor.util.isMediumEditorElement(parentNode)) {\n                    break;\n                }\n                parentNode = parentNode.parentNode;\n            }\n        },\n\n        // Positioning toolbar\n\n        positionToolbarIfShown: function () {\n            if (this.isDisplayed()) {\n                this.setToolbarPosition();\n            }\n        },\n\n        setToolbarPosition: function () {\n            var container = this.base.getFocusedElement(),\n                selection = this.window.getSelection();\n\n            // If there isn't a valid selection, bail\n            if (!container) {\n                return this;\n            }\n\n            if (this.static || !selection.isCollapsed) {\n                this.showToolbar();\n\n                // we don't need any absolute positioning if relativeContainer is set\n                if (!this.relativeContainer) {\n                    if (this.static) {\n                        this.positionStaticToolbar(container);\n                    } else {\n                        this.positionToolbar(selection);\n                    }\n                }\n\n                this.trigger('positionedToolbar', {}, this.base.getFocusedElement());\n            }\n        },\n\n        positionStaticToolbar: function (container) {\n            // position the toolbar at left 0, so we can get the real width of the toolbar\n            this.getToolbarElement().style.left = '0';\n\n            // document.documentElement for IE 9\n            var scrollTop = (this.document.documentElement && this.document.documentElement.scrollTop) || this.document.body.scrollTop,\n                windowWidth = this.window.innerWidth,\n                toolbarElement = this.getToolbarElement(),\n                containerRect = container.getBoundingClientRect(),\n                containerTop = containerRect.top + scrollTop,\n                containerCenter = (containerRect.left + (containerRect.width / 2)),\n                toolbarHeight = toolbarElement.offsetHeight,\n                toolbarWidth = toolbarElement.offsetWidth,\n                halfOffsetWidth = toolbarWidth / 2,\n                targetLeft;\n\n            if (this.sticky) {\n                // If it's beyond the height of the editor, position it at the bottom of the editor\n                if (scrollTop > (containerTop + container.offsetHeight - toolbarHeight - this.stickyTopOffset)) {\n                    toolbarElement.style.top = (containerTop + container.offsetHeight - toolbarHeight) + 'px';\n                    toolbarElement.classList.remove('medium-editor-sticky-toolbar');\n                // Stick the toolbar to the top of the window\n                } else if (scrollTop > (containerTop - toolbarHeight - this.stickyTopOffset)) {\n                    toolbarElement.classList.add('medium-editor-sticky-toolbar');\n                    toolbarElement.style.top = this.stickyTopOffset + 'px';\n                // Normal static toolbar position\n                } else {\n                    toolbarElement.classList.remove('medium-editor-sticky-toolbar');\n                    toolbarElement.style.top = containerTop - toolbarHeight + 'px';\n                }\n            } else {\n                toolbarElement.style.top = containerTop - toolbarHeight + 'px';\n            }\n\n            switch (this.align) {\n                case 'left':\n                    targetLeft = containerRect.left;\n                    break;\n\n                case 'right':\n                    targetLeft = containerRect.right - toolbarWidth;\n                    break;\n\n                case 'center':\n                    targetLeft = containerCenter - halfOffsetWidth;\n                    break;\n            }\n\n            if (targetLeft < 0) {\n                targetLeft = 0;\n            } else if ((targetLeft + toolbarWidth) > windowWidth) {\n                targetLeft = (windowWidth - Math.ceil(toolbarWidth) - 1);\n            }\n\n            toolbarElement.style.left = targetLeft + 'px';\n        },\n\n        positionToolbar: function (selection) {\n            // position the toolbar at left 0, so we can get the real width of the toolbar\n            this.getToolbarElement().style.left = '0';\n            this.getToolbarElement().style.right = 'initial';\n\n            var range = selection.getRangeAt(0),\n                boundary = range.getBoundingClientRect();\n\n            // Handle selections with just images\n            if (!boundary || ((boundary.height === 0 && boundary.width === 0) && range.startContainer === range.endContainer)) {\n                // If there's a nested image, use that for the bounding rectangle\n                if (range.startContainer.nodeType === 1 && range.startContainer.querySelector('img')) {\n                    boundary = range.startContainer.querySelector('img').getBoundingClientRect();\n                } else {\n                    boundary = range.startContainer.getBoundingClientRect();\n                }\n            }\n\n            var windowWidth = this.window.innerWidth,\n                middleBoundary = (boundary.left + boundary.right) / 2,\n                toolbarElement = this.getToolbarElement(),\n                toolbarHeight = toolbarElement.offsetHeight,\n                toolbarWidth = toolbarElement.offsetWidth,\n                halfOffsetWidth = toolbarWidth / 2,\n                buttonHeight = 50,\n                defaultLeft = this.diffLeft - halfOffsetWidth;\n\n            if (boundary.top < buttonHeight) {\n                toolbarElement.classList.add('medium-toolbar-arrow-over');\n                toolbarElement.classList.remove('medium-toolbar-arrow-under');\n                toolbarElement.style.top = buttonHeight + boundary.bottom - this.diffTop + this.window.pageYOffset - toolbarHeight + 'px';\n            } else {\n                toolbarElement.classList.add('medium-toolbar-arrow-under');\n                toolbarElement.classList.remove('medium-toolbar-arrow-over');\n                toolbarElement.style.top = boundary.top + this.diffTop + this.window.pageYOffset - toolbarHeight + 'px';\n            }\n\n            if (middleBoundary < halfOffsetWidth) {\n                toolbarElement.style.left = defaultLeft + halfOffsetWidth + 'px';\n                toolbarElement.style.right = 'initial';\n            } else if ((windowWidth - middleBoundary) < halfOffsetWidth) {\n                toolbarElement.style.left = 'auto';\n                toolbarElement.style.right = 0;\n            } else {\n                toolbarElement.style.left = defaultLeft + middleBoundary + 'px';\n                toolbarElement.style.right = 'initial';\n            }\n        }\n    });\n\n    MediumEditor.extensions.toolbar = Toolbar;\n}());\n\n(function () {\n    'use strict';\n\n    var ImageDragging = MediumEditor.Extension.extend({\n        init: function () {\n            MediumEditor.Extension.prototype.init.apply(this, arguments);\n\n            this.subscribe('editableDrag', this.handleDrag.bind(this));\n            this.subscribe('editableDrop', this.handleDrop.bind(this));\n        },\n\n        handleDrag: function (event) {\n            var className = 'medium-editor-dragover';\n            event.preventDefault();\n            event.dataTransfer.dropEffect = 'copy';\n\n            if (event.type === 'dragover') {\n                event.target.classList.add(className);\n            } else if (event.type === 'dragleave') {\n                event.target.classList.remove(className);\n            }\n        },\n\n        handleDrop: function (event) {\n            var className = 'medium-editor-dragover',\n                files;\n            event.preventDefault();\n            event.stopPropagation();\n\n            // IE9 does not support the File API, so prevent file from opening in a new window\n            // but also don't try to actually get the file\n            if (event.dataTransfer.files) {\n                files = Array.prototype.slice.call(event.dataTransfer.files, 0);\n                files.some(function (file) {\n                    if (file.type.match('image')) {\n                        var fileReader, id;\n                        fileReader = new FileReader();\n                        fileReader.readAsDataURL(file);\n\n                        id = 'medium-img-' + (+new Date());\n                        MediumEditor.util.insertHTMLCommand(this.document, '<img class=\"medium-editor-image-loading\" id=\"' + id + '\" />');\n\n                        fileReader.onload = function () {\n                            var img = this.document.getElementById(id);\n                            if (img) {\n                                img.removeAttribute('id');\n                                img.removeAttribute('class');\n                                img.src = fileReader.result;\n                            }\n                        }.bind(this);\n                    }\n                }.bind(this));\n            }\n            event.target.classList.remove(className);\n        }\n    });\n\n    MediumEditor.extensions.imageDragging = ImageDragging;\n}());\n\n(function () {\n    'use strict';\n\n    // Event handlers that shouldn't be exposed externally\n\n    function handleDisableExtraSpaces(event) {\n        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),\n            textContent = node.textContent,\n            caretPositions = MediumEditor.selection.getCaretOffsets(node);\n\n        if ((textContent[caretPositions.left - 1] === undefined) || (textContent[caretPositions.left - 1].trim() === '') || (textContent[caretPositions.left] !== undefined && textContent[caretPositions.left].trim() === '')) {\n            event.preventDefault();\n        }\n    }\n\n    function handleDisabledEnterKeydown(event, element) {\n        if (this.options.disableReturn || element.getAttribute('data-disable-return')) {\n            event.preventDefault();\n        } else if (this.options.disableDoubleReturn || element.getAttribute('data-disable-double-return')) {\n            var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument);\n\n            // if current text selection is empty OR previous sibling text is empty OR it is not a list\n            if ((node && node.textContent.trim() === '' && node.nodeName.toLowerCase() !== 'li') ||\n                (node.previousElementSibling && node.previousElementSibling.nodeName.toLowerCase() !== 'br' &&\n                 node.previousElementSibling.textContent.trim() === '')) {\n                event.preventDefault();\n            }\n        }\n    }\n\n    function handleTabKeydown(event) {\n        // Override tab only for pre nodes\n        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),\n            tag = node && node.nodeName.toLowerCase();\n\n        if (tag === 'pre') {\n            event.preventDefault();\n            MediumEditor.util.insertHTMLCommand(this.options.ownerDocument, '    ');\n        }\n\n        // Tab to indent list structures!\n        if (MediumEditor.util.isListItem(node)) {\n            event.preventDefault();\n\n            // If Shift is down, outdent, otherwise indent\n            if (event.shiftKey) {\n                this.options.ownerDocument.execCommand('outdent', false, null);\n            } else {\n                this.options.ownerDocument.execCommand('indent', false, null);\n            }\n        }\n    }\n\n    function handleBlockDeleteKeydowns(event) {\n        var p, node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),\n            tagName = node.nodeName.toLowerCase(),\n            isEmpty = /^(\\s+|<br\\/?>)?$/i,\n            isHeader = /h\\d/i;\n\n        if (MediumEditor.util.isKey(event, [MediumEditor.util.keyCode.BACKSPACE, MediumEditor.util.keyCode.ENTER]) &&\n                // has a preceeding sibling\n                node.previousElementSibling &&\n                // in a header\n                isHeader.test(tagName) &&\n                // at the very end of the block\n                MediumEditor.selection.getCaretOffsets(node).left === 0) {\n            if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) && isEmpty.test(node.previousElementSibling.innerHTML)) {\n                // backspacing the begining of a header into an empty previous element will\n                // change the tagName of the current node to prevent one\n                // instead delete previous node and cancel the event.\n                node.previousElementSibling.parentNode.removeChild(node.previousElementSibling);\n                event.preventDefault();\n            } else if (!this.options.disableDoubleReturn && MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER)) {\n                // hitting return in the begining of a header will create empty header elements before the current one\n                // instead, make \"<p><br></p>\" element, which are what happens if you hit return in an empty paragraph\n                p = this.options.ownerDocument.createElement('p');\n                p.innerHTML = '<br>';\n                node.previousElementSibling.parentNode.insertBefore(p, node);\n                event.preventDefault();\n            }\n        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.DELETE) &&\n                    // between two sibling elements\n                    node.nextElementSibling &&\n                    node.previousElementSibling &&\n                    // not in a header\n                    !isHeader.test(tagName) &&\n                    // in an empty tag\n                    isEmpty.test(node.innerHTML) &&\n                    // when the next tag *is* a header\n                    isHeader.test(node.nextElementSibling.nodeName.toLowerCase())) {\n            // hitting delete in an empty element preceding a header, ex:\n            //  <p>[CURSOR]</p><h1>Header</h1>\n            // Will cause the h1 to become a paragraph.\n            // Instead, delete the paragraph node and move the cursor to the begining of the h1\n\n            // remove node and move cursor to start of header\n            MediumEditor.selection.moveCursor(this.options.ownerDocument, node.nextElementSibling);\n\n            node.previousElementSibling.parentNode.removeChild(node);\n\n            event.preventDefault();\n        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) &&\n                tagName === 'li' &&\n                // hitting backspace inside an empty li\n                isEmpty.test(node.innerHTML) &&\n                // is first element (no preceeding siblings)\n                !node.previousElementSibling &&\n                // parent also does not have a sibling\n                !node.parentElement.previousElementSibling &&\n                // is not the only li in a list\n                node.nextElementSibling &&\n                node.nextElementSibling.nodeName.toLowerCase() === 'li') {\n            // backspacing in an empty first list element in the first list (with more elements) ex:\n            //  <ul><li>[CURSOR]</li><li>List Item 2</li></ul>\n            // will remove the first <li> but add some extra element before (varies based on browser)\n            // Instead, this will:\n            // 1) remove the list element\n            // 2) create a paragraph before the list\n            // 3) move the cursor into the paragraph\n\n            // create a paragraph before the list\n            p = this.options.ownerDocument.createElement('p');\n            p.innerHTML = '<br>';\n            node.parentElement.parentElement.insertBefore(p, node.parentElement);\n\n            // move the cursor into the new paragraph\n            MediumEditor.selection.moveCursor(this.options.ownerDocument, p);\n\n            // remove the list element\n            node.parentElement.removeChild(node);\n\n            event.preventDefault();\n        } else if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.BACKSPACE) &&\n                (MediumEditor.util.getClosestTag(node, 'blockquote') !== false) &&\n                MediumEditor.selection.getCaretOffsets(node).left === 0) {\n\n            // when cursor is at the begining of the element and the element is <blockquote>\n            // then pressing backspace key should change the <blockquote> to a <p> tag\n            event.preventDefault();\n            MediumEditor.util.execFormatBlock(this.options.ownerDocument, 'p');\n        }\n    }\n\n    function handleKeyup(event) {\n        var node = MediumEditor.selection.getSelectionStart(this.options.ownerDocument),\n            tagName;\n\n        if (!node) {\n            return;\n        }\n\n        // https://github.com/yabwe/medium-editor/issues/994\n        // Firefox thrown an error when calling `formatBlock` on an empty editable blockContainer that's not a <div>\n        if (MediumEditor.util.isMediumEditorElement(node) && node.children.length === 0 && !MediumEditor.util.isBlockContainer(node)) {\n            this.options.ownerDocument.execCommand('formatBlock', false, 'p');\n        }\n\n        // https://github.com/yabwe/medium-editor/issues/834\n        // https://github.com/yabwe/medium-editor/pull/382\n        // Don't call format block if this is a block element (ie h1, figCaption, etc.)\n        if (MediumEditor.util.isKey(event, MediumEditor.util.keyCode.ENTER) &&\n            !MediumEditor.util.isListItem(node) &&\n            !MediumEditor.util.isBlockContainer(node)) {\n\n            tagName = node.nodeName.toLowerCase();\n            // For anchor tags, unlink\n            if (tagName === 'a') {\n                this.options.ownerDocument.execCommand('unlink', false, null);\n            } else if (!event.shiftKey && !event.ctrlKey) {\n                this.options.ownerDocument.execCommand('formatBlock', false, 'p');\n            }\n        }\n    }\n\n    function handleEditableInput(event, editable) {\n        var textarea = editable.parentNode.querySelector('textarea[medium-editor-textarea-id=\"' + editable.getAttribute('medium-editor-textarea-id') + '\"]');\n        if (textarea) {\n            textarea.value = editable.innerHTML.trim();\n        }\n    }\n\n    // Internal helper methods which shouldn't be exposed externally\n\n    function addToEditors(win) {\n        if (!win._mediumEditors) {\n            // To avoid breaking users who are assuming that the unique id on\n            // medium-editor elements will start at 1, inserting a 'null' in the\n            // array so the unique-id can always map to the index of the editor instance\n            win._mediumEditors = [null];\n        }\n\n        // If this already has a unique id, re-use it\n        if (!this.id) {\n            this.id = win._mediumEditors.length;\n        }\n\n        win._mediumEditors[this.id] = this;\n    }\n\n    function removeFromEditors(win) {\n        if (!win._mediumEditors || !win._mediumEditors[this.id]) {\n            return;\n        }\n\n        /* Setting the instance to null in the array instead of deleting it allows:\n         * 1) Each instance to preserve its own unique-id, even after being destroyed\n         *    and initialized again\n         * 2) The unique-id to always correspond to an index in the array of medium-editor\n         *    instances. Thus, we will be able to look at a contenteditable, and determine\n         *    which instance it belongs to, by indexing into the global array.\n         */\n        win._mediumEditors[this.id] = null;\n    }\n\n    function createElementsArray(selector, doc, filterEditorElements) {\n        var elements = [];\n\n        if (!selector) {\n            selector = [];\n        }\n        // If string, use as query selector\n        if (typeof selector === 'string') {\n            selector = doc.querySelectorAll(selector);\n        }\n        // If element, put into array\n        if (MediumEditor.util.isElement(selector)) {\n            selector = [selector];\n        }\n\n        if (filterEditorElements) {\n            // Remove elements that have already been initialized by the editor\n            // selecotr might not be an array (ie NodeList) so use for loop\n            for (var i = 0; i < selector.length; i++) {\n                var el = selector[i];\n                if (MediumEditor.util.isElement(el) &&\n                    !el.getAttribute('data-medium-editor-element') &&\n                    !el.getAttribute('medium-editor-textarea-id')) {\n                    elements.push(el);\n                }\n            }\n        } else {\n            // Convert NodeList (or other array like object) into an array\n            elements = Array.prototype.slice.apply(selector);\n        }\n\n        return elements;\n    }\n\n    function cleanupTextareaElement(element) {\n        var textarea = element.parentNode.querySelector('textarea[medium-editor-textarea-id=\"' + element.getAttribute('medium-editor-textarea-id') + '\"]');\n        if (textarea) {\n            // Un-hide the textarea\n            textarea.classList.remove('medium-editor-hidden');\n            textarea.removeAttribute('medium-editor-textarea-id');\n        }\n        if (element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    }\n\n    function setExtensionDefaults(extension, defaults) {\n        Object.keys(defaults).forEach(function (prop) {\n            if (extension[prop] === undefined) {\n                extension[prop] = defaults[prop];\n            }\n        });\n        return extension;\n    }\n\n    function initExtension(extension, name, instance) {\n        var extensionDefaults = {\n            'window': instance.options.contentWindow,\n            'document': instance.options.ownerDocument,\n            'base': instance\n        };\n\n        // Add default options into the extension\n        extension = setExtensionDefaults(extension, extensionDefaults);\n\n        // Call init on the extension\n        if (typeof extension.init === 'function') {\n            extension.init();\n        }\n\n        // Set extension name (if not already set)\n        if (!extension.name) {\n            extension.name = name;\n        }\n        return extension;\n    }\n\n    function isToolbarEnabled() {\n        // If any of the elements don't have the toolbar disabled\n        // We need a toolbar\n        if (this.elements.every(function (element) {\n                return !!element.getAttribute('data-disable-toolbar');\n            })) {\n            return false;\n        }\n\n        return this.options.toolbar !== false;\n    }\n\n    function isAnchorPreviewEnabled() {\n        // If toolbar is disabled, don't add\n        if (!isToolbarEnabled.call(this)) {\n            return false;\n        }\n\n        return this.options.anchorPreview !== false;\n    }\n\n    function isPlaceholderEnabled() {\n        return this.options.placeholder !== false;\n    }\n\n    function isAutoLinkEnabled() {\n        return this.options.autoLink !== false;\n    }\n\n    function isImageDraggingEnabled() {\n        return this.options.imageDragging !== false;\n    }\n\n    function isKeyboardCommandsEnabled() {\n        return this.options.keyboardCommands !== false;\n    }\n\n    function shouldUseFileDraggingExtension() {\n        // Since the file-dragging extension replaces the image-dragging extension,\n        // we need to check if the user passed an overrided image-dragging extension.\n        // If they have, to avoid breaking users, we won't use file-dragging extension.\n        return !this.options.extensions['imageDragging'];\n    }\n\n    function createContentEditable(textarea) {\n        var div = this.options.ownerDocument.createElement('div'),\n            now = Date.now(),\n            uniqueId = 'medium-editor-' + now,\n            atts = textarea.attributes;\n\n        // Some browsers can move pretty fast, since we're using a timestamp\n        // to make a unique-id, ensure that the id is actually unique on the page\n        while (this.options.ownerDocument.getElementById(uniqueId)) {\n            now++;\n            uniqueId = 'medium-editor-' + now;\n        }\n\n        div.className = textarea.className;\n        div.id = uniqueId;\n        div.innerHTML = textarea.value;\n\n        textarea.setAttribute('medium-editor-textarea-id', uniqueId);\n\n        // re-create all attributes from the textearea to the new created div\n        for (var i = 0, n = atts.length; i < n; i++) {\n            // do not re-create existing attributes\n            if (!div.hasAttribute(atts[i].nodeName)) {\n                div.setAttribute(atts[i].nodeName, atts[i].nodeValue);\n            }\n        }\n\n        // If textarea has a form, listen for reset on the form to clear\n        // the content of the created div\n        if (textarea.form) {\n            this.on(textarea.form, 'reset', function (event) {\n                if (!event.defaultPrevented) {\n                    this.resetContent(this.options.ownerDocument.getElementById(uniqueId));\n                }\n            }.bind(this));\n        }\n\n        textarea.classList.add('medium-editor-hidden');\n        textarea.parentNode.insertBefore(\n            div,\n            textarea\n        );\n\n        return div;\n    }\n\n    function initElement(element, editorId) {\n        if (!element.getAttribute('data-medium-editor-element')) {\n            if (element.nodeName.toLowerCase() === 'textarea') {\n                element = createContentEditable.call(this, element);\n\n                // Make sure we only attach to editableInput once for <textarea> elements\n                if (!this.instanceHandleEditableInput) {\n                    this.instanceHandleEditableInput = handleEditableInput.bind(this);\n                    this.subscribe('editableInput', this.instanceHandleEditableInput);\n                }\n            }\n\n            if (!this.options.disableEditing && !element.getAttribute('data-disable-editing')) {\n                element.setAttribute('contentEditable', true);\n                element.setAttribute('spellcheck', this.options.spellcheck);\n            }\n\n            // Make sure we only attach to editableKeydownEnter once for disable-return options\n            if (!this.instanceHandleEditableKeydownEnter) {\n                if (element.getAttribute('data-disable-return') || element.getAttribute('data-disable-double-return')) {\n                    this.instanceHandleEditableKeydownEnter = handleDisabledEnterKeydown.bind(this);\n                    this.subscribe('editableKeydownEnter', this.instanceHandleEditableKeydownEnter);\n                }\n            }\n\n            // if we're not disabling return, add a handler to help handle cleanup\n            // for certain cases when enter is pressed\n            if (!this.options.disableReturn && !element.getAttribute('data-disable-return')) {\n                this.on(element, 'keyup', handleKeyup.bind(this));\n            }\n\n            var elementId = MediumEditor.util.guid();\n\n            element.setAttribute('data-medium-editor-element', true);\n            element.classList.add('medium-editor-element');\n            element.setAttribute('role', 'textbox');\n            element.setAttribute('aria-multiline', true);\n            element.setAttribute('data-medium-editor-editor-index', editorId);\n            // TODO: Merge data-medium-editor-element and medium-editor-index attributes for 6.0.0\n            // medium-editor-index is not named correctly anymore and can be re-purposed to signify\n            // whether the element has been initialized or not\n            element.setAttribute('medium-editor-index', elementId);\n            initialContent[elementId] = element.innerHTML;\n\n            this.events.attachAllEventsToElement(element);\n        }\n\n        return element;\n    }\n\n    function attachHandlers() {\n        // attach to tabs\n        this.subscribe('editableKeydownTab', handleTabKeydown.bind(this));\n\n        // Bind keys which can create or destroy a block element: backspace, delete, return\n        this.subscribe('editableKeydownDelete', handleBlockDeleteKeydowns.bind(this));\n        this.subscribe('editableKeydownEnter', handleBlockDeleteKeydowns.bind(this));\n\n        // Bind double space event\n        if (this.options.disableExtraSpaces) {\n            this.subscribe('editableKeydownSpace', handleDisableExtraSpaces.bind(this));\n        }\n\n        // Make sure we only attach to editableKeydownEnter once for disable-return options\n        if (!this.instanceHandleEditableKeydownEnter) {\n            // disabling return or double return\n            if (this.options.disableReturn || this.options.disableDoubleReturn) {\n                this.instanceHandleEditableKeydownEnter = handleDisabledEnterKeydown.bind(this);\n                this.subscribe('editableKeydownEnter', this.instanceHandleEditableKeydownEnter);\n            }\n        }\n    }\n\n    function initExtensions() {\n\n        this.extensions = [];\n\n        // Passed in extensions\n        Object.keys(this.options.extensions).forEach(function (name) {\n            // Always save the toolbar extension for last\n            if (name !== 'toolbar' && this.options.extensions[name]) {\n                this.extensions.push(initExtension(this.options.extensions[name], name, this));\n            }\n        }, this);\n\n        // 4 Cases for imageDragging + fileDragging extensons:\n        //\n        // 1. ImageDragging ON + No Custom Image Dragging Extension:\n        //    * Use fileDragging extension (default options)\n        // 2. ImageDragging OFF + No Custom Image Dragging Extension:\n        //    * Use fileDragging extension w/ images turned off\n        // 3. ImageDragging ON + Custom Image Dragging Extension:\n        //    * Don't use fileDragging (could interfere with custom image dragging extension)\n        // 4. ImageDragging OFF + Custom Image Dragging:\n        //    * Don't use fileDragging (could interfere with custom image dragging extension)\n        if (shouldUseFileDraggingExtension.call(this)) {\n            var opts = this.options.fileDragging;\n            if (!opts) {\n                opts = {};\n\n                // Image is in the 'allowedTypes' list by default.\n                // If imageDragging is off override the 'allowedTypes' list with an empty one\n                if (!isImageDraggingEnabled.call(this)) {\n                    opts.allowedTypes = [];\n                }\n            }\n            this.addBuiltInExtension('fileDragging', opts);\n        }\n\n        // Built-in extensions\n        var builtIns = {\n            paste: true,\n            'anchor-preview': isAnchorPreviewEnabled.call(this),\n            autoLink: isAutoLinkEnabled.call(this),\n            keyboardCommands: isKeyboardCommandsEnabled.call(this),\n            placeholder: isPlaceholderEnabled.call(this)\n        };\n        Object.keys(builtIns).forEach(function (name) {\n            if (builtIns[name]) {\n                this.addBuiltInExtension(name);\n            }\n        }, this);\n\n        // Users can pass in a custom toolbar extension\n        // so check for that first and if it's not present\n        // just create the default toolbar\n        var toolbarExtension = this.options.extensions['toolbar'];\n        if (!toolbarExtension && isToolbarEnabled.call(this)) {\n            // Backwards compatability\n            var toolbarOptions = MediumEditor.util.extend({}, this.options.toolbar, {\n                allowMultiParagraphSelection: this.options.allowMultiParagraphSelection // deprecated\n            });\n            toolbarExtension = new MediumEditor.extensions.toolbar(toolbarOptions);\n        }\n\n        // If the toolbar is not disabled, so we actually have an extension\n        // initialize it and add it to the extensions array\n        if (toolbarExtension) {\n            this.extensions.push(initExtension(toolbarExtension, 'toolbar', this));\n        }\n    }\n\n    function mergeOptions(defaults, options) {\n        var deprecatedProperties = [\n            ['allowMultiParagraphSelection', 'toolbar.allowMultiParagraphSelection']\n        ];\n        // warn about using deprecated properties\n        if (options) {\n            deprecatedProperties.forEach(function (pair) {\n                if (options.hasOwnProperty(pair[0]) && options[pair[0]] !== undefined) {\n                    MediumEditor.util.deprecated(pair[0], pair[1], 'v6.0.0');\n                }\n            });\n        }\n\n        return MediumEditor.util.defaults({}, options, defaults);\n    }\n\n    function execActionInternal(action, opts) {\n        /*jslint regexp: true*/\n        var appendAction = /^append-(.+)$/gi,\n            justifyAction = /justify([A-Za-z]*)$/g, /* Detecting if is justifyCenter|Right|Left */\n            match,\n            cmdValueArgument;\n        /*jslint regexp: false*/\n\n        // Actions starting with 'append-' should attempt to format a block of text ('formatBlock') using a specific\n        // type of block element (ie append-blockquote, append-h1, append-pre, etc.)\n        match = appendAction.exec(action);\n        if (match) {\n            return MediumEditor.util.execFormatBlock(this.options.ownerDocument, match[1]);\n        }\n\n        if (action === 'fontSize') {\n            // TODO: Deprecate support for opts.size in 6.0.0\n            if (opts.size) {\n                MediumEditor.util.deprecated('.size option for fontSize command', '.value', '6.0.0');\n            }\n            cmdValueArgument = opts.value || opts.size;\n            return this.options.ownerDocument.execCommand('fontSize', false, cmdValueArgument);\n        }\n\n        if (action === 'fontName') {\n            // TODO: Deprecate support for opts.name in 6.0.0\n            if (opts.name) {\n                MediumEditor.util.deprecated('.name option for fontName command', '.value', '6.0.0');\n            }\n            cmdValueArgument = opts.value || opts.name;\n            return this.options.ownerDocument.execCommand('fontName', false, cmdValueArgument);\n        }\n\n        if (action === 'createLink') {\n            return this.createLink(opts);\n        }\n\n        if (action === 'image') {\n            var src = this.options.contentWindow.getSelection().toString().trim();\n            return this.options.ownerDocument.execCommand('insertImage', false, src);\n        }\n\n        /* Issue: https://github.com/yabwe/medium-editor/issues/595\n         * If the action is to justify the text */\n        if (justifyAction.exec(action)) {\n            var result = this.options.ownerDocument.execCommand(action, false, null),\n                parentNode = MediumEditor.selection.getSelectedParentElement(MediumEditor.selection.getSelectionRange(this.options.ownerDocument));\n            if (parentNode) {\n                cleanupJustifyDivFragments.call(this, MediumEditor.util.getTopBlockContainer(parentNode));\n            }\n\n            return result;\n        }\n\n        cmdValueArgument = opts && opts.value;\n        return this.options.ownerDocument.execCommand(action, false, cmdValueArgument);\n    }\n\n    /* If we've just justified text within a container block\n     * Chrome may have removed <br> elements and instead wrapped lines in <div> elements\n     * with a text-align property.  If so, we want to fix this\n     */\n    function cleanupJustifyDivFragments(blockContainer) {\n        if (!blockContainer) {\n            return;\n        }\n\n        var textAlign,\n            childDivs = Array.prototype.slice.call(blockContainer.childNodes).filter(function (element) {\n                var isDiv = element.nodeName.toLowerCase() === 'div';\n                if (isDiv && !textAlign) {\n                    textAlign = element.style.textAlign;\n                }\n                return isDiv;\n            });\n\n        /* If we found child <div> elements with text-align style attributes\n         * we should fix this by:\n         *\n         * 1) Unwrapping each <div> which has a text-align style\n         * 2) Insert a <br> element after each set of 'unwrapped' div children\n         * 3) Set the text-align style of the parent block element\n         */\n        if (childDivs.length) {\n            // Since we're mucking with the HTML, preserve selection\n            this.saveSelection();\n            childDivs.forEach(function (div) {\n                if (div.style.textAlign === textAlign) {\n                    var lastChild = div.lastChild;\n                    if (lastChild) {\n                        // Instead of a div, extract the child elements and add a <br>\n                        MediumEditor.util.unwrap(div, this.options.ownerDocument);\n                        var br = this.options.ownerDocument.createElement('BR');\n                        lastChild.parentNode.insertBefore(br, lastChild.nextSibling);\n                    }\n                }\n            }, this);\n            blockContainer.style.textAlign = textAlign;\n            // We're done, so restore selection\n            this.restoreSelection();\n        }\n    }\n\n    var initialContent = {};\n\n    MediumEditor.prototype = {\n        // NOT DOCUMENTED - exposed for backwards compatability\n        init: function (elements, options) {\n            this.options = mergeOptions.call(this, this.defaults, options);\n            this.origElements = elements;\n\n            if (!this.options.elementsContainer) {\n                this.options.elementsContainer = this.options.ownerDocument.body;\n            }\n\n            return this.setup();\n        },\n\n        setup: function () {\n            if (this.isActive) {\n                return;\n            }\n\n            addToEditors.call(this, this.options.contentWindow);\n            this.events = new MediumEditor.Events(this);\n            this.elements = [];\n\n            this.addElements(this.origElements);\n\n            if (this.elements.length === 0) {\n                return;\n            }\n\n            this.isActive = true;\n\n            // Call initialization helpers\n            initExtensions.call(this);\n            attachHandlers.call(this);\n        },\n\n        destroy: function () {\n            if (!this.isActive) {\n                return;\n            }\n\n            this.isActive = false;\n\n            this.extensions.forEach(function (extension) {\n                if (typeof extension.destroy === 'function') {\n                    extension.destroy();\n                }\n            }, this);\n\n            this.events.destroy();\n\n            this.elements.forEach(function (element) {\n                // Reset elements content, fix for issue where after editor destroyed the red underlines on spelling errors are left\n                if (this.options.spellcheck) {\n                    element.innerHTML = element.innerHTML;\n                }\n\n                // cleanup extra added attributes\n                element.removeAttribute('contentEditable');\n                element.removeAttribute('spellcheck');\n                element.removeAttribute('data-medium-editor-element');\n                element.classList.remove('medium-editor-element');\n                element.removeAttribute('role');\n                element.removeAttribute('aria-multiline');\n                element.removeAttribute('medium-editor-index');\n                element.removeAttribute('data-medium-editor-editor-index');\n\n                // Remove any elements created for textareas\n                if (element.getAttribute('medium-editor-textarea-id')) {\n                    cleanupTextareaElement(element);\n                }\n            }, this);\n            this.elements = [];\n            this.instanceHandleEditableKeydownEnter = null;\n            this.instanceHandleEditableInput = null;\n\n            removeFromEditors.call(this, this.options.contentWindow);\n        },\n\n        on: function (target, event, listener, useCapture) {\n            this.events.attachDOMEvent(target, event, listener, useCapture);\n\n            return this;\n        },\n\n        off: function (target, event, listener, useCapture) {\n            this.events.detachDOMEvent(target, event, listener, useCapture);\n\n            return this;\n        },\n\n        subscribe: function (event, listener) {\n            this.events.attachCustomEvent(event, listener);\n\n            return this;\n        },\n\n        unsubscribe: function (event, listener) {\n            this.events.detachCustomEvent(event, listener);\n\n            return this;\n        },\n\n        trigger: function (name, data, editable) {\n            this.events.triggerCustomEvent(name, data, editable);\n\n            return this;\n        },\n\n        delay: function (fn) {\n            var self = this;\n            return setTimeout(function () {\n                if (self.isActive) {\n                    fn();\n                }\n            }, this.options.delay);\n        },\n\n        serialize: function () {\n            var this$1 = this;\n\n            var i,\n                elementid,\n                content = {},\n                len = this.elements.length;\n\n            for (i = 0; i < len; i += 1) {\n                elementid = (this$1.elements[i].id !== '') ? this$1.elements[i].id : 'element-' + i;\n                content[elementid] = {\n                    value: this$1.elements[i].innerHTML.trim()\n                };\n            }\n            return content;\n        },\n\n        getExtensionByName: function (name) {\n            var extension;\n            if (this.extensions && this.extensions.length) {\n                this.extensions.some(function (ext) {\n                    if (ext.name === name) {\n                        extension = ext;\n                        return true;\n                    }\n                    return false;\n                });\n            }\n            return extension;\n        },\n\n        /**\n         * NOT DOCUMENTED - exposed as a helper for other extensions to use\n         */\n        addBuiltInExtension: function (name, opts) {\n            var extension = this.getExtensionByName(name),\n                merged;\n            if (extension) {\n                return extension;\n            }\n\n            switch (name) {\n                case 'anchor':\n                    merged = MediumEditor.util.extend({}, this.options.anchor, opts);\n                    extension = new MediumEditor.extensions.anchor(merged);\n                    break;\n                case 'anchor-preview':\n                    extension = new MediumEditor.extensions.anchorPreview(this.options.anchorPreview);\n                    break;\n                case 'autoLink':\n                    extension = new MediumEditor.extensions.autoLink();\n                    break;\n                case 'fileDragging':\n                    extension = new MediumEditor.extensions.fileDragging(opts);\n                    break;\n                case 'fontname':\n                    extension = new MediumEditor.extensions.fontName(this.options.fontName);\n                    break;\n                case 'fontsize':\n                    extension = new MediumEditor.extensions.fontSize(opts);\n                    break;\n                case 'keyboardCommands':\n                    extension = new MediumEditor.extensions.keyboardCommands(this.options.keyboardCommands);\n                    break;\n                case 'paste':\n                    extension = new MediumEditor.extensions.paste(this.options.paste);\n                    break;\n                case 'placeholder':\n                    extension = new MediumEditor.extensions.placeholder(this.options.placeholder);\n                    break;\n                default:\n                    // All of the built-in buttons for MediumEditor are extensions\n                    // so check to see if the extension we're creating is a built-in button\n                    if (MediumEditor.extensions.button.isBuiltInButton(name)) {\n                        if (opts) {\n                            merged = MediumEditor.util.defaults({}, opts, MediumEditor.extensions.button.prototype.defaults[name]);\n                            extension = new MediumEditor.extensions.button(merged);\n                        } else {\n                            extension = new MediumEditor.extensions.button(name);\n                        }\n                    }\n            }\n\n            if (extension) {\n                this.extensions.push(initExtension(extension, name, this));\n            }\n\n            return extension;\n        },\n\n        stopSelectionUpdates: function () {\n            this.preventSelectionUpdates = true;\n        },\n\n        startSelectionUpdates: function () {\n            this.preventSelectionUpdates = false;\n        },\n\n        checkSelection: function () {\n            var toolbar = this.getExtensionByName('toolbar');\n            if (toolbar) {\n                toolbar.checkState();\n            }\n            return this;\n        },\n\n        // Wrapper around document.queryCommandState for checking whether an action has already\n        // been applied to the current selection\n        queryCommandState: function (action) {\n            var fullAction = /^full-(.+)$/gi,\n                match,\n                queryState = null;\n\n            // Actions starting with 'full-' need to be modified since this is a medium-editor concept\n            match = fullAction.exec(action);\n            if (match) {\n                action = match[1];\n            }\n\n            try {\n                queryState = this.options.ownerDocument.queryCommandState(action);\n            } catch (exc) {\n                queryState = null;\n            }\n\n            return queryState;\n        },\n\n        execAction: function (action, opts) {\n            /*jslint regexp: true*/\n            var fullAction = /^full-(.+)$/gi,\n                match,\n                result;\n            /*jslint regexp: false*/\n\n            // Actions starting with 'full-' should be applied to to the entire contents of the editable element\n            // (ie full-bold, full-append-pre, etc.)\n            match = fullAction.exec(action);\n            if (match) {\n                // Store the current selection to be restored after applying the action\n                this.saveSelection();\n                // Select all of the contents before calling the action\n                this.selectAllContents();\n                result = execActionInternal.call(this, match[1], opts);\n                // Restore the previous selection\n                this.restoreSelection();\n            } else {\n                result = execActionInternal.call(this, action, opts);\n            }\n\n            // do some DOM clean-up for known browser issues after the action\n            if (action === 'insertunorderedlist' || action === 'insertorderedlist') {\n                MediumEditor.util.cleanListDOM(this.options.ownerDocument, this.getSelectedParentElement());\n            }\n\n            this.checkSelection();\n            return result;\n        },\n\n        getSelectedParentElement: function (range) {\n            if (range === undefined) {\n                range = this.options.contentWindow.getSelection().getRangeAt(0);\n            }\n            return MediumEditor.selection.getSelectedParentElement(range);\n        },\n\n        selectAllContents: function () {\n            var currNode = MediumEditor.selection.getSelectionElement(this.options.contentWindow);\n\n            if (currNode) {\n                // Move to the lowest descendant node that still selects all of the contents\n                while (currNode.children.length === 1) {\n                    currNode = currNode.children[0];\n                }\n\n                this.selectElement(currNode);\n            }\n        },\n\n        selectElement: function (element) {\n            MediumEditor.selection.selectNode(element, this.options.ownerDocument);\n\n            var selElement = MediumEditor.selection.getSelectionElement(this.options.contentWindow);\n            if (selElement) {\n                this.events.focusElement(selElement);\n            }\n        },\n\n        getFocusedElement: function () {\n            var focused;\n            this.elements.some(function (element) {\n                // Find the element that has focus\n                if (!focused && element.getAttribute('data-medium-focused')) {\n                    focused = element;\n                }\n\n                // bail if we found the element that had focus\n                return !!focused;\n            }, this);\n\n            return focused;\n        },\n\n        // Export the state of the selection in respect to one of this\n        // instance of MediumEditor's elements\n        exportSelection: function () {\n            var selectionElement = MediumEditor.selection.getSelectionElement(this.options.contentWindow),\n                editableElementIndex = this.elements.indexOf(selectionElement),\n                selectionState = null;\n\n            if (editableElementIndex >= 0) {\n                selectionState = MediumEditor.selection.exportSelection(selectionElement, this.options.ownerDocument);\n            }\n\n            if (selectionState !== null && editableElementIndex !== 0) {\n                selectionState.editableElementIndex = editableElementIndex;\n            }\n\n            return selectionState;\n        },\n\n        saveSelection: function () {\n            this.selectionState = this.exportSelection();\n        },\n\n        // Restore a selection based on a selectionState returned by a call\n        // to MediumEditor.exportSelection\n        importSelection: function (selectionState, favorLaterSelectionAnchor) {\n            if (!selectionState) {\n                return;\n            }\n\n            var editableElement = this.elements[selectionState.editableElementIndex || 0];\n            MediumEditor.selection.importSelection(selectionState, editableElement, this.options.ownerDocument, favorLaterSelectionAnchor);\n        },\n\n        restoreSelection: function () {\n            this.importSelection(this.selectionState);\n        },\n\n        createLink: function (opts) {\n            var this$1 = this;\n\n            var currentEditor = MediumEditor.selection.getSelectionElement(this.options.contentWindow),\n                customEvent = {},\n                targetUrl;\n\n            // Make sure the selection is within an element this editor is tracking\n            if (this.elements.indexOf(currentEditor) === -1) {\n                return;\n            }\n\n            try {\n                this.events.disableCustomEvent('editableInput');\n                // TODO: Deprecate support for opts.url in 6.0.0\n                if (opts.url) {\n                    MediumEditor.util.deprecated('.url option for createLink', '.value', '6.0.0');\n                }\n                targetUrl = opts.url || opts.value;\n                if (targetUrl && targetUrl.trim().length > 0) {\n                    var currentSelection = this.options.contentWindow.getSelection();\n                    if (currentSelection) {\n                        var currRange = currentSelection.getRangeAt(0),\n                            commonAncestorContainer = currRange.commonAncestorContainer,\n                            exportedSelection,\n                            startContainerParentElement,\n                            endContainerParentElement,\n                            textNodes;\n\n                        // If the selection is contained within a single text node\n                        // and the selection starts at the beginning of the text node,\n                        // MSIE still says the startContainer is the parent of the text node.\n                        // If the selection is contained within a single text node, we\n                        // want to just use the default browser 'createLink', so we need\n                        // to account for this case and adjust the commonAncestorContainer accordingly\n                        if (currRange.endContainer.nodeType === 3 &&\n                            currRange.startContainer.nodeType !== 3 &&\n                            currRange.startOffset === 0 &&\n                            currRange.startContainer.firstChild === currRange.endContainer) {\n                            commonAncestorContainer = currRange.endContainer;\n                        }\n\n                        startContainerParentElement = MediumEditor.util.getClosestBlockContainer(currRange.startContainer);\n                        endContainerParentElement = MediumEditor.util.getClosestBlockContainer(currRange.endContainer);\n\n                        // If the selection is not contained within a single text node\n                        // but the selection is contained within the same block element\n                        // we want to make sure we create a single link, and not multiple links\n                        // which can happen with the built in browser functionality\n                        if (commonAncestorContainer.nodeType !== 3 && commonAncestorContainer.textContent.length !== 0 && startContainerParentElement === endContainerParentElement) {\n                            var parentElement = (startContainerParentElement || currentEditor),\n                                fragment = this.options.ownerDocument.createDocumentFragment();\n\n                            // since we are going to create a link from an extracted text,\n                            // be sure that if we are updating a link, we won't let an empty link behind (see #754)\n                            // (Workaroung for Chrome)\n                            this.execAction('unlink');\n\n                            exportedSelection = this.exportSelection();\n                            fragment.appendChild(parentElement.cloneNode(true));\n\n                            if (currentEditor === parentElement) {\n                                // We have to avoid the editor itself being wiped out when it's the only block element,\n                                // as our reference inside this.elements gets detached from the page when insertHTML runs.\n                                // If we just use [parentElement, 0] and [parentElement, parentElement.childNodes.length]\n                                // as the range boundaries, this happens whenever parentElement === currentEditor.\n                                // The tradeoff to this workaround is that a orphaned tag can sometimes be left behind at\n                                // the end of the editor's content.\n                                // In Gecko:\n                                // as an empty <strong></strong> if parentElement.lastChild is a <strong> tag.\n                                // In WebKit:\n                                // an invented <br /> tag at the end in the same situation\n                                MediumEditor.selection.select(\n                                    this.options.ownerDocument,\n                                    parentElement.firstChild,\n                                    0,\n                                    parentElement.lastChild,\n                                    parentElement.lastChild.nodeType === 3 ?\n                                    parentElement.lastChild.nodeValue.length : parentElement.lastChild.childNodes.length\n                                );\n                            } else {\n                                MediumEditor.selection.select(\n                                    this.options.ownerDocument,\n                                    parentElement,\n                                    0,\n                                    parentElement,\n                                    parentElement.childNodes.length\n                                );\n                            }\n\n                            var modifiedExportedSelection = this.exportSelection();\n\n                            textNodes = MediumEditor.util.findOrCreateMatchingTextNodes(\n                                this.options.ownerDocument,\n                                fragment,\n                                {\n                                    start: exportedSelection.start - modifiedExportedSelection.start,\n                                    end: exportedSelection.end - modifiedExportedSelection.start,\n                                    editableElementIndex: exportedSelection.editableElementIndex\n                                }\n                            );\n                            // If textNodes are not present, when changing link on images\n                            // ex: <a><img src=\"http://image.test.com\"></a>, change fragment to currRange.startContainer\n                            // and set textNodes array to [imageElement, imageElement]\n                            if (textNodes.length === 0) {\n                                fragment = this.options.ownerDocument.createDocumentFragment();\n                                fragment.appendChild(commonAncestorContainer.cloneNode(true));\n                                textNodes = [fragment.firstChild.firstChild, fragment.firstChild.lastChild];\n                            }\n\n                            // Creates the link in the document fragment\n                            MediumEditor.util.createLink(this.options.ownerDocument, textNodes, targetUrl.trim());\n\n                            // Chrome trims the leading whitespaces when inserting HTML, which messes up restoring the selection.\n                            var leadingWhitespacesCount = (fragment.firstChild.innerHTML.match(/^\\s+/) || [''])[0].length;\n\n                            // Now move the created link back into the original document in a way to preserve undo/redo history\n                            MediumEditor.util.insertHTMLCommand(this.options.ownerDocument, fragment.firstChild.innerHTML.replace(/^\\s+/, ''));\n                            exportedSelection.start -= leadingWhitespacesCount;\n                            exportedSelection.end -= leadingWhitespacesCount;\n\n                            this.importSelection(exportedSelection);\n                        } else {\n                            this.options.ownerDocument.execCommand('createLink', false, targetUrl);\n                        }\n\n                        if (this.options.targetBlank || opts.target === '_blank') {\n                            MediumEditor.util.setTargetBlank(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), targetUrl);\n                        } else {\n                            MediumEditor.util.removeTargetBlank(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), targetUrl);\n                        }\n\n                        if (opts.buttonClass) {\n                            MediumEditor.util.addClassToAnchors(MediumEditor.selection.getSelectionStart(this.options.ownerDocument), opts.buttonClass);\n                        }\n                    }\n                }\n                // Fire input event for backwards compatibility if anyone was listening directly to the DOM input event\n                if (this.options.targetBlank || opts.target === '_blank' || opts.buttonClass) {\n                    customEvent = this.options.ownerDocument.createEvent('HTMLEvents');\n                    customEvent.initEvent('input', true, true, this.options.contentWindow);\n                    for (var i = 0, len = this.elements.length; i < len; i += 1) {\n                        this$1.elements[i].dispatchEvent(customEvent);\n                    }\n                }\n            } finally {\n                this.events.enableCustomEvent('editableInput');\n            }\n            // Fire our custom editableInput event\n            this.events.triggerCustomEvent('editableInput', customEvent, currentEditor);\n        },\n\n        cleanPaste: function (text) {\n            this.getExtensionByName('paste').cleanPaste(text);\n        },\n\n        pasteHTML: function (html, options) {\n            this.getExtensionByName('paste').pasteHTML(html, options);\n        },\n\n        setContent: function (html, index) {\n            index = index || 0;\n\n            if (this.elements[index]) {\n                var target = this.elements[index];\n                target.innerHTML = html;\n                this.checkContentChanged(target);\n            }\n        },\n\n        getContent: function (index) {\n            index = index || 0;\n\n            if (this.elements[index]) {\n                return this.elements[index].innerHTML.trim();\n            }\n            return null;\n        },\n\n        checkContentChanged: function (editable) {\n            editable = editable || MediumEditor.selection.getSelectionElement(this.options.contentWindow);\n            this.events.updateInput(editable, { target: editable, currentTarget: editable });\n        },\n\n        resetContent: function (element) {\n            // For all elements that exist in the this.elements array, we can assume:\n            // - Its initial content has been set in the initialContent object\n            // - It has a medium-editor-index attribute which is the key value in the initialContent object\n\n            if (element) {\n                var index = this.elements.indexOf(element);\n                if (index !== -1) {\n                    this.setContent(initialContent[element.getAttribute('medium-editor-index')], index);\n                }\n                return;\n            }\n\n            this.elements.forEach(function (el, idx) {\n                this.setContent(initialContent[el.getAttribute('medium-editor-index')], idx);\n            }, this);\n        },\n\n        addElements: function (selector) {\n            // Convert elements into an array\n            var elements = createElementsArray(selector, this.options.ownerDocument, true);\n\n            // Do we have elements to add now?\n            if (elements.length === 0) {\n                return false;\n            }\n\n            elements.forEach(function (element) {\n                // Initialize all new elements (we check that in those functions don't worry)\n                element = initElement.call(this, element, this.id);\n\n                // Add new elements to our internal elements array\n                this.elements.push(element);\n\n                // Trigger event so extensions can know when an element has been added\n                this.trigger('addElement', { target: element, currentTarget: element }, element);\n            }, this);\n        },\n\n        removeElements: function (selector) {\n            // Convert elements into an array\n            var elements = createElementsArray(selector, this.options.ownerDocument),\n                toRemove = elements.map(function (el) {\n                    // For textareas, make sure we're looking at the editor div and not the textarea itself\n                    if (el.getAttribute('medium-editor-textarea-id') && el.parentNode) {\n                        return el.parentNode.querySelector('div[medium-editor-textarea-id=\"' + el.getAttribute('medium-editor-textarea-id') + '\"]');\n                    } else {\n                        return el;\n                    }\n                });\n\n            this.elements = this.elements.filter(function (element) {\n                // If this is an element we want to remove\n                if (toRemove.indexOf(element) !== -1) {\n                    this.events.cleanupElement(element);\n                    if (element.getAttribute('medium-editor-textarea-id')) {\n                        cleanupTextareaElement(element);\n                    }\n                    // Trigger event so extensions can clean-up elements that are being removed\n                    this.trigger('removeElement', { target: element, currentTarget: element }, element);\n                    return false;\n                }\n                return true;\n            }, this);\n        }\n    };\n\n    MediumEditor.getEditorFromElement = function (element) {\n        var index = element.getAttribute('data-medium-editor-editor-index'),\n            win = element && element.ownerDocument && (element.ownerDocument.defaultView || element.ownerDocument.parentWindow);\n        if (win && win._mediumEditors && win._mediumEditors[index]) {\n            return win._mediumEditors[index];\n        }\n        return null;\n    };\n}());\n\n(function () {\n    // summary: The default options hash used by the Editor\n\n    MediumEditor.prototype.defaults = {\n        activeButtonClass: 'medium-editor-button-active',\n        buttonLabels: false,\n        delay: 0,\n        disableReturn: false,\n        disableDoubleReturn: false,\n        disableExtraSpaces: false,\n        disableEditing: false,\n        autoLink: false,\n        elementsContainer: false,\n        contentWindow: window,\n        ownerDocument: document,\n        targetBlank: false,\n        extensions: {},\n        spellcheck: true\n    };\n})();\n\nMediumEditor.parseVersionString = function (release) {\n    var split = release.split('-'),\n        version = split[0].split('.'),\n        preRelease = (split.length > 1) ? split[1] : '';\n    return {\n        major: parseInt(version[0], 10),\n        minor: parseInt(version[1], 10),\n        revision: parseInt(version[2], 10),\n        preRelease: preRelease,\n        toString: function () {\n            return [version[0], version[1], version[2]].join('.') + (preRelease ? '-' + preRelease : '');\n        }\n    };\n};\n\nMediumEditor.version = MediumEditor.parseVersionString.call(this, ({\n    // grunt-bump looks for this:\n    'version': '5.21.0'\n}).version);\n\n    return MediumEditor;\n}()));\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9ub2RlX21vZHVsZXMvbWVkaXVtLWVkaXRvci9kaXN0L2pzL21lZGl1bS1lZGl0b3IuanM/ZjIxNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBzZWxmLCBkb2N1bWVudCwgRE9NRXhjZXB0aW9uICovXG5cbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9jbGFzc0xpc3QuanMvYmxvYi9tYXN0ZXIvY2xhc3NMaXN0LmpzICovXG5cbi8vIEZ1bGwgcG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcbmlmICghKFwiY2xhc3NMaXN0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIl9cIikpKSB7XG4gIChmdW5jdGlvbiAodmlldykge1xuXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmICghKCdFbGVtZW50JyBpbiB2aWV3KSkgcmV0dXJuO1xuXG4gIHZhclxuICAgICAgY2xhc3NMaXN0UHJvcCA9IFwiY2xhc3NMaXN0XCJcbiAgICAsIHByb3RvUHJvcCA9IFwicHJvdG90eXBlXCJcbiAgICAsIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdXG4gICAgLCBvYmpDdHIgPSBPYmplY3RcbiAgICAsIHN0clRyaW0gPSBTdHJpbmdbcHJvdG9Qcm9wXS50cmltIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuICAgIH1cbiAgICAsIGFyckluZGV4T2YgPSBBcnJheVtwcm90b1Byb3BdLmluZGV4T2YgfHwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhclxuICAgICAgICAgIGkgPSAwXG4gICAgICAgICwgbGVuID0gdGhpcy5sZW5ndGhcbiAgICAgIDtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgLy8gVmVuZG9yczogcGxlYXNlIGFsbG93IGNvbnRlbnQgY29kZSB0byBpbnN0YW50aWF0ZSBET01FeGNlcHRpb25zXG4gICAgLCBET01FeCA9IGZ1bmN0aW9uICh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICB0aGlzLm5hbWUgPSB0eXBlO1xuICAgICAgdGhpcy5jb2RlID0gRE9NRXhjZXB0aW9uW3R5cGVdO1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgLCBjaGVja1Rva2VuQW5kR2V0SW5kZXggPSBmdW5jdGlvbiAoY2xhc3NMaXN0LCB0b2tlbikge1xuICAgICAgaWYgKHRva2VuID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeChcbiAgICAgICAgICAgIFwiU1lOVEFYX0VSUlwiXG4gICAgICAgICAgLCBcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoL1xccy8udGVzdCh0b2tlbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4KFxuICAgICAgICAgICAgXCJJTlZBTElEX0NIQVJBQ1RFUl9FUlJcIlxuICAgICAgICAgICwgXCJTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXJcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyckluZGV4T2YuY2FsbChjbGFzc0xpc3QsIHRva2VuKTtcbiAgICB9XG4gICAgLCBDbGFzc0xpc3QgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdmFyXG4gICAgICAgICAgdHJpbW1lZENsYXNzZXMgPSBzdHJUcmltLmNhbGwoZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiKVxuICAgICAgICAsIGNsYXNzZXMgPSB0cmltbWVkQ2xhc3NlcyA/IHRyaW1tZWRDbGFzc2VzLnNwbGl0KC9cXHMrLykgOiBbXVxuICAgICAgICAsIGkgPSAwXG4gICAgICAgICwgbGVuID0gY2xhc3Nlcy5sZW5ndGhcbiAgICAgIDtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5wdXNoKGNsYXNzZXNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAsIGNsYXNzTGlzdFByb3RvID0gQ2xhc3NMaXN0W3Byb3RvUHJvcF0gPSBbXVxuICAgICwgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBDbGFzc0xpc3QodGhpcyk7XG4gICAgfVxuICA7XG4gIC8vIE1vc3QgRE9NRXhjZXB0aW9uIGltcGxlbWVudGF0aW9ucyBkb24ndCBhbGxvdyBjYWxsaW5nIERPTUV4Y2VwdGlvbidzIHRvU3RyaW5nKClcbiAgLy8gb24gbm9uLURPTUV4Y2VwdGlvbnMuIEVycm9yJ3MgdG9TdHJpbmcoKSBpcyBzdWZmaWNpZW50IGhlcmUuXG4gIERPTUV4W3Byb3RvUHJvcF0gPSBFcnJvcltwcm90b1Byb3BdO1xuICBjbGFzc0xpc3RQcm90by5pdGVtID0gZnVuY3Rpb24gKGkpIHtcbiAgICByZXR1cm4gdGhpc1tpXSB8fCBudWxsO1xuICB9O1xuICBjbGFzc0xpc3RQcm90by5jb250YWlucyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHRva2VuICs9IFwiXCI7XG4gICAgcmV0dXJuIGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgIT09IC0xO1xuICB9O1xuICBjbGFzc0xpc3RQcm90by5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyXG4gICAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xuICAgICAgLCBpID0gMFxuICAgICAgLCBsID0gdG9rZW5zLmxlbmd0aFxuICAgICAgLCB0b2tlblxuICAgICAgLCB1cGRhdGVkID0gZmFsc2VcbiAgICA7XG4gICAgZG8ge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xuICAgICAgaWYgKGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbikgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucHVzaCh0b2tlbik7XG4gICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoKytpIDwgbCk7XG5cbiAgICBpZiAodXBkYXRlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlQ2xhc3NOYW1lKCk7XG4gICAgfVxuICB9O1xuICBjbGFzc0xpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyXG4gICAgICAgIHRva2VucyA9IGFyZ3VtZW50c1xuICAgICAgLCBpID0gMFxuICAgICAgLCBsID0gdG9rZW5zLmxlbmd0aFxuICAgICAgLCB0b2tlblxuICAgICAgLCB1cGRhdGVkID0gZmFsc2VcbiAgICAgICwgaW5kZXhcbiAgICA7XG4gICAgZG8ge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV0gKyBcIlwiO1xuICAgICAgaW5kZXggPSBjaGVja1Rva2VuQW5kR2V0SW5kZXgodGhpcywgdG9rZW4pO1xuICAgICAgd2hpbGUgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICBpbmRleCA9IGNoZWNrVG9rZW5BbmRHZXRJbmRleCh0aGlzLCB0b2tlbik7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICgrK2kgPCBsKTtcblxuICAgIGlmICh1cGRhdGVkKSB7XG4gICAgICB0aGlzLl91cGRhdGVDbGFzc05hbWUoKTtcbiAgICB9XG4gIH07XG4gIGNsYXNzTGlzdFByb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcbiAgICB0b2tlbiArPSBcIlwiO1xuXG4gICAgdmFyXG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY29udGFpbnModG9rZW4pXG4gICAgICAsIG1ldGhvZCA9IHJlc3VsdCA/XG4gICAgICAgIGZvcmNlICE9PSB0cnVlICYmIFwicmVtb3ZlXCJcbiAgICAgIDpcbiAgICAgICAgZm9yY2UgIT09IGZhbHNlICYmIFwiYWRkXCJcbiAgICA7XG5cbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICB0aGlzW21ldGhvZF0odG9rZW4pO1xuICAgIH1cblxuICAgIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgfVxuICB9O1xuICBjbGFzc0xpc3RQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5qb2luKFwiIFwiKTtcbiAgfTtcblxuICBpZiAob2JqQ3RyLmRlZmluZVByb3BlcnR5KSB7XG4gICAgdmFyIGNsYXNzTGlzdFByb3BEZXNjID0ge1xuICAgICAgICBnZXQ6IGNsYXNzTGlzdEdldHRlclxuICAgICAgLCBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcbiAgICB9IGNhdGNoIChleCkgeyAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcbiAgICAgIGlmIChleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XG4gICAgICAgIGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcbiAgICAgICAgb2JqQ3RyLmRlZmluZVByb3BlcnR5KGVsZW1DdHJQcm90bywgY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0UHJvcERlc2MpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChvYmpDdHJbcHJvdG9Qcm9wXS5fX2RlZmluZUdldHRlcl9fKSB7XG4gICAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcbiAgfVxuXG4gIH0oc2VsZikpO1xufVxuXG4vKiBCbG9iLmpzXG4gKiBBIEJsb2IgaW1wbGVtZW50YXRpb24uXG4gKiAyMDE0LTA3LTI0XG4gKlxuICogQnkgRWxpIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuICogQnkgRGV2aW4gU2FtYXJpbiwgaHR0cHM6Ly9naXRodWIuY29tL2RzYW1hcmluXG4gKiBMaWNlbnNlOiBYMTEvTUlUXG4gKiAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9CbG9iLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiAqL1xuXG4vKmdsb2JhbCBzZWxmLCB1bmVzY2FwZSAqL1xuLypqc2xpbnQgYml0d2lzZTogdHJ1ZSwgcmVnZXhwOiB0cnVlLCBjb25mdXNpb246IHRydWUsIGVzNTogdHJ1ZSwgdmFyczogdHJ1ZSwgd2hpdGU6IHRydWUsXG4gIHBsdXNwbHVzOiB0cnVlICovXG5cbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9CbG9iLmpzL2Jsb2IvbWFzdGVyL0Jsb2IuanMgKi9cblxuKGZ1bmN0aW9uICh2aWV3KSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZpZXcuVVJMID0gdmlldy5VUkwgfHwgdmlldy53ZWJraXRVUkw7XG5cbiAgaWYgKHZpZXcuQmxvYiAmJiB2aWV3LlVSTCkge1xuICAgIHRyeSB7XG4gICAgICBuZXcgQmxvYjtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgLy8gSW50ZXJuYWxseSB3ZSB1c2UgYSBCbG9iQnVpbGRlciBpbXBsZW1lbnRhdGlvbiB0byBiYXNlIEJsb2Igb2ZmIG9mXG4gIC8vIGluIG9yZGVyIHRvIHN1cHBvcnQgb2xkZXIgYnJvd3NlcnMgdGhhdCBvbmx5IGhhdmUgQmxvYkJ1aWxkZXJcbiAgdmFyIEJsb2JCdWlsZGVyID0gdmlldy5CbG9iQnVpbGRlciB8fCB2aWV3LldlYktpdEJsb2JCdWlsZGVyIHx8IHZpZXcuTW96QmxvYkJ1aWxkZXIgfHwgKGZ1bmN0aW9uKHZpZXcpIHtcbiAgICB2YXJcbiAgICAgICAgZ2V0X2NsYXNzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXlxcW29iamVjdFxccyguKilcXF0kLylbMV07XG4gICAgICB9XG4gICAgICAsIEZha2VCbG9iQnVpbGRlciA9IGZ1bmN0aW9uIEJsb2JCdWlsZGVyKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIH1cbiAgICAgICwgRmFrZUJsb2IgPSBmdW5jdGlvbiBCbG9iKGRhdGEsIHR5cGUsIGVuY29kaW5nKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICAsIEZCQl9wcm90byA9IEZha2VCbG9iQnVpbGRlci5wcm90b3R5cGVcbiAgICAgICwgRkJfcHJvdG8gPSBGYWtlQmxvYi5wcm90b3R5cGVcbiAgICAgICwgRmlsZVJlYWRlclN5bmMgPSB2aWV3LkZpbGVSZWFkZXJTeW5jXG4gICAgICAsIEZpbGVFeGNlcHRpb24gPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IHRoaXNbdGhpcy5uYW1lID0gdHlwZV07XG4gICAgICB9XG4gICAgICAsIGZpbGVfZXhfY29kZXMgPSAoXG4gICAgICAgICAgXCJOT1RfRk9VTkRfRVJSIFNFQ1VSSVRZX0VSUiBBQk9SVF9FUlIgTk9UX1JFQURBQkxFX0VSUiBFTkNPRElOR19FUlIgXCJcbiAgICAgICAgKyBcIk5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUiBJTlZBTElEX1NUQVRFX0VSUiBTWU5UQVhfRVJSXCJcbiAgICAgICkuc3BsaXQoXCIgXCIpXG4gICAgICAsIGZpbGVfZXhfY29kZSA9IGZpbGVfZXhfY29kZXMubGVuZ3RoXG4gICAgICAsIHJlYWxfVVJMID0gdmlldy5VUkwgfHwgdmlldy53ZWJraXRVUkwgfHwgdmlld1xuICAgICAgLCByZWFsX2NyZWF0ZV9vYmplY3RfVVJMID0gcmVhbF9VUkwuY3JlYXRlT2JqZWN0VVJMXG4gICAgICAsIHJlYWxfcmV2b2tlX29iamVjdF9VUkwgPSByZWFsX1VSTC5yZXZva2VPYmplY3RVUkxcbiAgICAgICwgVVJMID0gcmVhbF9VUkxcbiAgICAgICwgYnRvYSA9IHZpZXcuYnRvYVxuICAgICAgLCBhdG9iID0gdmlldy5hdG9iXG5cbiAgICAgICwgQXJyYXlCdWZmZXIgPSB2aWV3LkFycmF5QnVmZmVyXG4gICAgICAsIFVpbnQ4QXJyYXkgPSB2aWV3LlVpbnQ4QXJyYXlcblxuICAgICAgLCBvcmlnaW4gPSAvXltcXHctXSs6XFwvKlxcWz9bXFx3XFwuOi1dK1xcXT8oPzo6WzAtOV0rKT8vXG4gICAgO1xuICAgIEZha2VCbG9iLmZha2UgPSBGQl9wcm90by5mYWtlID0gdHJ1ZTtcbiAgICB3aGlsZSAoZmlsZV9leF9jb2RlLS0pIHtcbiAgICAgIEZpbGVFeGNlcHRpb24ucHJvdG90eXBlW2ZpbGVfZXhfY29kZXNbZmlsZV9leF9jb2RlXV0gPSBmaWxlX2V4X2NvZGUgKyAxO1xuICAgIH1cbiAgICAvLyBQb2x5ZmlsbCBVUkxcbiAgICBpZiAoIXJlYWxfVVJMLmNyZWF0ZU9iamVjdFVSTCkge1xuICAgICAgVVJMID0gdmlldy5VUkwgPSBmdW5jdGlvbih1cmkpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICB1cmlfaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIiwgXCJhXCIpXG4gICAgICAgICAgLCB1cmlfb3JpZ2luXG4gICAgICAgIDtcbiAgICAgICAgdXJpX2luZm8uaHJlZiA9IHVyaTtcbiAgICAgICAgaWYgKCEoXCJvcmlnaW5cIiBpbiB1cmlfaW5mbykpIHtcbiAgICAgICAgICBpZiAodXJpX2luZm8ucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiKSB7XG4gICAgICAgICAgICB1cmlfaW5mby5vcmlnaW4gPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cmlfb3JpZ2luID0gdXJpLm1hdGNoKG9yaWdpbik7XG4gICAgICAgICAgICB1cmlfaW5mby5vcmlnaW4gPSB1cmlfb3JpZ2luICYmIHVyaV9vcmlnaW5bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmlfaW5mbztcbiAgICAgIH07XG4gICAgfVxuICAgIFVSTC5jcmVhdGVPYmplY3RVUkwgPSBmdW5jdGlvbihibG9iKSB7XG4gICAgICB2YXJcbiAgICAgICAgICB0eXBlID0gYmxvYi50eXBlXG4gICAgICAgICwgZGF0YV9VUklfaGVhZGVyXG4gICAgICA7XG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChibG9iIGluc3RhbmNlb2YgRmFrZUJsb2IpIHtcbiAgICAgICAgZGF0YV9VUklfaGVhZGVyID0gXCJkYXRhOlwiICsgdHlwZTtcbiAgICAgICAgaWYgKGJsb2IuZW5jb2RpbmcgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YV9VUklfaGVhZGVyICsgXCI7YmFzZTY0LFwiICsgYmxvYi5kYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKGJsb2IuZW5jb2RpbmcgPT09IFwiVVJJXCIpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YV9VUklfaGVhZGVyICsgXCIsXCIgKyBkZWNvZGVVUklDb21wb25lbnQoYmxvYi5kYXRhKTtcbiAgICAgICAgfSBpZiAoYnRvYSkge1xuICAgICAgICAgIHJldHVybiBkYXRhX1VSSV9oZWFkZXIgKyBcIjtiYXNlNjQsXCIgKyBidG9hKGJsb2IuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGFfVVJJX2hlYWRlciArIFwiLFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGJsb2IuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVhbF9jcmVhdGVfb2JqZWN0X1VSTCkge1xuICAgICAgICByZXR1cm4gcmVhbF9jcmVhdGVfb2JqZWN0X1VSTC5jYWxsKHJlYWxfVVJMLCBibG9iKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwgPSBmdW5jdGlvbihvYmplY3RfVVJMKSB7XG4gICAgICBpZiAob2JqZWN0X1VSTC5zdWJzdHJpbmcoMCwgNSkgIT09IFwiZGF0YTpcIiAmJiByZWFsX3Jldm9rZV9vYmplY3RfVVJMKSB7XG4gICAgICAgIHJlYWxfcmV2b2tlX29iamVjdF9VUkwuY2FsbChyZWFsX1VSTCwgb2JqZWN0X1VSTCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBGQkJfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24oZGF0YS8qLCBlbmRpbmdzKi8pIHtcbiAgICAgIHZhciBiYiA9IHRoaXMuZGF0YTtcbiAgICAgIC8vIGRlY29kZSBkYXRhIHRvIGEgYmluYXJ5IHN0cmluZ1xuICAgICAgaWYgKFVpbnQ4QXJyYXkgJiYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBzdHIgPSBcIlwiXG4gICAgICAgICAgLCBidWYgPSBuZXcgVWludDhBcnJheShkYXRhKVxuICAgICAgICAgICwgaSA9IDBcbiAgICAgICAgICAsIGJ1Zl9sZW4gPSBidWYubGVuZ3RoXG4gICAgICAgIDtcbiAgICAgICAgZm9yICg7IGkgPCBidWZfbGVuOyBpKyspIHtcbiAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGJiLnB1c2goc3RyKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2V0X2NsYXNzKGRhdGEpID09PSBcIkJsb2JcIiB8fCBnZXRfY2xhc3MoZGF0YSkgPT09IFwiRmlsZVwiKSB7XG4gICAgICAgIGlmIChGaWxlUmVhZGVyU3luYykge1xuICAgICAgICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyU3luYztcbiAgICAgICAgICBiYi5wdXNoKGZyLnJlYWRBc0JpbmFyeVN0cmluZyhkYXRhKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYXN5bmMgRmlsZVJlYWRlciB3b24ndCB3b3JrIGFzIEJsb2JCdWlsZGVyIGlzIHN5bmNcbiAgICAgICAgICB0aHJvdyBuZXcgRmlsZUV4Y2VwdGlvbihcIk5PVF9SRUFEQUJMRV9FUlJcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEZha2VCbG9iKSB7XG4gICAgICAgIGlmIChkYXRhLmVuY29kaW5nID09PSBcImJhc2U2NFwiICYmIGF0b2IpIHtcbiAgICAgICAgICBiYi5wdXNoKGF0b2IoZGF0YS5kYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5lbmNvZGluZyA9PT0gXCJVUklcIikge1xuICAgICAgICAgIGJiLnB1c2goZGVjb2RlVVJJQ29tcG9uZW50KGRhdGEuZGF0YSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEuZW5jb2RpbmcgPT09IFwicmF3XCIpIHtcbiAgICAgICAgICBiYi5wdXNoKGRhdGEuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGRhdGEgKz0gXCJcIjsgLy8gY29udmVydCB1bnN1cHBvcnRlZCB0eXBlcyB0byBzdHJpbmdzXG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVjb2RlIFVURi0xNiB0byBiaW5hcnkgc3RyaW5nXG4gICAgICAgIGJiLnB1c2godW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBGQkJfcHJvdG8uZ2V0QmxvYiA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0eXBlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRmFrZUJsb2IodGhpcy5kYXRhLmpvaW4oXCJcIiksIHR5cGUsIFwicmF3XCIpO1xuICAgIH07XG4gICAgRkJCX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJbb2JqZWN0IEJsb2JCdWlsZGVyXVwiO1xuICAgIH07XG4gICAgRkJfcHJvdG8uc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kLCB0eXBlKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoYXJncyA8IDMpIHtcbiAgICAgICAgdHlwZSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEZha2VCbG9iKFxuICAgICAgICAgIHRoaXMuZGF0YS5zbGljZShzdGFydCwgYXJncyA+IDEgPyBlbmQgOiB0aGlzLmRhdGEubGVuZ3RoKVxuICAgICAgICAsIHR5cGVcbiAgICAgICAgLCB0aGlzLmVuY29kaW5nXG4gICAgICApO1xuICAgIH07XG4gICAgRkJfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBcIltvYmplY3QgQmxvYl1cIjtcbiAgICB9O1xuICAgIEZCX3Byb3RvLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuZGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBGYWtlQmxvYkJ1aWxkZXI7XG4gIH0odmlldykpO1xuXG4gIHZpZXcuQmxvYiA9IGZ1bmN0aW9uKGJsb2JQYXJ0cywgb3B0aW9ucykge1xuICAgIHZhciB0eXBlID0gb3B0aW9ucyA/IChvcHRpb25zLnR5cGUgfHwgXCJcIikgOiBcIlwiO1xuICAgIHZhciBidWlsZGVyID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgaWYgKGJsb2JQYXJ0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJsb2JQYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoVWludDhBcnJheSAmJiBibG9iUGFydHNbaV0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgYnVpbGRlci5hcHBlbmQoYmxvYlBhcnRzW2ldLmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYnVpbGRlci5hcHBlbmQoYmxvYlBhcnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYmxvYiA9IGJ1aWxkZXIuZ2V0QmxvYih0eXBlKTtcbiAgICBpZiAoIWJsb2Iuc2xpY2UgJiYgYmxvYi53ZWJraXRTbGljZSkge1xuICAgICAgYmxvYi5zbGljZSA9IGJsb2Iud2Via2l0U2xpY2U7XG4gICAgfVxuICAgIHJldHVybiBibG9iO1xuICB9O1xuXG4gIHZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0Ll9fcHJvdG9fXztcbiAgfTtcbiAgdmlldy5CbG9iLnByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKG5ldyB2aWV3LkJsb2IoKSk7XG59KHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgfHwgdGhpcy5jb250ZW50IHx8IHRoaXMpKTtcblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBpc0VsZWN0cm9uID0gdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb247XG4gICAgaWYgKCFpc0VsZWN0cm9uICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhY3Rvcnk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuTWVkaXVtRWRpdG9yID0gZmFjdG9yeTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcblxuICAgICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gTWVkaXVtRWRpdG9yKGVsZW1lbnRzLCBvcHRpb25zKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHJldHVybiB0aGlzLmluaXQoZWxlbWVudHMsIG9wdGlvbnMpO1xufVxuXG5NZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucyA9IHt9O1xuLypqc2hpbnQgdW51c2VkOiB0cnVlICovXG4oZnVuY3Rpb24gKHdpbmRvdykge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIGNvcHlJbnRvKG92ZXJ3cml0ZSwgZGVzdCkge1xuICAgICAgICB2YXIgcHJvcCxcbiAgICAgICAgICAgIHNvdXJjZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgICAgICBkZXN0ID0gZGVzdCB8fCB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VbcHJvcF0gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAob3ZlcndyaXRlIHx8IGRlc3QuaGFzT3duUHJvcGVydHkocHJvcCkgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTm9kZS9jb250YWluc1xuICAgIC8vIFNvbWUgYnJvd3NlcnMgKGluY2x1ZGluZyBwaGFudG9tKSBkb24ndCByZXR1cm4gdHJ1ZSBmb3IgTm9kZS5jb250YWlucyhjaGlsZClcbiAgICAvLyBpZiBjaGlsZCBpcyBhIHRleHQgbm9kZS4gIERldGVjdCB0aGVzZSBjYXNlcyBoZXJlIGFuZCB1c2UgYSBmYWxsYmFja1xuICAgIC8vIGZvciBjYWxscyB0byBVdGlsLmlzRGVzY2VuZGFudCgpXG4gICAgdmFyIG5vZGVDb250YWluc1dvcmtzV2l0aFRleHROb2RlcyA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciB0ZXN0UGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgICAgICB0ZXN0VGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcgJyk7XG4gICAgICAgIHRlc3RQYXJlbnQuYXBwZW5kQ2hpbGQodGVzdFRleHQpO1xuICAgICAgICBub2RlQ29udGFpbnNXb3Jrc1dpdGhUZXh0Tm9kZXMgPSB0ZXN0UGFyZW50LmNvbnRhaW5zKHRlc3RUZXh0KTtcbiAgICB9IGNhdGNoIChleGMpIHt9XG5cbiAgICB2YXIgVXRpbCA9IHtcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3OTA3NDQ1L2hvdy10by1kZXRlY3QtaWUxMSNjb21tZW50MzAxNjU4ODhfMTc5MDc1NjJcbiAgICAgICAgLy8gYnkgcmc4OVxuICAgICAgICBpc0lFOiAoKG5hdmlnYXRvci5hcHBOYW1lID09PSAnTWljcm9zb2Z0IEludGVybmV0IEV4cGxvcmVyJykgfHwgKChuYXZpZ2F0b3IuYXBwTmFtZSA9PT0gJ05ldHNjYXBlJykgJiYgKG5ldyBSZWdFeHAoJ1RyaWRlbnQvLipydjooWzAtOV17MSx9Wy4wLTldezAsfSknKS5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpICE9PSBudWxsKSkpLFxuXG4gICAgICAgIGlzRWRnZTogKC9FZGdlXFwvXFxkKy8pLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgIT09IG51bGwsXG5cbiAgICAgICAgLy8gaWYgZmlyZWZveFxuICAgICAgICBpc0ZGOiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IC0xKSxcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTc1MjA4NC81NjkxMDFcbiAgICAgICAgaXNNYWM6ICh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLnRvVXBwZXJDYXNlKCkuaW5kZXhPZignTUFDJykgPj0gMCksXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlXG4gICAgICAgIC8vIExvbmVseSBsZXR0ZXIgTVVTVCBVU0UgdGhlIHVwcGVyY2FzZSBjb2RlXG4gICAgICAgIGtleUNvZGU6IHtcbiAgICAgICAgICAgIEJBQ0tTUEFDRTogOCxcbiAgICAgICAgICAgIFRBQjogOSxcbiAgICAgICAgICAgIEVOVEVSOiAxMyxcbiAgICAgICAgICAgIEVTQ0FQRTogMjcsXG4gICAgICAgICAgICBTUEFDRTogMzIsXG4gICAgICAgICAgICBERUxFVEU6IDQ2LFxuICAgICAgICAgICAgSzogNzUsIC8vIEsga2V5Y29kZSwgYW5kIG5vdCBrXG4gICAgICAgICAgICBNOiA3NyxcbiAgICAgICAgICAgIFY6IDg2XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiBpdCdzIG1ldGFLZXkgb24gTWFjLCBvciBjdHJsS2V5IG9uIG5vbi1NYWMuXG4gICAgICAgICAqIFNlZSAjNTkxXG4gICAgICAgICAqL1xuICAgICAgICBpc01ldGFDdHJsS2V5OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICgoVXRpbC5pc01hYyAmJiBldmVudC5tZXRhS2V5KSB8fCAoIVV0aWwuaXNNYWMgJiYgZXZlbnQuY3RybEtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGtleSBhc3NvY2lhdGVkIHRvIHRoZSBldmVudCBpcyBpbnNpZGUga2V5cyBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAc2VlIDogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi8wNzA1YmU0NzUwOTJhZWRlMWVkZGFlMDEzMTllYzkzMWZiOWM2NWZjL3NyYy9ldmVudC5qcyNMNDczLUw0ODRcbiAgICAgICAgICogQHNlZSA6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xLzQ0NzE1ODIvNTY5MTAxXG4gICAgICAgICAqL1xuICAgICAgICBpc0tleTogZnVuY3Rpb24gKGV2ZW50LCBrZXlzKSB7XG4gICAgICAgICAgICB2YXIga2V5Q29kZSA9IFV0aWwuZ2V0S2V5Q29kZShldmVudCk7XG5cbiAgICAgICAgICAgIC8vIGl0J3Mgbm90IGFuIGFycmF5IGxldCdzIGp1c3QgY29tcGFyZSBzdHJpbmdzIVxuICAgICAgICAgICAgaWYgKGZhbHNlID09PSBBcnJheS5pc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleUNvZGUgPT09IGtleXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgtMSA9PT0ga2V5cy5pbmRleE9mKGtleUNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRLZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQud2hpY2g7XG5cbiAgICAgICAgICAgIC8vIGdldHRpbmcgdGhlIGtleSBjb2RlIGZyb20gZXZlbnRcbiAgICAgICAgICAgIGlmIChudWxsID09PSBrZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAga2V5Q29kZSA9IGV2ZW50LmNoYXJDb2RlICE9PSBudWxsID8gZXZlbnQuY2hhckNvZGUgOiBldmVudC5rZXlDb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ga2V5Q29kZTtcbiAgICAgICAgfSxcblxuICAgICAgICBibG9ja0NvbnRhaW5lckVsZW1lbnROYW1lczogW1xuICAgICAgICAgICAgLy8gZWxlbWVudHMgb3VyIGVkaXRvciBnZW5lcmF0ZXNcbiAgICAgICAgICAgICdwJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2Jsb2NrcXVvdGUnLCAncHJlJywgJ3VsJywgJ2xpJywgJ29sJyxcbiAgICAgICAgICAgIC8vIGFsbCBvdGhlciBrbm93biBibG9jayBlbGVtZW50c1xuICAgICAgICAgICAgJ2FkZHJlc3MnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdjYW52YXMnLCAnZGQnLCAnZGwnLCAnZHQnLCAnZmllbGRzZXQnLFxuICAgICAgICAgICAgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnbWFpbicsICduYXYnLFxuICAgICAgICAgICAgJ25vc2NyaXB0JywgJ291dHB1dCcsICdzZWN0aW9uJywgJ3ZpZGVvJyxcbiAgICAgICAgICAgICd0YWJsZScsICd0aGVhZCcsICd0Ym9keScsICd0Zm9vdCcsICd0cicsICd0aCcsICd0ZCdcbiAgICAgICAgXSxcblxuICAgICAgICBlbXB0eUVsZW1lbnROYW1lczogWydicicsICdjb2wnLCAnY29sZ3JvdXAnLCAnaHInLCAnaW1nJywgJ2lucHV0JywgJ3NvdXJjZScsICd3YnInXSxcblxuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgvKiBkZXN0LCBzb3VyY2UxLCBzb3VyY2UyLCAuLi4qLykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbdHJ1ZV0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlJbnRvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlZmF1bHRzOiBmdW5jdGlvbiBkZWZhdWx0cygvKmRlc3QsIHNvdXJjZTEsIHNvdXJjZTIsIC4uLiovKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtmYWxzZV0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHlJbnRvLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIENyZWF0ZSBhIGxpbmsgYXJvdW5kIHRoZSBwcm92aWRlZCB0ZXh0IG5vZGVzIHdoaWNoIG11c3QgYmUgYWRqYWNlbnQgdG8gZWFjaCBvdGhlciBhbmQgYWxsIGJlXG4gICAgICAgICAqIGRlc2NlbmRhbnRzIG9mIHRoZSBzYW1lIGNsb3Nlc3QgYmxvY2sgY29udGFpbmVyLiBJZiB0aGUgcHJlY29uZGl0aW9ucyBhcmUgbm90IG1ldCwgdW5leHBlY3RlZFxuICAgICAgICAgKiBiZWhhdmlvciB3aWxsIHJlc3VsdC5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUxpbms6IGZ1bmN0aW9uIChkb2N1bWVudCwgdGV4dE5vZGVzLCBocmVmLCB0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgICAgICBVdGlsLm1vdmVUZXh0UmFuZ2VJbnRvRWxlbWVudCh0ZXh0Tm9kZXNbMF0sIHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV0sIGFuY2hvcik7XG4gICAgICAgICAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgYW5jaG9yLnNldEF0dHJpYnV0ZSgndGFyZ2V0JywgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgICogR2l2ZW4gdGhlIHByb3ZpZGVkIG1hdGNoIGluIHRoZSBmb3JtYXQge3N0YXJ0OiAxLCBlbmQ6IDJ9IHdoZXJlIHN0YXJ0IGFuZCBlbmQgYXJlIGluZGljZXMgaW50byB0aGVcbiAgICAgICAgICogdGV4dENvbnRlbnQgb2YgdGhlIHByb3ZpZGVkIGVsZW1lbnQgYXJndW1lbnQsIG1vZGlmeSB0aGUgRE9NIGluc2lkZSBlbGVtZW50IHRvIGVuc3VyZSB0aGF0IHRoZSB0ZXh0XG4gICAgICAgICAqIGlkZW50aWZpZWQgYnkgdGhlIHByb3ZpZGVkIG1hdGNoIGNhbiBiZSByZXR1cm5lZCBhcyB0ZXh0IG5vZGVzIHRoYXQgY29udGFpbiBleGFjdGx5IHRoYXQgdGV4dCwgd2l0aG91dFxuICAgICAgICAgKiBhbnkgYWRkaXRpb25hbCB0ZXh0IGF0IHRoZSBiZWdpbm5pbmcgb3IgZW5kIG9mIHRoZSByZXR1cm5lZCBhcnJheSBvZiBhZGphY2VudCB0ZXh0IG5vZGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgb25seSBET00gbWFuaXB1bGF0aW9uIHBlcmZvcm1lZCBieSB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0dGluZyB0aGUgdGV4dCBub2Rlcywgbm9uLXRleHQgbm9kZXMgYXJlXG4gICAgICAgICAqIG5vdCBhZmZlY3RlZCBpbiBhbnkgd2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgZmluZE9yQ3JlYXRlTWF0Y2hpbmdUZXh0Tm9kZXM6IGZ1bmN0aW9uIChkb2N1bWVudCwgZWxlbWVudCwgbWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfQUxMLCBudWxsLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgbWF0Y2hlZE5vZGVzID0gW10sXG4gICAgICAgICAgICAgICAgY3VycmVudFRleHRJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRSZWFjaGVkID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBudWxsLFxuICAgICAgICAgICAgICAgIG5ld05vZGUgPSBudWxsO1xuXG4gICAgICAgICAgICB3aGlsZSAoKGN1cnJlbnROb2RlID0gdHJlZVdhbGtlci5uZXh0Tm9kZSgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0UmVhY2hlZCAmJiBtYXRjaC5zdGFydCA8IChjdXJyZW50VGV4dEluZGV4ICsgY3VycmVudE5vZGUubm9kZVZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0UmVhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlID0gVXRpbC5zcGxpdFN0YXJ0Tm9kZUlmTmVlZGVkKGN1cnJlbnROb2RlLCBtYXRjaC5zdGFydCwgY3VycmVudFRleHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0UmVhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbC5zcGxpdEVuZE5vZGVJZk5lZWRlZChjdXJyZW50Tm9kZSwgbmV3Tm9kZSwgbWF0Y2guZW5kLCBjdXJyZW50VGV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRSZWFjaGVkICYmIGN1cnJlbnRUZXh0SW5kZXggPT09IG1hdGNoLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEZvdW5kIHRoZSBub2RlKHMpIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxpbmsuIEJyZWFrIG91dCBhbmQgbW92ZSBvbiB0byB0aGUgbmV4dC5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdGFydFJlYWNoZWQgJiYgY3VycmVudFRleHRJbmRleCA+IChtYXRjaC5lbmQgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQZXJmb3JtTGlua2luZyBvdmVyc2hvdCB0aGUgdGFyZ2V0IScpOyAvLyBzaG91bGQgbmV2ZXIgaGFwcGVuLi4uXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRSZWFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkTm9kZXMucHVzaChuZXdOb2RlIHx8IGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0SW5kZXggKz0gY3VycmVudE5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0SW5kZXggKz0gbmV3Tm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCB0aGUgbmV3Tm9kZSBhcyB3ZSdsbCBhbHJlYWR5IGhhdmUgcHVzaGVkIGl0IHRvIHRoZSBtYXRjaGVzXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlV2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Tm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhcnRSZWFjaGVkICYmIChtYXRjaC5zdGFydCA8PSBjdXJyZW50VGV4dEluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRSZWFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRSZWFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkTm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZE5vZGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEdpdmVuIHRoZSBwcm92aWRlZCB0ZXh0IG5vZGUgYW5kIHRleHQgY29vcmRpbmF0ZXMsIHNwbGl0IHRoZSB0ZXh0IG5vZGUgaWYgbmVlZGVkIHRvIG1ha2UgaXQgYWxpZ25cbiAgICAgICAgICogcHJlY2lzZWx5IHdpdGggdGhlIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIFV0aWwuZmluZE9yQ3JlYXRlTWF0Y2hpbmdUZXh0Tm9kZXMuXG4gICAgICAgICAqL1xuICAgICAgICBzcGxpdFN0YXJ0Tm9kZUlmTmVlZGVkOiBmdW5jdGlvbiAoY3VycmVudE5vZGUsIG1hdGNoU3RhcnRJbmRleCwgY3VycmVudFRleHRJbmRleCkge1xuICAgICAgICAgICAgaWYgKG1hdGNoU3RhcnRJbmRleCAhPT0gY3VycmVudFRleHRJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Tm9kZS5zcGxpdFRleHQobWF0Y2hTdGFydEluZGV4IC0gY3VycmVudFRleHRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgKiBHaXZlbiB0aGUgcHJvdmlkZWQgdGV4dCBub2RlIGFuZCB0ZXh0IGNvb3JkaW5hdGVzLCBzcGxpdCB0aGUgdGV4dCBub2RlIGlmIG5lZWRlZCB0byBtYWtlIGl0IGFsaWduXG4gICAgICAgICAqIHByZWNpc2VseSB3aXRoIHRoZSBjb29yZGluYXRlcy4gVGhlIG5ld05vZGUgYXJndW1lbnQgc2hvdWxkIGZyb20gdGhlIHJlc3VsdCBvZiBVdGlsLnNwbGl0U3RhcnROb2RlSWZOZWVkZWQsXG4gICAgICAgICAqIGlmIHRoYXQgZnVuY3Rpb24gaGFzIGJlZW4gY2FsbGVkIG9uIHRoZSBzYW1lIGN1cnJlbnROb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIFV0aWwuZmluZE9yQ3JlYXRlTWF0Y2hpbmdUZXh0Tm9kZXMuXG4gICAgICAgICAqL1xuICAgICAgICBzcGxpdEVuZE5vZGVJZk5lZWRlZDogZnVuY3Rpb24gKGN1cnJlbnROb2RlLCBuZXdOb2RlLCBtYXRjaEVuZEluZGV4LCBjdXJyZW50VGV4dEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgdGV4dEluZGV4T2ZFbmRPZkZhcnRoZXN0Tm9kZSxcbiAgICAgICAgICAgICAgICBlbmRTcGxpdFBvaW50O1xuICAgICAgICAgICAgdGV4dEluZGV4T2ZFbmRPZkZhcnRoZXN0Tm9kZSA9IGN1cnJlbnRUZXh0SW5kZXggKyAobmV3Tm9kZSB8fCBjdXJyZW50Tm9kZSkubm9kZVZhbHVlLmxlbmd0aCArXG4gICAgICAgICAgICAgICAgICAgIChuZXdOb2RlID8gY3VycmVudE5vZGUubm9kZVZhbHVlLmxlbmd0aCA6IDApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgIGVuZFNwbGl0UG9pbnQgPSAobmV3Tm9kZSB8fCBjdXJyZW50Tm9kZSkubm9kZVZhbHVlLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgICAgICh0ZXh0SW5kZXhPZkVuZE9mRmFydGhlc3ROb2RlICsgMSAtIG1hdGNoRW5kSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRleHRJbmRleE9mRW5kT2ZGYXJ0aGVzdE5vZGUgPj0gbWF0Y2hFbmRJbmRleCAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dEluZGV4ICE9PSB0ZXh0SW5kZXhPZkVuZE9mRmFydGhlc3ROb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIGVuZFNwbGl0UG9pbnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAobmV3Tm9kZSB8fCBjdXJyZW50Tm9kZSkuc3BsaXRUZXh0KGVuZFNwbGl0UG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICogVGFrZSBhbiBlbGVtZW50LCBhbmQgYnJlYWsgdXAgYWxsIG9mIGl0cyB0ZXh0IGNvbnRlbnQgaW50byB1bmlxdWUgcGllY2VzIHN1Y2ggdGhhdDpcbiAgICAgICAgICogMSkgQWxsIHRleHQgY29udGVudCBvZiB0aGUgZWxlbWVudHMgYXJlIGluIHNlcGFyYXRlIGJsb2Nrcy4gTm8gcGllY2Ugb2YgdGV4dCBjb250ZW50IHNob3VsZCBzcGFuXG4gICAgICAgICAqICAgIGFjcm9zcyBtdWx0aXBsZSBibG9ja3MuIFRoaXMgbWVhbnMgbm8gZWxlbWVudCByZXR1cm4gYnkgdGhpcyBmdW5jdGlvbiBzaG91bGQgaGF2ZVxuICAgICAgICAgKiAgICBhbnkgYmxvY2tzIGFzIGNoaWxkcmVuLlxuICAgICAgICAgKiAyKSBUaGUgdW5pb24gb2YgdGhlIHRleHRjb250ZW50IG9mIGFsbCBvZiB0aGUgZWxlbWVudHMgcmV0dXJuZWQgaGVyZSBjb3ZlcnMgYWxsXG4gICAgICAgICAqICAgIG9mIHRoZSB0ZXh0IHdpdGhpbiB0aGUgZWxlbWVudC5cbiAgICAgICAgICpcbiAgICAgICAgICpcbiAgICAgICAgICogRVhBTVBMRTpcbiAgICAgICAgICogSW4gdGhlIGV2ZW50IHRoYXQgd2UgaGF2ZSBzb21ldGhpbmcgbGlrZTpcbiAgICAgICAgICpcbiAgICAgICAgICogPGJsb2NrcXVvdGU+XG4gICAgICAgICAqICAgPHA+U29tZSBUZXh0PC9wPlxuICAgICAgICAgKiAgIDxvbD5cbiAgICAgICAgICogICAgIDxsaT5MaXN0IEl0ZW0gMTwvbGk+XG4gICAgICAgICAqICAgICA8bGk+TGlzdCBJdGVtIDI8L2xpPlxuICAgICAgICAgKiAgIDwvb2w+XG4gICAgICAgICAqIDwvYmxvY2txdW90ZT5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiB3b3VsZCByZXR1cm4gdGhlc2UgZWxlbWVudHMgYXMgYW4gYXJyYXk6XG4gICAgICAgICAqICAgWyA8cD5Tb21lIFRleHQ8L3A+LCA8bGk+TGlzdCBJdGVtIDE8L2xpPiwgPGxpPkxpc3QgSXRlbSAyPC9saT4gXVxuICAgICAgICAgKlxuICAgICAgICAgKiBTaW5jZSB0aGUgPGJsb2NrcXVvdGU+IGFuZCA8b2w+IGVsZW1lbnRzIGNvbnRhaW4gYmxvY2tzIHdpdGhpbiB0aGVtIHRoZXkgYXJlIG5vdCByZXR1cm5lZC5cbiAgICAgICAgICogU2luY2UgdGhlIDxwPiBhbmQgPGxpPidzIGRvbid0IGNvbnRhaW4gYmxvY2sgZWxlbWVudHMgYW5kIGNvdmVyIGFsbCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZVxuICAgICAgICAgKiA8YmxvY2txdW90ZT4gY29udGFpbmVyLCB0aGV5IGFyZSB0aGUgZWxlbWVudHMgcmV0dXJuZWQuXG4gICAgICAgICAqL1xuICAgICAgICBzcGxpdEJ5QmxvY2tFbGVtZW50czogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAzICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b1JldCA9IFtdLFxuICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudFF1ZXJ5ID0gTWVkaXVtRWRpdG9yLnV0aWwuYmxvY2tDb250YWluZXJFbGVtZW50TmFtZXMuam9pbignLCcpO1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYmxvY2tFbGVtZW50UXVlcnkpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbZWxlbWVudF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICB0b1JldC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0VsZW1lbnRzID0gY2hpbGQucXVlcnlTZWxlY3RvckFsbChibG9ja0VsZW1lbnRRdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja0VsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldCA9IHRvUmV0LmNvbmNhdChNZWRpdW1FZGl0b3IudXRpbC5zcGxpdEJ5QmxvY2tFbGVtZW50cyhjaGlsZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9SZXQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRmluZCB0aGUgbmV4dCBub2RlIGluIHRoZSBET00gdHJlZSB0aGF0IHJlcHJlc2VudHMgYW55IHRleHQgdGhhdCBpcyBiZWluZ1xuICAgICAgICAvLyBkaXNwbGF5ZWQgZGlyZWN0bHkgbmV4dCB0byB0aGUgdGFyZ2V0Tm9kZSAocGFzc2VkIGFzIGFuIGFyZ3VtZW50KVxuICAgICAgICAvLyBUZXh0IHRoYXQgYXBwZWFycyBkaXJlY3RseSBuZXh0IHRvIHRoZSBjdXJyZW50IG5vZGUgY2FuIGJlOlxuICAgICAgICAvLyAgLSBBIHNpYmxpbmcgdGV4dCBub2RlXG4gICAgICAgIC8vICAtIEEgZGVzY2VuZGFudCBvZiBhIHNpYmxpbmcgZWxlbWVudFxuICAgICAgICAvLyAgLSBBIHNpYmxpbmcgdGV4dCBub2RlIG9mIGFuIGFuY2VzdG9yXG4gICAgICAgIC8vICAtIEEgZGVzY2VuZGFudCBvZiBhIHNpYmxpbmcgZWxlbWVudCBvZiBhbiBhbmNlc3RvclxuICAgICAgICBmaW5kQWRqYWNlbnRUZXh0Tm9kZVdpdGhDb250ZW50OiBmdW5jdGlvbiBmaW5kQWRqYWNlbnRUZXh0Tm9kZVdpdGhDb250ZW50KHJvb3ROb2RlLCB0YXJnZXROb2RlLCBvd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgcGFzdFRhcmdldCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5leHROb2RlLFxuICAgICAgICAgICAgICAgIG5vZGVJdGVyYXRvciA9IG93bmVyRG9jdW1lbnQuY3JlYXRlTm9kZUl0ZXJhdG9yKHJvb3ROb2RlLCBOb2RlRmlsdGVyLlNIT1dfVEVYVCwgbnVsbCwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBVc2UgYSBuYXRpdmUgTm9kZUl0ZXJhdG9yIHRvIGl0ZXJhdGUgb3ZlciBhbGwgdGhlIHRleHQgbm9kZXMgdGhhdCBhcmUgZGVzY2VuZGFudHNcbiAgICAgICAgICAgIC8vIG9mIHRoZSByb290Tm9kZS4gIE9uY2UgcGFzdCB0aGUgdGFyZ2V0Tm9kZSwgY2hvb3NlIHRoZSBmaXJzdCBub24tZW1wdHkgdGV4dCBub2RlXG4gICAgICAgICAgICBuZXh0Tm9kZSA9IG5vZGVJdGVyYXRvci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgd2hpbGUgKG5leHROb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHROb2RlID09PSB0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3RUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzdFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dE5vZGUubm9kZVR5cGUgPT09IDMgJiYgbmV4dE5vZGUubm9kZVZhbHVlICYmIG5leHROb2RlLm5vZGVWYWx1ZS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5leHROb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZpbmQgYW4gZWxlbWVudCdzIHByZXZpb3VzIHNpYmxpbmcgd2l0aGluIGEgbWVkaXVtLWVkaXRvciBlbGVtZW50XG4gICAgICAgIC8vIElmIG9uZSBkb2Vzbid0IGV4aXN0LCBmaW5kIHRoZSBjbG9zZXN0IGFuY2VzdG9yJ3MgcHJldmlvdXMgc2libGluZ1xuICAgICAgICBmaW5kUHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IFV0aWwuaXNNZWRpdW1FZGl0b3JFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAoIXByZXZpb3VzU2libGluZyAmJiAhVXRpbC5pc01lZGl1bUVkaXRvckVsZW1lbnQobm9kZS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNEZXNjZW5kYW50OiBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQocGFyZW50LCBjaGlsZCwgY2hlY2tFcXVhbGl0eSkge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFjaGVja0VxdWFsaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgcGFyZW50IGlzIG5vdCBhbiBlbGVtZW50LCBpdCBjYW4ndCBoYXZlIGFueSBkZXNjZW5kYW50c1xuICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlQ29udGFpbnNXb3Jrc1dpdGhUZXh0Tm9kZXMgfHwgY2hpbGQubm9kZVR5cGUgIT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50LmNvbnRhaW5zKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlID0gY2hpbGQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmVcbiAgICAgICAgaXNFbGVtZW50OiBmdW5jdGlvbiBpc0VsZW1lbnQob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlXG4gICAgICAgIHRocm90dGxlOiBmdW5jdGlvbiAoZnVuYywgd2FpdCkge1xuICAgICAgICAgICAgdmFyIFRIUk9UVExFX0lOVEVSVkFMID0gNTAsXG4gICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbCxcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IDAsXG4gICAgICAgICAgICAgICAgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCF3YWl0ICYmIHdhaXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICB3YWl0ID0gVEhST1RUTEVfSU5URVJWQUw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhdmVyc2VVcDogZnVuY3Rpb24gKGN1cnJlbnQsIHRlc3RFbGVtZW50RnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0RWxlbWVudEZ1bmN0aW9uKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3QgdHJhdmVyc2UgdXB3YXJkcyBwYXN0IHRoZSBuZWFyZXN0IGNvbnRhaW5pbmcgZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIGlmIChVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbEVudGl0aWVzOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0cyBzcGVjaWFsIGNoYXJhY3RlcnMgKGxpa2UgPCkgaW50byB0aGVpciBlc2NhcGVkL2VuY29kZWQgdmFsdWVzIChsaWtlICZsdDspLlxuICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgeW91IHRvIHNob3cgdG8gZGlzcGxheSB0aGUgc3RyaW5nIHdpdGhvdXQgdGhlIGJyb3dzZXIgcmVhZGluZyBpdCBhcyBIVE1MLlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoLz4vZywgJyZndDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NjkwNzUyL2luc2VydC1odG1sLWF0LWNhcmV0LWluLWEtY29udGVudGVkaXRhYmxlLWRpdlxuICAgICAgICBpbnNlcnRIVE1MQ29tbWFuZDogZnVuY3Rpb24gKGRvYywgaHRtbCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiwgcmFuZ2UsIGVsLCBmcmFnbWVudCwgbm9kZSwgbGFzdE5vZGUsIHRvUmVwbGFjZSxcbiAgICAgICAgICAgICAgICByZXMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBlY0FyZ3MgPSBbJ2luc2VydEhUTUwnLCBmYWxzZSwgaHRtbF07XG5cbiAgICAgICAgICAgIC8qIEVkZ2UncyBpbXBsZW1lbnRhdGlvbiBvZiBpbnNlcnRIVE1MIGlzIGp1c3QgYnVnZ3kgcmlnaHQgbm93OlxuICAgICAgICAgICAgICogLSBEb2Vzbid0IGFsbG93IGxlYWRpbmcgd2hpdGUgc3BhY2UgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBlbGVtZW50XG4gICAgICAgICAgICAgKiAtIEZvdW5kIGEgY2FzZSB3aGVuIGEgPGZvbnQgc2l6ZT1cIjJcIj4gdGFnIHdhcyBpbnNlcnRlZCB3aGVuIGNhbGxpbmcgYWxpZ25DZW50ZXIgaW5zaWRlIGEgYmxvY2txdW90ZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZXJlIGFyZSBsaWtlbHkgb3RoZXIgYnVncywgdGhlc2UgYXJlIGp1c3QgdGhlIG9uZXMgd2UgZm91bmQgc28gZmFyLlxuICAgICAgICAgICAgICogRm9yIG5vdywgbGV0J3MganVzdCB1c2UgdGhlIHNhbWUgZmFsbGJhY2sgd2UgZGlkIGZvciBJRVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIU1lZGl1bUVkaXRvci51dGlsLmlzRWRnZSAmJiBkb2MucXVlcnlDb21tYW5kU3VwcG9ydGVkKCdpbnNlcnRIVE1MJykpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jLmV4ZWNDb21tYW5kLmFwcGx5KGRvYywgZWNBcmdzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAgICAgdG9SZXBsYWNlID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20veWFid2UvbWVkaXVtLWVkaXRvci9pc3N1ZXMvNzQ4XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBhbiBlbXB0eSBlZGl0b3IgZWxlbWVudCwgY3JlYXRlIGEgdGVtcG9yYXJ5IHRleHQgbm9kZSBpbnNpZGUgb2YgdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgIC8vIGFuZCBzZWxlY3QgaXQgc28gdGhhdCB3ZSBkb24ndCBkZWxldGUgdGhlIGVkaXRvciBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNNZWRpdW1FZGl0b3JFbGVtZW50KHRvUmVwbGFjZSkgJiYgIXRvUmVwbGFjZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGUodG9SZXBsYWNlLmFwcGVuZENoaWxkKGRvYy5jcmVhdGVUZXh0Tm9kZSgnJykpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0b1JlcGxhY2Uubm9kZVR5cGUgPT09IDMgJiYgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IDAgJiYgcmFuZ2UuZW5kT2Zmc2V0ID09PSB0b1JlcGxhY2Uubm9kZVZhbHVlLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0b1JlcGxhY2Uubm9kZVR5cGUgIT09IDMgJiYgdG9SZXBsYWNlLmlubmVySFRNTCA9PT0gcmFuZ2UudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHJhbmdlIGNvdmVycyBtYXhpbXVtIGFtb3VudCBvZiBub2RlcyBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyBCeSBtb3ZpbmcgdXAgdGhlIERPTSBhbmQgc2VsZWN0aW5nIGFuY2VzdG9ycyB3aG9zZSBvbmx5IGNoaWxkIGlzIHRoZSByYW5nZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIVV0aWwuaXNNZWRpdW1FZGl0b3JFbGVtZW50KHRvUmVwbGFjZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1JlcGxhY2UucGFyZW50Tm9kZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvUmVwbGFjZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIVV0aWwuaXNNZWRpdW1FZGl0b3JFbGVtZW50KHRvUmVwbGFjZS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXBsYWNlID0gdG9SZXBsYWNlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZSh0b1JlcGxhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByYW5nZS5kZWxldGVDb250ZW50cygpO1xuXG4gICAgICAgICAgICAgICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgICAgICBmcmFnbWVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUoZnJhZ21lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIHNlbGVjdGlvbjpcbiAgICAgICAgICAgICAgICBpZiAobGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QWZ0ZXIobGFzdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5zZWxlY3RSYW5nZShkb2MsIHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3lhYndlL21lZGl1bS1lZGl0b3IvaXNzdWVzLzk5MlxuICAgICAgICAgICAgLy8gSWYgd2UncmUgbW9uaXRvcmluZyBjYWxscyB0byBleGVjQ29tbWFuZCwgbm90aWZ5IGxpc3RlbmVycyBhcyBpZiBhIHJlYWwgY2FsbCBoYWQgaGFwcGVuZWRcbiAgICAgICAgICAgIGlmIChkb2MuZXhlY0NvbW1hbmQuY2FsbExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZC5jYWxsTGlzdGVuZXJzKGVjQXJncywgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXhlY0Zvcm1hdEJsb2NrOiBmdW5jdGlvbiAoZG9jLCB0YWdOYW1lKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIHRvcCBsZXZlbCBibG9jayBlbGVtZW50IHRoYXQgY29udGFpbnMgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgdmFyIGJsb2NrQ29udGFpbmVyID0gVXRpbC5nZXRUb3BCbG9ja0NvbnRhaW5lcihNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvblN0YXJ0KGRvYykpLFxuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM7XG5cbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIGJsb2NrcXVvdGVcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnYmxvY2txdW90ZScpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJsb2NrQ29udGFpbmVyLmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYmxvY2txdW90ZSBoYXMgYSBibG9jayBlbGVtZW50IGFzIGEgY2hpbGQgKG5lc3RlZCBibG9ja3MpXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLnNvbWUoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWwuaXNCbG9ja0NvbnRhaW5lcihjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRkYgaGFuZGxlcyBibG9ja3F1b3RlIGRpZmZlcmVudGx5IG9uIGZvcm1hdEJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvd2luZyBuZXN0aW5nLCB3ZSBuZWVkIHRvIHVzZSBvdXRkZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1JpY2gtVGV4dF9FZGl0aW5nX2luX01vemlsbGFcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2MuZXhlY0NvbW1hbmQoJ291dGRlbnQnLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIElFIGJsb2NrcXVvdGUgbmVlZHMgdG8gYmUgY2FsbGVkIGFzIGluZGVudFxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxNjIyMy9yaWNoLXRleHQtZWRpdG9yLXdpdGgtYmxvY2txdW90ZS1mdW5jdGlvbi8xODIxNzc3IzE4MjE3NzdcbiAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc0lFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2MuZXhlY0NvbW1hbmQoJ2luZGVudCcsIGZhbHNlLCB0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBibG9ja0NvbnRhaW5lciBpcyBhbHJlYWR5IHRoZSBlbGVtZW50IHR5cGUgYmVpbmcgcGFzc2VkIGluXG4gICAgICAgICAgICAvLyB0cmVhdCBpdCBhcyAndW5kbycgZm9ybWF0dGluZyBhbmQganVzdCBjb252ZXJ0IGl0IHRvIGEgPHA+XG4gICAgICAgICAgICBpZiAoYmxvY2tDb250YWluZXIgJiYgdGFnTmFtZSA9PT0gYmxvY2tDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAncCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoZW4gSUUgd2UgbmVlZCB0byBhZGQgPD4gdG8gaGVhZGluZyBlbGVtZW50c1xuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDc0MTgzMS9leGVjY29tbWFuZC1mb3JtYXRibG9jay1oZWFkaW5ncy1pbi1pZVxuICAgICAgICAgICAgaWYgKFV0aWwuaXNJRSkge1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnPCcgKyB0YWdOYW1lICsgJz4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIEZGLCBJRSBhbmQgRWRnZSwgd2UgaGF2ZSB0byBoYW5kbGUgYmxvY2txdW90ZSBub2RlIHNlcGVyYXRlbHkgYXMgJ2Zvcm1hdGJsb2NrJyBkb2VzIG5vdCB3b3JrLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2V4ZWNDb21tYW5kI0NvbW1hbmRzXG4gICAgICAgICAgICBpZiAoYmxvY2tDb250YWluZXIgJiYgYmxvY2tDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2Jsb2NrcXVvdGUnKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIElFLCBqdXN0IHVzZSBvdXRkZW50XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNJRSAmJiB0YWdOYW1lID09PSAnPHA+Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jLmV4ZWNDb21tYW5kKCdvdXRkZW50JywgZmFsc2UsIHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvciBGaXJlZm94IGFuZCBFZGdlLCBtYWtlIHN1cmUgdGhlcmUncyBhIG5lc3RlZCBibG9jayBlbGVtZW50IGJlZm9yZSBjYWxsaW5nIG91dGRlbnRcbiAgICAgICAgICAgICAgICBpZiAoKFV0aWwuaXNGRiB8fCBVdGlsLmlzRWRnZSkgJiYgdGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChibG9ja0NvbnRhaW5lci5jaGlsZE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHNvbWUgbm9uLWJsb2NrIGVsZW1lbnRzIHdlIG5lZWQgdG8gd3JhcCBldmVyeXRoaW5nIGluIGEgPHA+IGJlZm9yZSB3ZSBvdXRkZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzLnNvbWUoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFVdGlsLmlzQmxvY2tDb250YWluZXIoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZCgnZm9ybWF0QmxvY2snLCBmYWxzZSwgdGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvYy5leGVjQ29tbWFuZCgnb3V0ZGVudCcsIGZhbHNlLCB0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkb2MuZXhlY0NvbW1hbmQoJ2Zvcm1hdEJsb2NrJywgZmFsc2UsIHRhZ05hbWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdGFyZ2V0IHRvIGJsYW5rIG9uIHRoZSBnaXZlbiBlbCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IG5vdCBzdXJlIGlmIHRoaXMgc2hvdWxkIGJlIGhlcmVcbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBjcmVhdGluZyBhIGxpbmsgKHVzaW5nIGNvcmUgLT4gY3JlYXRlTGluaykgdGhlIHNlbGVjdGlvbiByZXR1cm5lZCBieSBGaXJlZm94IHdpbGwgYmUgdGhlIHBhcmVudCBvZiB0aGUgY3JlYXRlZCBsaW5rXG4gICAgICAgICAqIGluc3RlYWQgb2YgdGhlIGNyZWF0ZWQgbGluayBpdHNlbGYgKGFzIGl0IGlzIGZvciBDaHJvbWUgZm9yIGV4YW1wbGUpLCBzbyB3ZSByZXRyaWV2ZSBhbGwgXCJhXCIgY2hpbGRyZW4gdG8gZ3JhYiB0aGUgZ29vZCBvbmUgYnlcbiAgICAgICAgICogdXNpbmcgYGFuY2hvclVybGAgdG8gZW5zdXJlIHRoYXQgd2UgYXJlIGFkZGluZyB0YXJnZXQ9XCJfYmxhbmtcIiBvbiB0aGUgZ29vZCBvbmUuXG4gICAgICAgICAqIFRoaXMgaXNuJ3QgYSBidWxsZXRwcm9vZiBzb2x1dGlvbiBhbnl3YXkgLi5cbiAgICAgICAgICovXG4gICAgICAgIHNldFRhcmdldEJsYW5rOiBmdW5jdGlvbiAoZWwsIGFuY2hvclVybCkge1xuICAgICAgICAgICAgdmFyIGksIHVybCA9IGFuY2hvclVybCB8fCBmYWxzZTtcbiAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICBlbC50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWwgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gdXJsIHx8IHVybCA9PT0gZWxbaV0uYXR0cmlidXRlcy5ocmVmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbFtpXS50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgKiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBleHBsaWNpdGx5IHJlbW92ZSB0aGUgdGFyZ2V0PSdfYmxhbmsnIGFzIEZGIGhvbGRzIG9uIHRvIF9ibGFuayB2YWx1ZSBldmVuXG4gICAgICAgICAqIGFmdGVyIHVuY2hlY2tpbmcgdGhlIGNoZWNrYm94IG9uIGFuY2hvciBmb3JtXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVUYXJnZXRCbGFuazogZnVuY3Rpb24gKGVsLCBhbmNob3JVcmwpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5jaG9yVXJsID09PSBlbFtpXS5hdHRyaWJ1dGVzLmhyZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW2ldLnJlbW92ZUF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkQ2xhc3NUb0FuY2hvcnM6IGZ1bmN0aW9uIChlbCwgYnV0dG9uQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gYnV0dG9uQ2xhc3Muc3BsaXQoJyAnKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIGo7XG4gICAgICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbGFzc2VzW2pdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWwubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW2ldLmNsYXNzTGlzdC5hZGQoY2xhc3Nlc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNMaXN0SXRlbTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdsaScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHdoaWxlICh0YWdOYW1lID09PSAnbGknIHx8ICghVXRpbC5pc0Jsb2NrQ29udGFpbmVyKHBhcmVudE5vZGUpICYmIHRhZ05hbWUgIT09ICdkaXYnKSkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbkxpc3RET006IGZ1bmN0aW9uIChvd25lckRvY3VtZW50LCBlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnbGknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGlzdCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKGxpc3QucGFyZW50RWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncCcpIHsgLy8geWVzIHdlIG5lZWQgdG8gY2xlYW4gdXBcbiAgICAgICAgICAgICAgICBVdGlsLnVud3JhcChsaXN0LnBhcmVudEVsZW1lbnQsIG93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gbW92ZSBjdXJzb3IgYXQgdGhlIGVuZCBvZiB0aGUgdGV4dCBpbnNpZGUgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAvLyBmb3Igc29tZSB1bmtub3duIHJlYXNvbiwgdGhlIGN1cnNvciBpcyBtb3ZlZCB0byBlbmQgb2YgdGhlIFwidmlzdWFsXCIgbGluZVxuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24ubW92ZUN1cnNvcihvd25lckRvY3VtZW50LCBlbGVtZW50LmZpcnN0Q2hpbGQsIGVsZW1lbnQuZmlyc3RDaGlsZC50ZXh0Q29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIHNwbGl0RE9NVHJlZVxuICAgICAgICAgKlxuICAgICAgICAgKiBHaXZlbiBhIHJvb3QgZWxlbWVudCBzb21lIGRlc2NlbmRhbnQgZWxlbWVudCwgc3BsaXQgdGhlIHJvb3QgZWxlbWVudFxuICAgICAgICAgKiBpbnRvIGl0cyBvd24gZWxlbWVudCBjb250YWluaW5nIHRoZSBkZXNjZW5kYW50IGVsZW1lbnQgYW5kIGFsbCBlbGVtZW50c1xuICAgICAgICAgKiBvbiB0aGUgbGVmdCBvciByaWdodCBzaWRlIG9mIHRoZSBkZXNjZW5kYW50ICgncmlnaHQnIGlzIGRlZmF1bHQpXG4gICAgICAgICAqXG4gICAgICAgICAqIGV4YW1wbGU6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgPGRpdj5cbiAgICAgICAgICogICAgICAvICAgIHwgICBcXFxuICAgICAgICAgKiAgPHNwYW4+IDxzcGFuPiA8c3Bhbj5cbiAgICAgICAgICogICAvIFxcICAgIC8gXFwgICAgLyBcXFxuICAgICAgICAgKiAgMSAgIDIgIDMgICA0ICA1ICAgNlxuICAgICAgICAgKlxuICAgICAgICAgKiAgSWYgSSB3YW50ZWQgdG8gc3BsaXQgdGhpcyB0cmVlIGdpdmVuIHRoZSA8ZGl2PiBhcyB0aGUgcm9vdCBhbmQgXCI0XCIgYXMgdGhlIGxlYWZcbiAgICAgICAgICogIHRoZSByZXN1bHQgd291bGQgYmUgKHRoZSBwcmltZSAnIG1hcmtzIGluZGljYXRlcyBub2RlcyB0aGF0IGFyZSBjcmVhdGVkIGFzIGNsb25lcyk6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgU1BMSVRUSU5HIE9GRiAnUklHSFQnIFRSRUUgICAgICAgU1BMSVRUSU5HIE9GRiAnTEVGVCcgVFJFRVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgPGRpdj4gICAgICAgICAgICA8ZGl2PicgICAgICAgICAgICAgIDxkaXY+JyAgICAgIDxkaXY+XG4gICAgICAgICAqICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICB8XG4gICAgICAgICAqIDxzcGFuPiA8c3Bhbj4gICA8c3Bhbj4nIDxzcGFuPiAgICAgICA8c3Bhbj4gPHNwYW4+ICAgPHNwYW4+XG4gICAgICAgICAqICAgLyBcXCAgICB8ICAgICAgICB8ICAgICAgLyBcXCAgICAgICAgICAgL1xcICAgICAvXFwgICAgICAgL1xcXG4gICAgICAgICAqICAxICAgMiAgIDMgICAgICAgIDQgICAgIDUgICA2ICAgICAgICAgMSAgMiAgIDMgIDQgICAgIDUgIDZcbiAgICAgICAgICpcbiAgICAgICAgICogIFRoZSBhYm92ZSBleGFtcGxlIHJlcHJlc2VudHMgc3BsaXR0aW5nIG9mZiB0aGUgJ3JpZ2h0JyBvciAnbGVmdCcgcGFydCBvZiBhIHRyZWUsIHdoZXJlXG4gICAgICAgICAqICB0aGUgPGRpdj4nIHdvdWxkIGJlIHJldHVybmVkIGFzIGFuIGVsZW1lbnQgbm90IGFwcGVuZGVkIHRvIHRoZSBET00sIGFuZCB0aGUgPGRpdj5cbiAgICAgICAgICogIHdvdWxkIHJlbWFpbiBpbiBwbGFjZSB3aGVyZSBpdCB3YXNcbiAgICAgICAgICpcbiAgICAgICAgKi9cbiAgICAgICAgc3BsaXRPZmZET01UcmVlOiBmdW5jdGlvbiAocm9vdE5vZGUsIGxlYWZOb2RlLCBzcGxpdExlZnQpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdE9uTm9kZSA9IGxlYWZOb2RlLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWROb2RlID0gbnVsbCxcbiAgICAgICAgICAgICAgICBzcGxpdFJpZ2h0ID0gIXNwbGl0TGVmdDtcblxuICAgICAgICAgICAgLy8gbG9vcCB1bnRpbCB3ZSBoaXQgdGhlIHJvb3RcbiAgICAgICAgICAgIHdoaWxlIChzcGxpdE9uTm9kZSAhPT0gcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyclBhcmVudCA9IHNwbGl0T25Ob2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG5ld1BhcmVudCA9IGN1cnJQYXJlbnQuY2xvbmVOb2RlKGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IChzcGxpdFJpZ2h0ID8gc3BsaXRPbk5vZGUgOiBjdXJyUGFyZW50LmZpcnN0Q2hpbGQpLFxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRMYXN0O1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhcmVudCBlbGVtZW50IHdoaWNoIGlzIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgcGFyZW50XG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGxpdFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBzcGxpdHRpbmcgcmlnaHQsIGFkZCBwcmV2aW91cyBjcmVhdGVkIGVsZW1lbnQgYmVmb3JlIHNpYmxpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQYXJlbnQuYXBwZW5kQ2hpbGQoY3JlYXRlZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgc3BsaXR0aW5nIGxlZnQsIGFkZCBwcmV2aW91cyBjcmVhdGVkIGVsZW1lbnQgbGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kTGFzdCA9IGNyZWF0ZWROb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyZWF0ZWROb2RlID0gbmV3UGFyZW50O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSB0YXJnZXROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB0aGUgJ3NwbGl0Tm9kZSdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUgPT09IHNwbGl0T25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldE5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIG5vZGUgd2UncmUgc3BsaXR0aW5nIG9uLCBpZiBpdCBoYXMgY2hpbGRyZW4sIHdlIG5lZWQgdG8gY2xvbmUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbm90IGp1c3QgbW92ZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSB0YXJnZXROb2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0aW5nIHNwbGl0IG5vZGUgaGFzIGNvbnRlbnQsIGFkZCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE5vZGUudGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkTm9kZS5hcHBlbmRDaGlsZCh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IChzcGxpdFJpZ2h0ID8gc2libGluZyA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGdlbmVyYWwgY2FzZSwganVzdCByZW1vdmUgdGhlIGVsZW1lbnQgYW5kIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpdCB0byB0aGUgc3BsaXQgdHJlZSBpZiBpdCBjb250YWlucyBzb21ldGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlLmhhc0NoaWxkTm9kZXMoKSB8fCB0YXJnZXROb2RlLnRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZE5vZGUuYXBwZW5kQ2hpbGQodGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGFkIGFuIGVsZW1lbnQgd2Ugd2FudGVkIHRvIGFwcGVuZCBhdCB0aGUgZW5kLCBkbyB0aGF0IG5vd1xuICAgICAgICAgICAgICAgIGlmIChhcHBlbmRMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZWROb2RlLmFwcGVuZENoaWxkKGFwcGVuZExhc3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNwbGl0T25Ob2RlID0gY3VyclBhcmVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZWROb2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVUZXh0UmFuZ2VJbnRvRWxlbWVudDogZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgZW5kTm9kZSwgbmV3RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCFzdGFydE5vZGUgfHwgIWVuZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb290Tm9kZSA9IFV0aWwuZmluZENvbW1vblJvb3Qoc3RhcnROb2RlLCBlbmROb2RlKTtcbiAgICAgICAgICAgIGlmICghcm9vdE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbmROb2RlID09PSBzdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHN0YXJ0Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgICAgICBzaWJsaW5nID0gc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIHRlbXAucmVtb3ZlQ2hpbGQoc3RhcnROb2RlKTtcbiAgICAgICAgICAgICAgICBuZXdFbGVtZW50LmFwcGVuZENoaWxkKHN0YXJ0Tm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgc2libGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0VsZW1lbnQuaGFzQ2hpbGROb2RlcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgcm9vdENoaWxkcmVuIGFycmF5IHdoaWNoIGluY2x1ZGVzIGFsbCB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHdlIGNhcmUgYWJvdXRcbiAgICAgICAgICAgIHZhciByb290Q2hpbGRyZW4gPSBbXSxcbiAgICAgICAgICAgICAgICBmaXJzdENoaWxkLFxuICAgICAgICAgICAgICAgIGxhc3RDaGlsZCxcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm9vdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5leHROb2RlID0gcm9vdE5vZGUuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNEZXNjZW5kYW50KG5leHROb2RlLCBzdGFydE5vZGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENoaWxkID0gbmV4dE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbC5pc0Rlc2NlbmRhbnQobmV4dE5vZGUsIGVuZE5vZGUsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQgPSBuZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdENoaWxkcmVuLnB1c2gobmV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYWZ0ZXJMYXN0ID0gbGFzdENoaWxkLm5leHRTaWJsaW5nLFxuICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gcm9vdE5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cbiAgICAgICAgICAgIC8vIGJ1aWxkIHVwIGZyYWdtZW50IG9uIHN0YXJ0Tm9kZSBzaWRlIG9mIHRyZWVcbiAgICAgICAgICAgIGlmIChmaXJzdENoaWxkID09PSBzdGFydE5vZGUpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKFV0aWwuc3BsaXRPZmZET01UcmVlKGZpcnN0Q2hpbGQsIHN0YXJ0Tm9kZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgYW55IGVsZW1lbnRzIGJldHdlZW4gZmlyc3RDaGlsZCAmIGxhc3RDaGlsZFxuICAgICAgICAgICAgcm9vdENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gYnVpbGQgdXAgZnJhZ21lbnQgb24gZW5kTm9kZSBzaWRlIG9mIHRoZSB0cmVlXG4gICAgICAgICAgICBpZiAobGFzdENoaWxkID09PSBlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgbGFzdENoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGFzdENoaWxkKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChsYXN0Q2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChVdGlsLnNwbGl0T2ZmRE9NVHJlZShsYXN0Q2hpbGQsIGVuZE5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIGZyYWdtZW50IGludG8gcGFzc2VkIGluIGVsZW1lbnRcbiAgICAgICAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuXG4gICAgICAgICAgICBpZiAobGFzdENoaWxkLnBhcmVudE5vZGUgPT09IHJvb3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGFzdCBjaGlsZCBpcyBpbiB0aGUgcm9vdCwgaW5zZXJ0IG5ld0VsZW1lbnQgaW4gZnJvbnQgb2YgaXRcbiAgICAgICAgICAgICAgICByb290Tm9kZS5pbnNlcnRCZWZvcmUobmV3RWxlbWVudCwgbGFzdENoaWxkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXJMYXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGFzdCBjaGlsZCB3YXMgcmVtb3ZlZCwgYnV0IGl0IGhhZCBhIHNpYmxpbmcsIGluc2VydCBpbiBmcm9udCBvZiBpdFxuICAgICAgICAgICAgICAgIHJvb3ROb2RlLmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBhZnRlckxhc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsYXN0Q2hpbGQgd2FzIHJlbW92ZWQgYW5kIHdhcyB0aGUgbGFzdCBhY3R1YWwgZWxlbWVudCBqdXN0IGFwcGVuZFxuICAgICAgICAgICAgICAgIHJvb3ROb2RlLmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3RWxlbWVudC5oYXNDaGlsZE5vZGVzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogYmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjE4MzA2OSAqL1xuICAgICAgICBkZXB0aE9mTm9kZTogZnVuY3Rpb24gKGluTm9kZSkge1xuICAgICAgICAgICAgdmFyIHRoZURlcHRoID0gMCxcbiAgICAgICAgICAgICAgICBub2RlID0gaW5Ob2RlO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgdGhlRGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGVEZXB0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBmaW5kQ29tbW9uUm9vdDogZnVuY3Rpb24gKGluTm9kZTEsIGluTm9kZTIpIHtcbiAgICAgICAgICAgIHZhciBkZXB0aDEgPSBVdGlsLmRlcHRoT2ZOb2RlKGluTm9kZTEpLFxuICAgICAgICAgICAgICAgIGRlcHRoMiA9IFV0aWwuZGVwdGhPZk5vZGUoaW5Ob2RlMiksXG4gICAgICAgICAgICAgICAgbm9kZTEgPSBpbk5vZGUxLFxuICAgICAgICAgICAgICAgIG5vZGUyID0gaW5Ob2RlMjtcblxuICAgICAgICAgICAgd2hpbGUgKGRlcHRoMSAhPT0gZGVwdGgyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoMSA+IGRlcHRoMikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMSA9IG5vZGUxLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoMSAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgyIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aGlsZSAobm9kZTEgIT09IG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgbm9kZTEgPSBub2RlMS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIG5vZGUyID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5vZGUxO1xuICAgICAgICB9LFxuICAgICAgICAvKiBFTkQgLSBiYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82MTgzMDY5ICovXG5cbiAgICAgICAgaXNFbGVtZW50QXRCZWdpbm5pbmdPZkJsb2NrOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHRleHRWYWwsXG4gICAgICAgICAgICAgICAgc2libGluZztcbiAgICAgICAgICAgIHdoaWxlICghVXRpbC5pc0Jsb2NrQ29udGFpbmVyKG5vZGUpICYmICFVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBub2RlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzaWJsaW5nID0gc2libGluZy5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dFZhbCA9IHNpYmxpbmcubm9kZVR5cGUgPT09IDMgPyBzaWJsaW5nLm5vZGVWYWx1ZSA6IHNpYmxpbmcudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0VmFsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNNZWRpdW1FZGl0b3JFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUgJiYgISFlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1tZWRpdW0tZWRpdG9yLWVsZW1lbnQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250YWluZXJFZGl0b3JFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwudHJhdmVyc2VVcChlbGVtZW50LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQmxvY2tDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSAzICYmIFV0aWwuYmxvY2tDb250YWluZXJFbGVtZW50TmFtZXMuaW5kZXhPZihlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpICE9PSAtMTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiBGaW5kcyB0aGUgY2xvc2VzdCBhbmNlc3RvciB3aGljaCBpcyBhIGJsb2NrIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAqIElmIGVsZW1lbnQgaXMgd2l0aGluIGVkaXRvciBlbGVtZW50IGJ1dCBub3Qgd2l0aGluIGFueSBvdGhlciBibG9jayBlbGVtZW50LFxuICAgICAgICAgKiB0aGUgZWRpdG9yIGVsZW1lbnQgaXMgcmV0dXJuZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldENsb3Nlc3RCbG9ja0NvbnRhaW5lcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlsLnRyYXZlcnNlVXAobm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbC5pc0Jsb2NrQ29udGFpbmVyKG5vZGUpIHx8IFV0aWwuaXNNZWRpdW1FZGl0b3JFbGVtZW50KG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogRmluZHMgaGlnaGVzdCBsZXZlbCBhbmNlc3RvciBlbGVtZW50IHdoaWNoIGlzIGEgYmxvY2sgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgICogSWYgZWxlbWVudCBpcyB3aXRoaW4gZWRpdG9yIGVsZW1lbnQgYnV0IG5vdCB3aXRoaW4gYW55IG90aGVyIGJsb2NrIGVsZW1lbnQsXG4gICAgICAgICAqIHRoZSBlZGl0b3IgZWxlbWVudCBpcyByZXR1cm5lZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VG9wQmxvY2tDb250YWluZXI6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgdG9wQmxvY2sgPSBVdGlsLmlzQmxvY2tDb250YWluZXIoZWxlbWVudCkgPyBlbGVtZW50IDogZmFsc2U7XG4gICAgICAgICAgICBVdGlsLnRyYXZlcnNlVXAoZWxlbWVudCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKFV0aWwuaXNCbG9ja0NvbnRhaW5lcihlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQmxvY2sgPSBlbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0b3BCbG9jayAmJiBVdGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wQmxvY2sgPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRvcEJsb2NrO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEZpcnN0U2VsZWN0YWJsZUxlYWZOb2RlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgd2hpbGUgKGVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBzZXQgdGhlIHNlbGVjdGlvbiB0byBhbiBlbGVtZW50IHRoYXQgY2FuJ3QgaGF2ZSBjaGlsZHJlbiwgdGhpcyBtZXNzZXMgdXAgR2Vja28uXG4gICAgICAgICAgICBlbGVtZW50ID0gVXRpbC50cmF2ZXJzZVVwKGVsZW1lbnQsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlsLmVtcHR5RWxlbWVudE5hbWVzLmluZGV4T2YoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBTZWxlY3RpbmcgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHRhYmxlIGRvZXNuJ3Qgd29yayBpbiBQaGFudG9tSlMuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0Q2VsbCA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGgsIHRkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0Q2VsbCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gZmlyc3RDZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBnZXRGaXJzdFRleHROb2RlIEFORCBfZ2V0Rmlyc3RUZXh0Tm9kZSB3aGVuIGp1bXBpbmcgaW4gNi4wLjAgKG5vIGNvZGUgcmVmZXJlbmNlcylcbiAgICAgICAgZ2V0Rmlyc3RUZXh0Tm9kZTogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIFV0aWwud2FybignZ2V0Rmlyc3RUZXh0Tm9kZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjAuMCcpO1xuICAgICAgICAgICAgcmV0dXJuIFV0aWwuX2dldEZpcnN0VGV4dE5vZGUoZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldEZpcnN0VGV4dE5vZGU6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IFV0aWwuX2dldEZpcnN0VGV4dE5vZGUoZWxlbWVudC5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVuc3VyZVVybEhhc1Byb3RvY29sOiBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaHR0cDovLycgKyB1cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9LFxuXG4gICAgICAgIHdhcm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3aW5kb3cuY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUud2Fybi5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXByZWNhdGVkOiBmdW5jdGlvbiAob2xkTmFtZSwgbmV3TmFtZSwgdmVyc2lvbikge1xuICAgICAgICAgICAgLy8gc2ltcGxlIGRlcHJlY2F0aW9uIHdhcm5pbmcgbWVjaGFuaXNtLlxuICAgICAgICAgICAgdmFyIG0gPSBvbGROYW1lICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyBuZXdOYW1lICsgJyBpbnN0ZWFkLic7XG4gICAgICAgICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgIG0gKz0gJyBXaWxsIGJlIHJlbW92ZWQgaW4gJyArIHZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBVdGlsLndhcm4obSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVwcmVjYXRlZE1ldGhvZDogZnVuY3Rpb24gKG9sZE5hbWUsIG5ld05hbWUsIGFyZ3MsIHZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIHJ1biB0aGUgcmVwbGFjZW1lbnQgYW5kIHdhcm4gd2hlbiBzb21lb25lIGNhbGxzIGEgZGVwcmVjYXRlZCBtZXRob2RcbiAgICAgICAgICAgIFV0aWwuZGVwcmVjYXRlZChvbGROYW1lLCBuZXdOYW1lLCB2ZXJzaW9uKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tuZXdOYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXNbbmV3TmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYW51cEF0dHJzOiBmdW5jdGlvbiAoZWwsIGF0dHJzKSB7XG4gICAgICAgICAgICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYW51cFRhZ3M6IGZ1bmN0aW9uIChlbCwgdGFncykge1xuICAgICAgICAgICAgdGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGdldCB0aGUgY2xvc2VzdCBwYXJlbnRcbiAgICAgICAgZ2V0Q2xvc2VzdFRhZzogZnVuY3Rpb24gKGVsLCB0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlsLnRyYXZlcnNlVXAoZWwsIGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bndyYXA6IGZ1bmN0aW9uIChlbCwgZG9jKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgIG5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZWwuY2hpbGROb2Rlcyk7XG5cbiAgICAgICAgICAgIC8vIGNhc3Qgbm9kZUxpc3QgdG8gYXJyYXkgc2luY2UgYXBwZW5kaW5nIGNoaWxkXG4gICAgICAgICAgICAvLyB0byBhIGRpZmZlcmVudCBub2RlIHdpbGwgYWx0ZXIgbGVuZ3RoIG9mIGVsLmNoaWxkTm9kZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2Rlc1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGZyYWdtZW50LCBlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGd1aWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9zNCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFxuICAgICAgICAgICAgICAgICAgICAuZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApXG4gICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygxNilcbiAgICAgICAgICAgICAgICAgICAgLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9zNCgpICsgX3M0KCkgKyAnLScgKyBfczQoKSArICctJyArIF9zNCgpICsgJy0nICsgX3M0KCkgKyAnLScgKyBfczQoKSArIF9zNCgpICsgX3M0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTWVkaXVtRWRpdG9yLnV0aWwgPSBVdGlsO1xufSh3aW5kb3cpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRXh0ZW5zaW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuZXh0ZW5kKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBFeHRlbnNpb24uZXh0ZW5kID0gZnVuY3Rpb24gKHByb3RvUHJvcHMpIHtcbiAgICAgICAgLy8gbWFnaWMgZXh0ZW5kZXIgdGhpbmdlci4gbW9zdGx5IGJvcnJvd2VkIGZyb20gYmFja2JvbmUvZ29vZy5pbmhlcml0c1xuICAgICAgICAvLyBwbGFjZSB0aGlzIGZ1bmN0aW9uIG9uIHNvbWUgdGhpbmcgeW91IHdhbnQgZXh0ZW5kLWFibGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGV4YW1wbGU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgZnVuY3Rpb24gVGhpbmcoYXJncyl7XG4gICAgICAgIC8vICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGFyZ3M7XG4gICAgICAgIC8vICAgICAgfVxuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgIFRoaW5nLnByb3RvdHlwZSA9IHsgZm9vOiBcImJhclwiIH07XG4gICAgICAgIC8vICAgICAgVGhpbmcuZXh0ZW5kID0gZXh0ZW5kZXJpZnk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgdmFyIFRoaW5nVHdvID0gVGhpbmcuZXh0ZW5kKHsgZm9vOiBcImJhelwiIH0pO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgIHZhciB0aGluZ09uZSA9IG5ldyBUaGluZygpOyAvLyBmb28gPT09IFwiYmFyXCJcbiAgICAgICAgLy8gICAgICB2YXIgdGhpbmdUd28gPSBuZXcgVGhpbmdUd28oKTsgLy8gZm9vID09PSBcImJhelwiXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgd2hpY2ggc2VlbXMgbGlrZSBzb21lIHNpbXBseSBzaGFsbG93IGNvcHkgbm9uc2Vuc2VcbiAgICAgICAgLy8gICAgICBhdCBmaXJzdCwgYnV0IGEgbG90IG1vcmUgaXMgZ29pbmcgb24gdGhlcmUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICAgcGFzc2luZyBhIGBjb25zdHJ1Y3RvcmAgdG8gdGhlIGV4dGVuZCBwcm9wc1xuICAgICAgICAvLyAgICAgIHdpbGwgY2F1c2UgdGhlIGluc3RhbmNlIHRvIGluc3RhbnRpYXRlIHRocm91Z2ggdGhhdFxuICAgICAgICAvLyAgICAgIGluc3RlYWQgb2YgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLFxuICAgICAgICAgICAgY2hpbGQ7XG5cbiAgICAgICAgLy8gVGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgbmV3IHN1YmNsYXNzIGlzIGVpdGhlciBkZWZpbmVkIGJ5IHlvdVxuICAgICAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgICAgICAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuXG4gICAgICAgIGlmIChwcm90b1Byb3BzICYmIHByb3RvUHJvcHMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgICAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkYXMgc3RhdGljcyAoLmV4dGVuZCBjb21lcyBvdmVyLCBzbyB5b3VyIHN1YmNsYXNzIGNhbiBoYXZlIHN1YmNsYXNzZXMgdG9vKVxuICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5leHRlbmQoY2hpbGQsIHBhcmVudCk7XG5cbiAgICAgICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAgICAgLy8gYHBhcmVudGAncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgICAgICAgfTtcbiAgICAgICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBTdXJyb2dhdGUoKTtcblxuICAgICAgICBpZiAocHJvdG9Qcm9wcykge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2RvOiAkc3VwZXI/XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH07XG5cbiAgICBFeHRlbnNpb24ucHJvdG90eXBlID0ge1xuICAgICAgICAvKiBpbml0OiBbZnVuY3Rpb25dXG4gICAgICAgICAqXG4gICAgICAgICAqIENhbGxlZCBieSBNZWRpdW1FZGl0b3IgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgKiBUaGUgLmJhc2UgcHJvcGVydHkgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBzZXQgdG9cbiAgICAgICAgICogY3VycmVudCBpbnN0YW5jZSBvZiBNZWRpdW1FZGl0b3Igd2hlbiB0aGlzIGlzIGNhbGxlZC5cbiAgICAgICAgICogQWxsIGhlbHBlciBtZXRob2RzIHdpbGwgZXhpc3QgYXMgd2VsbFxuICAgICAgICAgKi9cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge30sXG5cbiAgICAgICAgLyogYmFzZTogW01lZGl1bUVkaXRvciBpbnN0YW5jZV1cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbm90IG92ZXJyaWRlbiwgdGhpcyB3aWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAgICAgKiBvZiBNZWRpdW1FZGl0b3IsIGJlZm9yZSB0aGUgaW5pdCBtZXRob2QgaXMgY2FsbGVkXG4gICAgICAgICAqL1xuICAgICAgICBiYXNlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogbmFtZTogW3N0cmluZ11cbiAgICAgICAgICpcbiAgICAgICAgICogJ25hbWUnIG9mIHRoZSBleHRlbnNpb24sIHVzZWQgZm9yIHJldHJpZXZpbmcgdGhlIGV4dGVuc2lvbi5cbiAgICAgICAgICogSWYgbm90IHNldCwgTWVkaXVtRWRpdG9yIHdpbGwgc2V0IHRoaXMgdG8gYmUgdGhlIGtleVxuICAgICAgICAgKiB1c2VkIHdoZW4gcGFzc2luZyB0aGUgZXh0ZW5zaW9uIGludG8gTWVkaXVtRWRpdG9yIHZpYSB0aGVcbiAgICAgICAgICogJ2V4dGVuc2lvbnMnIG9wdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgbmFtZTogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIGNoZWNrU3RhdGU6IFtmdW5jdGlvbiAobm9kZSldXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGltcGxlbWVudGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uZSBvciBtb3JlIHRpbWVzXG4gICAgICAgICAqIHRoZSBzdGF0ZSBvZiB0aGUgZWRpdG9yICYgdG9vbGJhciBhcmUgdXBkYXRlZC5cbiAgICAgICAgICogV2hlbiB0aGUgc3RhdGUgaXMgdXBkYXRlZCwgdGhlIGVkaXRvciBkb2VzIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAqXG4gICAgICAgICAqIDEpIEZpbmQgdGhlIHBhcmVudCBub2RlIGNvbnRhaW5pbmcgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICAgICAqIDIpIENhbGwgY2hlY2tTdGF0ZSBvbiB0aGUgZXh0ZW5zaW9uLCBwYXNzaW5nIHRoZSBub2RlIGFzIGFuIGFyZ3VtZW50XG4gICAgICAgICAqIDMpIEdldCB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIHByZXZpb3VzIG5vZGVcbiAgICAgICAgICogNCkgUmVwZWF0IHN0ZXBzICMyIGFuZCAjMyB1bnRpbCB3ZSBtb3ZlIG91dHNpZGUgdGhlIHBhcmVudCBjb250ZW50ZWRpdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrU3RhdGU6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBkZXN0cm95OiBbZnVuY3Rpb24gKCldXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCByZW1vdmUgYW55IGNyZWF0ZWQgaHRtbCwgY3VzdG9tIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAqIG9yIGFueSBvdGhlciBjbGVhbnVwIHRhc2tzIHRoYXQgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAgICAgICAgICogSWYgaW1wbGVtZW50ZWQsIHRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBNZWRpdW1FZGl0b3Inc1xuICAgICAgICAgKiBkZXN0cm95IG1ldGhvZCBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogQXMgYWx0ZXJuYXRpdmVzIHRvIGNoZWNrU3RhdGUsIHRoZXNlIGZ1bmN0aW9ucyBwcm92aWRlIGEgbW9yZSBzdHJ1Y3R1cmVkXG4gICAgICAgICAqIHBhdGggdG8gdXBkYXRpbmcgdGhlIHN0YXRlIG9mIGFuIGV4dGVuc2lvbiAodXN1YWxseSBhIGJ1dHRvbikgd2hlbmV2ZXJcbiAgICAgICAgICogdGhlIHN0YXRlIG9mIHRoZSBlZGl0b3IgJiB0b29sYmFyIGFyZSB1cGRhdGVkLlxuICAgICAgICAgKi9cblxuICAgICAgICAvKiBxdWVyeUNvbW1hbmRTdGF0ZTogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBpbXBsZW1lbnRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmNlIG9uIGVhY2ggZXh0ZW5zaW9uXG4gICAgICAgICAqIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBlZGl0b3IvdG9vbGJhciBpcyBiZWluZyB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBub24tbnVsbCB2YWx1ZSwgdGhlIGV4dGVuc2lvbiB3aWxsXG4gICAgICAgICAqIGJlIGlnbm9yZWQgYXMgdGhlIGNvZGUgY2xpbWJzIHRoZSBkb20gdHJlZS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRydWUsIGFuZCB0aGUgc2V0QWN0aXZlKCkgZnVuY3Rpb24gaXMgZGVmaW5lZFxuICAgICAgICAgKiBzZXRBY3RpdmUoKSB3aWxsIGJlIGNhbGxlZFxuICAgICAgICAgKi9cbiAgICAgICAgcXVlcnlDb21tYW5kU3RhdGU6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBpc0FjdGl2ZTogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBpbXBsZW1lbnRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIE1lZGl1bUVkaXRvclxuICAgICAgICAgKiBoYXMgZGV0ZXJtaW5lZCB0aGF0IHRoaXMgZXh0ZW5zaW9uIGlzICdhY3RpdmUnIGZvciB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqIFRoaXMgbWF5IGJlIGNhbGxlZCB3aGVuIHRoZSBlZGl0b3IgJiB0b29sYmFyIGFyZSBiZWluZyB1cGRhdGVkLFxuICAgICAgICAgKiBidXQgb25seSBpZiBxdWVyeUNvbW1hbmRTdGF0ZSgpIG9yIGlzQWxyZWFkeUFwcGxpZWQoKSBmdW5jdGlvbnNcbiAgICAgICAgICogYXJlIGltcGxlbWVudGVkLCBhbmQgd2hlbiBjYWxsZWQsIHJldHVybiB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNBY3RpdmU6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBpc0FscmVhZHlBcHBsaWVkOiBbZnVuY3Rpb24gKG5vZGUpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBpbXBsZW1lbnRlZCwgdGhpcyBmdW5jdGlvbiBpcyBzaW1pbGFyIHRvIGNoZWNrU3RhdGUoKSBpblxuICAgICAgICAgKiB0aGF0IGl0IHdpbGwgYmUgY2FsbGVkIHJlcGVhdGVkbHkgYXMgTWVkaXVtRWRpdG9yIG1vdmVzIHVwXG4gICAgICAgICAqIHRoZSBET00gdG8gdXBkYXRlIHRoZSBlZGl0b3IgJiB0b29sYmFyIGFmdGVyIGEgc3RhdGUgY2hhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOT1RFOiBUaGlzIGZ1bmN0aW9uIHdpbGwgTk9UIGJlIGNhbGxlZCBpZiBjaGVja1N0YXRlKCkgaGFzXG4gICAgICAgICAqIGJlZW4gaW1wbGVtZW50ZWQuIFRoaXMgZnVuY3Rpb24gd2lsbCBOT1QgYmUgY2FsbGVkIGlmXG4gICAgICAgICAqIHF1ZXJ5Q29tbWFuZFN0YXRlKCkgaXMgaW1wbGVtZW50ZWQgYW5kIHJldHVybnMgYSBub24tbnVsbFxuICAgICAgICAgKiB2YWx1ZSB3aGVuIGNhbGxlZFxuICAgICAgICAgKi9cbiAgICAgICAgaXNBbHJlYWR5QXBwbGllZDogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIHNldEFjdGl2ZTogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBpbXBsZW1lbnRlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBNZWRpdW1FZGl0b3Iga25vd3NcbiAgICAgICAgICogdGhhdCB0aGlzIGV4dGVuc2lvbiBpcyBjdXJyZW50bHkgZW5hYmxlZC4gIEN1cnJlbnRseSwgdGhpc1xuICAgICAgICAgKiBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiB1cGRhdGluZyB0aGUgZWRpdG9yICYgdG9vbGJhciwgYW5kXG4gICAgICAgICAqIG9ubHkgaWYgcXVlcnlDb21tYW5kU3RhdGUoKSBvciBpc0FscmVhZHlBcHBsaWVkKG5vZGUpIHJldHVyblxuICAgICAgICAgKiB0cnVlIHdoZW4gY2FsbGVkXG4gICAgICAgICAqL1xuICAgICAgICBzZXRBY3RpdmU6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBzZXRJbmFjdGl2ZTogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBpbXBsZW1lbnRlZCwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBNZWRpdW1FZGl0b3Iga25vd3NcbiAgICAgICAgICogdGhhdCB0aGlzIGV4dGVuc2lvbiBpcyBjdXJyZW50bHkgZGlzYWJsZWQuICBDdXJlbnRseSwgdGhpc1xuICAgICAgICAgKiBpcyBjYWxsZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBlYWNoIHN0YXRlIGNoYW5nZSBmb3JcbiAgICAgICAgICogdGhlIGVkaXRvciAmIHRvb2xiYXIuIEFmdGVyIGNhbGxpbmcgdGhpcywgTWVkaXVtRWRpdG9yXG4gICAgICAgICAqIHdpbGwgYXR0ZW1wdCB0byB1cGRhdGUgdGhlIGV4dGVuc2lvbiwgZWl0aGVyIHZpYSBjaGVja1N0YXRlKClcbiAgICAgICAgICogb3IgdGhlIGNvbWJpbmF0aW9uIG9mIHF1ZXJ5Q29tbWFuZFN0YXRlKCksIGlzQWxyZWFkeUFwcGxpZWQobm9kZSksXG4gICAgICAgICAqIGlzQWN0aXZlKCksIGFuZCBzZXRBY3RpdmUoKVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0SW5hY3RpdmU6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBnZXRJbnRlcmFjdGlvbkVsZW1lbnRzOiBbZnVuY3Rpb24gKCldXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBleHRlbnNpb24gcmVuZGVycyBhbnkgZWxlbWVudHMgdGhhdCB0aGUgdXNlciBjYW4gaW50ZXJhY3Qgd2l0aCxcbiAgICAgICAgICogdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGltcGxlbWVudGVkIGFuZCByZXR1cm4gdGhlIHJvb3QgZWxlbWVudCBvciBhbiBhcnJheVxuICAgICAgICAgKiBjb250YWluaW5nIGFsbCBvZiB0aGUgcm9vdCBlbGVtZW50cy4gTWVkaXVtRWRpdG9yIHdpbGwgY2FsbCB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAqIGR1cmluZyBpbnRlcmFjdGlvbiB0byBzZWUgaWYgdGhlIHVzZXIgY2xpY2tlZCBvbiBzb21ldGhpbmcgb3V0c2lkZSBvZiB0aGUgZWRpdG9yLlxuICAgICAgICAgKiBUaGUgZWxlbWVudHMgYXJlIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRhcmdldCBlbGVtZW50IG9mIGEgY2xpY2sgb3JcbiAgICAgICAgICogb3RoZXIgdXNlciBldmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYW55IGV4dGVuc2lvbiBlbGVtZW50cy5cbiAgICAgICAgICogVGhpcyB3YXksIHRoZSBlZGl0b3IgY2FuIGFsc28gY291bnQgdXNlciBpbnRlcmFjdGlvbiB3aXRoaW4gZWRpdG9yIGVsZW1lbnRzIGFzXG4gICAgICAgICAqIGludGVyYWN0aW9ucyB3aXRoIHRoZSBlZGl0b3IsIGFuZCB0aHVzIG5vdCB0cmlnZ2VyICdibHVyJ1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0SW50ZXJhY3Rpb25FbGVtZW50czogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiogSGVscGVycyAqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBhcmUgaGVscGVycyB0aGF0IGFyZSBlaXRoZXIgc2V0IGJ5IE1lZGl1bUVkaXRvclxuICAgICAgICAgKiBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIG9yIGFyZSBoZWxwZXIgbWV0aG9kcyB3aGljaCBlaXRoZXJcbiAgICAgICAgICogcm91dGUgY2FsbHMgdG8gdGhlIE1lZGl1bUVkaXRvciBpbnN0YW5jZSBvciBwcm92aWRlIGNvbW1vblxuICAgICAgICAgKiBmdW5jdGlvbmFsaXR5IGZvciBhbGwgZXh0ZW5zaW9uc1xuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAgIC8qIHdpbmRvdzogW1dpbmRvd11cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbm90IG92ZXJyaWRlbiwgdGhpcyB3aWxsIGJlIHNldCB0byB0aGUgd2luZG93IG9iamVjdFxuICAgICAgICAgKiB0byBiZSB1c2VkIGJ5IE1lZGl1bUVkaXRvciBhbmQgaXRzIGV4dGVuc2lvbnMuICBUaGlzIGlzXG4gICAgICAgICAqIHBhc3NlZCB2aWEgdGhlICdjb250ZW50V2luZG93JyBvcHRpb24gdG8gTWVkaXVtRWRpdG9yXG4gICAgICAgICAqIGFuZCBpcyB0aGUgZ2xvYmFsICd3aW5kb3cnIG9iamVjdCBieSBkZWZhdWx0XG4gICAgICAgICAqL1xuICAgICAgICAnd2luZG93JzogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIGRvY3VtZW50OiBbRG9jdW1lbnRdXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIG5vdCBvdmVycmlkZW4sIHRoaXMgd2lsbCBiZSBzZXQgdG8gdGhlIGRvY3VtZW50IG9iamVjdFxuICAgICAgICAgKiB0byBiZSB1c2VkIGJ5IE1lZGl1bUVkaXRvciBhbmQgaXRzIGV4dGVuc2lvbnMuIFRoaXMgaXNcbiAgICAgICAgICogcGFzc2VkIHZpYSB0aGUgJ293bmVyRG9jdW1lbnQnIG9wdGluIHRvIE1lZGl1bUVkaXRvclxuICAgICAgICAgKiBhbmQgaXMgdGhlIGdsb2JhbCAnZG9jdW1lbnQnIG9iamVjdCBieSBkZWZhdWx0XG4gICAgICAgICAqL1xuICAgICAgICAnZG9jdW1lbnQnOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogZ2V0RWRpdG9yRWxlbWVudHM6IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZ1xuICAgICAgICAgKiBhbGwgdGhlIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50cyBmb3IgdGhpcyBpbnN0YW5jZVxuICAgICAgICAgKiBvZiBNZWRpdW1FZGl0b3JcbiAgICAgICAgICovXG4gICAgICAgIGdldEVkaXRvckVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlLmVsZW1lbnRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGdldEVkaXRvcklkOiBbZnVuY3Rpb24gKCldXG4gICAgICAgICAqXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgdW5pcXVlIGlkZW50aWZpZXJcbiAgICAgICAgICogZm9yIHRoaXMgaW5zdGFuY2Ugb2YgTWVkaXVtRWRpdG9yXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFZGl0b3JJZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZS5pZDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiBnZXRFZGl0b3JPcHRpb25zOiBbZnVuY3Rpb24gKG9wdGlvbildXG4gICAgICAgICAqXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBvcHRpb25cbiAgICAgICAgICogdXNlZCB0byBpbml0aWFsaXplIHRoaXMgaW5zdGFuY2Ugb2YgTWVkaXVtRWRpdG9yXG4gICAgICAgICAqL1xuICAgICAgICBnZXRFZGl0b3JPcHRpb246IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2Uub3B0aW9uc1tvcHRpb25dO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qIExpc3Qgb2YgbWV0aG9kIG5hbWVzIHRvIGFkZCB0byB0aGUgcHJvdG90eXBlIG9mIEV4dGVuc2lvblxuICAgICAqIEVhY2ggb2YgdGhlc2UgbWV0aG9kcyB3aWxsIGJlIGRlZmluZWQgYXMgaGVscGVycyB0aGF0XG4gICAgICoganVzdCBjYWxsIGRpcmVjdGx5IGludG8gdGhlIE1lZGl1bUVkaXRvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIGV4YW1wbGUgZm9yICdvbicgbWV0aG9kOlxuICAgICAqIEV4dGVuc2lvbi5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgIHJldHVybiB0aGlzLmJhc2Uub24uYXBwbHkodGhpcy5iYXNlLCBhcmd1bWVudHMpO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICBbXG4gICAgICAgIC8vIGdlbmVyYWwgaGVscGVyc1xuICAgICAgICAnZXhlY0FjdGlvbicsXG5cbiAgICAgICAgLy8gZXZlbnQgaGFuZGxpbmdcbiAgICAgICAgJ29uJyxcbiAgICAgICAgJ29mZicsXG4gICAgICAgICdzdWJzY3JpYmUnLFxuICAgICAgICAndHJpZ2dlcidcblxuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoaGVscGVyKSB7XG4gICAgICAgIEV4dGVuc2lvbi5wcm90b3R5cGVbaGVscGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VbaGVscGVyXS5hcHBseSh0aGlzLmJhc2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uID0gRXh0ZW5zaW9uO1xufSkoKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJPbmx5UGFyZW50RWxlbWVudHMobm9kZSkge1xuICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNCbG9ja0NvbnRhaW5lcihub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFNlbGVjdGlvbiA9IHtcbiAgICAgICAgZmluZE1hdGNoaW5nU2VsZWN0aW9uUGFyZW50OiBmdW5jdGlvbiAodGVzdEVsZW1lbnRGdW5jdGlvbiwgY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGNvbnRlbnRXaW5kb3cuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICAgICAgY3VycmVudDtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgY3VycmVudCA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gICAgICAgICAgICByZXR1cm4gTWVkaXVtRWRpdG9yLnV0aWwudHJhdmVyc2VVcChjdXJyZW50LCB0ZXN0RWxlbWVudEZ1bmN0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTZWxlY3Rpb25FbGVtZW50OiBmdW5jdGlvbiAoY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluZE1hdGNoaW5nU2VsZWN0aW9uUGFyZW50KGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNZWRpdW1FZGl0b3IudXRpbC5pc01lZGl1bUVkaXRvckVsZW1lbnQoZWwpO1xuICAgICAgICAgICAgfSwgY29udGVudFdpbmRvdyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNzY3ODg0My9jYW50LXJlc3RvcmUtc2VsZWN0aW9uLWFmdGVyLWh0bWwtbW9kaWZ5LWV2ZW4taWYtaXRzLXRoZS1zYW1lLWh0bWxcbiAgICAgICAgLy8gVGltIERvd25cbiAgICAgICAgZXhwb3J0U2VsZWN0aW9uOiBmdW5jdGlvbiAocm9vdCwgZG9jKSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblN0YXRlID0gbnVsbCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBkb2MuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uUmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHJvb3QpO1xuICAgICAgICAgICAgICAgIHByZVNlbGVjdGlvblJhbmdlLnNldEVuZChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcHJlU2VsZWN0aW9uUmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHN0YXJ0ICsgcmFuZ2UudG9TdHJpbmcoKS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBzZWxlY3Rpb24gc3RhcnRzIHdpdGggYW55IGltYWdlc1xuICAgICAgICAgICAgICAgIC8vIGlmIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWxlY3Rpb24gaXNcbiAgICAgICAgICAgICAgICAvLyBzZXQgY29ycmVjdGx5IHdoZW4gaW1wb3J0aW5nIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvZXNSYW5nZVN0YXJ0V2l0aEltYWdlcyhyYW5nZSwgZG9jKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZS5zdGFydHNXaXRoSW1hZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgc2VsZWN0aW9uIGhhcyBhbnkgdHJhaWxpbmcgaW1hZ2VzXG4gICAgICAgICAgICAgICAgLy8gaWYgc28sIHRoaXMgdGhpcyBtZWFucyB3ZSBuZWVkIHRvIGxvb2sgZm9yIHRoZW0gd2hlbiB3ZSBpbXBvcnQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIHRyYWlsaW5nSW1hZ2VDb3VudCA9IHRoaXMuZ2V0VHJhaWxpbmdJbWFnZUNvdW50KHJvb3QsIHNlbGVjdGlvblN0YXRlLCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWlsaW5nSW1hZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZS50cmFpbGluZ0ltYWdlQ291bnQgPSB0cmFpbGluZ0ltYWdlQ291bnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgc3RhcnQgPSAwIHRoZXJlIG1heSBzdGlsbCBiZSBhbiBlbXB0eSBwYXJhZ3JhcGggYmVmb3JlIGl0LCBidXQgd2UgZG9uJ3QgY2FyZS5cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVtcHR5QmxvY2tzSW5kZXggPSB0aGlzLmdldEluZGV4UmVsYXRpdmVUb0FkamFjZW50RW1wdHlCbG9ja3MoZG9jLCByb290LCByYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHlCbG9ja3NJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlLmVtcHR5QmxvY2tzSW5kZXggPSBlbXB0eUJsb2Nrc0luZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNzY3ODg0My9jYW50LXJlc3RvcmUtc2VsZWN0aW9uLWFmdGVyLWh0bWwtbW9kaWZ5LWV2ZW4taWYtaXRzLXRoZS1zYW1lLWh0bWxcbiAgICAgICAgLy8gVGltIERvd25cbiAgICAgICAgLy9cbiAgICAgICAgLy8ge29iamVjdH0gc2VsZWN0aW9uU3RhdGUgLSB0aGUgc2VsZWN0aW9uIHRvIGltcG9ydFxuICAgICAgICAvLyB7RE9NRWxlbWVudH0gcm9vdCAtIHRoZSByb290IGVsZW1lbnQgdGhlIHNlbGVjdGlvbiBpcyBiZWluZyByZXN0b3JlZCBpbnNpZGUgb2ZcbiAgICAgICAgLy8ge0RvY3VtZW50fSBkb2MgLSB0aGUgZG9jdW1lbnQgdG8gdXNlIGZvciBtYW5hZ2luZyBzZWxlY3Rpb25cbiAgICAgICAgLy8ge2Jvb2xlYW59IFtmYXZvckxhdGVyU2VsZWN0aW9uQW5jaG9yXSAtIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiB0cnVlLCBpbXBvcnQgdGhlIGN1cnNvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyAgICAgIHN1YnNlcXVlbnQgdG8gYW4gYW5jaG9yIHRhZyBpZiBpdCB3b3VsZCBvdGhlcndpc2UgYmUgcGxhY2VkIHJpZ2h0IGF0IHRoZSB0cmFpbGluZyBlZGdlIGluc2lkZSB0aGVcbiAgICAgICAgLy8gICAgICBhbmNob3IuIFRoaXMgY3Vyc29yIHBvc2l0aW9uaW5nLCBldmVuIHRob3VnaCB2aXN1YWxseSBlcXVpdmFsZW50IHRvIHRoZSB1c2VyLCBjYW4gYWZmZWN0IGJlaGF2aW9yXG4gICAgICAgIC8vICAgICAgaW4gTVMgSUUuXG4gICAgICAgIGltcG9ydFNlbGVjdGlvbjogZnVuY3Rpb24gKHNlbGVjdGlvblN0YXRlLCByb290LCBkb2MsIGZhdm9yTGF0ZXJTZWxlY3Rpb25BbmNob3IpIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uU3RhdGUgfHwgIXJvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQocm9vdCwgMCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcblxuICAgICAgICAgICAgdmFyIG5vZGUgPSByb290LFxuICAgICAgICAgICAgICAgIG5vZGVTdGFjayA9IFtdLFxuICAgICAgICAgICAgICAgIGNoYXJJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgZm91bmRTdGFydCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZvdW5kRW5kID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdHJhaWxpbmdJbWFnZUNvdW50ID0gMCxcbiAgICAgICAgICAgICAgICBzdG9wID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbmV4dENoYXJJbmRleCxcbiAgICAgICAgICAgICAgICBhbGxvd1JhbmdlVG9TdGFydEF0RW5kT2ZOb2RlID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbGFzdFRleHROb2RlID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gV2hlbiBpbXBvcnRpbmcgc2VsZWN0aW9uLCB0aGUgc3RhcnQgb2YgdGhlIHNlbGVjdGlvbiBtYXkgbGllIGF0IHRoZSBlbmQgb2YgYW4gZWxlbWVudFxuICAgICAgICAgICAgLy8gb3IgYXQgdGhlIGJlZ2lubmluZyBvZiBhbiBlbGVtZW50LiAgU2luY2UgdmlzdWFsbHkgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZXNlIDJcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgdHJ5IHRvIG1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgYmVnaW5uaW5nIG9mIGFuIGVsZW1lbnQgc2luY2UgdGhpcyBpcyBnZW5lcmFsbHlcbiAgICAgICAgICAgIC8vIHdoYXQgdXNlcnMgd2lsbCBleHBlY3QgYW5kIGl0J3MgYSBtb3JlIHByZWRpY3RhYmxlIGJlaGF2aW9yLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoZXJlIGFyZSBzb21lIHNwZWNpZmljIGNhc2VzIHdoZW4gd2UgZG9uJ3Qgd2FudCB0byBkbyB0aGlzOlxuICAgICAgICAgICAgLy8gIDEpIFdlJ3JlIGF0dGVtcHRpbmcgdG8gbW92ZSB0aGUgY3Vyc29yIG91dHNpZGUgb2YgdGhlIGVuZCBvZiBhbiBhbmNob3IgW2Zhdm9yTGF0ZXJTZWxlY3Rpb25BbmNob3IgPSB0cnVlXVxuICAgICAgICAgICAgLy8gIDIpIFRoZSBzZWxlY3Rpb24gc3RhcnRzIHdpdGggYW4gaW1hZ2UsIHdoaWNoIGlzIHNwZWNpYWwgc2luY2UgYW4gaW1hZ2UgZG9lc24ndCBoYXZlIGFueSAnY29udGVudCdcbiAgICAgICAgICAgIC8vICAgICBhcyBmYXIgYXMgc2VsZWN0aW9uIGFuZCByYW5nZXMgYXJlIGNvbmNlcm5lZFxuICAgICAgICAgICAgLy8gIDMpIFRoZSBzZWxlY3Rpb24gc3RhcnRzIGFmdGVyIGEgc3BlY2lmaWVkIG51bWJlciBvZiBlbXB0eSBibG9jayBlbGVtZW50cyAoc2VsZWN0aW9uU3RhdGUuZW1wdHlCbG9ja3NJbmRleClcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgdGhlc2UgY2FzZXMsIHdlIHdhbnQgdGhlIHNlbGVjdGlvbiB0byBzdGFydCBhdCBhIHZlcnkgc3BlY2lmaWMgbG9jYXRpb24sIHNvIHdlIHNob3VsZCBOT1RcbiAgICAgICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgbW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGZpcnN0IGFjdHVhbCBjaHVuayBvZiB0ZXh0XG4gICAgICAgICAgICBpZiAoZmF2b3JMYXRlclNlbGVjdGlvbkFuY2hvciB8fCBzZWxlY3Rpb25TdGF0ZS5zdGFydHNXaXRoSW1hZ2UgfHwgdHlwZW9mIHNlbGVjdGlvblN0YXRlLmVtcHR5QmxvY2tzSW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dSYW5nZVRvU3RhcnRBdEVuZE9mTm9kZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlICghc3RvcCAmJiBub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBpdGVyYXRlIG92ZXIgZWxlbWVudHMgYW5kIHRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGl0IGEgdGV4dCBub2RlLCB3ZSBuZWVkIHRvIGFkZCB0aGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gdGhlIG92ZXJhbGwgY291bnRcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAhZm91bmRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXJJbmRleCA9IGNoYXJJbmRleCArIG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBhdCBvciBiZXlvbmQgdGhlIHN0YXJ0IG9mIHRoZSBzZWxlY3Rpb24gd2UncmUgaW1wb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFydCAmJiBzZWxlY3Rpb25TdGF0ZS5zdGFydCA+PSBjaGFySW5kZXggJiYgc2VsZWN0aW9uU3RhdGUuc3RhcnQgPD0gbmV4dENoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogV2Ugb25seSB3YW50IHRvIGFsbG93IGEgc2VsZWN0aW9uIHRvIHN0YXJ0IGF0IHRoZSBFTkQgb2YgYW4gZWxlbWVudCBpZlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGFsbG93UmFuZ2VUb1N0YXJ0QXRFbmRPZk5vZGUgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93UmFuZ2VUb1N0YXJ0QXRFbmRPZk5vZGUgfHwgc2VsZWN0aW9uU3RhdGUuc3RhcnQgPCBuZXh0Q2hhckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgc2VsZWN0aW9uU3RhdGUuc3RhcnQgLSBjaGFySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgYXQgdGhlIGVuZCBvZiBhIHRleHQgbm9kZSB3aGVyZSB0aGUgc2VsZWN0aW9uIGNvdWxkIHN0YXJ0IGJ1dCB3ZSBzaG91bGRuJ3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIHNlbGVjdGlvbiBzdGFydCBoZXJlIGJlY2F1c2UgYWxsb3dSYW5nZVRvU3RhcnRBdEVuZE9mTm9kZSBpcyBmYWxzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHdlIHNob3VsZCBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoaXMgbm9kZSBpbiBjYXNlIHRoZXJlIGFyZW4ndCBhbnkgbW9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGV4dCBub2RlcyBhZnRlciB0aGlzLCBzbyB0aGF0IHdlIGhhdmUgc29tZXdoZXJlIHRvIGltcG9ydCB0aGUgc2VsZWN0aW9uIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0VGV4dE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGZvdW5kIHRoZSBzdGFydCBvZiB0aGUgc2VsZWN0aW9uLCBjaGVjayBpZiB3ZSdyZSBhdCBvciBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgc2VsZWN0aW9uIHdlJ3JlIGltcG9ydGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGFydCAmJiBzZWxlY3Rpb25TdGF0ZS5lbmQgPj0gY2hhckluZGV4ICYmIHNlbGVjdGlvblN0YXRlLmVuZCA8PSBuZXh0Q2hhckluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvblN0YXRlLnRyYWlsaW5nSW1hZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChub2RlLCBzZWxlY3Rpb25TdGF0ZS5lbmQgLSBjaGFySW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEVuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckluZGV4ID0gbmV4dENoYXJJbmRleDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUudHJhaWxpbmdJbWFnZUNvdW50ICYmIGZvdW5kRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW1nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSW1hZ2VDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWlsaW5nSW1hZ2VDb3VudCA9PT0gc2VsZWN0aW9uU3RhdGUudHJhaWxpbmdJbWFnZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB3aGljaCBpbmRleCB0aGUgaW1hZ2UgaXMgaW4gaXRzIHBhcmVudCdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbZW5kSW5kZXhdICE9PSBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZChub2RlLnBhcmVudE5vZGUsIGVuZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3AgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWxsIGl0cyBjaGlsZHJlbiB0byB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVN0YWNrLnB1c2gobm9kZS5jaGlsZE5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGdvbmUgdGhyb3VnaCB0aGUgZW50aXJlIHRleHQgYnV0IGRpZG4ndCBmaW5kIHRoZSBiZWdpbm5pbmcgb2YgYSB0ZXh0IG5vZGVcbiAgICAgICAgICAgIC8vIHRvIG1ha2UgdGhlIHNlbGVjdGlvbiBzdGFydCBhdCwgd2Ugc2hvdWxkIGZhbGwgYmFjayB0byBzdGFydGluZyB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAvLyBhdCB0aGUgRU5EIG9mIHRoZSBsYXN0IHRleHQgbm9kZSB3ZSBmb3VuZFxuICAgICAgICAgICAgaWYgKCFmb3VuZFN0YXJ0ICYmIGxhc3RUZXh0Tm9kZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KGxhc3RUZXh0Tm9kZSwgbGFzdFRleHROb2RlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGxhc3RUZXh0Tm9kZSwgbGFzdFRleHROb2RlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0aW9uU3RhdGUuZW1wdHlCbG9ja3NJbmRleCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuaW1wb3J0U2VsZWN0aW9uTW92ZUN1cnNvclBhc3RCbG9ja3MoZG9jLCByb290LCBzZWxlY3Rpb25TdGF0ZS5lbXB0eUJsb2Nrc0luZGV4LCByYW5nZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBzZWxlY3Rpb24gaXMgcmlnaHQgYXQgdGhlIGVuZGluZyBlZGdlIG9mIGEgbGluaywgcHV0IGl0IG91dHNpZGUgdGhlIGFuY2hvciB0YWcgaW5zdGVhZCBvZiBpbnNpZGUuXG4gICAgICAgICAgICBpZiAoZmF2b3JMYXRlclNlbGVjdGlvbkFuY2hvcikge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5pbXBvcnRTZWxlY3Rpb25Nb3ZlQ3Vyc29yUGFzdEFuY2hvcihzZWxlY3Rpb25TdGF0ZSwgcmFuZ2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdFJhbmdlKGRvYywgcmFuZ2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFV0aWxpdHkgbWV0aG9kIGNhbGxlZCBmcm9tIGltcG9ydFNlbGVjdGlvbiBvbmx5XG4gICAgICAgIGltcG9ydFNlbGVjdGlvbk1vdmVDdXJzb3JQYXN0QW5jaG9yOiBmdW5jdGlvbiAoc2VsZWN0aW9uU3RhdGUsIHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUluc2lkZUFuY2hvclRhZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYSc7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXRlLnN0YXJ0ID09PSBzZWxlY3Rpb25TdGF0ZS5lbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc3RhcnRPZmZzZXQgPT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVWYWx1ZS5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwudHJhdmVyc2VVcChyYW5nZS5zdGFydENvbnRhaW5lciwgbm9kZUluc2lkZUFuY2hvclRhZ0Z1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsICYmIGN1cnJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdhJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuY2hpbGROb2Rlc1tjdXJyZW50Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDFdICE9PSBwcmV2Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldk5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgIT09IG51bGwgJiYgY3VycmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZUluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGN1cnJlbnROb2RlSW5kZXggPT09IG51bGwgJiYgaSA8IGN1cnJlbnROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlc1tpXSA9PT0gY3VycmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChjdXJyZW50Tm9kZS5wYXJlbnROb2RlLCBjdXJyZW50Tm9kZUluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBVc2VzIHRoZSBlbXB0eUJsb2Nrc0luZGV4IGNhbGN1bGF0ZWQgYnkgZ2V0SW5kZXhSZWxhdGl2ZVRvQWRqYWNlbnRFbXB0eUJsb2Nrc1xuICAgICAgICAvLyB0byBtb3ZlIHRoZSBjdXJzb3IgYmFjayB0byB0aGUgc3RhcnQgb2YgdGhlIGNvcnJlY3QgcGFyYWdyYXBoXG4gICAgICAgIGltcG9ydFNlbGVjdGlvbk1vdmVDdXJzb3JQYXN0QmxvY2tzOiBmdW5jdGlvbiAoZG9jLCByb290LCBpbmRleCwgcmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jLmNyZWF0ZVRyZWVXYWxrZXIocm9vdCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIGZpbHRlck9ubHlQYXJlbnRFbGVtZW50cywgZmFsc2UpLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgICAgICAgc3RhcnRCbG9jayxcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIGN1cnJJbmRleCA9IDA7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4IHx8IDE7IC8vIElmIGluZGV4IGlzIDAsIHdlIHN0aWxsIHdhbnQgdG8gbW92ZSB0byB0aGUgbmV4dCBibG9ja1xuXG4gICAgICAgICAgICAvLyBDaHJvbWUgY291bnRzIG5ld2xpbmVzIGFuZCBzcGFjZXMgdGhhdCBzZXBhcmF0ZSBibG9jayBlbGVtZW50cyBhcyBhY3R1YWwgZWxlbWVudHMuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGluc2lkZSBvbmUgb2YgdGhlc2UgdGV4dCBub2RlcywgYW5kIGl0IGhhcyBhIHByZXZpb3VzIHNpYmxpbmdcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIGEgYmxvY2sgZWxlbWVudCwgd2Ugd2FudCB0aGUgdHJlZXdhbGtlciB0byBzdGFydCBhdCB0aGUgcHJldmlvdXMgc2libGluZ1xuICAgICAgICAgICAgLy8gYW5kIE5PVCBhdCB0aGUgcGFyZW50IG9mIHRoZSB0ZXh0bm9kZVxuICAgICAgICAgICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSAzICYmIE1lZGl1bUVkaXRvci51dGlsLmlzQmxvY2tDb250YWluZXIoc3RhcnRDb250YWluZXIucHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBzdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2sgPSBNZWRpdW1FZGl0b3IudXRpbC5nZXRDbG9zZXN0QmxvY2tDb250YWluZXIoc3RhcnRDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTa2lwIG92ZXIgZW1wdHkgYmxvY2tzIHVudGlsIHdlIGhpdCB0aGUgYmxvY2sgd2Ugd2FudCB0aGUgc2VsZWN0aW9uIHRvIGJlIGluXG4gICAgICAgICAgICB3aGlsZSAodHJlZVdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgYmxvY2tzIHVudGlsIHdlIGhpdCB0aGUgc3RhcnRpbmcgYmxvY2sgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRCbG9jayA9PT0gdHJlZVdhbGtlci5jdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRyZWVXYWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gdHJlZVdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY3VyckluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhpdCB0aGUgdGFyZ2V0IGluZGV4LCBiYWlsXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJySW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmaW5kIGEgbm9uLWVtcHR5IGJsb2NrLCBpZ25vcmUgdGhlIGVtcHR5QmxvY2tzSW5kZXggYW5kIGp1c3QgcHV0IHNlbGVjdGlvbiBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXROb2RlLnRleHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gc3RhcnRCbG9jaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UncmUgc2VsZWN0aW5nIGEgaGlnaC1sZXZlbCBibG9jayBub2RlLCBzbyBtYWtlIHN1cmUgdGhlIGN1cnNvciBnZXRzIG1vdmVkIGludG8gdGhlIGRlZXBlc3RcbiAgICAgICAgICAgIC8vIGVsZW1lbnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYmxvY2tcbiAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0KE1lZGl1bUVkaXRvci51dGlsLmdldEZpcnN0U2VsZWN0YWJsZUxlYWZOb2RlKHRhcmdldE5vZGUpLCAwKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJldHVybnMgLTEgdW5sZXNzIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHBhcmFncmFwaC9ibG9ja1xuICAgICAgICAvLyBJZiB0aGUgcGFyYWdyYXBoL2Jsb2NrIGlzIHByZWNlZWRlZCBieSBlbXB0eSBwYXJhZ3JhcGhzL2Jsb2NrICh3aXRoIG5vIHRleHQpXG4gICAgICAgIC8vIGl0IHdpbGwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZW1wdHkgcGFyYWdyYXBocyBiZWZvcmUgdGhlIGN1cnNvci5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiAwLCB3aGljaCBpbmRpY2F0ZXMgdGhlIGN1cnNvciBpcyBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgIC8vIG9mIGEgcGFyYWdyYXBoL2Jsb2NrLCBhbmQgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHBhcmFncmFwaC9ibG9jayBiZWZvcmUgaXRcbiAgICAgICAgZ2V0SW5kZXhSZWxhdGl2ZVRvQWRqYWNlbnRFbXB0eUJsb2NrczogZnVuY3Rpb24gKGRvYywgcm9vdCwgY3Vyc29yQ29udGFpbmVyLCBjdXJzb3JPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIHRleHQgaW4gZnJvbnQgb2YgdGhlIGN1cnNvciwgdGhhdCBtZWFucyB0aGVyZSBpc24ndCBvbmx5IGVtcHR5IGJsb2NrcyBiZWZvcmUgaXRcbiAgICAgICAgICAgIGlmIChjdXJzb3JDb250YWluZXIudGV4dENvbnRlbnQubGVuZ3RoID4gMCAmJiBjdXJzb3JPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYmxvY2sgdGhhdCBjb250YWlucyB0aGUgY3Vyc29yIGhhcyBhbnkgb3RoZXIgdGV4dCBpbiBmcm9udCBvZiB0aGUgY3Vyc29yXG4gICAgICAgICAgICB2YXIgbm9kZSA9IGN1cnNvckNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IGN1cnNvckNvbnRhaW5lci5jaGlsZE5vZGVzW2N1cnNvck9mZnNldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGlzbid0IGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBibG9jaywgc28gaXQgaGFzIGNvbnRlbnQgYmVmb3JlIGl0XG4gICAgICAgICAgICAgICAgaWYgKCFNZWRpdW1FZGl0b3IudXRpbC5pc0VsZW1lbnRBdEJlZ2lubmluZ09mQmxvY2sobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1NpYmxpbmcgPSBNZWRpdW1FZGl0b3IudXRpbC5maW5kUHJldmlvdXNTaWJsaW5nKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIHNpYmxpbmcsIHRoaXMgaXMgdGhlIGZpcnN0IHRleHQgZWxlbWVudCBpbiB0aGUgZWRpdG9yXG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgc2libGluZyBoYXMgdGV4dCwgdGhlbiB0aGVyZSBhcmUgbm8gZW1wdHkgYmxvY2tzIGJlZm9yZSB0aGlzXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldmlvdXNTaWJsaW5nLm5vZGVWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYWxrIG92ZXIgYmxvY2sgZWxlbWVudHMsIGNvdW50aW5nIG51bWJlciBvZiBlbXB0eSBibG9ja3MgYmV0d2VlbiBsYXN0IHBpZWNlIG9mIHRleHRcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgYmxvY2sgdGhlIGN1cnNvciBpcyBpblxuICAgICAgICAgICAgdmFyIGNsb3Nlc3RCbG9jayA9IE1lZGl1bUVkaXRvci51dGlsLmdldENsb3Nlc3RCbG9ja0NvbnRhaW5lcihjdXJzb3JDb250YWluZXIpLFxuICAgICAgICAgICAgICAgIHRyZWVXYWxrZXIgPSBkb2MuY3JlYXRlVHJlZVdhbGtlcihyb290LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgZmlsdGVyT25seVBhcmVudEVsZW1lbnRzLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgZW1wdHlCbG9ja3NDb3VudCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodHJlZVdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrSXNFbXB0eSA9IHRyZWVXYWxrZXIuY3VycmVudE5vZGUudGV4dENvbnRlbnQgPT09ICcnO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja0lzRW1wdHkgfHwgZW1wdHlCbG9ja3NDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlCbG9ja3NDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJlZVdhbGtlci5jdXJyZW50Tm9kZSA9PT0gY2xvc2VzdEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eUJsb2Nrc0NvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrSXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eUJsb2Nrc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbXB0eUJsb2Nrc0NvdW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIHJhbmdlIGJlZ2lucyB3aXRoIGFuIGltYWdlIHRhZ1xuICAgICAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSByYW5nZSBzdGFydHMgd2l0aCBhbnkgbm9uIGVtcHR5IHRleHQgbm9kZXNcbiAgICAgICAgZG9lc1JhbmdlU3RhcnRXaXRoSW1hZ2VzOiBmdW5jdGlvbiAocmFuZ2UsIGRvYykge1xuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0T2Zmc2V0ICE9PSAwIHx8IHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGltZyA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmVlV2Fsa2VyID0gZG9jLmNyZWF0ZVRyZWVXYWxrZXIocmFuZ2Uuc3RhcnRDb250YWluZXIsIE5vZGVGaWx0ZXIuU0hPV19BTEwsIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIHdoaWxlICh0cmVlV2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRyZWVXYWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGl0IHRoZSBpbWFnZSwgdGhlbiB0aGVyZSBpc24ndCBhbnkgdGV4dCBiZWZvcmUgdGhlIGltYWdlIHNvXG4gICAgICAgICAgICAgICAgLy8gdGhlIGltYWdlIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IGltZykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBoaXQgdGhlIGlhbWdlLCBidXQgZm91bmQgdGV4dCB0aGF0IGNvbnRhaW5zIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHRoZSByYW5nZSBkb2Vzbid0IHN0YXJ0IHdpdGggYW4gaW1hZ2VcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VHJhaWxpbmdJbWFnZUNvdW50OiBmdW5jdGlvbiAocm9vdCwgc2VsZWN0aW9uU3RhdGUsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZW5kT2Zmc2V0IG9mIGEgcmFuZ2UgaXMgMCwgdGhlIGVuZENvbnRhaW5lciBkb2Vzbid0IGNvbnRhaW4gaW1hZ2VzXG4gICAgICAgICAgICAvLyBJZiB0aGUgZW5kQ29udGFpbmVyIGlzIGEgdGV4dCBub2RlLCB0aGVyZSBhcmUgbm8gdHJhaWxpbmcgaW1hZ2VzXG4gICAgICAgICAgICBpZiAoZW5kT2Zmc2V0ID09PSAwIHx8IGVuZENvbnRhaW5lci5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZW5kQ29udGFpbmVyIGlzbid0IGFuIGltYWdlLCBhbmQgZG9lc24ndCBoYXZlIGFuIGltYWdlIGRlc2NlbmRhbnRzXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gdHJhaWxpbmcgaW1hZ2VzXG4gICAgICAgICAgICBpZiAoZW5kQ29udGFpbmVyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdpbWcnICYmICFlbmRDb250YWluZXIucXVlcnlTZWxlY3RvcignaW1nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxhc3ROb2RlID0gZW5kQ29udGFpbmVyLmNoaWxkTm9kZXNbZW5kT2Zmc2V0IC0gMV07XG4gICAgICAgICAgICB3aGlsZSAobGFzdE5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBub2RlID0gcm9vdCxcbiAgICAgICAgICAgICAgICBub2RlU3RhY2sgPSBbXSxcbiAgICAgICAgICAgICAgICBjaGFySW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIGZvdW5kU3RhcnQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb3VuZEVuZCA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN0b3AgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXh0Q2hhckluZGV4LFxuICAgICAgICAgICAgICAgIHRyYWlsaW5nSW1hZ2VzID0gMDtcblxuICAgICAgICAgICAgd2hpbGUgKCFzdG9wICYmIG5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGl0ZXJhdGUgb3ZlciBlbGVtZW50cyBhbmQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID4gMykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMyAmJiAhZm91bmRFbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdJbWFnZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBuZXh0Q2hhckluZGV4ID0gY2hhckluZGV4ICsgbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFydCAmJiBzZWxlY3Rpb25TdGF0ZS5zdGFydCA+PSBjaGFySW5kZXggJiYgc2VsZWN0aW9uU3RhdGUuc3RhcnQgPD0gbmV4dENoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kU3RhcnQgJiYgc2VsZWN0aW9uU3RhdGUuZW5kID49IGNoYXJJbmRleCAmJiBzZWxlY3Rpb25TdGF0ZS5lbmQgPD0gbmV4dENoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJJbmRleCA9IG5leHRDaGFySW5kZXg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nSW1hZ2VzKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZSA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGFsbCBpdHMgY2hpbGRyZW4gdG8gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVTdGFjay5wdXNoKG5vZGUuY2hpbGROb2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdJbWFnZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBjb250YWlucyBhbnkgJ2NvbnRlbnQnXG4gICAgICAgIC8vIGNvbnRlbnQgYmVpbmcgYW55IG5vbi13aGl0ZSBzcGFjZSB0ZXh0IG9yIGFuIGltYWdlXG4gICAgICAgIHNlbGVjdGlvbkNvbnRhaW5zQ29udGVudDogZnVuY3Rpb24gKGRvYykge1xuICAgICAgICAgICAgdmFyIHNlbCA9IGRvYy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgLy8gY29sbGFwc2VkIHNlbGVjdGlvbiBvciBzZWxlY3Rpb24gd2l0aG91ciByYW5nZSBkb2Vzbid0IGNvbnRhaW4gY29udGVudFxuICAgICAgICAgICAgaWYgKCFzZWwgfHwgc2VsLmlzQ29sbGFwc2VkIHx8ICFzZWwucmFuZ2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdG9TdHJpbmcoKSBjb250YWlucyBhbnkgdGV4dCwgdGhlIHNlbGVjdGlvbiBjb250YWlucyBzb21lIGNvbnRlbnRcbiAgICAgICAgICAgIGlmIChzZWwudG9TdHJpbmcoKS50cmltKCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHNlbGVjdGlvbiBjb250YWlucyBvbmx5IGltYWdlKHMpLCBpdCB3aWxsIHJldHVybiBlbXB0eSBmb3IgdG9TdHJpbmcoKVxuICAgICAgICAgICAgLy8gc28gY2hlY2sgZm9yIGFuIGltYWdlIG1hbnVhbGx5XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uTm9kZSA9IHRoaXMuZ2V0U2VsZWN0ZWRQYXJlbnRFbGVtZW50KHNlbC5nZXRSYW5nZUF0KDApKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGlvbk5vZGUubm9kZVR5cGUgPT09IDEgJiYgc2VsZWN0aW9uTm9kZS5xdWVyeVNlbGVjdG9yKCdpbWcnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VsZWN0aW9uSW5Db250ZW50RWRpdGFibGVGYWxzZTogZnVuY3Rpb24gKGNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgZXhjbHVzaXZlbHkgaW5zaWRlXG4gICAgICAgICAgICAvLyBhIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIsIHRob3VnaCB0cmVhdCB0aGUgY2FzZSBvZiBhblxuICAgICAgICAgICAgLy8gZXhwbGljaXQgY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiIGluc2lkZSBhIFwiZmFsc2VcIiBhcyBmYWxzZS5cbiAgICAgICAgICAgIHZhciBzYXd0cnVlLFxuICAgICAgICAgICAgICAgIHNhd2ZhbHNlID0gdGhpcy5maW5kTWF0Y2hpbmdTZWxlY3Rpb25QYXJlbnQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZSA9IGVsICYmIGVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYXd0cnVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwubm9kZU5hbWUgIT09ICcjdGV4dCcgJiYgY2UgPT09ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgfSwgY29udGVudFdpbmRvdyk7XG5cbiAgICAgICAgICAgIHJldHVybiAhc2F3dHJ1ZSAmJiBzYXdmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQxNzY5MjMvaHRtbC1vZi1zZWxlY3RlZC10ZXh0XG4gICAgICAgIC8vIGJ5IFRpbSBEb3duXG4gICAgICAgIGdldFNlbGVjdGlvbkh0bWw6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbkh0bWwoZG9jKSB7XG4gICAgICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgICAgICBodG1sID0gJycsXG4gICAgICAgICAgICAgICAgc2VsID0gZG9jLmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgICAgICBjb250YWluZXI7XG4gICAgICAgICAgICBpZiAoc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc2VsLnJhbmdlQ291bnQ7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsLmdldFJhbmdlQXQoaSkuY2xvbmVDb250ZW50cygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCA9IGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogIEZpbmQgdGhlIGNhcmV0IHBvc2l0aW9uIHdpdGhpbiBhbiBlbGVtZW50IGlycmVzcGVjdGl2ZSBvZiBhbnkgaW5saW5lIHRhZ3MgaXQgbWF5IGNvbnRhaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqICBAcGFyYW0ge0RPTUVsZW1lbnR9IEFuIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY3Vyc29yIHRvIGZpbmQgb2Zmc2V0cyByZWxhdGl2ZSB0by5cbiAgICAgICAgICogIEBwYXJhbSB7UmFuZ2V9IEEgUmFuZ2UgcmVwcmVzZW50aW5nIGN1cnNvciBwb3NpdGlvbi4gV2lsbCB3aW5kb3cuZ2V0U2VsZWN0aW9uIGlmIG5vbmUgaXMgcGFzc2VkLlxuICAgICAgICAgKiAgQHJldHVybiB7T2JqZWN0fSAnbGVmdCcgYW5kICdyaWdodCcgYXR0cmlidXRlcyBjb250YWluIG9mZnNldHMgZnJvbSBiZWdpbmluZyBhbmQgZW5kIG9mIEVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGdldENhcmV0T2Zmc2V0czogZnVuY3Rpb24gZ2V0Q2FyZXRPZmZzZXRzKGVsZW1lbnQsIHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgcHJlQ2FyZXRSYW5nZSwgcG9zdENhcmV0UmFuZ2U7XG5cbiAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVDYXJldFJhbmdlID0gcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgICAgICAgICAgcG9zdENhcmV0UmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG5cbiAgICAgICAgICAgIHByZUNhcmV0UmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgcHJlQ2FyZXRSYW5nZS5zZXRFbmQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuXG4gICAgICAgICAgICBwb3N0Q2FyZXRSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZWxlbWVudCk7XG4gICAgICAgICAgICBwb3N0Q2FyZXRSYW5nZS5zZXRTdGFydChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGVmdDogcHJlQ2FyZXRSYW5nZS50b1N0cmluZygpLmxlbmd0aCxcbiAgICAgICAgICAgICAgICByaWdodDogcG9zdENhcmV0UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTg2NzU0Mi9yYW5nZS1vYmplY3QtZ2V0LXNlbGVjdGlvbi1wYXJlbnQtbm9kZS1jaHJvbWUtdnMtZmlyZWZveFxuICAgICAgICByYW5nZVNlbGVjdHNTaW5nbGVOb2RlOiBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE5vZGUgPT09IHJhbmdlLmVuZENvbnRhaW5lciAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0Tm9kZS5oYXNDaGlsZE5vZGVzKCkgJiZcbiAgICAgICAgICAgICAgICByYW5nZS5lbmRPZmZzZXQgPT09IHJhbmdlLnN0YXJ0T2Zmc2V0ICsgMTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTZWxlY3RlZFBhcmVudEVsZW1lbnQ6IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZWxlY3Rpb24gZW5jb21wYXNzZXMgYSBzaW5nbGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VTZWxlY3RzU2luZ2xlTm9kZShyYW5nZSkgJiYgcmFuZ2Uuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tyYW5nZS5zdGFydE9mZnNldF0ubm9kZVR5cGUgIT09IDMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2Uuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tyYW5nZS5zdGFydE9mZnNldF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbiByYW5nZSBzdGFydHMgaW5zaWRlIGEgdGV4dCBub2RlLCBzbyBnZXQgaXRzIHBhcmVudFxuICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbiBzdGFydHMgaW5zaWRlIGFuIGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRTZWxlY3RlZEVsZW1lbnRzOiBmdW5jdGlvbiAoZG9jKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZG9jLmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIHRvUmV0LFxuICAgICAgICAgICAgICAgIGN1cnJOb2RlO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5yYW5nZUNvdW50IHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCAhc2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuY29tbW9uQW5jZXN0b3JDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRvUmV0ID0gW107XG4gICAgICAgICAgICAgICAgY3Vyck5vZGUgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyck5vZGUucGFyZW50Tm9kZSAmJiBjdXJyTm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0LnB1c2goY3Vyck5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJOb2RlID0gY3Vyck5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9SZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbXS5maWx0ZXIuY2FsbChyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBzZWxlY3Rpb24uY29udGFpbnNOb2RlID09PSAnZnVuY3Rpb24nKSA/IHNlbGVjdGlvbi5jb250YWluc05vZGUoZWwsIHRydWUpIDogdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNlbGVjdE5vZGU6IGZ1bmN0aW9uIChub2RlLCBkb2MpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RSYW5nZShkb2MsIHJhbmdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxlY3Q6IGZ1bmN0aW9uIChkb2MsIHN0YXJ0Tm9kZSwgc3RhcnRPZmZzZXQsIGVuZE5vZGUsIGVuZE9mZnNldCkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5zZXRTdGFydChzdGFydE5vZGUsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChlbmROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE5vZGUsIGVuZE9mZnNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RSYW5nZShkb2MsIHJhbmdlKTtcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogIENsZWFyIHRoZSBjdXJyZW50IGhpZ2hsaWdodGVkIHNlbGVjdGlvbiBhbmQgc2V0IHRoZSBjYXJldCB0byB0aGUgc3RhcnQgb3IgdGhlIGVuZCBvZiB0aGF0IHByaW9yIHNlbGVjdGlvbiwgZGVmYXVsdHMgdG8gZW5kLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgQHBhcmFtIHtEb21Eb2N1bWVudH0gZG9jICAgICAgICAgICAgQ3VycmVudCBkb2N1bWVudFxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBtb3ZlQ3Vyc29yVG9TdGFydCAgQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlIGNhcmV0IHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHByaW9yIHNlbGVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNsZWFyU2VsZWN0aW9uOiBmdW5jdGlvbiAoZG9jLCBtb3ZlQ3Vyc29yVG9TdGFydCkge1xuICAgICAgICAgICAgaWYgKG1vdmVDdXJzb3JUb1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZG9jLmdldFNlbGVjdGlvbigpLmNvbGxhcHNlVG9TdGFydCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2MuZ2V0U2VsZWN0aW9uKCkuY29sbGFwc2VUb0VuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNb3ZlIGN1cnNvciB0byB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoZSBnaXZlbiBvZmZzZXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge0RvbURvY3VtZW50fSBkb2MgICAgIEN1cnJlbnQgZG9jdW1lbnRcbiAgICAgICAgICogQHBhcmFtICB7RG9tRWxlbWVudH0gIG5vZGUgICAgRWxlbWVudCB3aGVyZSB0byBqdW1wXG4gICAgICAgICAqIEBwYXJhbSAge2ludGVnZXJ9ICAgICBvZmZzZXQgIFdoZXJlIGluIHRoZSBlbGVtZW50IHNob3VsZCB3ZSBqdW1wLCAwIGJ5IGRlZmF1bHRcbiAgICAgICAgICovXG4gICAgICAgIG1vdmVDdXJzb3I6IGZ1bmN0aW9uIChkb2MsIG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QoZG9jLCBub2RlLCBvZmZzZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFNlbGVjdGlvblJhbmdlOiBmdW5jdGlvbiAob3duZXJEb2N1bWVudCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IG93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxlY3RSYW5nZTogZnVuY3Rpb24gKG93bmVyRG9jdW1lbnQsIHJhbmdlKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gb3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExOTc0MDEvaG93LWNhbi1pLWdldC10aGUtZWxlbWVudC10aGUtY2FyZXQtaXMtaW4td2l0aC1qYXZhc2NyaXB0LXdoZW4tdXNpbmctY29udGVudGVkaVxuICAgICAgICAvLyBieSBZb3VcbiAgICAgICAgZ2V0U2VsZWN0aW9uU3RhcnQ6IGZ1bmN0aW9uIChvd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkuYW5jaG9yTm9kZSxcbiAgICAgICAgICAgICAgICBzdGFydE5vZGUgPSAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzID8gbm9kZS5wYXJlbnROb2RlIDogbm9kZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzdGFydE5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbiA9IFNlbGVjdGlvbjtcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50RGVzY2VuZGFudE9mRXh0ZW5zaW9uKGV4dGVuc2lvbnMsIGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuc29tZShmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbi5nZXRJbnRlcmFjdGlvbkVsZW1lbnRzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXh0ZW5zaW9uRWxlbWVudHMgPSBleHRlbnNpb24uZ2V0SW50ZXJhY3Rpb25FbGVtZW50cygpO1xuICAgICAgICAgICAgaWYgKCFleHRlbnNpb25FbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGV4dGVuc2lvbkVsZW1lbnRzKSkge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvbkVsZW1lbnRzID0gW2V4dGVuc2lvbkVsZW1lbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb25FbGVtZW50cy5zb21lKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNZWRpdW1FZGl0b3IudXRpbC5pc0Rlc2NlbmRhbnQoZWwsIGVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBFdmVudHMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5iYXNlID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuYmFzZS5vcHRpb25zO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmRpc2FibGVkRXZlbnRzID0ge307XG4gICAgICAgIHRoaXMuY3VzdG9tRXZlbnRzID0ge307XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgfTtcblxuICAgIEV2ZW50cy5wcm90b3R5cGUgPSB7XG4gICAgICAgIElucHV0RXZlbnRPbkNvbnRlbnRlZGl0YWJsZVN1cHBvcnRlZDogIU1lZGl1bUVkaXRvci51dGlsLmlzSUUgJiYgIU1lZGl1bUVkaXRvci51dGlsLmlzRWRnZSxcblxuICAgICAgICAvLyBIZWxwZXJzIGZvciBldmVudCBoYW5kbGluZ1xuXG4gICAgICAgIGF0dGFjaERPTUV2ZW50OiBmdW5jdGlvbiAodGFyZ2V0cywgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB0YXJnZXRzID0gTWVkaXVtRWRpdG9yLnV0aWwuaXNFbGVtZW50KHRhcmdldHMpIHx8IFt3aW5kb3csIGRvY3VtZW50XS5pbmRleE9mKHRhcmdldHMpID4gLTEgPyBbdGFyZ2V0c10gOiB0YXJnZXRzO1xuXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRhcmdldHMsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goW3RhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlXSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaERPTUV2ZW50OiBmdW5jdGlvbiAodGFyZ2V0cywgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXgsIGU7XG4gICAgICAgICAgICB0YXJnZXRzID0gTWVkaXVtRWRpdG9yLnV0aWwuaXNFbGVtZW50KHRhcmdldHMpIHx8IFt3aW5kb3csIGRvY3VtZW50XS5pbmRleE9mKHRhcmdldHMpID4gLTEgPyBbdGFyZ2V0c10gOiB0YXJnZXRzO1xuXG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHRhcmdldHMsIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXhPZkxpc3RlbmVyKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICBlWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoZVsxXSwgZVsyXSwgZVszXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbmRleE9mTGlzdGVuZXI6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgdmFyIGksIG4sIGl0ZW07XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gdGhpcy5ldmVudHMubGVuZ3RoOyBpIDwgbjsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtWzBdID09PSB0YXJnZXQgJiYgaXRlbVsxXSA9PT0gZXZlbnQgJiYgaXRlbVsyXSA9PT0gbGlzdGVuZXIgJiYgaXRlbVszXSA9PT0gdXNlQ2FwdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoQWxsRE9NRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMuZXZlbnRzLnBvcCgpO1xuICAgICAgICAgICAgd2hpbGUgKGUpIHtcbiAgICAgICAgICAgICAgICBlWzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIoZVsxXSwgZVsyXSwgZVszXSk7XG4gICAgICAgICAgICAgICAgZSA9IHRoaXMuZXZlbnRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaEFsbEV2ZW50c0Zyb21FbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gdGhpcy5ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUgJiYgZVswXS5nZXRBdHRyaWJ1dGUgJiYgZVswXS5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItaW5kZXgnKSA9PT0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItaW5kZXgnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZmlsdGVyZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGZpbHRlcmVkW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoRE9NRXZlbnQoZVswXSwgZVsxXSwgZVsyXSwgZVszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQXR0YWNoIGFsbCBleGlzdGluZyBoYW5kbGVycyB0byBhIG5ldyBlbGVtZW50XG4gICAgICAgIGF0dGFjaEFsbEV2ZW50c1RvRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1snZWRpdGFibGVJbnB1dCddKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50Q2FjaGVbZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItaW5kZXgnKV0gPSBlbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c0NhY2hlLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hET01FdmVudChlbGVtZW50LCBlWyduYW1lJ10sIGVbJ2hhbmRsZXInXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGVDdXN0b21FdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZEV2ZW50c1tldmVudF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRpc2FibGVkRXZlbnRzW2V2ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkaXNhYmxlQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlZEV2ZW50c1tldmVudF0gPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGN1c3RvbSBldmVudHNcbiAgICAgICAgYXR0YWNoQ3VzdG9tRXZlbnQ6IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBMaXN0ZW5lcihldmVudCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VzdG9tRXZlbnRzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRXZlbnRzW2V2ZW50XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXN0b21FdmVudHNbZXZlbnRdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaEN1c3RvbUV2ZW50OiBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2ZDdXN0b21MaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRXZlbnRzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IElmIGFycmF5IGlzIGVtcHR5LCBzaG91bGQgZGV0YWNoIGludGVybmFsIGxpc3RlbmVycyB2aWEgZGVzdHJveUxpc3RlbmVyKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbmRleE9mQ3VzdG9tTGlzdGVuZXI6IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXN0b21FdmVudHNbZXZlbnRdIHx8ICF0aGlzLmN1c3RvbUV2ZW50c1tldmVudF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21FdmVudHNbZXZlbnRdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRldGFjaEFsbEN1c3RvbUV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21FdmVudHMgPSB7fTtcbiAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCBkZXRhY2ggaW50ZXJuYWwgbGlzdGVuZXJzIGhlcmUgdmlhIGRlc3Ryb3lMaXN0ZW5lcigpXG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJpZ2dlckN1c3RvbUV2ZW50OiBmdW5jdGlvbiAobmFtZSwgZGF0YSwgZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUV2ZW50c1tuYW1lXSAmJiAhdGhpcy5kaXNhYmxlZEV2ZW50c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tRXZlbnRzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKGRhdGEsIGVkaXRhYmxlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDbGVhbmluZyB1cFxuXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoQWxsRE9NRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLmRldGFjaEFsbEN1c3RvbUV2ZW50cygpO1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hFeGVjQ29tbWFuZCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbWVkaXVtLWZvY3VzZWQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBMaXN0ZW5pbmcgdG8gY2FsbHMgdG8gZG9jdW1lbnQuZXhlY0NvbW1hbmRcblxuICAgICAgICAvLyBBdHRhY2ggYSBsaXN0ZW5lciB0byBiZSBub3RpZmllZCB3aGVuIGRvY3VtZW50LmV4ZWNDb21tYW5kIGlzIGNhbGxlZFxuICAgICAgICBhdHRhY2hUb0V4ZWNDb21tYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5leGVjQ29tbWFuZExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdG9yZSBhbiBpbnN0YW5jZSBvZiB0aGUgbGlzdGVuZXIgc286XG4gICAgICAgICAgICAvLyAxKSBXZSBvbmx5IGF0dGFjaCB0byBleGVjQ29tbWFuZCBvbmNlXG4gICAgICAgICAgICAvLyAyKSBXZSBjYW4gcmVtb3ZlIHRoZSBsaXN0ZW5lciBsYXRlclxuICAgICAgICAgICAgdGhpcy5leGVjQ29tbWFuZExpc3RlbmVyID0gZnVuY3Rpb24gKGV4ZWNJbmZvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudEV4ZWNDb21tYW5kKGV4ZWNJbmZvKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgZXhlY0NvbW1hbmQgaGFzIGJlZW4gd3JhcHBlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgIHRoaXMud3JhcEV4ZWNDb21tYW5kKCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBsaXN0ZW5lciB0byBsaXN0IG9mIGV4ZWNDb21tYW5kIGxpc3RlbmVyc1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuZXhlY0NvbW1hbmQubGlzdGVuZXJzLnB1c2godGhpcy5leGVjQ29tbWFuZExpc3RlbmVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBSZW1vdmUgb3VyIGxpc3RlbmVyIGZvciBjYWxscyB0byBkb2N1bWVudC5leGVjQ29tbWFuZFxuICAgICAgICBkZXRhY2hFeGVjQ29tbWFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRvYyA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4ZWNDb21tYW5kTGlzdGVuZXIgfHwgIWRvYy5leGVjQ29tbWFuZC5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoaXMgbGlzdGVuZXIgaW4gdGhlIGFycmF5IG9mIGxpc3RlbmVycyBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZG9jLmV4ZWNDb21tYW5kLmxpc3RlbmVycy5pbmRleE9mKHRoaXMuZXhlY0NvbW1hbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kLmxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbGlzdCBvZiBsaXN0ZW5lcnMgaXMgbm93IGVtcHR5LCBwdXQgZXhlY0NvbW1hbmQgYmFjayB0byBpdHMgb3JpZ2luYWwgc3RhdGVcbiAgICAgICAgICAgIGlmICghZG9jLmV4ZWNDb21tYW5kLmxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVud3JhcEV4ZWNDb21tYW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV3JhcCBkb2N1bWVudC5leGVjQ29tbWFuZCBpbiBhIGN1c3RvbSBtZXRob2Qgc28gd2UgY2FuIGxpc3RlbiB0byBjYWxscyB0byBpdFxuICAgICAgICB3cmFwRXhlY0NvbW1hbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudDtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCBpbnN0YW5jZSBvZiBNZWRpdW1FZGl0b3Igb25seSB3cmFwIGV4ZWNDb21tYW5kIG9uY2VcbiAgICAgICAgICAgIGlmIChkb2MuZXhlY0NvbW1hbmQubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIZWxwZXIgbWV0aG9kIHRvIGNhbGwgYWxsIGxpc3RlbmVycyB0byBleGVjQ29tbWFuZFxuICAgICAgICAgICAgdmFyIGNhbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoYXJncywgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb2MuZXhlY0NvbW1hbmQubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MuZXhlY0NvbW1hbmQubGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiBhcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJnc1syXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlciBtZXRob2QgZm9yIGV4ZWNDb21tYW5kIHdoaWNoIHdpbGw6XG4gICAgICAgICAgICAvLyAxKSBDYWxsIGRvY3VtZW50LmV4ZWNDb21tYW5kIHdpdGggdGhlIGNvcnJlY3QgYXJndW1lbnRzXG4gICAgICAgICAgICAvLyAyKSBMb29wIHRocm91Z2ggYW55IGxpc3RlbmVycyBhbmQgbm90aWZ5IHRoZW0gdGhhdCBleGVjQ29tbWFuZCB3YXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAgICBwYXNzaW5nIGV4dHJhIGluZm8gb24gdGhlIGNhbGxcbiAgICAgICAgICAgIC8vIDMpIFJldHVybiB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGRvYy5leGVjQ29tbWFuZC5vcmlnLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2MuZXhlY0NvbW1hbmQubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsTGlzdGVuZXJzKGFyZ3MsIHJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXhlY0NvbW1hbmRcbiAgICAgICAgICAgIHdyYXBwZXIub3JpZyA9IGRvYy5leGVjQ29tbWFuZDtcblxuICAgICAgICAgICAgLy8gQXR0YWNoIGFuIGFycmF5IGZvciBzdG9yaW5nIGxpc3RlbmVyc1xuICAgICAgICAgICAgd3JhcHBlci5saXN0ZW5lcnMgPSBbXTtcblxuICAgICAgICAgICAgLy8gSGVscGVyIGZvciBub3RpZnlpbmcgbGlzdGVuZXJzXG4gICAgICAgICAgICB3cmFwcGVyLmNhbGxMaXN0ZW5lcnMgPSBjYWxsTGlzdGVuZXJzO1xuXG4gICAgICAgICAgICAvLyBPdmVyd3JpdGUgZXhlY0NvbW1hbmRcbiAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZCA9IHdyYXBwZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmV2ZXJ0IGRvY3VtZW50LmV4ZWNDb21tYW5kIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHNlbGZcbiAgICAgICAgdW53cmFwRXhlY0NvbW1hbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIGlmICghZG9jLmV4ZWNDb21tYW5kLm9yaWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBleGVjQ29tbWFuZCB0byByZXZlcnQgYmFja1xuICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kID0gZG9jLmV4ZWNDb21tYW5kLm9yaWc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gTGlzdGVuaW5nIHRvIGJyb3dzZXIgZXZlbnRzIHRvIGVtaXQgZXZlbnRzIG1lZGl1bS1lZGl0b3IgY2FyZXMgYWJvdXRcbiAgICAgICAgc2V0dXBMaXN0ZW5lcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXh0ZXJuYWxJbnRlcmFjdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyB3aGVuIHVzZXIgaGFzIGludGVyYWN0ZWQgd2l0aCBlbGVtZW50cyBvdXRzaWRlIG9mIE1lZGl1bUVkaXRvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaERPTUV2ZW50KHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmJvZHksICdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZUJvZHlNb3VzZWRvd24uYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoRE9NRXZlbnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuYm9keSwgJ2NsaWNrJywgdGhpcy5oYW5kbGVCb2R5Q2xpY2suYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoRE9NRXZlbnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuYm9keSwgJ2ZvY3VzJywgdGhpcy5oYW5kbGVCb2R5Rm9jdXMuYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JsdXInOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3Rpbmcgd2hlbiBmb2N1cyBpcyBsb3N0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBMaXN0ZW5lcignZXh0ZXJuYWxJbnRlcmFjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyB3aGVuIGZvY3VzIG1vdmVzIGludG8gc29tZSBwYXJ0IG9mIE1lZGl1bUVkaXRvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwTGlzdGVuZXIoJ2V4dGVybmFsSW50ZXJhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVJbnB1dCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldHVwIGNhY2hlIGZvciBrbm93aW5nIHdoZW4gdGhlIGNvbnRlbnQgaGFzIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50Q2FjaGUgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXNlLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudENhY2hlW2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdtZWRpdW0tZWRpdG9yLWluZGV4JyldID0gZWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEF0dGFjaCB0byB0aGUgJ29uaW5wdXQnIGV2ZW50LCBoYW5kbGVkIGNvcnJlY3RseSBieSBtb3N0IGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLklucHV0RXZlbnRPbkNvbnRlbnRlZGl0YWJsZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0VhY2hFbGVtZW50KCdpbnB1dCcsIHRoaXMuaGFuZGxlSW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IG9uIGNvbnRlbnRlZGl0YWJsZSAoSUUpXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlJ2xsIGF0dGFjaCB0byAnc2VsZWN0aW9uY2hhbmdlJyBvbiB0aGUgZG9jdW1lbnQgYW5kICdrZXlwcmVzcycgb24gdGhlIGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuSW5wdXRFdmVudE9uQ29udGVudGVkaXRhYmxlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHVwTGlzdGVuZXIoJ2VkaXRhYmxlS2V5cHJlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMua2V5cHJlc3NVcGRhdGVJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaERPTUV2ZW50KGRvY3VtZW50LCAnc2VsZWN0aW9uY2hhbmdlJywgdGhpcy5oYW5kbGVEb2N1bWVudFNlbGVjdGlvbkNoYW5nZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExpc3RlbiB0byBjYWxscyB0byBleGVjQ29tbWFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0V4ZWNDb21tYW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVDbGljayc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBjbGljayBpbiB0aGUgY29udGVudGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWFjaEVsZW1lbnQoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljayk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlQmx1cic6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBibHVyIGluIHRoZSBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoVG9FYWNoRWxlbWVudCgnYmx1cicsIHRoaXMuaGFuZGxlQmx1cik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlS2V5cHJlc3MnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3Rpbmcga2V5cHJlc3MgaW4gdGhlIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0VhY2hFbGVtZW50KCdrZXlwcmVzcycsIHRoaXMuaGFuZGxlS2V5cHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlZGl0YWJsZUtleXVwJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIGtleXVwIGluIHRoZSBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoVG9FYWNoRWxlbWVudCgna2V5dXAnLCB0aGlzLmhhbmRsZUtleXVwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVLZXlkb3duJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIGtleWRvd24gb24gdGhlIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0VhY2hFbGVtZW50KCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVLZXlkb3duU3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3Rpbmcga2V5ZG93biBmb3IgU1BBQ0Ugb24gdGhlIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cExpc3RlbmVyKCdlZGl0YWJsZUtleWRvd24nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVLZXlkb3duRW50ZXInOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3Rpbmcga2V5ZG93biBmb3IgRU5URVIgb24gdGhlIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR1cExpc3RlbmVyKCdlZGl0YWJsZUtleWRvd24nKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVLZXlkb3duVGFiJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIGtleWRvd24gZm9yIFRBQiBvbiB0aGUgY29udGVudGVkaXRhYmxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBMaXN0ZW5lcignZWRpdGFibGVLZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlS2V5ZG93bkRlbGV0ZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBrZXlkb3duIGZvciBERUxFVEUvQkFDS1NQQUNFIG9uIHRoZSBjb250ZW50ZWRpdGFibGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBMaXN0ZW5lcignZWRpdGFibGVLZXlkb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VkaXRhYmxlTW91c2VvdmVyJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIG1vdXNlb3ZlciBvbiB0aGUgY29udGVudGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWFjaEVsZW1lbnQoJ21vdXNlb3ZlcicsIHRoaXMuaGFuZGxlTW91c2VvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVEcmFnJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZWN0aW5nIGRyYWdvdmVyIGFuZCBkcmFnbGVhdmUgb24gdGhlIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hUb0VhY2hFbGVtZW50KCdkcmFnb3ZlcicsIHRoaXMuaGFuZGxlRHJhZ2dpbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWFjaEVsZW1lbnQoJ2RyYWdsZWF2ZScsIHRoaXMuaGFuZGxlRHJhZ2dpbmcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlZGl0YWJsZURyb3AnOlxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3RpbmcgZHJvcCBvbiB0aGUgY29udGVudGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWFjaEVsZW1lbnQoJ2Ryb3AnLCB0aGlzLmhhbmRsZURyb3ApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIGhhdmUgYSBjdXN0b20gJ3Bhc3RlJyBldmVudCBzZXBhcmF0ZSBmcm9tICdlZGl0YWJsZVBhc3RlJ1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gdGhpbmsgYWJvdXQgdGhlIHdheSB0byBpbnRyb2R1Y2UgdGhpcyB3aXRob3V0IGJyZWFraW5nIGZvbGtzXG4gICAgICAgICAgICAgICAgY2FzZSAnZWRpdGFibGVQYXN0ZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdGluZyBwYXN0ZSBvbiB0aGUgY29udGVudGVkaXRhYmxlc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaFRvRWFjaEVsZW1lbnQoJ3Bhc3RlJywgdGhpcy5oYW5kbGVQYXN0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaFRvRWFjaEVsZW1lbnQ6IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBidWlsZCBvdXIgaW50ZXJuYWwgY2FjaGUgdG8ga25vdyB3aGljaCBlbGVtZW50IGdvdCBhbHJlYWR5IHdoYXQgaGFuZGxlciBhdHRhY2hlZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50c0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNDYWNoZSA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJhc2UuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoRE9NRXZlbnQoZWxlbWVudCwgbmFtZSwgaGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50c0NhY2hlLnB1c2goeyAnbmFtZSc6IG5hbWUsICdoYW5kbGVyJzogaGFuZGxlciB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbnVwRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtZWRpdW0tZWRpdG9yLWluZGV4Jyk7XG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaEFsbEV2ZW50c0Zyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRDYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5jb250ZW50Q2FjaGVbaW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmb2N1c0VsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvY3VzKGVsZW1lbnQsIHsgdGFyZ2V0OiBlbGVtZW50LCB0eXBlOiAnZm9jdXMnIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUZvY3VzOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE9iaikge1xuICAgICAgICAgICAgdmFyIGhhZEZvY3VzID0gdGhpcy5iYXNlLmdldEZvY3VzZWRFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgdG9Gb2N1cztcblxuICAgICAgICAgICAgLy8gRm9yIGNsaWNrcywgd2UgbmVlZCB0byBrbm93IGlmIHRoZSBtb3VzZWRvd24gdGhhdCBjYXVzZWQgdGhlIGNsaWNrIGhhcHBlbmVkIGluc2lkZSB0aGUgZXhpc3RpbmcgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgICAgICAvLyBvciBvbmUgb2YgdGhlIGV4dGVuc2lvbiBlbGVtZW50cy4gIElmIHNvLCB3ZSBkb24ndCB3YW50IHRvIGZvY3VzIGFub3RoZXIgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGhhZEZvY3VzICYmXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50T2JqLnR5cGUgPT09ICdjbGljaycgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TW91c2Vkb3duVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIChNZWRpdW1FZGl0b3IudXRpbC5pc0Rlc2NlbmRhbnQoaGFkRm9jdXMsIHRoaXMubGFzdE1vdXNlZG93blRhcmdldCwgdHJ1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgIGlzRWxlbWVudERlc2NlbmRhbnRPZkV4dGVuc2lvbih0aGlzLmJhc2UuZXh0ZW5zaW9ucywgdGhpcy5sYXN0TW91c2Vkb3duVGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgICB0b0ZvY3VzID0gaGFkRm9jdXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdG9Gb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuYmFzZS5lbGVtZW50cy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgcGFydCBvZiBhbiBlZGl0b3IgZWxlbWVudCwgdGhpcyBpcyB0aGUgZWxlbWVudCBnZXR0aW5nIGZvY3VzXG4gICAgICAgICAgICAgICAgICAgIGlmICghdG9Gb2N1cyAmJiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNEZXNjZW5kYW50KGVsZW1lbnQsIHRhcmdldCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0ZvY3VzID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhaWwgaWYgd2UgZm91bmQgYW4gZWxlbWVudCB0aGF0J3MgZ2V0dGluZyBmb2N1c1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0b0ZvY3VzO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGV4dGVybmFsIChub3QgcGFydCBvZiB0aGUgZWRpdG9yLCB0b29sYmFyLCBvciBhbnkgb3RoZXIgZXh0ZW5zaW9uKVxuICAgICAgICAgICAgdmFyIGV4dGVybmFsRXZlbnQgPSAhTWVkaXVtRWRpdG9yLnV0aWwuaXNEZXNjZW5kYW50KGhhZEZvY3VzLCB0YXJnZXQsIHRydWUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc0VsZW1lbnREZXNjZW5kYW50T2ZFeHRlbnNpb24odGhpcy5iYXNlLmV4dGVuc2lvbnMsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGlmICh0b0ZvY3VzICE9PSBoYWRGb2N1cykge1xuICAgICAgICAgICAgICAgIC8vIElmIGVsZW1lbnQgaGFzIGZvY3VzLCBhbmQgZm9jdXMgaXMgZ29pbmcgb3V0c2lkZSBvZiBlZGl0b3JcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBibHVyIGZvY3VzZWQgZWxlbWVudCBpZiBjbGlja2luZyBvbiBlZGl0b3IsIHRvb2xiYXIsIG9yIGFuY2hvcnByZXZpZXdcbiAgICAgICAgICAgICAgICBpZiAoaGFkRm9jdXMgJiYgZXh0ZXJuYWxFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGJsdXIgb24gdGhlIGVkaXRhYmxlIHRoYXQgaGFzIGxvc3QgZm9jdXNcbiAgICAgICAgICAgICAgICAgICAgaGFkRm9jdXMucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1lZGl1bS1mb2N1c2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdibHVyJywgZXZlbnRPYmosIGhhZEZvY3VzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBmb2N1cyBpcyBnb2luZyBpbnRvIGFuIGVkaXRvciBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHRvRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBmb2N1cyBvbiB0aGUgZWRpdGFibGUgdGhhdCBub3cgaGFzIGZvY3VzXG4gICAgICAgICAgICAgICAgICAgIHRvRm9jdXMuc2V0QXR0cmlidXRlKCdkYXRhLW1lZGl1bS1mb2N1c2VkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdmb2N1cycsIGV2ZW50T2JqLCB0b0ZvY3VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChleHRlcm5hbEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2V4dGVybmFsSW50ZXJhY3Rpb24nLCBldmVudE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlSW5wdXQ6IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50T2JqKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudENhY2hlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW4gZXZlbnQgdHJpZ2dlcmVkIHdoaWNoIHNpZ25pZmllcyB0aGF0IHRoZSB1c2VyIG1heSBoYXZlIGNoYW5nZWQgc29tZXRpbmdcbiAgICAgICAgICAgIC8vIExvb2sgaW4gb3VyIGNhY2hlIG9mIGlucHV0IGZvciB0aGUgY29udGVudGVkaXRhYmxlcyB0byBzZWUgaWYgc29tZXRoaW5nIGNoYW5nZWRcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItaW5kZXgnKSxcbiAgICAgICAgICAgICAgICBodG1sID0gdGFyZ2V0LmlubmVySFRNTDtcblxuICAgICAgICAgICAgaWYgKGh0bWwgIT09IHRoaXMuY29udGVudENhY2hlW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBjb250ZW50IGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2UgY2hlY2tlZCwgZmlyZSB0aGUgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVJbnB1dCcsIGV2ZW50T2JqLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250ZW50Q2FjaGVbaW5kZXhdID0gaHRtbDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVEb2N1bWVudFNlbGVjdGlvbkNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBXaGVuIHNlbGVjdGlvbmNoYW5nZSBmaXJlcywgdGFyZ2V0IGFuZCBjdXJyZW50IHRhcmdldCBhcmUgc2V0XG4gICAgICAgICAgICAvLyB0byBkb2N1bWVudCwgc2luY2UgdGhpcyBpcyB3aGVyZSB0aGUgZXZlbnQgaXMgaGFuZGxlZFxuICAgICAgICAgICAgLy8gSG93ZXZlciwgY3VycmVudFRhcmdldCB3aWxsIGhhdmUgYW4gJ2FjdGl2ZUVsZW1lbnQnIHByb3BlcnR5XG4gICAgICAgICAgICAvLyB3aGljaCB3aWxsIHBvaW50IHRvIHdoYXRldmVyIGVsZW1lbnQgaGFzIGZvY3VzLlxuICAgICAgICAgICAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQgJiYgZXZlbnQuY3VycmVudFRhcmdldC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBldmVudC5jdXJyZW50VGFyZ2V0LmFjdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIGxvb2sgYXQgdGhlICdhY3RpdmVFbGVtZW50JyB0byBkZXRlcm1pbmUgaWYgdGhlIHNlbGVjdGlvbmNoYW5nZSBoYXNcbiAgICAgICAgICAgICAgICAvLyBoYXBwZW5lZCB3aXRoaW4gYSBjb250ZW50ZWRpdGFibGUgb3duZWQgYnkgdGhpcyBpbnN0YW5jZSBvZiBNZWRpdW1FZGl0b3JcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2UuZWxlbWVudHMuc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNEZXNjZW5kYW50KGVsZW1lbnQsIGFjdGl2ZUVsZW1lbnQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgc2VsZWN0aW9uY2hhbmdlIGZpcmVkIHdpdGhpbiBvbmUgb2Ygb3VyIGNvbnRlbnRlZGl0YWJsZXNcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KGN1cnJlbnRUYXJnZXQsIHsgdGFyZ2V0OiBhY3RpdmVFbGVtZW50LCBjdXJyZW50VGFyZ2V0OiBjdXJyZW50VGFyZ2V0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVEb2N1bWVudEV4ZWNDb21tYW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBkb2N1bWVudC5leGVjQ29tbWFuZCBoYXMgYmVlbiBjYWxsZWRcbiAgICAgICAgICAgIC8vIElmIG9uZSBvZiBvdXIgY29udGVudGVkaXRhYmxlcyBjdXJyZW50bHkgaGFzIGZvY3VzLCB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gdHJpZ2dlciB0aGUgJ2VkaXRhYmxlSW5wdXQnIGV2ZW50XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5iYXNlLmdldEZvY3VzZWRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dCh0YXJnZXQsIHsgdGFyZ2V0OiB0YXJnZXQsIGN1cnJlbnRUYXJnZXQ6IHRhcmdldCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVCb2R5Q2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb2N1cyhldmVudC50YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVCb2R5Rm9jdXM6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb2N1cyhldmVudC50YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVCb2R5TW91c2Vkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdE1vdXNlZG93blRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVJbnB1dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVDbGljaycsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVCbHVyOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdlZGl0YWJsZUJsdXInLCBldmVudCwgZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlS2V5cHJlc3M6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlS2V5cHJlc3MnLCBldmVudCwgZXZlbnQuY3VycmVudFRhcmdldCk7XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGRvaW5nIG1hbnVhbCBkZXRlY3Rpb24gb2YgdGhlIGVkaXRhYmxlSW5wdXQgZXZlbnQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gY2hlY2sgZm9yIGlucHV0IGNoYW5nZXMgZHVyaW5nICdrZXlwcmVzcydcbiAgICAgICAgICAgIGlmICh0aGlzLmtleXByZXNzVXBkYXRlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRPYmogPSB7IHRhcmdldDogZXZlbnQudGFyZ2V0LCBjdXJyZW50VGFyZ2V0OiBldmVudC5jdXJyZW50VGFyZ2V0IH07XG5cbiAgICAgICAgICAgICAgICAvLyBJbiBJRSwgd2UgbmVlZCB0byBsZXQgdGhlIHJlc3Qgb2YgdGhlIGV2ZW50IHN0YWNrIGNvbXBsZXRlIGJlZm9yZSB3ZSBkZXRlY3RcbiAgICAgICAgICAgICAgICAvLyBjaGFuZ2VzIHRvIGlucHV0LCBzbyB1c2luZyBzZXRUaW1lb3V0IGhlcmVcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnB1dChldmVudE9iai5jdXJyZW50VGFyZ2V0LCBldmVudE9iaik7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVLZXl1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVLZXl1cCcsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVNb3VzZW92ZXI6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlTW91c2VvdmVyJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZURyYWdnaW5nOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdlZGl0YWJsZURyYWcnLCBldmVudCwgZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlRHJvcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVEcm9wJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVBhc3RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdlZGl0YWJsZVBhc3RlJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUtleWRvd246IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVLZXlkb3duJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuXG4gICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuU1BBQ0UpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlckN1c3RvbUV2ZW50KCdlZGl0YWJsZUtleWRvd25TcGFjZScsIGV2ZW50LCBldmVudC5jdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci51dGlsLmlzS2V5KGV2ZW50LCBNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLkVOVEVSKSB8fCAoZXZlbnQuY3RybEtleSAmJiBNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5NKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyQ3VzdG9tRXZlbnQoJ2VkaXRhYmxlS2V5ZG93bkVudGVyJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuVEFCKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVLZXlkb3duVGFiJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIFtNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLkRFTEVURSwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5CQUNLU1BBQ0VdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVLZXlkb3duRGVsZXRlJywgZXZlbnQsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIE1lZGl1bUVkaXRvci5FdmVudHMgPSBFdmVudHM7XG59KCkpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBCdXR0b24gPSBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLmV4dGVuZCh7XG5cbiAgICAgICAgLyogQnV0dG9uIE9wdGlvbnMgKi9cblxuICAgICAgICAvKiBhY3Rpb246IFtzdHJpbmddXG4gICAgICAgICAqIFRoZSBhY3Rpb24gYXJndW1lbnQgdG8gcGFzcyB0byBNZWRpdW1FZGl0b3IuZXhlY0FjdGlvbigpXG4gICAgICAgICAqIHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICAgICAqL1xuICAgICAgICBhY3Rpb246IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBhcmlhOiBbc3RyaW5nXVxuICAgICAgICAgKiBUaGUgdmFsdWUgdG8gYWRkIGFzIHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZSBvZiB0aGUgYnV0dG9uXG4gICAgICAgICAqIGVsZW1lbnQgZGlzcGxheWVkIGluIHRoZSB0b29sYmFyLlxuICAgICAgICAgKiBUaGlzIGlzIGFsc28gdXNlZCBhcyB0aGUgdG9vbHRpcCBmb3IgdGhlIGJ1dHRvblxuICAgICAgICAgKi9cbiAgICAgICAgYXJpYTogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIHRhZ05hbWVzOiBbQXJyYXldXG4gICAgICAgICAqIE5PVEU6IFRoaXMgaXMgbm90IHVzZWQgaWYgdXNlUXVlcnlTdGF0ZSBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQXJyYXkgb2YgZWxlbWVudCB0YWcgbmFtZXMgdGhhdCB3b3VsZCBpbmRpY2F0ZSB0aGF0IHRoaXNcbiAgICAgICAgICogYnV0dG9uIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZC4gSWYgdGhpcyBhY3Rpb24gaGFzIGFscmVhZHlcbiAgICAgICAgICogYmVlbiBhcHBsaWVkLCB0aGUgYnV0dG9uIHdpbGwgYmUgZGlzcGxheWVkIGFzICdhY3RpdmUnIGluIHRoZSB0b29sYmFyXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAqIEZvciAnYm9sZCcsIGlmIHRoZSB0ZXh0IGlzIGV2ZXIgd2l0aGluIGEgPGI+IG9yIDxzdHJvbmc+XG4gICAgICAgICAqIHRhZyB0aGF0IGluZGljYXRlcyB0aGUgdGV4dCBpcyBhbHJlYWR5IGJvbGQuIFNvIHRoZSBhcnJheVxuICAgICAgICAgKiBvZiB0YWdOYW1lcyBmb3IgYm9sZCB3b3VsZCBiZTogWydiJywgJ3N0cm9uZyddXG4gICAgICAgICAqL1xuICAgICAgICB0YWdOYW1lczogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIHN0eWxlOiBbT2JqZWN0XVxuICAgICAgICAgKiBOT1RFOiBUaGlzIGlzIG5vdCB1c2VkIGlmIHVzZVF1ZXJ5U3RhdGUgaXMgc2V0IHRvIHRydWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgcGFpciBvZiBjc3MgcHJvcGVydHkgJiB2YWx1ZShzKSB0aGF0IGluZGljYXRlIHRoYXQgdGhpc1xuICAgICAgICAgKiBidXR0b24gaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkLiBJZiB0aGlzIGFjdGlvbiBoYXMgYWxyZWFkeVxuICAgICAgICAgKiBiZWVuIGFwcGxpZWQsIHRoZSBidXR0b24gd2lsbCBiZSBkaXNwbGF5ZWQgYXMgJ2FjdGl2ZScgaW4gdGhlIHRvb2xiYXJcbiAgICAgICAgICogUHJvcGVydGllcyBvZiB0aGUgb2JqZWN0OlxuICAgICAgICAgKiAgIHByb3AgW1N0cmluZ106IG5hbWUgb2YgdGhlIGNzcyBwcm9wZXJ0eVxuICAgICAgICAgKiAgIHZhbHVlIFtTdHJpbmddOiB2YWx1ZShzKSBvZiB0aGUgY3NzIHByb3BlcnR5XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgIG11bHRpcGxlIHZhbHVlcyBjYW4gYmUgc2VwYXJhdGVkIGJ5IGEgJ3wnXG4gICAgICAgICAqXG4gICAgICAgICAqIEV4YW1wbGU6XG4gICAgICAgICAqIEZvciAnYm9sZCcsIGlmIHRoZSB0ZXh0IGlzIGV2ZXIgd2l0aGluIGFuIGVsZW1lbnQgd2l0aCBhICdmb250LXdlaWdodCdcbiAgICAgICAgICogc3R5bGUgcHJvcGVydHkgc2V0IHRvICc3MDAnIG9yICdib2xkJywgdGhhdCBpbmRpY2F0ZXMgdGhlIHRleHRcbiAgICAgICAgICogaXMgYWxyZWFkeSBib2xkLiAgU28gdGhlIHN0eWxlIG9iamVjdCBmb3IgYm9sZCB3b3VsZCBiZTpcbiAgICAgICAgICogeyBwcm9wOiAnZm9udC13ZWlnaHQnLCB2YWx1ZTogJzcwMHxib2xkJyB9XG4gICAgICAgICAqL1xuICAgICAgICBzdHlsZTogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIHVzZVF1ZXJ5U3RhdGU6IFtib29sZWFuXVxuICAgICAgICAgKiBFbmFibGVzL2Rpc2FibGVzIHdoZXRoZXIgdGhpcyBidXR0b24gc2hvdWxkIHVzZSB0aGUgYnVpbHQtaW5cbiAgICAgICAgICogZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUoKSBtZXRob2QgdG8gZGV0ZXJtaW5lIHdoZXRoZXJcbiAgICAgICAgICogdGhlIGFjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQuICBJZiB0aGUgYWN0aW9uIGhhcyBhbHJlYWR5XG4gICAgICAgICAqIGJlZW4gYXBwbGllZCwgdGhlIGJ1dHRvbiB3aWxsIGJlIGRpc3BsYXllZCBhcyAnYWN0aXZlJyBpbiB0aGUgdG9vbGJhclxuICAgICAgICAgKlxuICAgICAgICAgKiBFeGFtcGxlOlxuICAgICAgICAgKiBGb3IgJ2JvbGQnLCBpZiB0aGlzIGlzIHNldCB0byB0cnVlLCB0aGUgY29kZSB3aWxsIGNhbGw6XG4gICAgICAgICAqIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN0YXRlKCdib2xkJykgd2hpY2ggd2lsbCByZXR1cm4gdHJ1ZSBpZiB0aGVcbiAgICAgICAgICogYnJvd3NlciB0aGlua3MgdGhlIHRleHQgaXMgYWxyZWFkeSBib2xkLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqL1xuICAgICAgICB1c2VRdWVyeVN0YXRlOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogY29udGVudERlZmF1bHQ6IFtzdHJpbmddXG4gICAgICAgICAqIERlZmF1bHQgaW5uZXJIVE1MIHRvIHB1dCBpbnNpZGUgdGhlIGJ1dHRvblxuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudERlZmF1bHQ6IHVuZGVmaW5lZCxcblxuICAgICAgICAvKiBjb250ZW50RkE6IFtzdHJpbmddXG4gICAgICAgICAqIFRoZSBpbm5lckhUTUwgdG8gdXNlIGZvciB0aGUgY29udGVudCBvZiB0aGUgYnV0dG9uXG4gICAgICAgICAqIGlmIHRoZSBgYnV0dG9uTGFiZWxzYCBvcHRpb24gZm9yIE1lZGl1bUVkaXRvciBpcyBzZXQgdG8gJ2ZvbnRhd2Vzb21lJ1xuICAgICAgICAgKi9cbiAgICAgICAgY29udGVudEZBOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLyogY2xhc3NMaXN0OiBbQXJyYXldXG4gICAgICAgICAqIEFuIGFycmF5IG9mIGNsYXNzTmFtZXMgKHN0cmluZ3MpIHRvIGJlIGFkZGVkIHRvIHRoZSBidXR0b25cbiAgICAgICAgICovXG4gICAgICAgIGNsYXNzTGlzdDogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8qIGF0dHJzOiBbb2JqZWN0XVxuICAgICAgICAgKiBBIHNldCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIHRvIHRoZSBidXR0b24gYXMgY3VzdG9tIGF0dHJpYnV0ZXNcbiAgICAgICAgICovXG4gICAgICAgIGF0dHJzOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLy8gVGhlIGJ1dHRvbiBjb25zdHJ1Y3RvciBjYW4gb3B0aW9uYWxseSBhY2NlcHQgdGhlIG5hbWUgb2YgYSBidWlsdC1pbiBidXR0b25cbiAgICAgICAgLy8gKGllICdib2xkJywgJ2l0YWxpYycsIGV0Yy4pXG4gICAgICAgIC8vIFdoZW4gdGhlIG5hbWUgb2YgYSBidXR0b24gaXMgcGFzc2VkLCBpdCB3aWxsIGluaXRpYWxpemUgaXRzZWxmIHdpdGggdGhlXG4gICAgICAgIC8vIGNvbmZpZ3VyYXRpb24gZm9yIHRoYXQgYnV0dG9uXG4gICAgICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKEJ1dHRvbi5pc0J1aWx0SW5CdXR0b24ob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLmNhbGwodGhpcywgdGhpcy5kZWZhdWx0c1tvcHRpb25zXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5FeHRlbnNpb24uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oKTtcbiAgICAgICAgICAgIHRoaXMub24odGhpcy5idXR0b24sICdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogZ2V0QnV0dG9uOiBbZnVuY3Rpb24gKCldXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGltcGxlbWVudGVkLCB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgICAgICAgICogdGhlIHRvb2xiYXIgaXMgYmVpbmcgY3JlYXRlZC4gIFRoZSBET00gRWxlbWVudCByZXR1cm5lZFxuICAgICAgICAgKiBieSB0aGlzIGZ1bmN0aW9uIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIHRvb2xiYXIgYWxvbmdcbiAgICAgICAgICogd2l0aCBhbnkgb3RoZXIgYnV0dG9ucy5cbiAgICAgICAgICovXG4gICAgICAgIGdldEJ1dHRvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnV0dG9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpcy5hY3Rpb24gPT09ICdmdW5jdGlvbicpID8gdGhpcy5hY3Rpb24odGhpcy5iYXNlLm9wdGlvbnMpIDogdGhpcy5hY3Rpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QXJpYTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0eXBlb2YgdGhpcy5hcmlhID09PSAnZnVuY3Rpb24nKSA/IHRoaXMuYXJpYSh0aGlzLmJhc2Uub3B0aW9ucykgOiB0aGlzLmFyaWE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VGFnTmFtZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHRoaXMudGFnTmFtZXMgPT09ICdmdW5jdGlvbicpID8gdGhpcy50YWdOYW1lcyh0aGlzLmJhc2Uub3B0aW9ucykgOiB0aGlzLnRhZ05hbWVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyksXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMuY29udGVudERlZmF1bHQsXG4gICAgICAgICAgICAgICAgYXJpYUxhYmVsID0gdGhpcy5nZXRBcmlhKCksXG4gICAgICAgICAgICAgICAgYnV0dG9uTGFiZWxzID0gdGhpcy5nZXRFZGl0b3JPcHRpb24oJ2J1dHRvbkxhYmVscycpO1xuICAgICAgICAgICAgLy8gQWRkIGNsYXNzIG5hbWVzXG4gICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnbWVkaXVtLWVkaXRvci1hY3Rpb24nKTtcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tZWRpdG9yLWFjdGlvbi0nICsgdGhpcy5uYW1lKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgYXR0cmlidXRlc1xuICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnZGF0YS1hY3Rpb24nLCB0aGlzLmdldEFjdGlvbigpKTtcbiAgICAgICAgICAgIGlmIChhcmlhTGFiZWwpIHtcbiAgICAgICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsIGFyaWFMYWJlbCk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGFyaWFMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5hdHRycykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJzW2F0dHJdKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGJ1dHRvbkxhYmVscyA9PT0gJ2ZvbnRhd2Vzb21lJyAmJiB0aGlzLmNvbnRlbnRGQSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnRGQTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmdldEFjdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leGVjQWN0aW9uKGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNBY3RpdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnModGhpcy5nZXRFZGl0b3JPcHRpb24oJ2FjdGl2ZUJ1dHRvbkNsYXNzJykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEluYWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdhY3RpdmVCdXR0b25DbGFzcycpKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmtub3duU3RhdGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0QWN0aXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdhY3RpdmVCdXR0b25DbGFzcycpKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmtub3duU3RhdGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcXVlcnlDb21tYW5kU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBxdWVyeVN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZVF1ZXJ5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVN0YXRlID0gdGhpcy5iYXNlLnF1ZXJ5Q29tbWFuZFN0YXRlKHRoaXMuZ2V0QWN0aW9uKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5U3RhdGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNBbHJlYWR5QXBwbGllZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBpc01hdGNoID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgdGFnTmFtZXMgPSB0aGlzLmdldFRhZ05hbWVzKCksXG4gICAgICAgICAgICAgICAgc3R5bGVWYWxzLFxuICAgICAgICAgICAgICAgIGNvbXB1dGVkU3R5bGU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmtub3duU3RhdGUgPT09IGZhbHNlIHx8IHRoaXMua25vd25TdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmtub3duU3RhdGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YWdOYW1lcyAmJiB0YWdOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaXNNYXRjaCA9IHRhZ05hbWVzLmluZGV4T2Yobm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNNYXRjaCAmJiB0aGlzLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVWYWxzID0gdGhpcy5zdHlsZS52YWx1ZS5zcGxpdCgnfCcpO1xuICAgICAgICAgICAgICAgIGNvbXB1dGVkU3R5bGUgPSB0aGlzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmdldFByb3BlcnR5VmFsdWUodGhpcy5zdHlsZS5wcm9wKTtcbiAgICAgICAgICAgICAgICBzdHlsZVZhbHMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5rbm93blN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc01hdGNoID0gKGNvbXB1dGVkU3R5bGUuaW5kZXhPZih2YWwpICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0LWRlY29yYXRpb24gaXMgbm90IGluaGVyaXRlZCBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBpZiB0aGUgY29tcHV0ZWQgc3R5bGUgZm9yIHRleHQtZGVjb3JhdGlvbiBkb2Vzbid0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCB3cml0ZSB0byBrbm93blN0YXRlIHNvIHdlIGNhbiBmYWxsYmFjayB0byBvdGhlciBjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc01hdGNoIHx8IHRoaXMuc3R5bGUucHJvcCAhPT0gJ3RleHQtZGVjb3JhdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtub3duU3RhdGUgPSBpc01hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpc01hdGNoO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBCdXR0b24uaXNCdWlsdEluQnV0dG9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpICYmIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbi5wcm90b3R5cGUuZGVmYXVsdHMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgfTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbiA9IEJ1dHRvbjtcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuYnV0dG9uLmRlZmF1bHRzOiBbT2JqZWN0XVxuICAgICAqIFNldCBvZiBkZWZhdWx0IGNvbmZpZyBvcHRpb25zIGZvciBhbGwgb2YgdGhlIGJ1aWx0LWluIE1lZGl1bUVkaXRvciBidXR0b25zXG4gICAgICovXG4gICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuYnV0dG9uLnByb3RvdHlwZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgJ2JvbGQnOiB7XG4gICAgICAgICAgICBuYW1lOiAnYm9sZCcsXG4gICAgICAgICAgICBhY3Rpb246ICdib2xkJyxcbiAgICAgICAgICAgIGFyaWE6ICdib2xkJyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ2InLCAnc3Ryb25nJ10sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHByb3A6ICdmb250LXdlaWdodCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICc3MDB8Ym9sZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1c2VRdWVyeVN0YXRlOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5CPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWJvbGRcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnaXRhbGljJzoge1xuICAgICAgICAgICAgbmFtZTogJ2l0YWxpYycsXG4gICAgICAgICAgICBhY3Rpb246ICdpdGFsaWMnLFxuICAgICAgICAgICAgYXJpYTogJ2l0YWxpYycsXG4gICAgICAgICAgICB0YWdOYW1lczogWydpJywgJ2VtJ10sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHByb3A6ICdmb250LXN0eWxlJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ2l0YWxpYydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1c2VRdWVyeVN0YXRlOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj48aT5JPC9pPjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1pdGFsaWNcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAndW5kZXJsaW5lJzoge1xuICAgICAgICAgICAgbmFtZTogJ3VuZGVybGluZScsXG4gICAgICAgICAgICBhY3Rpb246ICd1bmRlcmxpbmUnLFxuICAgICAgICAgICAgYXJpYTogJ3VuZGVybGluZScsXG4gICAgICAgICAgICB0YWdOYW1lczogWyd1J10sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHByb3A6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAndW5kZXJsaW5lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGU6IHRydWUsXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPjx1PlU8L3U+PC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLXVuZGVybGluZVwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdzdHJpa2V0aHJvdWdoJzoge1xuICAgICAgICAgICAgbmFtZTogJ3N0cmlrZXRocm91Z2gnLFxuICAgICAgICAgICAgYWN0aW9uOiAnc3RyaWtldGhyb3VnaCcsXG4gICAgICAgICAgICBhcmlhOiAnc3RyaWtlIHRocm91Z2gnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsnc3RyaWtlJ10sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHByb3A6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnbGluZS10aHJvdWdoJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVzZVF1ZXJ5U3RhdGU6IHRydWUsXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxzPkE8L3M+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtc3RyaWtldGhyb3VnaFwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdzdXBlcnNjcmlwdCc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdzdXBlcnNjcmlwdCcsXG4gICAgICAgICAgICBhY3Rpb246ICdzdXBlcnNjcmlwdCcsXG4gICAgICAgICAgICBhcmlhOiAnc3VwZXJzY3JpcHQnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsnc3VwJ10sXG4gICAgICAgICAgICAvKiBmaXJlZm94IGRvZXNuJ3QgYmVoYXZlIHRoZSB3YXkgd2Ugd2FudCBpdCB0bywgc28gd2UgQ0FOJ1QgdXNlIHF1ZXJ5Q29tbWFuZFN0YXRlIGZvciBzdXBlcnNjcmlwdFxuICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2d1YXJkaWFuL3NjcmliZS9ibG9iL21hc3Rlci9CUk9XU0VSSU5DT05TSVNURU5DSUVTLm1kI2RvY3VtZW50cXVlcnljb21tYW5kc3RhdGUgKi9cbiAgICAgICAgICAgIC8vIHVzZVF1ZXJ5U3RhdGU6IHRydWVcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+eDxzdXA+MTwvc3VwPjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1zdXBlcnNjcmlwdFwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdzdWJzY3JpcHQnOiB7XG4gICAgICAgICAgICBuYW1lOiAnc3Vic2NyaXB0JyxcbiAgICAgICAgICAgIGFjdGlvbjogJ3N1YnNjcmlwdCcsXG4gICAgICAgICAgICBhcmlhOiAnc3Vic2NyaXB0JyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ3N1YiddLFxuICAgICAgICAgICAgLyogZmlyZWZveCBkb2Vzbid0IGJlaGF2ZSB0aGUgd2F5IHdlIHdhbnQgaXQgdG8sIHNvIHdlIENBTidUIHVzZSBxdWVyeUNvbW1hbmRTdGF0ZSBmb3Igc3Vic2NyaXB0XG4gICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZ3VhcmRpYW4vc2NyaWJlL2Jsb2IvbWFzdGVyL0JST1dTRVJJTkNPTlNJU1RFTkNJRVMubWQjZG9jdW1lbnRxdWVyeWNvbW1hbmRzdGF0ZSAqL1xuICAgICAgICAgICAgLy8gdXNlUXVlcnlTdGF0ZTogdHJ1ZVxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj54PHN1Yj4xPC9zdWI+PC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLXN1YnNjcmlwdFwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdpbWFnZSc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbWFnZScsXG4gICAgICAgICAgICBhY3Rpb246ICdpbWFnZScsXG4gICAgICAgICAgICBhcmlhOiAnaW1hZ2UnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsnaW1nJ10sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPmltYWdlPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLXBpY3R1cmUtb1wiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdvcmRlcmVkbGlzdCc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdvcmRlcmVkbGlzdCcsXG4gICAgICAgICAgICBhY3Rpb246ICdpbnNlcnRvcmRlcmVkbGlzdCcsXG4gICAgICAgICAgICBhcmlhOiAnb3JkZXJlZCBsaXN0JyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ29sJ10sXG4gICAgICAgICAgICB1c2VRdWVyeVN0YXRlOiB0cnVlLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj4xLjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1saXN0LW9sXCI+PC9pPidcbiAgICAgICAgfSxcbiAgICAgICAgJ3Vub3JkZXJlZGxpc3QnOiB7XG4gICAgICAgICAgICBuYW1lOiAndW5vcmRlcmVkbGlzdCcsXG4gICAgICAgICAgICBhY3Rpb246ICdpbnNlcnR1bm9yZGVyZWRsaXN0JyxcbiAgICAgICAgICAgIGFyaWE6ICd1bm9yZGVyZWQgbGlzdCcsXG4gICAgICAgICAgICB0YWdOYW1lczogWyd1bCddLFxuICAgICAgICAgICAgdXNlUXVlcnlTdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+JmJ1bGw7PC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWxpc3QtdWxcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnaW5kZW50Jzoge1xuICAgICAgICAgICAgbmFtZTogJ2luZGVudCcsXG4gICAgICAgICAgICBhY3Rpb246ICdpbmRlbnQnLFxuICAgICAgICAgICAgYXJpYTogJ2luZGVudCcsXG4gICAgICAgICAgICB0YWdOYW1lczogW10sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPiZyYXJyOzwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1pbmRlbnRcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAnb3V0ZGVudCc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdvdXRkZW50JyxcbiAgICAgICAgICAgIGFjdGlvbjogJ291dGRlbnQnLFxuICAgICAgICAgICAgYXJpYTogJ291dGRlbnQnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFtdLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj4mbGFycjs8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtb3V0ZGVudFwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdqdXN0aWZ5Q2VudGVyJzoge1xuICAgICAgICAgICAgbmFtZTogJ2p1c3RpZnlDZW50ZXInLFxuICAgICAgICAgICAgYWN0aW9uOiAnanVzdGlmeUNlbnRlcicsXG4gICAgICAgICAgICBhcmlhOiAnY2VudGVyIGp1c3RpZnknLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFtdLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBwcm9wOiAndGV4dC1hbGlnbicsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICdjZW50ZXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5DPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWFsaWduLWNlbnRlclwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdqdXN0aWZ5RnVsbCc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdqdXN0aWZ5RnVsbCcsXG4gICAgICAgICAgICBhY3Rpb246ICdqdXN0aWZ5RnVsbCcsXG4gICAgICAgICAgICBhcmlhOiAnZnVsbCBqdXN0aWZ5JyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgcHJvcDogJ3RleHQtYWxpZ24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnanVzdGlmeSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPko8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtYWxpZ24tanVzdGlmeVwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdqdXN0aWZ5TGVmdCc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdqdXN0aWZ5TGVmdCcsXG4gICAgICAgICAgICBhY3Rpb246ICdqdXN0aWZ5TGVmdCcsXG4gICAgICAgICAgICBhcmlhOiAnbGVmdCBqdXN0aWZ5JyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgcHJvcDogJ3RleHQtYWxpZ24nLFxuICAgICAgICAgICAgICAgIHZhbHVlOiAnbGVmdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPkw8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtYWxpZ24tbGVmdFwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgICdqdXN0aWZ5UmlnaHQnOiB7XG4gICAgICAgICAgICBuYW1lOiAnanVzdGlmeVJpZ2h0JyxcbiAgICAgICAgICAgIGFjdGlvbjogJ2p1c3RpZnlSaWdodCcsXG4gICAgICAgICAgICBhcmlhOiAncmlnaHQganVzdGlmeScsXG4gICAgICAgICAgICB0YWdOYW1lczogW10sXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHByb3A6ICd0ZXh0LWFsaWduJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogJ3JpZ2h0J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+UjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1hbGlnbi1yaWdodFwiPjwvaT4nXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEtub3duIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBub3QgcmVtb3ZlZCwgb3Igbm90IHJlbW92ZWQgY29uc2lzdGFudGx5IGFjcm9zcyBicm93c2VyczpcbiAgICAgICAgLy8gPHNwYW4+LCA8bGFiZWw+LCA8YnI+XG4gICAgICAgICdyZW1vdmVGb3JtYXQnOiB7XG4gICAgICAgICAgICBuYW1lOiAncmVtb3ZlRm9ybWF0JyxcbiAgICAgICAgICAgIGFyaWE6ICdyZW1vdmUgZm9ybWF0dGluZycsXG4gICAgICAgICAgICBhY3Rpb246ICdyZW1vdmVGb3JtYXQnLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5YPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWVyYXNlclwiPjwvaT4nXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqKioqIEJ1dHRvbnMgZm9yIGFwcGVuZGluZyBibG9jayBlbGVtZW50cyAoYXBwZW5kLTxlbGVtZW50PiBhY3Rpb24pICoqKioqL1xuXG4gICAgICAgICdxdW90ZSc6IHtcbiAgICAgICAgICAgIG5hbWU6ICdxdW90ZScsXG4gICAgICAgICAgICBhY3Rpb246ICdhcHBlbmQtYmxvY2txdW90ZScsXG4gICAgICAgICAgICBhcmlhOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICB0YWdOYW1lczogWydibG9ja3F1b3RlJ10sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPiZsZHF1bzs8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtcXVvdGUtcmlnaHRcIj48L2k+J1xuICAgICAgICB9LFxuICAgICAgICAncHJlJzoge1xuICAgICAgICAgICAgbmFtZTogJ3ByZScsXG4gICAgICAgICAgICBhY3Rpb246ICdhcHBlbmQtcHJlJyxcbiAgICAgICAgICAgIGFyaWE6ICdwcmVmb3JtYXR0ZWQgdGV4dCcsXG4gICAgICAgICAgICB0YWdOYW1lczogWydwcmUnXSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+MDEwMTwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1jb2RlIGZhLWxnXCI+PC9pPidcbiAgICAgICAgfSxcbiAgICAgICAgJ2gxJzoge1xuICAgICAgICAgICAgbmFtZTogJ2gxJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ2FwcGVuZC1oMScsXG4gICAgICAgICAgICBhcmlhOiAnaGVhZGVyIHR5cGUgb25lJyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ2gxJ10sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPkgxPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWhlYWRlclwiPjxzdXA+MTwvc3VwPidcbiAgICAgICAgfSxcbiAgICAgICAgJ2gyJzoge1xuICAgICAgICAgICAgbmFtZTogJ2gyJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ2FwcGVuZC1oMicsXG4gICAgICAgICAgICBhcmlhOiAnaGVhZGVyIHR5cGUgdHdvJyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ2gyJ10sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPkgyPC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWhlYWRlclwiPjxzdXA+Mjwvc3VwPidcbiAgICAgICAgfSxcbiAgICAgICAgJ2gzJzoge1xuICAgICAgICAgICAgbmFtZTogJ2gzJyxcbiAgICAgICAgICAgIGFjdGlvbjogJ2FwcGVuZC1oMycsXG4gICAgICAgICAgICBhcmlhOiAnaGVhZGVyIHR5cGUgdGhyZWUnLFxuICAgICAgICAgICAgdGFnTmFtZXM6IFsnaDMnXSxcbiAgICAgICAgICAgIGNvbnRlbnREZWZhdWx0OiAnPGI+SDM8L2I+JyxcbiAgICAgICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtaGVhZGVyXCI+PHN1cD4zPC9zdXA+J1xuICAgICAgICB9LFxuICAgICAgICAnaDQnOiB7XG4gICAgICAgICAgICBuYW1lOiAnaDQnLFxuICAgICAgICAgICAgYWN0aW9uOiAnYXBwZW5kLWg0JyxcbiAgICAgICAgICAgIGFyaWE6ICdoZWFkZXIgdHlwZSBmb3VyJyxcbiAgICAgICAgICAgIHRhZ05hbWVzOiBbJ2g0J10sXG4gICAgICAgICAgICBjb250ZW50RGVmYXVsdDogJzxiPkg0PC9iPicsXG4gICAgICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWhlYWRlclwiPjxzdXA+NDwvc3VwPidcbiAgICAgICAgfSxcbiAgICAgICAgJ2g1Jzoge1xuICAgICAgICAgICAgbmFtZTogJ2g1JyxcbiAgICAgICAgICAgIGFjdGlvbjogJ2FwcGVuZC1oNScsXG4gICAgICAgICAgICBhcmlhOiAnaGVhZGVyIHR5cGUgZml2ZScsXG4gICAgICAgICAgICB0YWdOYW1lczogWydoNSddLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5INTwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1oZWFkZXJcIj48c3VwPjU8L3N1cD4nXG4gICAgICAgIH0sXG4gICAgICAgICdoNic6IHtcbiAgICAgICAgICAgIG5hbWU6ICdoNicsXG4gICAgICAgICAgICBhY3Rpb246ICdhcHBlbmQtaDYnLFxuICAgICAgICAgICAgYXJpYTogJ2hlYWRlciB0eXBlIHNpeCcsXG4gICAgICAgICAgICB0YWdOYW1lczogWydoNiddLFxuICAgICAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj5INjwvYj4nLFxuICAgICAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS1oZWFkZXJcIj48c3VwPjY8L3N1cD4nXG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKiBCYXNlIGZ1bmN0aW9uYWxpdHkgZm9yIGFuIGV4dGVuc2lvbiB3aGljaCB3aWxsIGRpc3BsYXlcbiAgICAgKiBhICdmb3JtJyBpbnNpZGUgdGhlIHRvb2xiYXJcbiAgICAgKi9cbiAgICB2YXIgRm9ybUV4dGVuc2lvbiA9IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbi5leHRlbmQoe1xuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmJ1dHRvbi5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGRlZmF1bHQgbGFiZWxzIGZvciB0aGUgZm9ybSBidXR0b25zXG4gICAgICAgIGZvcm1TYXZlTGFiZWw6ICcmIzEwMDAzOycsXG4gICAgICAgIGZvcm1DbG9zZUxhYmVsOiAnJnRpbWVzOycsXG5cbiAgICAgICAgLyogYWN0aXZlQ2xhc3M6IFtzdHJpbmddXG4gICAgICAgICAqIHNldCBjbGFzcyB3aGljaCBhZGRlZCB0byBzaG93biBmb3JtXG4gICAgICAgICAqL1xuICAgICAgICBhY3RpdmVDbGFzczogJ21lZGl1bS1lZGl0b3ItdG9vbGJhci1mb3JtLWFjdGl2ZScsXG5cbiAgICAgICAgLyogaGFzRm9ybTogW2Jvb2xlYW5dXG4gICAgICAgICAqXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyB0byB0cnVlIHdpbGwgY2F1c2UgZ2V0Rm9ybSgpIHRvIGJlIGNhbGxlZFxuICAgICAgICAgKiB3aGVuIHRoZSB0b29sYmFyIGlzIGNyZWF0ZWQsIHNvIHRoZSBmb3JtIGNhbiBiZSBhcHBlbmRlZFxuICAgICAgICAgKiBpbnNpZGUgdGhlIHRvb2xiYXIgY29udGFpbmVyXG4gICAgICAgICAqL1xuICAgICAgICBoYXNGb3JtOiB0cnVlLFxuXG4gICAgICAgIC8qIGdldEZvcm06IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBoYXNGb3JtIGlzIHRydWUsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBpbXBsZW1lbnRlZFxuICAgICAgICAgKiBhbmQgcmV0dXJuIGEgRE9NIEVsZW1lbnQgd2hpY2ggd2lsbCBiZSBhcHBlbmRlZCB0b1xuICAgICAgICAgKiB0aGUgdG9vbGJhciBjb250YWluZXIuIFRoZSBmb3JtIHNob3VsZCBzdGFydCBoaWRkZW4sIGFuZFxuICAgICAgICAgKiB0aGUgZXh0ZW5zaW9uIGNhbiBjaG9vc2Ugd2hlbiB0byBoaWRlL3Nob3cgaXRcbiAgICAgICAgICovXG4gICAgICAgIGdldEZvcm06IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIC8qIGlzRGlzcGxheWVkOiBbZnVuY3Rpb24gKCldXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiB0cnVlL2ZhbHNlIHJlZmxlY3RpbmdcbiAgICAgICAgICogd2hldGhlciB0aGUgZm9ybSBpcyBjdXJyZW50bHkgZGlzcGxheWVkXG4gICAgICAgICAqL1xuICAgICAgICBpc0Rpc3BsYXllZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZvcm0oKS5jbGFzc0xpc3QuY29udGFpbnModGhpcy5hY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogaGlkZUZvcm06IFtmdW5jdGlvbiAoKV1cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgc2hvdyB0aGUgZm9ybSBlbGVtZW50IGluc2lkZVxuICAgICAgICAgKiB0aGUgdG9vbGJhciBjb250YWluZXJcbiAgICAgICAgICovXG4gICAgICAgIHNob3dGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGb3JtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRGb3JtKCkuY2xhc3NMaXN0LmFkZCh0aGlzLmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKiBoaWRlRm9ybTogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBoaWRlIHRoZSBmb3JtIGVsZW1lbnQgaW5zaWRlXG4gICAgICAgICAqIHRoZSB0b29sYmFyIGNvbnRhaW5lclxuICAgICAgICAgKi9cbiAgICAgICAgaGlkZUZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0Zvcm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEZvcm0oKS5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKiogSGVscGVycyAqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBhcmUgaGVscGVycyB0aGF0IGFyZSBlaXRoZXIgc2V0IGJ5IE1lZGl1bUVkaXRvclxuICAgICAgICAgKiBkdXJpbmcgaW5pdGlhbGl6YXRpb24sIG9yIGFyZSBoZWxwZXIgbWV0aG9kcyB3aGljaCBlaXRoZXJcbiAgICAgICAgICogcm91dGUgY2FsbHMgdG8gdGhlIE1lZGl1bUVkaXRvciBpbnN0YW5jZSBvciBwcm92aWRlIGNvbW1vblxuICAgICAgICAgKiBmdW5jdGlvbmFsaXR5IGZvciBhbGwgZm9ybSBleHRlbnNpb25zXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyogc2hvd1Rvb2xiYXJEZWZhdWx0QWN0aW9uczogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBIZWxwZXIgbWV0aG9kIHdoaWNoIHdpbGwgdHVybiBiYWNrIHRoZSB0b29sYmFyIGFmdGVyIGNhbmNlbGluZ1xuICAgICAgICAgKiB0aGUgY3VzdG9taXplZCBmb3JtXG4gICAgICAgICAqL1xuICAgICAgICBzaG93VG9vbGJhckRlZmF1bHRBY3Rpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9vbGJhciA9IHRoaXMuYmFzZS5nZXRFeHRlbnNpb25CeU5hbWUoJ3Rvb2xiYXInKTtcbiAgICAgICAgICAgIGlmICh0b29sYmFyKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhci5zaG93VG9vbGJhckRlZmF1bHRBY3Rpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogaGlkZVRvb2xiYXJEZWZhdWx0QWN0aW9uczogW2Z1bmN0aW9uICgpXVxuICAgICAgICAgKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggd2lsbCBoaWRlIHRoZSBkZWZhdWx0IGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgKiB0b29sYmFyLCBidXQgbGVhdmUgdGhlIHRvb2xiYXIgY29udGFpbmVyIGluIHRoZSBzYW1lIHN0YXRlXG4gICAgICAgICAqIHRvIGFsbG93IGEgZm9ybSB0byBkaXNwbGF5IGl0cyBjdXN0b20gY29udGVudHMgaW5zaWRlIHRoZSB0b29sYmFyXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlVG9vbGJhckRlZmF1bHRBY3Rpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9vbGJhciA9IHRoaXMuYmFzZS5nZXRFeHRlbnNpb25CeU5hbWUoJ3Rvb2xiYXInKTtcbiAgICAgICAgICAgIGlmICh0b29sYmFyKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhci5oaWRlVG9vbGJhckRlZmF1bHRBY3Rpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyogc2V0VG9vbGJhclBvc2l0aW9uOiBbZnVuY3Rpb24gKCldXG4gICAgICAgICAqXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiB3aGljaCB3aWxsIHVwZGF0ZSB0aGUgc2l6ZSBhbmQgcG9zaXRpb25cbiAgICAgICAgICogb2YgdGhlIHRvb2xiYXIgYmFzZWQgb24gdGhlIHRvb2xiYXIgY29udGVudCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgICAgICogcG9zaXRpb24gb2YgdGhlIHVzZXIncyBzZWxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHNldFRvb2xiYXJQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmJhc2UuZ2V0RXh0ZW5zaW9uQnlOYW1lKCd0b29sYmFyJyk7XG4gICAgICAgICAgICBpZiAodG9vbGJhcikge1xuICAgICAgICAgICAgICAgIHRvb2xiYXIuc2V0VG9vbGJhclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvcm0gPSBGb3JtRXh0ZW5zaW9uO1xufSkoKTtcbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEFuY2hvckZvcm0gPSBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5mb3JtLmV4dGVuZCh7XG4gICAgICAgIC8qIEFuY2hvciBGb3JtIE9wdGlvbnMgKi9cblxuICAgICAgICAvKiBjdXN0b21DbGFzc09wdGlvbjogW3N0cmluZ10gIChwcmV2aW91c2x5IG9wdGlvbnMuYW5jaG9yQnV0dG9uICsgb3B0aW9ucy5hbmNob3JCdXR0b25DbGFzcylcbiAgICAgICAgICogQ3VzdG9tIGNsYXNzIG5hbWUgdGhlIHVzZXIgY2FuIG9wdGlvbmFsbHkgaGF2ZSBhZGRlZCB0byB0aGVpciBjcmVhdGVkIGxpbmtzIChpZSAnYnV0dG9uJykuXG4gICAgICAgICAqIElmIHBhc3NlZCBhcyBhIG5vbi1lbXB0eSBzdHJpbmcsIGEgY2hlY2tib3ggd2lsbCBiZSBkaXNwbGF5ZWQgYWxsb3dpbmcgdGhlIHVzZXIgdG8gY2hvb3NlXG4gICAgICAgICAqIHdoZXRoZXIgdG8gaGF2ZSB0aGUgY2xhc3MgYWRkZWQgdG8gdGhlIGNyZWF0ZWQgbGluayBvciBub3QuXG4gICAgICAgICAqL1xuICAgICAgICBjdXN0b21DbGFzc09wdGlvbjogbnVsbCxcblxuICAgICAgICAvKiBjdXN0b21DbGFzc09wdGlvblRleHQ6IFtzdHJpbmddXG4gICAgICAgICAqIHRleHQgdG8gYmUgc2hvd24gaW4gdGhlIGNoZWNrYm94IHdoZW4gdGhlIF9fY3VzdG9tQ2xhc3NPcHRpb25fXyBpcyBiZWluZyB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY3VzdG9tQ2xhc3NPcHRpb25UZXh0OiAnQnV0dG9uJyxcblxuICAgICAgICAvKiBsaW5rVmFsaWRhdGlvbjogW2Jvb2xlYW5dICAocHJldmlvdXNseSBvcHRpb25zLmNoZWNrTGlua0Zvcm1hdClcbiAgICAgICAgICogZW5hYmxlcy9kaXNhYmxlcyBjaGVjayBmb3IgY29tbW9uIFVSTCBwcm90b2NvbHMgb24gYW5jaG9yIGxpbmtzLlxuICAgICAgICAgKi9cbiAgICAgICAgbGlua1ZhbGlkYXRpb246IGZhbHNlLFxuXG4gICAgICAgIC8qIHBsYWNlaG9sZGVyVGV4dDogW3N0cmluZ10gIChwcmV2aW91c2x5IG9wdGlvbnMuYW5jaG9ySW5wdXRQbGFjZWhvbGRlcilcbiAgICAgICAgICogdGV4dCB0byBiZSBzaG93biBhcyBwbGFjZWhvbGRlciBvZiB0aGUgYW5jaG9yIGlucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgcGxhY2Vob2xkZXJUZXh0OiAnUGFzdGUgb3IgdHlwZSBhIGxpbmsnLFxuXG4gICAgICAgIC8qIHRhcmdldENoZWNrYm94OiBbYm9vbGVhbl0gIChwcmV2aW91c2x5IG9wdGlvbnMuYW5jaG9yVGFyZ2V0KVxuICAgICAgICAgKiBlbmFibGVzL2Rpc2FibGVzIGRpc3BsYXlpbmcgYSBcIk9wZW4gaW4gbmV3IHdpbmRvd1wiIGNoZWNrYm94LCB3aGljaCB3aGVuIGNoZWNrZWRcbiAgICAgICAgICogY2hhbmdlcyB0aGUgYHRhcmdldGAgYXR0cmlidXRlIG9mIHRoZSBjcmVhdGVkIGxpbmsuXG4gICAgICAgICAqL1xuICAgICAgICB0YXJnZXRDaGVja2JveDogZmFsc2UsXG5cbiAgICAgICAgLyogdGFyZ2V0Q2hlY2tib3hUZXh0OiBbc3RyaW5nXSAgKHByZXZpb3VzbHkgb3B0aW9ucy5hbmNob3JJbnB1dENoZWNrYm94TGFiZWwpXG4gICAgICAgICAqIHRleHQgdG8gYmUgc2hvd24gaW4gdGhlIGNoZWNrYm94IGVuYWJsZWQgdmlhIHRoZSBfX3RhcmdldENoZWNrYm94X18gb3B0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGFyZ2V0Q2hlY2tib3hUZXh0OiAnT3BlbiBpbiBuZXcgd2luZG93JyxcblxuICAgICAgICAvLyBPcHRpb25zIGZvciB0aGUgQnV0dG9uIGJhc2UgY2xhc3NcbiAgICAgICAgbmFtZTogJ2FuY2hvcicsXG4gICAgICAgIGFjdGlvbjogJ2NyZWF0ZUxpbmsnLFxuICAgICAgICBhcmlhOiAnbGluaycsXG4gICAgICAgIHRhZ05hbWVzOiBbJ2EnXSxcbiAgICAgICAgY29udGVudERlZmF1bHQ6ICc8Yj4jPC9iPicsXG4gICAgICAgIGNvbnRlbnRGQTogJzxpIGNsYXNzPVwiZmEgZmEtbGlua1wiPjwvaT4nLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvcm0ucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlS2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiB0aGUgYnV0dG9uIHRoZSB0b29sYmFyIGlzIGNsaWNrZWRcbiAgICAgICAgLy8gT3ZlcnJpZGVzIEJ1dHRvbkV4dGVuc2lvbi5oYW5kbGVDbGlja1xuICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciByYW5nZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5kb2N1bWVudCk7XG5cbiAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydENvbnRhaW5lci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScgfHxcbiAgICAgICAgICAgICAgICByYW5nZS5lbmRDb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnIHx8XG4gICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuZ2V0Q2xvc2VzdFRhZyhNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGVkUGFyZW50RWxlbWVudChyYW5nZSksICdhJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leGVjQWN0aW9uKCd1bmxpbmsnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiB1c2VyIGhpdHMgdGhlIGRlZmluZWQgc2hvcnRjdXQgKENUUkwgLyBDT01NQU5EICsgSylcbiAgICAgICAgaGFuZGxlS2V5ZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuSykgJiYgTWVkaXVtRWRpdG9yLnV0aWwuaXNNZXRhQ3RybEtleShldmVudCkgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbGljayhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbGVkIGJ5IG1lZGl1bS1lZGl0b3IgdG8gYXBwZW5kIGZvcm0gdG8gdGhlIHRvb2xiYXJcbiAgICAgICAgZ2V0Rm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0gPSB0aGlzLmNyZWF0ZUZvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VGVtcGxhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IFtcbiAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRvb2xiYXItaW5wdXRcIiBwbGFjZWhvbGRlcj1cIicsIHRoaXMucGxhY2Vob2xkZXJUZXh0LCAnXCI+J1xuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdGVtcGxhdGUucHVzaChcbiAgICAgICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm1lZGl1bS1lZGl0b3ItdG9vbGJhci1zYXZlXCI+JyxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEVkaXRvck9wdGlvbignYnV0dG9uTGFiZWxzJykgPT09ICdmb250YXdlc29tZScgPyAnPGkgY2xhc3M9XCJmYSBmYS1jaGVja1wiPjwvaT4nIDogdGhpcy5mb3JtU2F2ZUxhYmVsLFxuICAgICAgICAgICAgICAgICc8L2E+J1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdGVtcGxhdGUucHVzaCgnPGEgaHJlZj1cIiNcIiBjbGFzcz1cIm1lZGl1bS1lZGl0b3ItdG9vbGJhci1jbG9zZVwiPicsXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFZGl0b3JPcHRpb24oJ2J1dHRvbkxhYmVscycpID09PSAnZm9udGF3ZXNvbWUnID8gJzxpIGNsYXNzPVwiZmEgZmEtdGltZXNcIj48L2k+JyA6IHRoaXMuZm9ybUNsb3NlTGFiZWwsXG4gICAgICAgICAgICAgICAgJzwvYT4nKTtcblxuICAgICAgICAgICAgLy8gYm90aCBvZiB0aGVzZSBvcHRpb25zIGFyZSBzbGlnaHRseSBtb290IHdpdGggdGhlIGFiaWxpdHkgdG9cbiAgICAgICAgICAgIC8vIG92ZXJyaWRlIHRoZSB2YXJpb3VzIGZvcm0gYnVpbGR1cC9zZXJpYWxpemUgZnVuY3Rpb25zLlxuXG4gICAgICAgICAgICBpZiAodGhpcy50YXJnZXRDaGVja2JveCkge1xuICAgICAgICAgICAgICAgIC8vIGZpeG1lOiBpZGVhbGx5LCB0aGlzIHRhcmdldENoZWNrYm94VGV4dCB3b3VsZCBiZSBhIGZvcm1MYWJlbCB0b28sXG4gICAgICAgICAgICAgICAgLy8gZmlndXJlIG91dCBob3cgdG8gZGVwcmVjYXRlPyBhbHNvIGNvbnNpZGVyIGBmYS1gIGljb24gZGVmYXVsdCBpbXBsY2F0aW9ucy5cbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cIm1lZGl1bS1lZGl0b3ItdG9vbGJhci1mb3JtLXJvd1wiPicsXG4gICAgICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRvb2xiYXItYW5jaG9yLXRhcmdldFwiPicsXG4gICAgICAgICAgICAgICAgICAgICc8bGFiZWw+JyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRDaGVja2JveFRleHQsXG4gICAgICAgICAgICAgICAgICAgICc8L2xhYmVsPicsXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY3VzdG9tQ2xhc3NPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBmaXhtZTogZXhwb3NlIHRoaXMgYEJ1dHRvbmAgdGV4dCBhcyBhIGZvcm1MYWJlbCBwcm9wZXJ0eSwgdG9vXG4gICAgICAgICAgICAgICAgLy8gYW5kIHByb3ZpZGUgc2ltaWxhciBhY2Nlc3MgdG8gYSBgZmEtYCBpY29uIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgdGVtcGxhdGUucHVzaChcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRvb2xiYXItZm9ybS1yb3dcIj4nLFxuICAgICAgICAgICAgICAgICAgICAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwibWVkaXVtLWVkaXRvci10b29sYmFyLWFuY2hvci1idXR0b25cIj4nLFxuICAgICAgICAgICAgICAgICAgICAnPGxhYmVsPicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tQ2xhc3NPcHRpb25UZXh0LFxuICAgICAgICAgICAgICAgICAgICAnPC9sYWJlbD4nLFxuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+J1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZS5qb2luKCcnKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFVzZWQgYnkgbWVkaXVtLWVkaXRvciB3aGVuIHRoZSBkZWZhdWx0IHRvb2xiYXIgaXMgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgIGlzRGlzcGxheWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9ybS5wcm90b3R5cGUuaXNEaXNwbGF5ZWQuYXBwbHkodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZUZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvcm0ucHJvdG90eXBlLmhpZGVGb3JtLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5nZXRJbnB1dCgpLnZhbHVlID0gJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd0Zvcm06IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLmdldElucHV0KCksXG4gICAgICAgICAgICAgICAgdGFyZ2V0Q2hlY2tib3ggPSB0aGlzLmdldEFuY2hvclRhcmdldENoZWNrYm94KCksXG4gICAgICAgICAgICAgICAgYnV0dG9uQ2hlY2tib3ggPSB0aGlzLmdldEFuY2hvckJ1dHRvbkNoZWNrYm94KCk7XG5cbiAgICAgICAgICAgIG9wdHMgPSBvcHRzIHx8IHsgdmFsdWU6ICcnIH07XG4gICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0YWJpbGl0eVxuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBzdXBwb3J0IHRoZSAnc3RyaW5nJyBhcmd1bWVudCBpbiA2LjAuMFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5iYXNlLnNhdmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2xiYXJEZWZhdWx0QWN0aW9ucygpO1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9ybS5wcm90b3R5cGUuc2hvd0Zvcm0uYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnNldFRvb2xiYXJQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IG9wdHMudmFsdWU7XG4gICAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdGFyZ2V0IGNoZWNrYm94LCB3ZSB3YW50IGl0IHRvIGJlIGNoZWNrZWQvdW5jaGVja2VkXG4gICAgICAgICAgICAvLyBiYXNlZCBvbiB3aGV0aGVyIHRoZSBleGlzdGluZyBsaW5rIGhhcyB0YXJnZXQ9X2JsYW5rXG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2hlY2tib3gpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRDaGVja2JveC5jaGVja2VkID0gb3B0cy50YXJnZXQgPT09ICdfYmxhbmsnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY3VzdG9tIGNsYXNzIGNoZWNrYm94LCB3ZSB3YW50IGl0IHRvIGJlIGNoZWNrZWQvdW5jaGVja2VkXG4gICAgICAgICAgICAvLyBiYXNlZCBvbiB3aGV0aGVyIGFuIGV4aXN0aW5nIGxpbmsgYWxyZWFkeSBoYXMgdGhlIGNsYXNzXG4gICAgICAgICAgICBpZiAoYnV0dG9uQ2hlY2tib3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NMaXN0ID0gb3B0cy5idXR0b25DbGFzcyA/IG9wdHMuYnV0dG9uQ2xhc3Muc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICAgICAgICAgIGJ1dHRvbkNoZWNrYm94LmNoZWNrZWQgPSAoY2xhc3NMaXN0LmluZGV4T2YodGhpcy5jdXN0b21DbGFzc09wdGlvbikgIT09IC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgYnkgY29yZSB3aGVuIHRlYXJpbmcgZG93biBtZWRpdW0tZWRpdG9yIChkZXN0cm95KVxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZm9ybTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjb3JlIG1ldGhvZHNcblxuICAgICAgICBnZXRGb3JtT3B0czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gbm8gbm90aW9uIG9mIHByaXZhdGUgZnVuY3Rpb25zPyB3YW50ZWQgYF9nZXRGb3JtT3B0c2BcbiAgICAgICAgICAgIHZhciB0YXJnZXRDaGVja2JveCA9IHRoaXMuZ2V0QW5jaG9yVGFyZ2V0Q2hlY2tib3goKSxcbiAgICAgICAgICAgICAgICBidXR0b25DaGVja2JveCA9IHRoaXMuZ2V0QW5jaG9yQnV0dG9uQ2hlY2tib3goKSxcbiAgICAgICAgICAgICAgICBvcHRzID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5nZXRJbnB1dCgpLnZhbHVlLnRyaW0oKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmtWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0cy52YWx1ZSA9IHRoaXMuY2hlY2tMaW5rRm9ybWF0KG9wdHMudmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRzLnRhcmdldCA9ICdfc2VsZic7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q2hlY2tib3ggJiYgdGFyZ2V0Q2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIG9wdHMudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChidXR0b25DaGVja2JveCAmJiBidXR0b25DaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5idXR0b25DbGFzcyA9IHRoaXMuY3VzdG9tQ2xhc3NPcHRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRvRm9ybVNhdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5nZXRGb3JtT3B0cygpO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUZvcm1TYXZlKG9wdHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXBsZXRlRm9ybVNhdmU6IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5leGVjQWN0aW9uKHRoaXMuYWN0aW9uLCBvcHRzKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZS5jaGVja1NlbGVjdGlvbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNoZWNrTGlua0Zvcm1hdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBNYXRjaGVzIGFueSBhbHBoYWJldGljYWwgY2hhcmFjdGVycyBmb2xsb3dlZCBieSA6Ly9cbiAgICAgICAgICAgIC8vIE1hdGNoZXMgcHJvdG9jb2wgcmVsYXRpdmUgXCIvL1wiXG4gICAgICAgICAgICAvLyBNYXRjaGVzIGNvbW1vbiBleHRlcm5hbCBwcm90b2NvbHMgXCJtYWlsdG86XCIgXCJ0ZWw6XCIgXCJtYXBzOlwiXG4gICAgICAgICAgICB2YXIgdXJsU2NoZW1lUmVnZXggPSAvXihbYS16XSs6KT9cXC9cXC98XihtYWlsdG98dGVsfG1hcHMpOi9pLFxuICAgICAgICAgICAgLy8gdmFyIHRlIGlzIGEgcmVnZXggZm9yIGNoZWNraW5nIGlmIHRoZSBzdHJpbmcgaXMgYSB0ZWxlcGhvbmUgbnVtYmVyXG4gICAgICAgICAgICB0ZWxSZWdleCA9IC9eXFwrP1xccz9cXCg/KD86XFxkXFxzP1xcLT9cXCk/KXszLDIwfSQvO1xuICAgICAgICAgICAgaWYgKHRlbFJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd0ZWw6JyArIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgVVJMIHNjaGVtZSBhbmQgZGVmYXVsdCB0byBodHRwOi8vIGlmIG5vbmUgZm91bmRcbiAgICAgICAgICAgICAgICByZXR1cm4gKHVybFNjaGVtZVJlZ2V4LnRlc3QodmFsdWUpID8gJycgOiAnaHR0cDovLycpICsgZW5jb2RlVVJJKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkb0Zvcm1DYW5jZWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZS5yZXN0b3JlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UuY2hlY2tTZWxlY3Rpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3JtIGNyZWF0aW9uIGFuZCBldmVudCBoYW5kbGluZ1xuICAgICAgICBhdHRhY2hGb3JtRXZlbnRzOiBmdW5jdGlvbiAoZm9ybSkge1xuICAgICAgICAgICAgdmFyIGNsb3NlID0gZm9ybS5xdWVyeVNlbGVjdG9yKCcubWVkaXVtLWVkaXRvci10b29sYmFyLWNsb3NlJyksXG4gICAgICAgICAgICAgICAgc2F2ZSA9IGZvcm0ucXVlcnlTZWxlY3RvcignLm1lZGl1bS1lZGl0b3ItdG9vbGJhci1zYXZlJyksXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoJy5tZWRpdW0tZWRpdG9yLXRvb2xiYXItaW5wdXQnKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIGNsaWNrcyBvbiB0aGUgZm9ybSBpdHNlbGZcbiAgICAgICAgICAgIHRoaXMub24oZm9ybSwgJ2NsaWNrJywgdGhpcy5oYW5kbGVGb3JtQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSB0eXBpbmcgaW4gdGhlIHRleHRib3hcbiAgICAgICAgICAgIHRoaXMub24oaW5wdXQsICdrZXl1cCcsIHRoaXMuaGFuZGxlVGV4dGJveEtleXVwLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xvc2UgYnV0dG9uIGNsaWNrc1xuICAgICAgICAgICAgdGhpcy5vbihjbG9zZSwgJ2NsaWNrJywgdGhpcy5oYW5kbGVDbG9zZUNsaWNrLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgc2F2ZSBidXR0b24gY2xpY2tzIChjYXB0dXJlKVxuICAgICAgICAgICAgdGhpcy5vbihzYXZlLCAnY2xpY2snLCB0aGlzLmhhbmRsZVNhdmVDbGljay5iaW5kKHRoaXMpLCB0cnVlKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkb2MgPSB0aGlzLmRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGZvcm0gPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIC8vIEFuY2hvciBGb3JtIChkaXYpXG4gICAgICAgICAgICBmb3JtLmNsYXNzTmFtZSA9ICdtZWRpdW0tZWRpdG9yLXRvb2xiYXItZm9ybSc7XG4gICAgICAgICAgICBmb3JtLmlkID0gJ21lZGl1bS1lZGl0b3ItdG9vbGJhci1mb3JtLWFuY2hvci0nICsgdGhpcy5nZXRFZGl0b3JJZCgpO1xuICAgICAgICAgICAgZm9ybS5pbm5lckhUTUwgPSB0aGlzLmdldFRlbXBsYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaEZvcm1FdmVudHMoZm9ybSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldElucHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCkucXVlcnlTZWxlY3RvcignaW5wdXQubWVkaXVtLWVkaXRvci10b29sYmFyLWlucHV0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QW5jaG9yVGFyZ2V0Q2hlY2tib3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZvcm0oKS5xdWVyeVNlbGVjdG9yKCcubWVkaXVtLWVkaXRvci10b29sYmFyLWFuY2hvci10YXJnZXQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRBbmNob3JCdXR0b25DaGVja2JveDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybSgpLnF1ZXJ5U2VsZWN0b3IoJy5tZWRpdW0tZWRpdG9yLXRvb2xiYXItYW5jaG9yLWJ1dHRvbicpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVRleHRib3hLZXl1cDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBGb3IgRU5URVIgLT4gY3JlYXRlIHRoZSBhbmNob3JcbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLkVOVEVSKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvRm9ybVNhdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvciBFU0NBUEUgLT4gY2xvc2UgdGhlIGZvcm1cbiAgICAgICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSBNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLkVTQ0FQRSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0Zvcm1DYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVGb3JtQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG5vdCB0byBoaWRlIGZvcm0gd2hlbiBjbGlja2luZyBpbnNpZGUgdGhlIGZvcm1cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVNhdmVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDbGlja2luZyBTYXZlIC0+IGNyZWF0ZSB0aGUgYW5jaG9yXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5kb0Zvcm1TYXZlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQ2xvc2VDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDbGljayBDbG9zZSAtPiBjbG9zZSB0aGUgZm9ybVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZG9Gb3JtQ2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmFuY2hvciA9IEFuY2hvckZvcm07XG59KCkpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBBbmNob3JQcmV2aWV3ID0gTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5leHRlbmQoe1xuICAgICAgICBuYW1lOiAnYW5jaG9yLXByZXZpZXcnLFxuXG4gICAgICAgIC8vIEFuY2hvciBQcmV2aWV3IE9wdGlvbnNcblxuICAgICAgICAvKiBoaWRlRGVsYXk6IFtudW1iZXJdICAocHJldmlvdXNseSBvcHRpb25zLmFuY2hvclByZXZpZXdIaWRlRGVsYXkpXG4gICAgICAgICAqIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRvIHNob3cgdGhlIGFuY2hvciB0YWcgcHJldmlldyBhZnRlciB0aGUgbW91c2UgaGFzIGxlZnQgdGhlIGFuY2hvciB0YWcuXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlRGVsYXk6IDUwMCxcblxuICAgICAgICAvKiBwcmV2aWV3VmFsdWVTZWxlY3RvcjogW3N0cmluZ11cbiAgICAgICAgICogdGhlIGRlZmF1bHQgc2VsZWN0b3IgdG8gbG9jYXRlIHdoZXJlIHRvIHB1dCB0aGUgYWN0aXZlQW5jaG9yIHZhbHVlIGluIHRoZSBwcmV2aWV3XG4gICAgICAgICAqL1xuICAgICAgICBwcmV2aWV3VmFsdWVTZWxlY3RvcjogJ2EnLFxuXG4gICAgICAgIC8qIHNob3dXaGVuVG9vbGJhcklzVmlzaWJsZTogW2Jvb2xlYW5dXG4gICAgICAgICAqIGRldGVybWluZXMgd2hldGhlciB0aGUgYW5jaG9yIHRhZyBwcmV2aWV3IHNob3dzIHVwIHdoZW4gdGhlIHRvb2xiYXIgaXMgdmlzaWJsZVxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1doZW5Ub29sYmFySXNWaXNpYmxlOiBmYWxzZSxcblxuICAgICAgICAvKiBzaG93T25FbXB0eUxpbmtzOiBbYm9vbGVhbl1cbiAgICAgICAgKiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFuY2hvciB0YWcgcHJldmlldyBzaG93cyB1cCBvbiBsaW5rcyB3aXRoIGhyZWY9XCJcIiBvciBocmVmPVwiI3NvbWV0aGluZ1wiXG4gICAgICAgICovXG4gICAgICAgIHNob3dPbkVtcHR5TGlua3M6IHRydWUsXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5hbmNob3JQcmV2aWV3ID0gdGhpcy5jcmVhdGVQcmV2aWV3KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdlbGVtZW50c0NvbnRhaW5lcicpLmFwcGVuZENoaWxkKHRoaXMuYW5jaG9yUHJldmlldyk7XG5cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoVG9FZGl0YWJsZXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRJbnRlcmFjdGlvbkVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcmV2aWV3RWxlbWVudCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGZ1bmN0aW9uIGluIDYuMC4wXG4gICAgICAgIGdldFByZXZpZXdFbGVtZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmNob3JQcmV2aWV3O1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVByZXZpZXc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgIGVsLmlkID0gJ21lZGl1bS1lZGl0b3ItYW5jaG9yLXByZXZpZXctJyArIHRoaXMuZ2V0RWRpdG9ySWQoKTtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9ICdtZWRpdW0tZWRpdG9yLWFuY2hvci1wcmV2aWV3JztcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHRoaXMuZ2V0VGVtcGxhdGUoKTtcblxuICAgICAgICAgICAgdGhpcy5vbihlbCwgJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRlbXBsYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRvb2xiYXItYW5jaG9yLXByZXZpZXdcIiBpZD1cIm1lZGl1bS1lZGl0b3ItdG9vbGJhci1hbmNob3ItcHJldmlld1wiPicgK1xuICAgICAgICAgICAgICAgICcgICAgPGEgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLXRvb2xiYXItYW5jaG9yLXByZXZpZXctaW5uZXJcIj48L2E+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYW5jaG9yUHJldmlldykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuY2hvclByZXZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmFuY2hvclByZXZpZXcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hbmNob3JQcmV2aWV3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGVQcmV2aWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci1hbmNob3ItcHJldmlldy1hY3RpdmUnKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQW5jaG9yID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93UHJldmlldzogZnVuY3Rpb24gKGFuY2hvckVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbmNob3JQcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnbWVkaXVtLWVkaXRvci1hbmNob3ItcHJldmlldy1hY3RpdmUnKSB8fFxuICAgICAgICAgICAgICAgICAgICBhbmNob3JFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZS1wcmV2aWV3JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMucHJldmlld1ZhbHVlU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcucXVlcnlTZWxlY3Rvcih0aGlzLnByZXZpZXdWYWx1ZVNlbGVjdG9yKS50ZXh0Q29udGVudCA9IGFuY2hvckVsLmF0dHJpYnV0ZXMuaHJlZi52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcucXVlcnlTZWxlY3Rvcih0aGlzLnByZXZpZXdWYWx1ZVNlbGVjdG9yKS5ocmVmID0gYW5jaG9yRWwuYXR0cmlidXRlcy5ocmVmLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuY2xhc3NMaXN0LmFkZCgnbWVkaXVtLXRvb2xiYXItYXJyb3ctb3ZlcicpO1xuICAgICAgICAgICAgdGhpcy5hbmNob3JQcmV2aWV3LmNsYXNzTGlzdC5yZW1vdmUoJ21lZGl1bS10b29sYmFyLWFycm93LXVuZGVyJyk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5hbmNob3JQcmV2aWV3LmNsYXNzTGlzdC5jb250YWlucygnbWVkaXVtLWVkaXRvci1hbmNob3ItcHJldmlldy1hY3RpdmUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYW5jaG9yUHJldmlldy5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tZWRpdG9yLWFuY2hvci1wcmV2aWV3LWFjdGl2ZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUFuY2hvciA9IGFuY2hvckVsO1xuXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uUHJldmlldygpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hQcmV2aWV3SGFuZGxlcnMoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpb25QcmV2aWV3OiBmdW5jdGlvbiAoYWN0aXZlQW5jaG9yKSB7XG4gICAgICAgICAgICBhY3RpdmVBbmNob3IgPSBhY3RpdmVBbmNob3IgfHwgdGhpcy5hY3RpdmVBbmNob3I7XG4gICAgICAgICAgICB2YXIgYnV0dG9uSGVpZ2h0ID0gdGhpcy5hbmNob3JQcmV2aWV3Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IGFjdGl2ZUFuY2hvci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBtaWRkbGVCb3VuZGFyeSA9IChib3VuZGFyeS5sZWZ0ICsgYm91bmRhcnkucmlnaHQpIC8gMixcbiAgICAgICAgICAgICAgICBkaWZmTGVmdCA9IHRoaXMuZGlmZkxlZnQsXG4gICAgICAgICAgICAgICAgZGlmZlRvcCA9IHRoaXMuZGlmZlRvcCxcbiAgICAgICAgICAgICAgICBoYWxmT2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICAgICAgZGVmYXVsdExlZnQ7XG5cbiAgICAgICAgICAgIGhhbGZPZmZzZXRXaWR0aCA9IHRoaXMuYW5jaG9yUHJldmlldy5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgICAgICB2YXIgdG9vbGJhckV4dGVuc2lvbiA9IHRoaXMuYmFzZS5nZXRFeHRlbnNpb25CeU5hbWUoJ3Rvb2xiYXInKTtcbiAgICAgICAgICAgIGlmICh0b29sYmFyRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgZGlmZkxlZnQgPSB0b29sYmFyRXh0ZW5zaW9uLmRpZmZMZWZ0O1xuICAgICAgICAgICAgICAgIGRpZmZUb3AgPSB0b29sYmFyRXh0ZW5zaW9uLmRpZmZUb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0TGVmdCA9IGRpZmZMZWZ0IC0gaGFsZk9mZnNldFdpZHRoO1xuXG4gICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuc3R5bGUudG9wID0gTWF0aC5yb3VuZChidXR0b25IZWlnaHQgKyBib3VuZGFyeS5ib3R0b20gLSBkaWZmVG9wICsgdGhpcy53aW5kb3cucGFnZVlPZmZzZXQgLSB0aGlzLmFuY2hvclByZXZpZXcub2Zmc2V0SGVpZ2h0KSArICdweCc7XG4gICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuc3R5bGUucmlnaHQgPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICBpZiAobWlkZGxlQm91bmRhcnkgPCBoYWxmT2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuc3R5bGUubGVmdCA9IGRlZmF1bHRMZWZ0ICsgaGFsZk9mZnNldFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuc3R5bGUucmlnaHQgPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0aGlzLndpbmRvdy5pbm5lcldpZHRoIC0gbWlkZGxlQm91bmRhcnkpIDwgaGFsZk9mZnNldFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3JQcmV2aWV3LnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3JQcmV2aWV3LnN0eWxlLnJpZ2h0ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmNob3JQcmV2aWV3LnN0eWxlLmxlZnQgPSBkZWZhdWx0TGVmdCArIG1pZGRsZUJvdW5kYXJ5ICsgJ3B4JztcbiAgICAgICAgICAgICAgICB0aGlzLmFuY2hvclByZXZpZXcuc3R5bGUucmlnaHQgPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoVG9FZGl0YWJsZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZU1vdXNlb3ZlcicsIHRoaXMuaGFuZGxlRWRpdGFibGVNb3VzZW92ZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgncG9zaXRpb25lZFRvb2xiYXInLCB0aGlzLmhhbmRsZVBvc2l0aW9uZWRUb29sYmFyLmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVBvc2l0aW9uZWRUb29sYmFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdG9vbGJhciBpcyB2aXNpYmxlIGFuZCBwb3NpdGlvbmVkLCB3ZSBkb24ndCBuZWVkIHRvIGhpZGUgdGhlIHByZXZpZXdcbiAgICAgICAgICAgIC8vIHdoZW4gc2hvd1doZW5Ub29sYmFySXNWaXNpYmxlIGlzIHRydWVcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG93V2hlblRvb2xiYXJJc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVQcmV2aWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGFuY2hvckV4dGVuc2lvbiA9IHRoaXMuYmFzZS5nZXRFeHRlbnNpb25CeU5hbWUoJ2FuY2hvcicpLFxuICAgICAgICAgICAgICAgIGFjdGl2ZUFuY2hvciA9IHRoaXMuYWN0aXZlQW5jaG9yO1xuXG4gICAgICAgICAgICBpZiAoYW5jaG9yRXh0ZW5zaW9uICYmIGFjdGl2ZUFuY2hvcikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJhc2Uuc2VsZWN0RWxlbWVudCh0aGlzLmFjdGl2ZUFuY2hvcik7XG5cbiAgICAgICAgICAgICAgICAvLyBVc2luZyBzZXRUaW1lb3V0ICsgZGVsYXkgYmVjYXVzZTpcbiAgICAgICAgICAgICAgICAvLyBXZSBtYXkgYWN0dWFsbHkgYmUgZGlzcGxheWluZyB0aGUgYW5jaG9yIGZvcm0sIHdoaWNoIHNob3VsZCBiZSBjb250cm9sbGVkIGJ5IGRlbGF5XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlLmRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUFuY2hvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGFjdGl2ZUFuY2hvci5hdHRyaWJ1dGVzLmhyZWYudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBhY3RpdmVBbmNob3IuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGFzczogYWN0aXZlQW5jaG9yLmdldEF0dHJpYnV0ZSgnY2xhc3MnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuY2hvckV4dGVuc2lvbi5zaG93Rm9ybShvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZUFuY2hvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmhpZGVQcmV2aWV3KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQW5jaG9yTW91c2VvdXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yVG9QcmV2aWV3ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuYWN0aXZlQW5jaG9yLCAnbW91c2VvdXQnLCB0aGlzLmluc3RhbmNlSGFuZGxlQW5jaG9yTW91c2VvdXQpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZUhhbmRsZUFuY2hvck1vdXNlb3V0ID0gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVFZGl0YWJsZU1vdXNlb3ZlcjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gTWVkaXVtRWRpdG9yLnV0aWwuZ2V0Q2xvc2VzdFRhZyhldmVudC50YXJnZXQsICdhJyk7XG5cbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEZXRlY3QgZW1wdHkgaHJlZiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAvLyBUaGUgYnJvd3NlciB3aWxsIG1ha2UgaHJlZj1cIlwiIG9yIGhyZWY9XCIjdG9wXCJcbiAgICAgICAgICAgIC8vIGludG8gYWJzb2x1dGUgdXJscyB3aGVuIGFjY2Vzc2VkIGFzIGV2ZW50LnRhcmdldC5ocmVmLCBzbyBjaGVjayB0aGUgaHRtbFxuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3dPbkVtcHR5TGlua3MgJiZcbiAgICAgICAgICAgICAgICAoIS9ocmVmPVtcIiddXFxTK1tcIiddLy50ZXN0KHRhcmdldC5vdXRlckhUTUwpIHx8IC9ocmVmPVtcIiddI1xcUytbXCInXS8udGVzdCh0YXJnZXQub3V0ZXJIVE1MKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSBzaG93IHdoZW4gdG9vbGJhciBpcyBub3QgcHJlc2VudFxuICAgICAgICAgICAgdmFyIHRvb2xiYXIgPSB0aGlzLmJhc2UuZ2V0RXh0ZW5zaW9uQnlOYW1lKCd0b29sYmFyJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hvd1doZW5Ub29sYmFySXNWaXNpYmxlICYmIHRvb2xiYXIgJiYgdG9vbGJhci5pc0Rpc3BsYXllZCAmJiB0b29sYmFyLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGV0YWNoIGhhbmRsZXIgZm9yIG90aGVyIGFuY2hvciBpbiBjYXNlIHdlIGhvdmVyZWQgbXVsdGlwbGUgYW5jaG9ycyBxdWlja2x5XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVBbmNob3IgJiYgdGhpcy5hY3RpdmVBbmNob3IgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoUHJldmlld0hhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYW5jaG9yVG9QcmV2aWV3ID0gdGFyZ2V0O1xuXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlSGFuZGxlQW5jaG9yTW91c2VvdXQgPSB0aGlzLmhhbmRsZUFuY2hvck1vdXNlb3V0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLm9uKHRoaXMuYW5jaG9yVG9QcmV2aWV3LCAnbW91c2VvdXQnLCB0aGlzLmluc3RhbmNlSGFuZGxlQW5jaG9yTW91c2VvdXQpO1xuICAgICAgICAgICAgLy8gVXNpbmcgc2V0VGltZW91dCArIGRlbGF5IGJlY2F1c2U6XG4gICAgICAgICAgICAvLyAtIFdlJ3JlIGdvaW5nIHRvIHNob3cgdGhlIGFuY2hvciBwcmV2aWV3IGFjY29yZGluZyB0byB0aGUgY29uZmlndXJlZCBkZWxheVxuICAgICAgICAgICAgLy8gICBpZiB0aGUgbW91c2UgaGFzIG5vdCBsZWZ0IHRoZSBhbmNob3IgdGFnIGluIHRoYXQgdGltZVxuICAgICAgICAgICAgdGhpcy5iYXNlLmRlbGF5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmNob3JUb1ByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93UHJldmlldyh0aGlzLmFuY2hvclRvUHJldmlldyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVQcmV2aWV3TW91c2VvdmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RPdmVyID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJpbmcgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVByZXZpZXdNb3VzZW91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgIS9hbmNob3ItcHJldmlldy8udGVzdChldmVudC5yZWxhdGVkVGFyZ2V0LmNsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlUHJldmlldzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaG92ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkdXJyID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRoaXMubGFzdE92ZXI7XG4gICAgICAgICAgICBpZiAoZHVyciA+IHRoaXMuaGlkZURlbGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gaGlkZSB0aGUgcHJldmlldyAxLzIgc2Vjb25kIGFmdGVyIG1vdXNlIGxlYXZlcyB0aGUgbGlua1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0YWNoUHJldmlld0hhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoUHJldmlld0hhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBjbGVhbnVwXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxUaW1lcik7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUhhbmRsZVByZXZpZXdNb3VzZW92ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZih0aGlzLmFuY2hvclByZXZpZXcsICdtb3VzZW92ZXInLCB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3Zlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5hbmNob3JQcmV2aWV3LCAnbW91c2VvdXQnLCB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVBbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYodGhpcy5hY3RpdmVBbmNob3IsICdtb3VzZW92ZXInLCB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub2ZmKHRoaXMuYWN0aXZlQW5jaG9yLCAnbW91c2VvdXQnLCB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaGlkZVByZXZpZXcoKTtcblxuICAgICAgICAgICAgdGhpcy5ob3ZlcmluZyA9IHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdmVyID0gdGhpcy5pbnN0YW5jZUhhbmRsZVByZXZpZXdNb3VzZW91dCA9IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ETzogYnJlYWsgdXAgbWV0aG9kIGFuZCBleHRyYWN0IG91dCBoYW5kbGVyc1xuICAgICAgICBhdHRhY2hQcmV2aWV3SGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdE92ZXIgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5ob3ZlcmluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdmVyID0gdGhpcy5oYW5kbGVQcmV2aWV3TW91c2VvdmVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlSGFuZGxlUHJldmlld01vdXNlb3V0ID0gdGhpcy5oYW5kbGVQcmV2aWV3TW91c2VvdXQuYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy51cGRhdGVQcmV2aWV3LmJpbmQodGhpcyksIDIwMCk7XG5cbiAgICAgICAgICAgIHRoaXMub24odGhpcy5hbmNob3JQcmV2aWV3LCAnbW91c2VvdmVyJywgdGhpcy5pbnN0YW5jZUhhbmRsZVByZXZpZXdNb3VzZW92ZXIpO1xuICAgICAgICAgICAgdGhpcy5vbih0aGlzLmFuY2hvclByZXZpZXcsICdtb3VzZW91dCcsIHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdXQpO1xuICAgICAgICAgICAgdGhpcy5vbih0aGlzLmFjdGl2ZUFuY2hvciwgJ21vdXNlb3ZlcicsIHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdmVyKTtcbiAgICAgICAgICAgIHRoaXMub24odGhpcy5hY3RpdmVBbmNob3IsICdtb3VzZW91dCcsIHRoaXMuaW5zdGFuY2VIYW5kbGVQcmV2aWV3TW91c2VvdXQpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5hbmNob3JQcmV2aWV3ID0gQW5jaG9yUHJldmlldztcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFdISVRFU1BBQ0VfQ0hBUlMsXG4gICAgICAgIEtOT1dOX1RMRFNfRlJBR01FTlQsXG4gICAgICAgIExJTktfUkVHRVhQX1RFWFQsXG4gICAgICAgIEtOT1dOX1RMRFNfUkVHRVhQO1xuXG4gICAgV0hJVEVTUEFDRV9DSEFSUyA9IFsnICcsICdcXHQnLCAnXFxuJywgJ1xccicsICdcXHUwMEEwJywgJ1xcdTIwMDAnLCAnXFx1MjAwMScsICdcXHUyMDAyJywgJ1xcdTIwMDMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcdTIwMjgnLCAnXFx1MjAyOSddO1xuICAgIEtOT1dOX1RMRFNfRlJBR01FTlQgPSAnY29tfG5ldHxvcmd8ZWR1fGdvdnxtaWx8YWVyb3xhc2lhfGJpenxjYXR8Y29vcHxpbmZvfGludHxqb2JzfG1vYml8bXVzZXVtfG5hbWV8cG9zdHxwcm98dGVsfHRyYXZlbHwnICtcbiAgICAgICAgJ3h4eHxhY3xhZHxhZXxhZnxhZ3xhaXxhbHxhbXxhbnxhb3xhcXxhcnxhc3xhdHxhdXxhd3xheHxhenxiYXxiYnxiZHxiZXxiZnxiZ3xiaHxiaXxianxibXxibnxib3xicnxic3xidHxidnxid3xieXwnICtcbiAgICAgICAgJ2J6fGNhfGNjfGNkfGNmfGNnfGNofGNpfGNrfGNsfGNtfGNufGNvfGNyfGNzfGN1fGN2fGN4fGN5fGN6fGRkfGRlfGRqfGRrfGRtfGRvfGR6fGVjfGVlfGVnfGVofGVyfGVzfGV0fGV1fGZpfGZqfCcgK1xuICAgICAgICAnZmt8Zm18Zm98ZnJ8Z2F8Z2J8Z2R8Z2V8Z2Z8Z2d8Z2h8Z2l8Z2x8Z218Z258Z3B8Z3F8Z3J8Z3N8Z3R8Z3V8Z3d8Z3l8aGt8aG18aG58aHJ8aHR8aHV8aWR8aWV8aWx8aW18aW58aW98aXF8aXJ8JyArXG4gICAgICAgICdpc3xpdHxqZXxqbXxqb3xqcHxrZXxrZ3xraHxraXxrbXxrbnxrcHxrcnxrd3xreXxrenxsYXxsYnxsY3xsaXxsa3xscnxsc3xsdHxsdXxsdnxseXxtYXxtY3xtZHxtZXxtZ3xtaHxta3xtbHxtbXwnICtcbiAgICAgICAgJ21ufG1vfG1wfG1xfG1yfG1zfG10fG11fG12fG13fG14fG15fG16fG5hfG5jfG5lfG5mfG5nfG5pfG5sfG5vfG5wfG5yfG51fG56fG9tfHBhfHBlfHBmfHBnfHBofHBrfHBsfHBtfHBufHByfHBzfCcgK1xuICAgICAgICAncHR8cHd8cHl8cWF8cmV8cm98cnN8cnV8cnd8c2F8c2J8c2N8c2R8c2V8c2d8c2h8c2l8c2p8amF8c2t8c2x8c218c258c298c3J8c3N8c3R8c3V8c3Z8c3h8c3l8c3p8dGN8dGR8dGZ8dGd8dGh8JyArXG4gICAgICAgICd0anx0a3x0bHx0bXx0bnx0b3x0cHx0cnx0dHx0dnx0d3x0enx1YXx1Z3x1a3x1c3x1eXx1enx2YXx2Y3x2ZXx2Z3x2aXx2bnx2dXx3Znx3c3x5ZXx5dHx5dXx6YXx6bXx6dyc7XG5cbiAgICBMSU5LX1JFR0VYUF9URVhUID1cbiAgICAgICAgJygnICtcbiAgICAgICAgLy8gVmVyc2lvbiBvZiBHcnViZXIgVVJMIFJlZ2V4cCBvcHRpbWl6ZWQgZm9yIEpTOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzczMzY0MFxuICAgICAgICAnKCg/OihodHRwcz86Ly98ZnRwcz86Ly98bm50cDovLyl8d3d3XFxcXGR7MCwzfVsuXXxbYS16MC05LlxcXFwtXStbLl0oJyArIEtOT1dOX1RMRFNfRlJBR01FTlQgKyAnKVxcXFxcXC8pXFxcXFMrKD86W15cXFxcc2AhXFxcXFtcXFxcXXt9OzpcXCdcXFwiLiw/XFx1MDBBQlxcdTAwQkJcXHUyMDFDXFx1MjAxRFxcdTIwMThcXHUyMDE5XSkpJyArXG4gICAgICAgIC8vIEFkZGl0aW9uIHRvIGFib3ZlIFJlZ2V4cCB0byBzdXBwb3J0IGJhcmUgZG9tYWlucy9vbmUgbGV2ZWwgc3ViZG9tYWlucyB3aXRoIGNvbW1vbiBub24taTE4biBUTERzIGFuZCB3aXRob3V0IHd3dyBwcmVmaXg6XG4gICAgICAgICcpfCgoW2EtejAtOVxcXFwtXStcXFxcLik/W2EtejAtOVxcXFwtXStcXFxcLignICsgS05PV05fVExEU19GUkFHTUVOVCArICcpKSc7XG5cbiAgICBLTk9XTl9UTERTX1JFR0VYUCA9IG5ldyBSZWdFeHAoJ14oJyArIEtOT1dOX1RMRFNfRlJBR01FTlQgKyAnKSQnLCAnaScpO1xuXG4gICAgZnVuY3Rpb24gbm9kZUlzTm90SW5zaWRlQW5jaG9yVGFnKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFNZWRpdW1FZGl0b3IudXRpbC5nZXRDbG9zZXN0VGFnKG5vZGUsICdhJyk7XG4gICAgfVxuXG4gICAgdmFyIEF1dG9MaW5rID0gTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5leHRlbmQoe1xuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUV2ZW50SGFuZGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZUtleXByZXNzJywgdGhpcy5vbktleXByZXNzLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlQmx1cicsIHRoaXMub25CbHVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgLy8gTVMgSUUgaGFzIGl0J3Mgb3duIGF1dG8tVVJMIGRldGVjdCBmZWF0dXJlIGJ1dCBvdXJzIGlzIGJldHRlciBpbiBzb21lIHdheXMuIEJlIGNvbnNpc3RlbnQuXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmV4ZWNDb21tYW5kKCdBdXRvVXJsRGV0ZWN0JywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpc0xhc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUluc3RhbmNlcyA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2luZG93Ll9tZWRpdW1FZGl0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMud2luZG93Ll9tZWRpdW1FZGl0b3JzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IgIT09IG51bGwgJiYgZWRpdG9yLmdldEV4dGVuc2lvbkJ5TmFtZSgnYXV0b0xpbmsnKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVJbnN0YW5jZXMgPT09IDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVHVybiBBdXRvVXJsRGV0ZWN0IGJhY2sgb25cbiAgICAgICAgICAgIGlmICh0aGlzLmRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCgnQXV0b1VybERldGVjdCcpICYmIHRoaXMuaXNMYXN0SW5zdGFuY2UoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ0F1dG9VcmxEZXRlY3QnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25CbHVyOiBmdW5jdGlvbiAoYmx1ckV2ZW50LCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtTGlua2luZyhlZGl0YWJsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25LZXlwcmVzczogZnVuY3Rpb24gKGtleVByZXNzRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVFdmVudEhhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoa2V5UHJlc3NFdmVudCwgW01lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuU1BBQ0UsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuRU5URVJdKSkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBlcmZvcm1MaW5raW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgLy8gU2F2aW5nL3Jlc3RvcmluZyB0aGUgc2VsZWN0aW9uIGluIHRoZSBtaWRkbGUgb2YgYSBrZXlwcmVzcyBkb2Vzbid0IHdvcmsgd2VsbC4uLlxuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybUxpbmtpbmdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsID0gdGhpcy5iYXNlLmV4cG9ydFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVyZm9ybUxpbmtpbmcoa2V5UHJlc3NFdmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB0cnVlIGZvciBmYXZvckxhdGVyU2VsZWN0aW9uQW5jaG9yIC0gdGhpcyBpcyBuZWVkZWQgZm9yIGxpbmtzIGF0IHRoZSBlbmQgb2YgYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBhcmFncmFwaCBpbiBNUyBJRSwgb3IgTVMgSUUgY2F1c2VzIHRoZSBsaW5rIHRvIGJlIGRlbGV0ZWQgcmlnaHQgYWZ0ZXIgYWRkaW5nIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmFzZS5pbXBvcnRTZWxlY3Rpb24oc2VsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwZXJmb3JtIGxpbmtpbmcnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZUV2ZW50SGFuZGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwZXJmb3JtTGlua2luZzogZnVuY3Rpb24gKGNvbnRlbnRlZGl0YWJsZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIFBlcmZvcm0gbGlua2luZyBvbiBibG9ja0VsZW1lbnQgYmFzaXMsIGJsb2NrRWxlbWVudHMgYXJlIEhUTUwgZWxlbWVudHMgd2l0aCB0ZXh0IGNvbnRlbnQgYW5kIHdpdGhvdXRcbiAgICAgICAgICAgIGNoaWxkIGVsZW1lbnQuXG5cbiAgICAgICAgICAgIEV4YW1wbGU6XG4gICAgICAgICAgICAtIEhUTUwgY29udGVudFxuICAgICAgICAgICAgPGJsb2NrcXVvdGU+XG4gICAgICAgICAgICAgIDxwPmxpbmsuPC9wPlxuICAgICAgICAgICAgICA8cD5teTwvcD5cbiAgICAgICAgICAgIDwvYmxvY2txdW90ZT5cblxuICAgICAgICAgICAgLSBibG9ja0VsZW1lbnRzXG4gICAgICAgICAgICBbPHA+bGluay48L3A+LCA8cD5teTwvcD5dXG5cbiAgICAgICAgICAgIG90aGVyd2lzZSB0aGUgZGV0ZWN0aW9uIGNhbiB3cm9uZ2x5IGZpbmQgdGhlIGVuZCBvZiBvbmUgcGFyYWdyYXBoIGFuZCB0aGUgYmVnaW5uaW5nIG9mIGFub3RoZXIgcGFyYWdyYXBoXG4gICAgICAgICAgICB0byBjb25zdGl0dXRlIGEgbGluaywgc3VjaCBhcyBhIHBhcmFncmFwaCBlbmRpbmcgXCJsaW5rLlwiIGFuZCB0aGUgbmV4dCBwYXJhZ3JhcGggYmVnaW5uaW5nIHdpdGggXCJteVwiIGlzXG4gICAgICAgICAgICBpbnRlcnByZXRlZCBpbnRvIFwibGluay5teVwiIGFuZCB0aGUgY29kZSB0cmllcyB0byBjcmVhdGUgYSBsaW5rIGFjcm9zcyBibG9ja0VsZW1lbnRzIC0gd2hpY2ggZG9lc24ndCB3b3JrXG4gICAgICAgICAgICBhbmQgaXMgdGVycmlibGUuXG4gICAgICAgICAgICAoTWVkaXVtIGRlbGV0ZXMgdGhlIHNwYWNlcy9yZXR1cm5zIGJldHdlZW4gUCB0YWdzIHNvIHRoZSB0ZXh0Q29udGVudCBlbmRzIHVwIHdpdGhvdXQgcGFyYWdyYXBoIHNwYWNpbmcpXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGJsb2NrRWxlbWVudHMgPSBNZWRpdW1FZGl0b3IudXRpbC5zcGxpdEJ5QmxvY2tFbGVtZW50cyhjb250ZW50ZWRpdGFibGUpLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50TW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChibG9ja0VsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJsb2NrRWxlbWVudHMgPSBbY29udGVudGVkaXRhYmxlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50TW9kaWZpZWQgPSB0aGlzLnJlbW92ZU9ic29sZXRlQXV0b0xpbmtTcGFucyhibG9ja0VsZW1lbnRzW2ldKSB8fCBkb2N1bWVudE1vZGlmaWVkO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50TW9kaWZpZWQgPSB0aGlzLnBlcmZvcm1MaW5raW5nV2l0aGluRWxlbWVudChibG9ja0VsZW1lbnRzW2ldKSB8fCBkb2N1bWVudE1vZGlmaWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYXNlLmV2ZW50cy51cGRhdGVJbnB1dChjb250ZW50ZWRpdGFibGUsIHsgdGFyZ2V0OiBjb250ZW50ZWRpdGFibGUsIGN1cnJlbnRUYXJnZXQ6IGNvbnRlbnRlZGl0YWJsZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudE1vZGlmaWVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZU9ic29sZXRlQXV0b0xpbmtTcGFuczogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3BhbnMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NwYW5bZGF0YS1hdXRvLWxpbms9XCJ0cnVlXCJdJyksXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRNb2RpZmllZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRDb250ZW50ID0gc3BhbnNbaV0udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRDb250ZW50LmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29udGVudCA9IE1lZGl1bUVkaXRvci51dGlsLmVuc3VyZVVybEhhc1Byb3RvY29sKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNwYW5zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJykgIT09IHRleHRDb250ZW50ICYmIG5vZGVJc05vdEluc2lkZUFuY2hvclRhZyhzcGFuc1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRNb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmltbWVkVGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW5zW2ldLmdldEF0dHJpYnV0ZSgnZGF0YS1ocmVmJykgPT09IHRyaW1tZWRUZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlcnNUcmltbWVkID0gdGV4dENvbnRlbnQubGVuZ3RoIC0gdHJpbW1lZFRleHRDb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmVlID0gTWVkaXVtRWRpdG9yLnV0aWwuc3BsaXRPZmZET01UcmVlKHNwYW5zW2ldLCB0aGlzLnNwbGl0VGV4dEJlZm9yZUVuZChzcGFuc1tpXSwgY2hhcmFjdGVyc1RyaW1tZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5zW2ldLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN1YnRyZWUsIHNwYW5zW2ldLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgZWRpdGluZyBoYXMgaGFwcGVuZWQgdG8gdGhlIHNwYW4sIHNvIGp1c3QgcmVtb3ZlIGl0IGVudGlyZWx5LiBUaGUgdXNlciBjYW4gcHV0IGl0IGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFyb3VuZCBqdXN0IHRoZSBocmVmIGNvbnRlbnQgaWYgdGhleSBuZWVkIHRvIHByZXZlbnQgaXQgZnJvbSBsaW5raW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC51bndyYXAoc3BhbnNbaV0sIHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50TW9kaWZpZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3BsaXRUZXh0QmVmb3JlRW5kOiBmdW5jdGlvbiAoZWxlbWVudCwgY2hhcmFjdGVyQ291bnQpIHtcbiAgICAgICAgICAgIHZhciB0cmVlV2Fsa2VyID0gdGhpcy5kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19URVhULCBudWxsLCBmYWxzZSksXG4gICAgICAgICAgICAgICAgbGFzdENoaWxkTm90RXhoYXVzdGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgdGhlIHRyZWUgd2Fsa2VyIGF0IHRoZSBsYXN0IGRlc2NlbmRhbnQgb2YgdGhlIHNwYW5cbiAgICAgICAgICAgIHdoaWxlIChsYXN0Q2hpbGROb3RFeGhhdXN0ZWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0Q2hpbGROb3RFeGhhdXN0ZWQgPSB0cmVlV2Fsa2VyLmxhc3RDaGlsZCgpICE9PSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUsXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGVWYWx1ZSxcbiAgICAgICAgICAgICAgICBwcmV2aW91c05vZGU7XG4gICAgICAgICAgICB3aGlsZSAoY2hhcmFjdGVyQ291bnQgPiAwICYmIHByZXZpb3VzTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdHJlZVdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZVZhbHVlID0gY3VycmVudE5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZVZhbHVlLmxlbmd0aCA+IGNoYXJhY3RlckNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChjdXJyZW50Tm9kZVZhbHVlLmxlbmd0aCAtIGNoYXJhY3RlckNvdW50KTtcbiAgICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IHRyZWVXYWxrZXIucHJldmlvdXNOb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlckNvdW50IC09IGN1cnJlbnROb2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c05vZGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUxpbmtpbmdXaXRoaW5FbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLmZpbmRMaW5rYWJsZVRleHQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgbGlua0NyZWF0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgbWF0Y2hJbmRleCA9IDA7IG1hdGNoSW5kZXggPCBtYXRjaGVzLmxlbmd0aDsgbWF0Y2hJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nVGV4dE5vZGVzID0gTWVkaXVtRWRpdG9yLnV0aWwuZmluZE9yQ3JlYXRlTWF0Y2hpbmdUZXh0Tm9kZXModGhpcy5kb2N1bWVudCwgZWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbbWF0Y2hJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZE5vdExpbmsobWF0Y2hpbmdUZXh0Tm9kZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUF1dG9MaW5rKG1hdGNoaW5nVGV4dE5vZGVzLCBtYXRjaGVzW21hdGNoSW5kZXhdLmhyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpbmtDcmVhdGVkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3VsZE5vdExpbms6IGZ1bmN0aW9uICh0ZXh0Tm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGROb3RMaW5rID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHROb2Rlcy5sZW5ndGggJiYgc2hvdWxkTm90TGluayA9PT0gZmFsc2U7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBsaW5rIGlmIHRoZSB0ZXh0IG5vZGUgaXMgZWl0aGVyIGluc2lkZSBhbiBhbmNob3Igb3IgaW5zaWRlIHNwYW5bZGF0YS1hdXRvLWxpbmtdXG4gICAgICAgICAgICAgICAgc2hvdWxkTm90TGluayA9ICEhTWVkaXVtRWRpdG9yLnV0aWwudHJhdmVyc2VVcCh0ZXh0Tm9kZXNbaV0sIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWF1dG8tbGluaycpID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNob3VsZE5vdExpbms7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmluZExpbmthYmxlVGV4dDogZnVuY3Rpb24gKGNvbnRlbnRlZGl0YWJsZSkge1xuICAgICAgICAgICAgdmFyIGxpbmtSZWdFeHAgPSBuZXcgUmVnRXhwKExJTktfUkVHRVhQX1RFWFQsICdnaScpLFxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50ID0gY29udGVudGVkaXRhYmxlLnRleHRDb250ZW50LFxuICAgICAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzID0gW107XG5cbiAgICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBsaW5rUmVnRXhwLmV4ZWModGV4dENvbnRlbnQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaE9rID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hFbmQgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcmVnZXhwIGRldGVjdGVkIHNvbWV0aGluZyBhcyBhIGxpbmsgdGhhdCBoYXMgdGV4dCBpbW1lZGlhdGVseSBwcmVjZWRpbmcvZm9sbG93aW5nIGl0LCBiYWlsIG91dC5cbiAgICAgICAgICAgICAgICBtYXRjaE9rID0gKG1hdGNoLmluZGV4ID09PSAwIHx8IFdISVRFU1BBQ0VfQ0hBUlMuaW5kZXhPZih0ZXh0Q29udGVudFttYXRjaC5pbmRleCAtIDFdKSAhPT0gLTEpICYmXG4gICAgICAgICAgICAgICAgICAgIChtYXRjaEVuZCA9PT0gdGV4dENvbnRlbnQubGVuZ3RoIHx8IFdISVRFU1BBQ0VfQ0hBUlMuaW5kZXhPZih0ZXh0Q29udGVudFttYXRjaEVuZF0pICE9PSAtMSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlZ2V4cCBkZXRlY3RlZCBhIGJhcmUgZG9tYWluIHRoYXQgZG9lc24ndCB1c2Ugb25lIG9mIG91ciBleHBlY3RlZCBUTERzLCBiYWlsIG91dC5cbiAgICAgICAgICAgICAgICBtYXRjaE9rID0gbWF0Y2hPayAmJiAobWF0Y2hbMF0uaW5kZXhPZignLycpICE9PSAtMSB8fFxuICAgICAgICAgICAgICAgICAgICBLTk9XTl9UTERTX1JFR0VYUC50ZXN0KG1hdGNoWzBdLnNwbGl0KCcuJykucG9wKCkuc3BsaXQoJz8nKS5zaGlmdCgpKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hPaykge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogbWF0Y2hbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG1hdGNoRW5kXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUF1dG9MaW5rOiBmdW5jdGlvbiAodGV4dE5vZGVzLCBocmVmKSB7XG4gICAgICAgICAgICBocmVmID0gTWVkaXVtRWRpdG9yLnV0aWwuZW5zdXJlVXJsSGFzUHJvdG9jb2woaHJlZik7XG4gICAgICAgICAgICB2YXIgYW5jaG9yID0gTWVkaXVtRWRpdG9yLnV0aWwuY3JlYXRlTGluayh0aGlzLmRvY3VtZW50LCB0ZXh0Tm9kZXMsIGhyZWYsIHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCd0YXJnZXRCbGFuaycpID8gJ19ibGFuaycgOiBudWxsKSxcbiAgICAgICAgICAgICAgICBzcGFuID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZSgnZGF0YS1hdXRvLWxpbmsnLCAndHJ1ZScpO1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoJ2RhdGEtaHJlZicsIGhyZWYpO1xuICAgICAgICAgICAgYW5jaG9yLmluc2VydEJlZm9yZShzcGFuLCBhbmNob3IuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB3aGlsZSAoYW5jaG9yLmNoaWxkTm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoYW5jaG9yLmNoaWxkTm9kZXNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmF1dG9MaW5rID0gQXV0b0xpbms7XG59KCkpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBDTEFTU19EUkFHX09WRVIgPSAnbWVkaXVtLWVkaXRvci1kcmFnb3Zlcic7XG5cbiAgICBmdW5jdGlvbiBjbGVhckNsYXNzTmFtZXMoZWxlbWVudCkge1xuICAgICAgICB2YXIgZWRpdGFibGUgPSBNZWRpdW1FZGl0b3IudXRpbC5nZXRDb250YWluZXJFZGl0b3JFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgZXhpc3RpbmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlZGl0YWJsZS5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nICsgQ0xBU1NfRFJBR19PVkVSKSk7XG5cbiAgICAgICAgZXhpc3RpbmcuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfRFJBR19PVkVSKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIEZpbGVEcmFnZ2luZyA9IE1lZGl1bUVkaXRvci5FeHRlbnNpb24uZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogJ2ZpbGVEcmFnZ2luZycsXG5cbiAgICAgICAgYWxsb3dlZFR5cGVzOiBbJ2ltYWdlJ10sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVEcmFnJywgdGhpcy5oYW5kbGVEcmFnLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlRHJvcCcsIHRoaXMuaGFuZGxlRHJvcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVEcmFnOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdjb3B5JztcblxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldC5jbGFzc0xpc3QgPyBldmVudC50YXJnZXQgOiBldmVudC50YXJnZXQucGFyZW50RWxlbWVudDtcblxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBjbGFzcyBnZXRzIHJlbW92ZWQgZnJvbSBhbnl0aGluZyB0aGF0IGhhZCBpdCBiZWZvcmVcbiAgICAgICAgICAgIGNsZWFyQ2xhc3NOYW1lcyh0YXJnZXQpO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2RyYWdvdmVyJykge1xuICAgICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX0RSQUdfT1ZFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlRHJvcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGZpbGUgZnJvbSBvcGVuaW5nIGluIHRoZSBjdXJyZW50IHdpbmRvd1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgLy8gU2VsZWN0IHRoZSBkcm9wcGluZyB0YXJnZXQsIGFuZCBzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95YWJ3ZS9tZWRpdW0tZWRpdG9yL2lzc3Vlcy85ODBcbiAgICAgICAgICAgIHRoaXMuYmFzZS5zZWxlY3RFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5iYXNlLmV4cG9ydFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgc2VsZWN0aW9uLnN0YXJ0ID0gc2VsZWN0aW9uLmVuZDtcbiAgICAgICAgICAgIHRoaXMuYmFzZS5pbXBvcnRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIElFOSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBGaWxlIEFQSSwgc28gcHJldmVudCBmaWxlIGZyb20gb3BlbmluZyBpbiB0aGUgd2luZG93XG4gICAgICAgICAgICAvLyBidXQgYWxzbyBkb24ndCB0cnkgdG8gYWN0dWFsbHkgZ2V0IHRoZSBmaWxlXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQWxsb3dlZEZpbGUoZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnR5cGUubWF0Y2goJ2ltYWdlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydEltYWdlRmlsZShmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcmVtb3ZlIG91ciBjbGFzcyBmcm9tIGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIGNsZWFyQ2xhc3NOYW1lcyhldmVudC50YXJnZXQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzQWxsb3dlZEZpbGU6IGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGxvd2VkVHlwZXMuc29tZShmdW5jdGlvbiAoZmlsZVR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFmaWxlLnR5cGUubWF0Y2goZmlsZVR5cGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5zZXJ0SW1hZ2VGaWxlOiBmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBGaWxlUmVhZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuXG4gICAgICAgICAgICAvLyBhdHRhY2ggdGhlIG9ubG9hZCBldmVudCBoYW5kbGVyLCBtYWtlcyBpdCBlYXNpZXIgdG8gbGlzdGVuIGluIHdpdGggamFzbWluZVxuICAgICAgICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkSW1hZ2VFbGVtZW50ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICBhZGRJbWFnZUVsZW1lbnQuc3JjID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmluc2VydEhUTUxDb21tYW5kKHRoaXMuZG9jdW1lbnQsIGFkZEltYWdlRWxlbWVudC5vdXRlckhUTUwpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZmlsZURyYWdnaW5nID0gRmlsZURyYWdnaW5nO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgS2V5Ym9hcmRDb21tYW5kcyA9IE1lZGl1bUVkaXRvci5FeHRlbnNpb24uZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogJ2tleWJvYXJkLWNvbW1hbmRzJyxcblxuICAgICAgICAvKiBLZXlib2FyZENvbW1hbmRzIE9wdGlvbnMgKi9cblxuICAgICAgICAvKiBjb21tYW5kczogW0FycmF5XVxuICAgICAgICAgKiBBcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgZWFjaCBjb21tYW5kIGFuZCB0aGUgY29tYmluYXRpb24gb2Yga2V5cyB0aGF0IHdpbGwgdHJpZ2dlciBpdFxuICAgICAgICAgKiBSZXF1aXJlZCBmb3IgZWFjaCBvYmplY3Q6XG4gICAgICAgICAqICAgY29tbWFuZCBbU3RyaW5nXSAoYXJndW1lbnQgcGFzc2VkIHRvIGVkaXRvci5leGVjQWN0aW9uKCkpXG4gICAgICAgICAqICAga2V5IFtTdHJpbmddIChrZXlib2FyZCBjaGFyYWN0ZXIgdGhhdCB0cmlnZ2VycyB0aGlzIGNvbW1hbmQpXG4gICAgICAgICAqICAgbWV0YSBbYm9vbGVhbl0gKHdoZXRoZXIgdGhlIGN0cmwvbWV0YSBrZXkgaGFzIHRvIGJlIGFjdGl2ZSBvciBpbmFjdGl2ZSlcbiAgICAgICAgICogICBzaGlmdCBbYm9vbGVhbl0gKHdoZXRoZXIgdGhlIHNoaWZ0IGtleSBoYXMgdG8gYmUgYWN0aXZlIG9yIGluYWN0aXZlKVxuICAgICAgICAgKiAgIGFsdCBbYm9vbGVhbl0gKHdoZXRoZXIgdGhlIGFsdCBrZXkgaGFzIHRvIGJlIGFjdGl2ZSBvciBpbmFjdGl2ZSlcbiAgICAgICAgICovXG4gICAgICAgIGNvbW1hbmRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGtleTogJ0InLFxuICAgICAgICAgICAgICAgIG1ldGE6IHRydWUsXG4gICAgICAgICAgICAgICAgc2hpZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFsdDogZmFsc2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAga2V5OiAnSScsXG4gICAgICAgICAgICAgICAgbWV0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaGlmdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWx0OiBmYWxzZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiAndW5kZXJsaW5lJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdVJyxcbiAgICAgICAgICAgICAgICBtZXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgIHNoaWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhbHQ6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG5cbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5rZXlzID0ge307XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24gKGNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGNvbW1hbmQua2V5LmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmtleXNba2V5Q29kZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlzW2tleUNvZGVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMua2V5c1trZXlDb2RlXS5wdXNoKGNvbW1hbmQpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlS2V5ZG93bjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIga2V5Q29kZSA9IE1lZGl1bUVkaXRvci51dGlsLmdldEtleUNvZGUoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtleXNba2V5Q29kZV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpc01ldGEgPSBNZWRpdW1FZGl0b3IudXRpbC5pc01ldGFDdHJsS2V5KGV2ZW50KSxcbiAgICAgICAgICAgICAgICBpc1NoaWZ0ID0gISFldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICBpc0FsdCA9ICEhZXZlbnQuYWx0S2V5O1xuXG4gICAgICAgICAgICB0aGlzLmtleXNba2V5Q29kZV0uZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLm1ldGEgPT09IGlzTWV0YSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRhLnNoaWZ0ID09PSBpc1NoaWZ0ICYmXG4gICAgICAgICAgICAgICAgICAgIChkYXRhLmFsdCA9PT0gaXNBbHQgfHxcbiAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA9PT0gZGF0YS5hbHQpKSB7IC8vIFRPRE8gZGVwcmVjYXRlZDogcmVtb3ZlIGNoZWNrIGZvciB1bmRlZmluZWQgPT09IGRhdGEuYWx0IHdoZW4ganVtcGluZyB0byA2LjAuMFxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb21tYW5kIGNhbiBiZSBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmNvbW1hbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29tbWFuZC5hcHBseSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb21tYW5kIGNhbiBiZSBmYWxzZSBzbyB0aGUgc2hvcnRjdXQgaXMganVzdCBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmYWxzZSAhPT0gZGF0YS5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWNBY3Rpb24oZGF0YS5jb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5rZXlib2FyZENvbW1hbmRzID0gS2V5Ym9hcmRDb21tYW5kcztcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIEZvbnROYW1lRm9ybSA9IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvcm0uZXh0ZW5kKHtcblxuICAgICAgICBuYW1lOiAnZm9udG5hbWUnLFxuICAgICAgICBhY3Rpb246ICdmb250TmFtZScsXG4gICAgICAgIGFyaWE6ICdjaGFuZ2UgZm9udCBuYW1lJyxcbiAgICAgICAgY29udGVudERlZmF1bHQ6ICcmI3hCMTsnLCAvLyDCsVxuICAgICAgICBjb250ZW50RkE6ICc8aSBjbGFzcz1cImZhIGZhLWZvbnRcIj48L2k+JyxcblxuICAgICAgICBmb250czogWycnLCAnQXJpYWwnLCAnVmVyZGFuYScsICdUaW1lcyBOZXcgUm9tYW4nXSxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5mb3JtLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGJ1dHRvbiB0aGUgdG9vbGJhciBpcyBjbGlja2VkXG4gICAgICAgIC8vIE92ZXJyaWRlcyBCdXR0b25FeHRlbnNpb24uaGFuZGxlQ2xpY2tcbiAgICAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIEdldCBGb250TmFtZSBvZiBjdXJyZW50IHNlbGVjdGlvbiAoY29udmVydCB0byBzdHJpbmcgc2luY2UgSUUgcmV0dXJucyB0aGlzIGFzIG51bWJlcilcbiAgICAgICAgICAgICAgICB2YXIgZm9udE5hbWUgPSB0aGlzLmRvY3VtZW50LnF1ZXJ5Q29tbWFuZFZhbHVlKCdmb250TmFtZScpICsgJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybShmb250TmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgYnkgbWVkaXVtLWVkaXRvciB0byBhcHBlbmQgZm9ybSB0byB0aGUgdG9vbGJhclxuICAgICAgICBnZXRGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9ybSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybSA9IHRoaXMuY3JlYXRlRm9ybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBVc2VkIGJ5IG1lZGl1bS1lZGl0b3Igd2hlbiB0aGUgZGVmYXVsdCB0b29sYmFyIGlzIHRvIGJlIGRpc3BsYXllZFxuICAgICAgICBpc0Rpc3BsYXllZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybSgpLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jayc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZUZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Rm9ybSgpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmdldFNlbGVjdCgpLnZhbHVlID0gJyc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd0Zvcm06IGZ1bmN0aW9uIChmb250TmFtZSkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdCA9IHRoaXMuZ2V0U2VsZWN0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuYmFzZS5zYXZlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmhpZGVUb29sYmFyRGVmYXVsdEFjdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0Rm9ybSgpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy5zZXRUb29sYmFyUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgc2VsZWN0LnZhbHVlID0gZm9udE5hbWUgfHwgJyc7XG4gICAgICAgICAgICBzZWxlY3QuZm9jdXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgYnkgY29yZSB3aGVuIHRlYXJpbmcgZG93biBtZWRpdW0tZWRpdG9yIChkZXN0cm95KVxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZm9ybTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjb3JlIG1ldGhvZHNcblxuICAgICAgICBkb0Zvcm1TYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5iYXNlLmNoZWNrU2VsZWN0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9Gb3JtQ2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckZvbnROYW1lKCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UuY2hlY2tTZWxlY3Rpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3JtIGNyZWF0aW9uIGFuZCBldmVudCBoYW5kbGluZ1xuICAgICAgICBjcmVhdGVGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmb3JtID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIHNlbGVjdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKSxcbiAgICAgICAgICAgICAgICBjbG9zZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJyksXG4gICAgICAgICAgICAgICAgc2F2ZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdhJyksXG4gICAgICAgICAgICAgICAgb3B0aW9uO1xuXG4gICAgICAgICAgICAvLyBGb250IE5hbWUgRm9ybSAoZGl2KVxuICAgICAgICAgICAgZm9ybS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyLWZvcm0nO1xuICAgICAgICAgICAgZm9ybS5pZCA9ICdtZWRpdW0tZWRpdG9yLXRvb2xiYXItZm9ybS1mb250bmFtZS0nICsgdGhpcy5nZXRFZGl0b3JJZCgpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tzIG9uIHRoZSBmb3JtIGl0c2VsZlxuICAgICAgICAgICAgdGhpcy5vbihmb3JtLCAnY2xpY2snLCB0aGlzLmhhbmRsZUZvcm1DbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gQWRkIGZvbnQgbmFtZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpPHRoaXMuZm9udHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvcHRpb24gPSBkb2MuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmlubmVySFRNTCA9IHRoaXMuZm9udHNbaV07XG4gICAgICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gdGhpcy5mb250c1tpXTtcbiAgICAgICAgICAgICAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0LmNsYXNzTmFtZSA9ICdtZWRpdW0tZWRpdG9yLXRvb2xiYXItc2VsZWN0JztcbiAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoc2VsZWN0KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHR5cGluZyBpbiB0aGUgdGV4dGJveFxuICAgICAgICAgICAgdGhpcy5vbihzZWxlY3QsICdjaGFuZ2UnLCB0aGlzLmhhbmRsZUZvbnRDaGFuZ2UuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBzYXZlIGJ1dG9uXG4gICAgICAgICAgICBzYXZlLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XG4gICAgICAgICAgICBzYXZlLmNsYXNzTmFtZSA9ICdtZWRpdW0tZWRpdG9yLXRvb2Jhci1zYXZlJztcbiAgICAgICAgICAgIHNhdmUuaW5uZXJIVE1MID0gdGhpcy5nZXRFZGl0b3JPcHRpb24oJ2J1dHRvbkxhYmVscycpID09PSAnZm9udGF3ZXNvbWUnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtY2hlY2tcIj48L2k+JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIzEwMDAzOyc7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHNhdmUpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgc2F2ZSBidXR0b24gY2xpY2tzIChjYXB0dXJlKVxuICAgICAgICAgICAgdGhpcy5vbihzYXZlLCAnY2xpY2snLCB0aGlzLmhhbmRsZVNhdmVDbGljay5iaW5kKHRoaXMpLCB0cnVlKTtcblxuICAgICAgICAgICAgLy8gQWRkIGNsb3NlIGJ1dHRvblxuICAgICAgICAgICAgY2xvc2Uuc2V0QXR0cmlidXRlKCdocmVmJywgJyMnKTtcbiAgICAgICAgICAgIGNsb3NlLmNsYXNzTmFtZSA9ICdtZWRpdW0tZWRpdG9yLXRvb2Jhci1jbG9zZSc7XG4gICAgICAgICAgICBjbG9zZS5pbm5lckhUTUwgPSB0aGlzLmdldEVkaXRvck9wdGlvbignYnV0dG9uTGFiZWxzJykgPT09ICdmb250YXdlc29tZScgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtdGltZXNcIj48L2k+JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJnRpbWVzOyc7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGNsb3NlKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIGNsb3NlIGJ1dHRvbiBjbGlja3NcbiAgICAgICAgICAgIHRoaXMub24oY2xvc2UsICdjbGljaycsIHRoaXMuaGFuZGxlQ2xvc2VDbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm07XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2VsZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCkucXVlcnlTZWxlY3Rvcignc2VsZWN0Lm1lZGl1bS1lZGl0b3ItdG9vbGJhci1zZWxlY3QnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhckZvbnROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudHModGhpcy5kb2N1bWVudCkuZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ZvbnQnICYmIGVsLmhhc0F0dHJpYnV0ZSgnZmFjZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZmFjZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUZvbnRDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmb250ID0gdGhpcy5nZXRTZWxlY3QoKS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChmb250ID09PSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGb250TmFtZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWNBY3Rpb24oJ2ZvbnROYW1lJywgeyB2YWx1ZTogZm9udCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVGb3JtQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG5vdCB0byBoaWRlIGZvcm0gd2hlbiBjbGlja2luZyBpbnNpZGUgdGhlIGZvcm1cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVNhdmVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDbGlja2luZyBTYXZlIC0+IGNyZWF0ZSB0aGUgZm9udCBzaXplXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5kb0Zvcm1TYXZlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQ2xvc2VDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDbGljayBDbG9zZSAtPiBjbG9zZSB0aGUgZm9ybVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZG9Gb3JtQ2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvbnROYW1lID0gRm9udE5hbWVGb3JtO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgRm9udFNpemVGb3JtID0gTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9ybS5leHRlbmQoe1xuXG4gICAgICAgIG5hbWU6ICdmb250c2l6ZScsXG4gICAgICAgIGFjdGlvbjogJ2ZvbnRTaXplJyxcbiAgICAgICAgYXJpYTogJ2luY3JlYXNlL2RlY3JlYXNlIGZvbnQgc2l6ZScsXG4gICAgICAgIGNvbnRlbnREZWZhdWx0OiAnJiN4QjE7JywgLy8gwrFcbiAgICAgICAgY29udGVudEZBOiAnPGkgY2xhc3M9XCJmYSBmYS10ZXh0LWhlaWdodFwiPjwvaT4nLFxuXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvcm0ucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgd2hlbiB0aGUgYnV0dG9uIHRoZSB0b29sYmFyIGlzIGNsaWNrZWRcbiAgICAgICAgLy8gT3ZlcnJpZGVzIEJ1dHRvbkV4dGVuc2lvbi5oYW5kbGVDbGlja1xuICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGZvbnRzaXplIG9mIGN1cnJlbnQgc2VsZWN0aW9uIChjb252ZXJ0IHRvIHN0cmluZyBzaW5jZSBJRSByZXR1cm5zIHRoaXMgYXMgbnVtYmVyKVxuICAgICAgICAgICAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZG9jdW1lbnQucXVlcnlDb21tYW5kVmFsdWUoJ2ZvbnRTaXplJykgKyAnJztcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKGZvbnRTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIENhbGxlZCBieSBtZWRpdW0tZWRpdG9yIHRvIGFwcGVuZCBmb3JtIHRvIHRoZSB0b29sYmFyXG4gICAgICAgIGdldEZvcm06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtID0gdGhpcy5jcmVhdGVGb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFVzZWQgYnkgbWVkaXVtLWVkaXRvciB3aGVuIHRoZSBkZWZhdWx0IHRvb2xiYXIgaXMgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgIGlzRGlzcGxheWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCkuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJztcbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlRm9ybTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nZXRGb3JtKCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuZ2V0SW5wdXQoKS52YWx1ZSA9ICcnO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dGb3JtOiBmdW5jdGlvbiAoZm9udFNpemUpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IHRoaXMuZ2V0SW5wdXQoKTtcblxuICAgICAgICAgICAgdGhpcy5iYXNlLnNhdmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2xiYXJEZWZhdWx0QWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5nZXRGb3JtKCkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLnNldFRvb2xiYXJQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGZvbnRTaXplIHx8ICcnO1xuICAgICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBDYWxsZWQgYnkgY29yZSB3aGVuIHRlYXJpbmcgZG93biBtZWRpdW0tZWRpdG9yIChkZXN0cm95KVxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZm9ybTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjb3JlIG1ldGhvZHNcblxuICAgICAgICBkb0Zvcm1TYXZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5iYXNlLmNoZWNrU2VsZWN0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZG9Gb3JtQ2FuY2VsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckZvbnRTaXplKCk7XG4gICAgICAgICAgICB0aGlzLmJhc2UuY2hlY2tTZWxlY3Rpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBmb3JtIGNyZWF0aW9uIGFuZCBldmVudCBoYW5kbGluZ1xuICAgICAgICBjcmVhdGVGb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmb3JtID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIGlucHV0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lucHV0JyksXG4gICAgICAgICAgICAgICAgY2xvc2UgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpLFxuICAgICAgICAgICAgICAgIHNhdmUgPSBkb2MuY3JlYXRlRWxlbWVudCgnYScpO1xuXG4gICAgICAgICAgICAvLyBGb250IFNpemUgRm9ybSAoZGl2KVxuICAgICAgICAgICAgZm9ybS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyLWZvcm0nO1xuICAgICAgICAgICAgZm9ybS5pZCA9ICdtZWRpdW0tZWRpdG9yLXRvb2xiYXItZm9ybS1mb250c2l6ZS0nICsgdGhpcy5nZXRFZGl0b3JJZCgpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tzIG9uIHRoZSBmb3JtIGl0c2VsZlxuICAgICAgICAgICAgdGhpcy5vbihmb3JtLCAnY2xpY2snLCB0aGlzLmhhbmRsZUZvcm1DbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gQWRkIGZvbnQgc2l6ZSBzbGlkZXJcbiAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYW5nZScpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdtaW4nLCAnMScpO1xuICAgICAgICAgICAgaW5wdXQuc2V0QXR0cmlidXRlKCdtYXgnLCAnNycpO1xuICAgICAgICAgICAgaW5wdXQuY2xhc3NOYW1lID0gJ21lZGl1bS1lZGl0b3ItdG9vbGJhci1pbnB1dCc7XG4gICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGlucHV0KTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHR5cGluZyBpbiB0aGUgdGV4dGJveFxuICAgICAgICAgICAgdGhpcy5vbihpbnB1dCwgJ2NoYW5nZScsIHRoaXMuaGFuZGxlU2xpZGVyQ2hhbmdlLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBBZGQgc2F2ZSBidXRvblxuICAgICAgICAgICAgc2F2ZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycpO1xuICAgICAgICAgICAgc2F2ZS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29iYXItc2F2ZSc7XG4gICAgICAgICAgICBzYXZlLmlubmVySFRNTCA9IHRoaXMuZ2V0RWRpdG9yT3B0aW9uKCdidXR0b25MYWJlbHMnKSA9PT0gJ2ZvbnRhd2Vzb21lJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLWNoZWNrXCI+PC9pPicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiMxMDAwMzsnO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChzYXZlKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIHNhdmUgYnV0dG9uIGNsaWNrcyAoY2FwdHVyZSlcbiAgICAgICAgICAgIHRoaXMub24oc2F2ZSwgJ2NsaWNrJywgdGhpcy5oYW5kbGVTYXZlQ2xpY2suYmluZCh0aGlzKSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBjbG9zZSBidXR0b25cbiAgICAgICAgICAgIGNsb3NlLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XG4gICAgICAgICAgICBjbG9zZS5jbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci10b29iYXItY2xvc2UnO1xuICAgICAgICAgICAgY2xvc2UuaW5uZXJIVE1MID0gdGhpcy5nZXRFZGl0b3JPcHRpb24oJ2J1dHRvbkxhYmVscycpID09PSAnZm9udGF3ZXNvbWUnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8aSBjbGFzcz1cImZhIGZhLXRpbWVzXCI+PC9pPicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyZ0aW1lczsnO1xuICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChjbG9zZSk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBjbG9zZSBidXR0b24gY2xpY2tzXG4gICAgICAgICAgICB0aGlzLm9uKGNsb3NlLCAnY2xpY2snLCB0aGlzLmhhbmRsZUNsb3NlQ2xpY2suYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldElucHV0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb3JtKCkucXVlcnlTZWxlY3RvcignaW5wdXQubWVkaXVtLWVkaXRvci10b29sYmFyLWlucHV0Jyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJGb250U2l6ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnRzKHRoaXMuZG9jdW1lbnQpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdmb250JyAmJiBlbC5oYXNBdHRyaWJ1dGUoJ3NpemUnKSkge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3NpemUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVTbGlkZXJDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRJbnB1dCgpLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHNpemUgPT09ICc0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJGb250U2l6ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWNBY3Rpb24oJ2ZvbnRTaXplJywgeyB2YWx1ZTogc2l6ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVGb3JtQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIG5vdCB0byBoaWRlIGZvcm0gd2hlbiBjbGlja2luZyBpbnNpZGUgdGhlIGZvcm1cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZVNhdmVDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDbGlja2luZyBTYXZlIC0+IGNyZWF0ZSB0aGUgZm9udCBzaXplXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5kb0Zvcm1TYXZlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQ2xvc2VDbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAvLyBDbGljayBDbG9zZSAtPiBjbG9zZSB0aGUgZm9ybVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuZG9Gb3JtQ2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZvbnRTaXplID0gRm9udFNpemVGb3JtO1xufSgpKTtcbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyogSGVscGVycyBhbmQgaW50ZXJuYWwgdmFyaWFibGVzIHRoYXQgZG9uJ3QgbmVlZCB0byBiZSBtZW1iZXJzIG9mIGFjdHVhbCBwYXN0ZSBoYW5kbGVyICovXG5cbiAgICB2YXIgcGFzdGVCaW5EZWZhdWx0Q29udGVudCA9ICclTUVfUEFTVEVCSU4lJyxcbiAgICAgICAgbGFzdFJhbmdlID0gbnVsbCxcbiAgICAgICAga2V5Ym9hcmRQYXN0ZUVkaXRhYmxlID0gbnVsbCxcbiAgICAgICAgc3RvcFByb3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9O1xuXG4gICAgLypqc2xpbnQgcmVnZXhwOiB0cnVlKi9cbiAgICAvKlxuICAgICAgICBqc2xpbnQgZG9lcyBub3QgYWxsb3cgY2hhcmFjdGVyIG5lZ2F0aW9uLCBiZWNhdXNlIHRoZSBuZWdhdGlvblxuICAgICAgICB3aWxsIG5vdCBtYXRjaCBhbnkgdW5pY29kZSBjaGFyYWN0ZXJzLiBJbiB0aGUgcmVnZXhlcyBpbiB0aGlzXG4gICAgICAgIGJsb2NrLCBuZWdhdGlvbiBpcyB1c2VkIHNwZWNpZmljYWxseSB0byBtYXRjaCB0aGUgZW5kIG9mIGFuIGh0bWxcbiAgICAgICAgdGFnLCBhbmQgaW4gZmFjdCB1bmljb2RlIGNoYXJhY3RlcnMgKnNob3VsZCogYmUgYWxsb3dlZC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlcGxhY2VtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbnl0aGluZyBidXQgdGhlIGNvbnRlbnRzIHdpdGhpbiB0aGUgQk9EWSBlbGVtZW50XG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvXltcXHNcXFNdKjxib2R5W14+XSo+XFxzKnxcXHMqPFxcL2JvZHlbXj5dKj5bXFxzXFxTXSokL2cpLCAnJ10sXG5cbiAgICAgICAgICAgIC8vIGNsZWFudXAgY29tbWVudHMgYWRkZWQgYnkgQ2hyb21lIHdoZW4gcGFzdGluZyBodG1sXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPCEtLVN0YXJ0RnJhZ21lbnQtLT58PCEtLUVuZEZyYWdtZW50LS0+L2cpLCAnJ10sXG5cbiAgICAgICAgICAgIC8vIFRyYWlsaW5nIEJSIGVsZW1lbnRzXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPGJyPiQvaSksICcnXSxcblxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0d28gYm9ndXMgdGFncyB0aGF0IGJlZ2luIHBhc3RlcyBmcm9tIGdvb2dsZSBkb2NzXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPFtePl0qZG9jcy1pbnRlcm5hbC1ndWlkW14+XSo+L2dpKSwgJyddLFxuICAgICAgICAgICAgW25ldyBSZWdFeHAoLzxcXC9iPig8YnJbXj5dKj4pPyQvZ2kpLCAnJ10sXG5cbiAgICAgICAgICAgICAvLyB1bi1odG1sIHNwYWNlcyBhbmQgbmV3bGluZXMgaW5zZXJ0ZWQgYnkgT1MgWFxuICAgICAgICAgICAgW25ldyBSZWdFeHAoLzxzcGFuIGNsYXNzPVwiQXBwbGUtY29udmVydGVkLXNwYWNlXCI+XFxzKzxcXC9zcGFuPi9nKSwgJyAnXSxcbiAgICAgICAgICAgIFtuZXcgUmVnRXhwKC88YnIgY2xhc3M9XCJBcHBsZS1pbnRlcmNoYW5nZS1uZXdsaW5lXCI+L2cpLCAnPGJyPiddLFxuXG4gICAgICAgICAgICAvLyByZXBsYWNlIGdvb2dsZSBkb2NzIGl0YWxpY3MrYm9sZCB3aXRoIGEgc3BhbiB0byBiZSByZXBsYWNlZCBvbmNlIHRoZSBodG1sIGlzIGluc2VydGVkXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPHNwYW5bXj5dKihmb250LXN0eWxlOml0YWxpYztmb250LXdlaWdodDpib2xkfGZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1zdHlsZTppdGFsaWMpW14+XSo+L2dpKSwgJzxzcGFuIGNsYXNzPVwicmVwbGFjZS13aXRoIGl0YWxpYyBib2xkXCI+J10sXG5cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgZ29vZ2xlIGRvY3MgaXRhbGljcyB3aXRoIGEgc3BhbiB0byBiZSByZXBsYWNlZCBvbmNlIHRoZSBodG1sIGlzIGluc2VydGVkXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPHNwYW5bXj5dKmZvbnQtc3R5bGU6aXRhbGljW14+XSo+L2dpKSwgJzxzcGFuIGNsYXNzPVwicmVwbGFjZS13aXRoIGl0YWxpY1wiPiddLFxuXG4gICAgICAgICAgICAvL1tyZXBsYWNlIGdvb2dsZSBkb2NzIGJvbGRzIHdpdGggYSBzcGFuIHRvIGJlIHJlcGxhY2VkIG9uY2UgdGhlIGh0bWwgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIFtuZXcgUmVnRXhwKC88c3BhbltePl0qZm9udC13ZWlnaHQ6Ym9sZFtePl0qPi9naSksICc8c3BhbiBjbGFzcz1cInJlcGxhY2Utd2l0aCBib2xkXCI+J10sXG5cbiAgICAgICAgICAgICAvLyByZXBsYWNlIG1hbnVhbGx5IGVudGVyZWQgYi9pL2EgdGFncyB3aXRoIHJlYWwgb25lc1xuICAgICAgICAgICAgW25ldyBSZWdFeHAoLyZsdDsoXFwvPykoaXxifGEpJmd0Oy9naSksICc8JDEkMj4nXSxcblxuICAgICAgICAgICAgIC8vIHJlcGxhY2UgbWFudWFsbHkgYSB0YWdzIHdpdGggcmVhbCBvbmVzLCBjb252ZXJ0aW5nIHNtYXJ0LXF1b3RlcyBmcm9tIGdvb2dsZSBkb2NzXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvJmx0O2EoPzooPyFocmVmKS4pK2hyZWY9KD86JnF1b3Q7fCZyZHF1bzt8JmxkcXVvO3xcInzigJx84oCdKSgoKD8hJnF1b3Q7fCZyZHF1bzt8JmxkcXVvO3xcInzigJx84oCdKS4pKikoPzomcXVvdDt8JnJkcXVvO3wmbGRxdW87fFwifOKAnHzigJ0pKD86KD8hJmd0OykuKSomZ3Q7L2dpKSwgJzxhIGhyZWY9XCIkMVwiPiddLFxuXG4gICAgICAgICAgICAvLyBOZXdsaW5lcyBiZXR3ZWVuIHBhcmFncmFwaHMgaW4gaHRtbCBoYXZlIG5vIHN5bnRhY3RpYyB2YWx1ZSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGVuIGhhdmUgYSB0ZW5kZW5jeSB0byBhY2NpZGVudGFsbHkgYmVjb21lIGFkZGl0aW9uYWwgcGFyYWdyYXBocyBkb3duIHRoZSBsaW5lXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPFxcL3A+XFxuKy9naSksICc8L3A+J10sXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvXFxuKzxwL2dpKSwgJzxwJ10sXG5cbiAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBXb3JkIG1ha2VzIHRoZXNlIG9kZCB0YWdzLCBsaWtlIDxvOnA+PC9vOnA+XG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPFxcLz9vOlthLXpdKj4vZ2kpLCAnJ10sXG5cbiAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBXb3JkIGFkZHMgc29tZSBzcGVjaWFsIGVsZW1lbnRzIGFyb3VuZCBsaXN0IGl0ZW1zXG4gICAgICAgICAgICBbbmV3IFJlZ0V4cCgvPCFcXFtpZiAhc3VwcG9ydExpc3RzXFxdPigoKD8hPCEpLikqKTwhXFxbZW5kaWZdXFw+L2dpKSwgJyQxJ11cbiAgICAgICAgXTtcbiAgICB9XG4gICAgLypqc2xpbnQgcmVnZXhwOiBmYWxzZSovXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHZhcmlvdXMgY29udGVudCB0eXBlcyBvdXQgb2YgdGhlIENsaXBib2FyZCBBUEkuIEl0IHdpbGwgYWxzbyBnZXQgdGhlXG4gICAgICogcGxhaW4gdGV4dCB1c2luZyBvbGRlciBJRSBhbmQgV2ViS2l0IEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IEV2ZW50IGZpcmVkIG9uIHBhc3RlLlxuICAgICAqIEBwYXJhbSB7d2lufSByZWZlcmVuY2UgdG8gd2luZG93XG4gICAgICogQHBhcmFtIHtkb2N9IHJlZmVyZW5jZSB0byBkb2N1bWVudFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IHdpdGggbWltZSB0eXBlcyBhbmQgZGF0YSBmb3IgdGhvc2UgbWltZSB0eXBlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDbGlwYm9hcmRDb250ZW50KGV2ZW50LCB3aW4sIGRvYykge1xuICAgICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCB3aW4uY2xpcGJvYXJkRGF0YSB8fCBkb2MuZGF0YVRyYW5zZmVyLFxuICAgICAgICAgICAgZGF0YSA9IHt9O1xuXG4gICAgICAgIGlmICghZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBvbGQgV2ViS2l0L0lFIEFQSVxuICAgICAgICBpZiAoZGF0YVRyYW5zZmVyLmdldERhdGEpIHtcbiAgICAgICAgICAgIHZhciBsZWdhY3lUZXh0ID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ1RleHQnKTtcbiAgICAgICAgICAgIGlmIChsZWdhY3lUZXh0ICYmIGxlZ2FjeVRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGRhdGFbJ3RleHQvcGxhaW4nXSA9IGxlZ2FjeVRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YVRyYW5zZmVyLnR5cGVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFUcmFuc2Zlci50eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGRhdGFUcmFuc2Zlci50eXBlc1tpXTtcbiAgICAgICAgICAgICAgICBkYXRhW2NvbnRlbnRUeXBlXSA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHZhciBQYXN0ZUhhbmRsZXIgPSBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLmV4dGVuZCh7XG4gICAgICAgIC8qIFBhc3RlIE9wdGlvbnMgKi9cblxuICAgICAgICAvKiBmb3JjZVBsYWluVGV4dDogW2Jvb2xlYW5dXG4gICAgICAgICAqIEZvcmNlcyBwYXN0aW5nIGFzIHBsYWluIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBmb3JjZVBsYWluVGV4dDogdHJ1ZSxcblxuICAgICAgICAvKiBjbGVhblBhc3RlZEhUTUw6IFtib29sZWFuXVxuICAgICAgICAgKiBjbGVhbnMgcGFzdGVkIGNvbnRlbnQgZnJvbSBkaWZmZXJlbnQgc291cmNlcywgbGlrZSBnb29nbGUgZG9jcyBldGMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhblBhc3RlZEhUTUw6IGZhbHNlLFxuXG4gICAgICAgIC8qIHByZUNsZWFuUmVwbGFjZW1lbnRzOiBbQXJyYXldXG4gICAgICAgICAqIGN1c3RvbSBwYWlycyAoMiBlbGVtZW50IGFycmF5cykgb2YgUmVnRXhwIGFuZCByZXBsYWNlbWVudCB0ZXh0IHRvIHVzZSBkdXJpbmcgcGFzdCB3aGVuXG4gICAgICAgICAqIF9fZm9yY2VQbGFpblRleHRfXyBvciBfX2NsZWFuUGFzdGVkSFRNTF9fIGFyZSBgdHJ1ZWAgT1Igd2hlbiBjYWxsaW5nIGBjbGVhblBhc3RlKHRleHQpYCBoZWxwZXIgbWV0aG9kLlxuICAgICAgICAgKiBUaGVzZSByZXBsYWNlbWVudHMgYXJlIGV4ZWN1dGVkIGJlZm9yZSBhbnkgbWVkaXVtIGVkaXRvciBkZWZpbmVkIHJlcGxhY2VtZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHByZUNsZWFuUmVwbGFjZW1lbnRzOiBbXSxcblxuICAgICAgICAvKiBjbGVhblJlcGxhY2VtZW50czogW0FycmF5XVxuICAgICAgICAgKiBjdXN0b20gcGFpcnMgKDIgZWxlbWVudCBhcnJheXMpIG9mIFJlZ0V4cCBhbmQgcmVwbGFjZW1lbnQgdGV4dCB0byB1c2UgZHVyaW5nIHBhc3RlIHdoZW5cbiAgICAgICAgICogX19mb3JjZVBsYWluVGV4dF9fIG9yIF9fY2xlYW5QYXN0ZWRIVE1MX18gYXJlIGB0cnVlYCBPUiB3aGVuIGNhbGxpbmcgYGNsZWFuUGFzdGUodGV4dClgIGhlbHBlciBtZXRob2QuXG4gICAgICAgICAqIFRoZXNlIHJlcGxhY2VtZW50cyBhcmUgZXhlY3V0ZWQgYWZ0ZXIgYW55IG1lZGl1bSBlZGl0b3IgZGVmaW5lZCByZXBsYWNlbWVudHMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhblJlcGxhY2VtZW50czogW10sXG5cbiAgICAgICAgLyogY2xlYW5BdHRyczo6IFtBcnJheV1cbiAgICAgICAgICogbGlzdCBvZiBlbGVtZW50IGF0dHJpYnV0ZXMgdG8gcmVtb3ZlIGR1cmluZyBwYXN0ZSB3aGVuIF9fY2xlYW5QYXN0ZWRIVE1MX18gaXMgYHRydWVgIG9yIHdoZW5cbiAgICAgICAgICogY2FsbGluZyBgY2xlYW5QYXN0ZSh0ZXh0KWAgb3IgYHBhc3RlSFRNTChodG1sLCBvcHRpb25zKWAgaGVscGVyIG1ldGhvZHMuXG4gICAgICAgICAqL1xuICAgICAgICBjbGVhbkF0dHJzOiBbJ2NsYXNzJywgJ3N0eWxlJywgJ2RpciddLFxuXG4gICAgICAgIC8qIGNsZWFuVGFnczogW0FycmF5XVxuICAgICAgICAgKiBsaXN0IG9mIGVsZW1lbnQgdGFnIG5hbWVzIHRvIHJlbW92ZSBkdXJpbmcgcGFzdGUgd2hlbiBfX2NsZWFuUGFzdGVkSFRNTF9fIGlzIGB0cnVlYCBvciB3aGVuXG4gICAgICAgICAqIGNhbGxpbmcgYGNsZWFuUGFzdGUodGV4dClgIG9yIGBwYXN0ZUhUTUwoaHRtbCwgb3B0aW9ucylgIGhlbHBlciBtZXRob2RzLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYW5UYWdzOiBbJ21ldGEnXSxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZvcmNlUGxhaW5UZXh0IHx8IHRoaXMuY2xlYW5QYXN0ZWRIVE1MKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlS2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIGFjY2VzcyB0byB0aGUgZnVsbCBldmVudCBkYXRhIGluIHBhc3RlXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuJ3QgdXNlIHRoZSBlZGl0YWJsZVBhc3RlIGV2ZW50IGhlcmVcbiAgICAgICAgICAgICAgICB0aGlzLmdldEVkaXRvckVsZW1lbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uKGVsZW1lbnQsICdwYXN0ZScsIHRoaXMuaGFuZGxlUGFzdGUuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2FkZEVsZW1lbnQnLCB0aGlzLmhhbmRsZUFkZEVsZW1lbnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQWRkRWxlbWVudDogZnVuY3Rpb24gKGV2ZW50LCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5vbihlZGl0YWJsZSwgJ3Bhc3RlJywgdGhpcy5oYW5kbGVQYXN0ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgcGFzdGViaW4gaXMgZGVzdHJveWVkIGluIGNhc2UgaXQncyBzdGlsbCBhcm91bmQgZm9yIHNvbWUgcmVhc29uXG4gICAgICAgICAgICBpZiAodGhpcy5mb3JjZVBsYWluVGV4dCB8fCB0aGlzLmNsZWFuUGFzdGVkSFRNTCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFzdGVCaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVQYXN0ZTogZnVuY3Rpb24gKGV2ZW50LCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjbGlwYm9hcmRDb250ZW50ID0gZ2V0Q2xpcGJvYXJkQ29udGVudChldmVudCwgdGhpcy53aW5kb3csIHRoaXMuZG9jdW1lbnQpLFxuICAgICAgICAgICAgICAgIHBhc3RlZEhUTUwgPSBjbGlwYm9hcmRDb250ZW50Wyd0ZXh0L2h0bWwnXSxcbiAgICAgICAgICAgICAgICBwYXN0ZWRQbGFpbiA9IGNsaXBib2FyZENvbnRlbnRbJ3RleHQvcGxhaW4nXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMud2luZG93LmNsaXBib2FyZERhdGEgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YSA9PT0gdW5kZWZpbmVkICYmICFwYXN0ZWRIVE1MKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2luZG93LmNsaXBib2FyZERhdGEgZXhpc3RzLCBidXQgZXZlbnQuY2xpcGJvYXJkRGF0YSBkb2Vzbid0IGV4aXN0LFxuICAgICAgICAgICAgICAgIC8vIHdlJ3JlIHByb2JhYmx5IGluIElFLiBJRSBvbmx5IGhhcyB0d28gcG9zc2liaWxpdGllcyBmb3IgY2xpcGJvYXJkXG4gICAgICAgICAgICAgICAgLy8gZGF0YSBmb3JtYXQ6ICdUZXh0JyBhbmQgJ1VSTCcuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBGb3IgSUUsIHdlJ2xsIGZhbGxiYWNrIHRvICdUZXh0JyBmb3IgdGV4dC9odG1sXG4gICAgICAgICAgICAgICAgcGFzdGVkSFRNTCA9IHBhc3RlZFBsYWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFzdGVkSFRNTCB8fCBwYXN0ZWRQbGFpbikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRvUGFzdGUocGFzdGVkSFRNTCwgcGFzdGVkUGxhaW4sIGVkaXRhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkb1Bhc3RlOiBmdW5jdGlvbiAocGFzdGVkSFRNTCwgcGFzdGVkUGxhaW4sIGVkaXRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgcGFyYWdyYXBocyxcbiAgICAgICAgICAgICAgICBodG1sID0gJycsXG4gICAgICAgICAgICAgICAgcDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW5QYXN0ZWRIVE1MICYmIHBhc3RlZEhUTUwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGVhblBhc3RlKHBhc3RlZEhUTUwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISh0aGlzLmdldEVkaXRvck9wdGlvbignZGlzYWJsZVJldHVybicpIHx8IChlZGl0YWJsZSAmJiBlZGl0YWJsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZS1yZXR1cm4nKSkpKSB7XG4gICAgICAgICAgICAgICAgcGFyYWdyYXBocyA9IHBhc3RlZFBsYWluLnNwbGl0KC9bXFxyXFxuXSsvZyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIFxcclxcbiBpbiBkYXRhLCBkb24ndCB3cmFwIGluIDxwPlxuICAgICAgICAgICAgICAgIGlmIChwYXJhZ3JhcGhzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChwID0gMDsgcCA8IHBhcmFncmFwaHMubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhZ3JhcGhzW3BdICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgKz0gJzxwPicgKyBNZWRpdW1FZGl0b3IudXRpbC5odG1sRW50aXRpZXMocGFyYWdyYXBoc1twXSkgKyAnPC9wPic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBodG1sID0gTWVkaXVtRWRpdG9yLnV0aWwuaHRtbEVudGl0aWVzKHBhcmFncmFwaHNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaHRtbCA9IE1lZGl1bUVkaXRvci51dGlsLmh0bWxFbnRpdGllcyhwYXN0ZWRQbGFpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5pbnNlcnRIVE1MQ29tbWFuZCh0aGlzLmRvY3VtZW50LCBodG1sKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVQYXN0ZUJpblBhc3RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXN0ZUJpbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNsaXBib2FyZENvbnRlbnQgPSBnZXRDbGlwYm9hcmRDb250ZW50KGV2ZW50LCB0aGlzLndpbmRvdywgdGhpcy5kb2N1bWVudCksXG4gICAgICAgICAgICAgICAgcGFzdGVkSFRNTCA9IGNsaXBib2FyZENvbnRlbnRbJ3RleHQvaHRtbCddLFxuICAgICAgICAgICAgICAgIHBhc3RlZFBsYWluID0gY2xpcGJvYXJkQ29udGVudFsndGV4dC9wbGFpbiddLFxuICAgICAgICAgICAgICAgIGVkaXRhYmxlID0ga2V5Ym9hcmRQYXN0ZUVkaXRhYmxlO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHZhbGlkIGh0bWwgYWxyZWFkeSwgb3Igd2UncmUgbm90IGluIGNsZWFuUGFzdGVkSFRNTCBtb2RlXG4gICAgICAgICAgICAvLyB3ZSBjYW4gaWdub3JlIHRoZSBwYXN0ZSBiaW4gYW5kIGp1c3QgcGFzdGUgbm93XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xlYW5QYXN0ZWRIVE1MIHx8IHBhc3RlZEhUTUwpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlUGFzdGVCaW4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvUGFzdGUocGFzdGVkSFRNTCwgcGFzdGVkUGxhaW4sIGVkaXRhYmxlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBldmVudCBoYW5kbGluZyBjb2RlIGxpc3RlbnMgZm9yIHBhc3RlIG9uIHRoZSBlZGl0YWJsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gdHJpZ2dlciB0aGUgZWRpdGFibGVQYXN0ZSBldmVudC4gIFNpbmNlIHRoaXMgcGFzdGUgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyBpcyBoYXBwZW5pbmcgb24gdGhlIHBhc3RlYmluLCB0aGUgZXZlbnQgaGFuZGxpbmcgY29kZSBuZXZlciBrbm93cyBhYm91dCBpdFxuICAgICAgICAgICAgICAgIC8vIFNvLCB3ZSBoYXZlIHRvIHRyaWdnZXIgZWRpdGFibGVQYXN0ZSBtYW51YWxseVxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZWRpdGFibGVQYXN0ZScsIHsgY3VycmVudFRhcmdldDogZWRpdGFibGUsIHRhcmdldDogZWRpdGFibGUgfSwgZWRpdGFibGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBsb29rIGF0IHRoZSBwYXN0ZSBiaW4sIHNvIGRvIGEgc2V0VGltZW91dCB0byBsZXQgdGhlIHBhc3RlXG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggaW50byB0aGUgcGFzdGUgYmluXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGxvb2sgZm9yIEhUTUwgaWYgd2UncmUgaW4gY2xlYW5QYXN0ZWRIVE1MIG1vZGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGVhblBhc3RlZEhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgY2xpcGJvYXJkIGRpZG4ndCBoYXZlIEhUTUwsIHRyeSB0aGUgcGFzdGUgYmluXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlZEhUTUwgPSB0aGlzLmdldFBhc3RlQmluSHRtbCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIG5lZWRlZCB0aGUgcGFzdGUgYmluLCB3ZSdyZSBkb25lIHdpdGggaXQgbm93LCByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVBhc3RlQmluKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIHBhc3RlIHdpdGggdGhlIGh0bWwgZnJvbSB0aGUgcGFzdGUgYmluXG4gICAgICAgICAgICAgICAgdGhpcy5kb1Bhc3RlKHBhc3RlZEhUTUwsIHBhc3RlZFBsYWluLCBlZGl0YWJsZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZXZlbnQgaGFuZGxpbmcgY29kZSBsaXN0ZW5zIGZvciBwYXN0ZSBvbiB0aGUgZWRpdGFibGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIHRyaWdnZXIgdGhlIGVkaXRhYmxlUGFzdGUgZXZlbnQuICBTaW5jZSB0aGlzIHBhc3RlIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gaXMgaGFwcGVuaW5nIG9uIHRoZSBwYXN0ZWJpbiwgdGhlIGV2ZW50IGhhbmRsaW5nIGNvZGUgbmV2ZXIga25vd3MgYWJvdXQgaXRcbiAgICAgICAgICAgICAgICAvLyBTbywgd2UgaGF2ZSB0byB0cmlnZ2VyIGVkaXRhYmxlUGFzdGUgbWFudWFsbHlcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2VkaXRhYmxlUGFzdGUnLCB7IGN1cnJlbnRUYXJnZXQ6IGVkaXRhYmxlLCB0YXJnZXQ6IGVkaXRhYmxlIH0sIGVkaXRhYmxlKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlS2V5ZG93bjogZnVuY3Rpb24gKGV2ZW50LCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgQ3RybCtWLCBkbyBub3RoaW5nXG4gICAgICAgICAgICBpZiAoIShNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5WKSAmJiBNZWRpdW1FZGl0b3IudXRpbC5pc01ldGFDdHJsS2V5KGV2ZW50KSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVBhc3RlQmluKCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVBhc3RlQmluKGVkaXRhYmxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQYXN0ZUJpbjogZnVuY3Rpb24gKGVkaXRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgcmVjdHMsXG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvblJhbmdlKHRoaXMuZG9jdW1lbnQpLFxuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMud2luZG93LnBhZ2VZT2Zmc2V0O1xuXG4gICAgICAgICAgICBrZXlib2FyZFBhc3RlRWRpdGFibGUgPSBlZGl0YWJsZTtcblxuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmVjdHMgPSByYW5nZS5nZXRDbGllbnRSZWN0cygpO1xuXG4gICAgICAgICAgICAgICAgLy8gb24gZW1wdHkgbGluZSwgcmVjdHMgaXMgZW1wdHkgc28gd2UgZ3JhYiBpbmZvcm1hdGlvbiBmcm9tIHRoZSBmaXJzdCBjb250YWluZXIgb2YgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0b3AgKz0gcmVjdHNbMF0udG9wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCArPSByYW5nZS5zdGFydENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0UmFuZ2UgPSByYW5nZTtcblxuICAgICAgICAgICAgdmFyIHBhc3RlQmluRWxtID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHBhc3RlQmluRWxtLmlkID0gdGhpcy5wYXN0ZUJpbklkID0gJ21lZGl1bS1lZGl0b3ItcGFzdGViaW4tJyArICgrRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICBwYXN0ZUJpbkVsbS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2JvcmRlcjogMXB4IHJlZCBzb2xpZDsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6ICcgKyB0b3AgKyAncHg7IHdpZHRoOiAxMHB4OyBoZWlnaHQ6IDEwcHg7IG92ZXJmbG93OiBoaWRkZW47IG9wYWNpdHk6IDAnKTtcbiAgICAgICAgICAgIHBhc3RlQmluRWxtLnNldEF0dHJpYnV0ZSgnY29udGVudEVkaXRhYmxlJywgdHJ1ZSk7XG4gICAgICAgICAgICBwYXN0ZUJpbkVsbS5pbm5lckhUTUwgPSBwYXN0ZUJpbkRlZmF1bHRDb250ZW50O1xuXG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFzdGVCaW5FbG0pO1xuXG4gICAgICAgICAgICAvLyBhdm9pZCAuZm9jdXMoKSB0byBzdG9wIG90aGVyIGV2ZW50IChhY3R1YWxseSB0aGUgcGFzdGUgZXZlbnQpXG4gICAgICAgICAgICB0aGlzLm9uKHBhc3RlQmluRWxtLCAnZm9jdXMnLCBzdG9wUHJvcCk7XG4gICAgICAgICAgICB0aGlzLm9uKHBhc3RlQmluRWxtLCAnZm9jdXNpbicsIHN0b3BQcm9wKTtcbiAgICAgICAgICAgIHRoaXMub24ocGFzdGVCaW5FbG0sICdmb2N1c291dCcsIHN0b3BQcm9wKTtcblxuICAgICAgICAgICAgcGFzdGVCaW5FbG0uZm9jdXMoKTtcblxuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5zZWxlY3ROb2RlKHBhc3RlQmluRWxtLCB0aGlzLmRvY3VtZW50KTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmJvdW5kSGFuZGxlUGFzdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kSGFuZGxlUGFzdGUgPSB0aGlzLmhhbmRsZVBhc3RlQmluUGFzdGUuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbihwYXN0ZUJpbkVsbSwgJ3Bhc3RlJywgdGhpcy5ib3VuZEhhbmRsZVBhc3RlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVQYXN0ZUJpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGxhc3RSYW5nZSkge1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uc2VsZWN0UmFuZ2UodGhpcy5kb2N1bWVudCwgbGFzdFJhbmdlKTtcbiAgICAgICAgICAgICAgICBsYXN0UmFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobnVsbCAhPT0ga2V5Ym9hcmRQYXN0ZUVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAga2V5Ym9hcmRQYXN0ZUVkaXRhYmxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhc3RlQmluRWxtID0gdGhpcy5nZXRQYXN0ZUJpbigpO1xuICAgICAgICAgICAgaWYgKCFwYXN0ZUJpbkVsbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhc3RlQmluRWxtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYocGFzdGVCaW5FbG0sICdmb2N1cycsIHN0b3BQcm9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihwYXN0ZUJpbkVsbSwgJ2ZvY3VzaW4nLCBzdG9wUHJvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYocGFzdGVCaW5FbG0sICdmb2N1c291dCcsIHN0b3BQcm9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihwYXN0ZUJpbkVsbSwgJ3Bhc3RlJywgdGhpcy5ib3VuZEhhbmRsZVBhc3RlKTtcbiAgICAgICAgICAgICAgICBwYXN0ZUJpbkVsbS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHBhc3RlQmluRWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRQYXN0ZUJpbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5wYXN0ZUJpbklkKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRQYXN0ZUJpbkh0bWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwYXN0ZUJpbkVsbSA9IHRoaXMuZ2V0UGFzdGVCaW4oKTtcblxuICAgICAgICAgICAgaWYgKCFwYXN0ZUJpbkVsbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2ViS2l0IGhhcyBhIG5pY2UgYnVnIHdoZXJlIGl0IGNsb25lcyB0aGUgcGFzdGUgYmluIGlmIHlvdSBwYXN0ZSBmcm9tIGZvciBleGFtcGxlIG5vdGVwYWRcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gZm9yY2UgcGxhaW4gdGV4dCBtb2RlIGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgaWYgKHBhc3RlQmluRWxtLmZpcnN0Q2hpbGQgJiYgcGFzdGVCaW5FbG0uZmlyc3RDaGlsZC5pZCA9PT0gJ21jZXBhc3RlYmluJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhc3RlQmluSHRtbCA9IHBhc3RlQmluRWxtLmlubmVySFRNTDtcblxuICAgICAgICAgICAgLy8gSWYgcGFzdGUgYmluIGlzIGVtcHR5IHRyeSB1c2luZyBwbGFpbiB0ZXh0IG1vZGVcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoYXQgaXMgYmV0dGVyIHRoYW4gbm90aGluZyByaWdodFxuICAgICAgICAgICAgaWYgKCFwYXN0ZUJpbkh0bWwgfHwgcGFzdGVCaW5IdG1sID09PSBwYXN0ZUJpbkRlZmF1bHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFzdGVCaW5IdG1sO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNsZWFuUGFzdGU6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgaSwgZWxMaXN0LCB0bXAsIHdvcmtFbCxcbiAgICAgICAgICAgICAgICBtdWx0aWxpbmUgPSAvPHB8PGJyfDxkaXYvLnRlc3QodGV4dCksXG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzID0gW10uY29uY2F0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZUNsZWFuUmVwbGFjZW1lbnRzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXBsYWNlbWVudHMoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhblJlcGxhY2VtZW50cyB8fCBbXSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBsYWNlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHJlcGxhY2VtZW50c1tpXVswXSwgcmVwbGFjZW1lbnRzW2ldWzFdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFtdWx0aWxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXN0ZUhUTUwodGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHRlbXBvcmFyeSBkaXYgdG8gY2xlYW51cCBibG9jayBlbGVtZW50c1xuICAgICAgICAgICAgdG1wID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgLy8gZG91YmxlIGJyJ3MgYXJlbid0IGNvbnZlcnRlZCB0byBwIHRhZ3MsIGJ1dCB3ZSB3YW50IHBhcmFncmFwaHMuXG4gICAgICAgICAgICB0bXAuaW5uZXJIVE1MID0gJzxwPicgKyB0ZXh0LnNwbGl0KCc8YnI+PGJyPicpLmpvaW4oJzwvcD48cD4nKSArICc8L3A+JztcblxuICAgICAgICAgICAgLy8gYmxvY2sgZWxlbWVudCBjbGVhbnVwXG4gICAgICAgICAgICBlbExpc3QgPSB0bXAucXVlcnlTZWxlY3RvckFsbCgnYSxwLGRpdixicicpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsTGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHdvcmtFbCA9IGVsTGlzdFtpXTtcblxuICAgICAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBXb3JkIHJlcGxhY2VzIHNvbWUgc3BhY2VzIHdpdGggbmV3bGluZXMuXG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgbmV3bGluZXMgYmV0d2VlbiBibG9jayBlbGVtZW50cyBhcmUgbWVhbmluZ2xlc3MsIG5ld2xpbmVzIHdpdGhpblxuICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRzIGFyZSBzb21ldGltZXMgYWN0dWFsbHkgc3BhY2VzLlxuICAgICAgICAgICAgICAgIHdvcmtFbC5pbm5lckhUTUwgPSB3b3JrRWwuaW5uZXJIVE1MLnJlcGxhY2UoL1xcbi9naSwgJyAnKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAod29ya0VsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckNvbW1vbkJsb2Nrcyh3b3JrRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyTGluZUJyZWFrKHdvcmtFbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGFzdGVIVE1MKHRtcC5pbm5lckhUTUwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhc3RlSFRNTDogZnVuY3Rpb24gKGh0bWwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBNZWRpdW1FZGl0b3IudXRpbC5kZWZhdWx0cyh7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIGNsZWFuQXR0cnM6IHRoaXMuY2xlYW5BdHRycyxcbiAgICAgICAgICAgICAgICBjbGVhblRhZ3M6IHRoaXMuY2xlYW5UYWdzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGVsTGlzdCwgd29ya0VsLCBpLCBmcmFnbWVudEJvZHksIHBhc3RlQmxvY2sgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICAgICAgcGFzdGVCbG9jay5hcHBlbmRDaGlsZCh0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JvZHknKSk7XG5cbiAgICAgICAgICAgIGZyYWdtZW50Qm9keSA9IHBhc3RlQmxvY2sucXVlcnlTZWxlY3RvcignYm9keScpO1xuICAgICAgICAgICAgZnJhZ21lbnRCb2R5LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFNwYW5zKGZyYWdtZW50Qm9keSk7XG5cbiAgICAgICAgICAgIGVsTGlzdCA9IGZyYWdtZW50Qm9keS5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxMaXN0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgd29ya0VsID0gZWxMaXN0W2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCdhJyA9PT0gd29ya0VsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgJiYgdGhpcy5nZXRFZGl0b3JPcHRpb24oJ3RhcmdldEJsYW5rJykpIHtcbiAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuc2V0VGFyZ2V0Qmxhbmsod29ya0VsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5jbGVhbnVwQXR0cnMod29ya0VsLCBvcHRpb25zLmNsZWFuQXR0cnMpO1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmNsZWFudXBUYWdzKHdvcmtFbCwgb3B0aW9ucy5jbGVhblRhZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5pbnNlcnRIVE1MQ29tbWFuZCh0aGlzLmRvY3VtZW50LCBmcmFnbWVudEJvZHkuaW5uZXJIVE1MLnJlcGxhY2UoLyZuYnNwOy9nLCAnICcpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPICg2LjApOiBNYWtlIHRoaXMgYW4gaW50ZXJuYWwgaGVscGVyIGluc3RlYWQgb2YgbWVtYmVyIG9mIHBhc3RlIGhhbmRsZXJcbiAgICAgICAgaXNDb21tb25CbG9jazogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGVsICYmIChlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncCcgfHwgZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2RpdicpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPICg2LjApOiBNYWtlIHRoaXMgYW4gaW50ZXJuYWwgaGVscGVyIGluc3RlYWQgb2YgbWVtYmVyIG9mIHBhc3RlIGhhbmRsZXJcbiAgICAgICAgZmlsdGVyQ29tbW9uQmxvY2tzOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICgvXlxccyokLy50ZXN0KGVsLnRleHRDb250ZW50KSAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVE9ETyAoNi4wKTogTWFrZSB0aGlzIGFuIGludGVybmFsIGhlbHBlciBpbnN0ZWFkIG9mIG1lbWJlciBvZiBwYXN0ZSBoYW5kbGVyXG4gICAgICAgIGZpbHRlckxpbmVCcmVhazogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbW1vbkJsb2NrKGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHN0cmF5IGJyJ3MgZm9sbG93aW5nIGNvbW1vbiBibG9jayBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlV2l0aFBhcmVudChlbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb21tb25CbG9jayhlbC5wYXJlbnROb2RlKSAmJiAoZWwucGFyZW50Tm9kZS5maXJzdENoaWxkID09PSBlbCB8fCBlbC5wYXJlbnROb2RlLmxhc3RDaGlsZCA9PT0gZWwpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGJyJ3MganVzdCBpbnNpZGUgb3BlbiBvciBjbG9zZSB0YWdzIG9mIGEgZGl2L3BcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVdpdGhQYXJlbnQoZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuY2hpbGRFbGVtZW50Q291bnQgPT09IDEgJiYgZWwucGFyZW50Tm9kZS50ZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBhbmQgYnIncyB0aGF0IGFyZSB0aGUgb25seSBjaGlsZCBvZiBlbGVtZW50cyBvdGhlciB0aGFuIGRpdi9wXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVXaXRoUGFyZW50KGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPICg2LjApOiBNYWtlIHRoaXMgYW4gaW50ZXJuYWwgaGVscGVyIGluc3RlYWQgb2YgbWVtYmVyIG9mIHBhc3RlIGhhbmRsZXJcbiAgICAgICAgLy8gcmVtb3ZlIGFuIGVsZW1lbnQsIGluY2x1ZGluZyBpdHMgcGFyZW50LCBpZiBpdCBpcyB0aGUgb25seSBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG4gICAgICAgIHJlbW92ZVdpdGhQYXJlbnQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZS5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuY2hpbGRFbGVtZW50Q291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUT0RPICg2LjApOiBNYWtlIHRoaXMgYW4gaW50ZXJuYWwgaGVscGVyIGluc3RlYWQgb2YgbWVtYmVyIG9mIHBhc3RlIGhhbmRsZXJcbiAgICAgICAgY2xlYW51cFNwYW5zOiBmdW5jdGlvbiAoY29udGFpbmVyRWwpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgIG5ld0VsLFxuICAgICAgICAgICAgICAgIHNwYW5zID0gY29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnJlcGxhY2Utd2l0aCcpLFxuICAgICAgICAgICAgICAgIGlzQ0VGID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZWwgJiYgZWwubm9kZU5hbWUgIT09ICcjdGV4dCcgJiYgZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ2ZhbHNlJyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBzcGFuc1tpXTtcbiAgICAgICAgICAgICAgICBuZXdFbCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbC5jbGFzc0xpc3QuY29udGFpbnMoJ2JvbGQnKSA/ICdiJyA6ICdpJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdib2xkJykgJiYgZWwuY2xhc3NMaXN0LmNvbnRhaW5zKCdpdGFsaWMnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYW4gaSB0YWcgYXMgd2VsbCBpZiB0aGlzIGhhcyBib3RoIGl0YWxpY3MgYW5kIGJvbGRcbiAgICAgICAgICAgICAgICAgICAgbmV3RWwuaW5uZXJIVE1MID0gJzxpPicgKyBlbC5pbm5lckhUTUwgKyAnPC9pPic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RWwuaW5uZXJIVE1MID0gZWwuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChuZXdFbCwgZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzcGFucyA9IGNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NwYW4nKTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGVsID0gc3BhbnNbaV07XG5cbiAgICAgICAgICAgICAgICAvLyBiYWlsIGlmIHNwYW4gaXMgaW4gY29udGVudGVkaXRhYmxlID0gZmFsc2VcbiAgICAgICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwudHJhdmVyc2VVcChlbCwgaXNDRUYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgc3BhbnMsIHJlcGxhY2Ugb3RoZXJzIHdpdGggdGhlaXIgY29udGVudHNcbiAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC51bndyYXAoZWwsIHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5wYXN0ZSA9IFBhc3RlSGFuZGxlcjtcbn0oKSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIFBsYWNlaG9sZGVyID0gTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5leHRlbmQoe1xuICAgICAgICBuYW1lOiAncGxhY2Vob2xkZXInLFxuXG4gICAgICAgIC8qIFBsYWNlaG9sZGVyIE9wdGlvbnMgKi9cblxuICAgICAgICAvKiB0ZXh0OiBbc3RyaW5nXVxuICAgICAgICAgKiBUZXh0IHRvIGRpc3BsYXkgaW4gdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgICAqL1xuICAgICAgICB0ZXh0OiAnVHlwZSB5b3VyIHRleHQnLFxuXG4gICAgICAgIC8qIGhpZGVPbkNsaWNrOiBbYm9vbGVhbl1cbiAgICAgICAgICogU2hvdWxkIHdlIGhpZGUgdGhlIHBsYWNlaG9sZGVyIG9uIGNsaWNrICh0cnVlKSBvciB3aGVuIHVzZXIgc3RhcnRzIHR5cGluZyAoZmFsc2UpXG4gICAgICAgICAqL1xuICAgICAgICBoaWRlT25DbGljazogdHJ1ZSxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdFBsYWNlaG9sZGVycygpO1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdFBsYWNlaG9sZGVyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5nZXRFZGl0b3JFbGVtZW50cygpLmZvckVhY2godGhpcy5pbml0RWxlbWVudCwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQWRkRWxlbWVudDogZnVuY3Rpb24gKGV2ZW50LCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RWxlbWVudChlZGl0YWJsZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdEVsZW1lbnQ6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKCFlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGxhY2Vob2xkZXInKSkge1xuICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicsIHRoaXMudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBsYWNlaG9sZGVyKGVsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmdldEVkaXRvckVsZW1lbnRzKCkuZm9yRWFjaCh0aGlzLmNsZWFudXBFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVSZW1vdmVFbGVtZW50OiBmdW5jdGlvbiAoZXZlbnQsIGVkaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXBFbGVtZW50KGVkaXRhYmxlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhbnVwRWxlbWVudDogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlaG9sZGVyJykgPT09IHRoaXMudGV4dCkge1xuICAgICAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dQbGFjZWhvbGRlcjogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20veWFid2UvbWVkaXVtLWVkaXRvci9pc3N1ZXMvMjM0XG4gICAgICAgICAgICAgICAgLy8gSW4gZmlyZWZveCwgc3R5bGluZyB0aGUgcGxhY2Vob2xkZXIgd2l0aCBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWRcbiAgICAgICAgICAgICAgICAvLyBwc2V1ZG8gZWxlbWVudCBjYXVzZXMgdGhlIGN1cnNvciB0byBhcHBlYXIgaW4gYSBiYWQgbG9jYXRpb25cbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBlbGVtZW50IGlzIGNvbXBsZXRlbHkgZW1wdHksIHNvIGFwcGx5IGEgZGlmZmVyZW50IGNsYXNzIHRvXG4gICAgICAgICAgICAgICAgLy8gc3R5bGUgaXQgd2l0aCBhIHJlbGF0aXZlbHkgcG9zaXRpb25lZCBwc2V1ZG8gZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0ZGICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ21lZGl1bS1lZGl0b3ItcGxhY2Vob2xkZXItcmVsYXRpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci1wbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ21lZGl1bS1lZGl0b3ItcGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci1wbGFjZWhvbGRlci1yZWxhdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlUGxhY2Vob2xkZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci1wbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ21lZGl1bS1lZGl0b3ItcGxhY2Vob2xkZXItcmVsYXRpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVQbGFjZWhvbGRlcjogZnVuY3Rpb24gKGVsLCBkb250U2hvdykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaGFzIGNvbnRlbnQsIGhpZGUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICBpZiAoZWwucXVlcnlTZWxlY3RvcignaW1nLCBibG9ja3F1b3RlLCB1bCwgb2wsIHRhYmxlJykgfHwgKGVsLnRleHRDb250ZW50LnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSAhPT0gJycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZVBsYWNlaG9sZGVyKGVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFkb250U2hvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1BsYWNlaG9sZGVyKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hFdmVudEhhbmRsZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oaWRlT25DbGljaykge1xuICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgJ2hpZGVPbkNsaWNrJyBvcHRpb24sIHRoZSBwbGFjZWhvbGRlciBzaG91bGQgYWx3YXlzIGJlIGhpZGRlbiBvbiBmb2N1c1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdmb2N1cycsIHRoaXMuaGFuZGxlRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBlZGl0b3IgaGFzIGNvbnRlbnQsIGl0IHNob3VsZCBhbHdheXMgaGlkZSB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZUlucHV0JywgdGhpcy5oYW5kbGVJbnB1dC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gV2hlbiB0aGUgZWRpdG9yIGxvc2VzIGZvY3VzLCBjaGVjayBpZiB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIHZpc2libGVcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdibHVyJywgdGhpcy5oYW5kbGVCbHVyLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBOZWVkIHRvIGtub3cgd2hlbiBlbGVtZW50cyBhcmUgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBlZGl0b3JcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdhZGRFbGVtZW50JywgdGhpcy5oYW5kbGVBZGRFbGVtZW50LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ3JlbW92ZUVsZW1lbnQnLCB0aGlzLmhhbmRsZVJlbW92ZUVsZW1lbnQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlSW5wdXQ6IGZ1bmN0aW9uIChldmVudCwgZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSBoaWRkZW4gb24gZm9jdXMgYW5kIHRoZVxuICAgICAgICAgICAgLy8gZWxlbWVudCBoYXMgZm9jdXMsIGRvbid0IHNob3cgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICB2YXIgZG9udFNob3cgPSB0aGlzLmhpZGVPbkNsaWNrICYmIChlbGVtZW50ID09PSB0aGlzLmJhc2UuZ2V0Rm9jdXNlZEVsZW1lbnQoKSk7XG5cbiAgICAgICAgICAgIC8vIEVkaXRvcidzIGNvbnRlbnQgaGFzIGNoYW5nZWQsIGNoZWNrIGlmIHRoZSBwbGFjZWhvbGRlciBzaG91bGQgYmUgaGlkZGVuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBsYWNlaG9sZGVyKGVsZW1lbnQsIGRvbnRTaG93KTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVGb2N1czogZnVuY3Rpb24gKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBFZGl0b3IgaGFzIGZvY3VzLCBoaWRlIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgdGhpcy5oaWRlUGxhY2Vob2xkZXIoZWxlbWVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlQmx1cjogZnVuY3Rpb24gKGV2ZW50LCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBFZGl0b3IgaGFzIGxvc3QgZm9jdXMsIGNoZWNrIGlmIHRoZSBwbGFjZWhvbGRlciBzaG91bGQgYmUgc2hvd25cbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGxhY2Vob2xkZXIoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLnBsYWNlaG9sZGVyID0gUGxhY2Vob2xkZXI7XG59KCkpO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBUb29sYmFyID0gTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5leHRlbmQoe1xuICAgICAgICBuYW1lOiAndG9vbGJhcicsXG5cbiAgICAgICAgLyogVG9vbGJhciBPcHRpb25zICovXG5cbiAgICAgICAgLyogYWxpZ246IFsnbGVmdCd8J2NlbnRlcid8J3JpZ2h0J11cbiAgICAgICAgICogV2hlbiB0aGUgX19zdGF0aWNfXyBvcHRpb24gaXMgdHJ1ZSwgdGhpcyBhbGlnbnMgdGhlIHN0YXRpYyB0b29sYmFyXG4gICAgICAgICAqIHJlbGF0aXZlIHRvIHRoZSBtZWRpdW0tZWRpdG9yIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG5cbiAgICAgICAgLyogYWxsb3dNdWx0aVBhcmFncmFwaFNlbGVjdGlvbjogW2Jvb2xlYW5dXG4gICAgICAgICAqIGVuYWJsZXMvZGlzYWJsZXMgd2hldGhlciB0aGUgdG9vbGJhciBzaG91bGQgYmUgZGlzcGxheWVkIHdoZW5cbiAgICAgICAgICogc2VsZWN0aW5nIG11bHRpcGxlIHBhcmFncmFwaHMvYmxvY2sgZWxlbWVudHNcbiAgICAgICAgICovXG4gICAgICAgIGFsbG93TXVsdGlQYXJhZ3JhcGhTZWxlY3Rpb246IHRydWUsXG5cbiAgICAgICAgLyogYnV0dG9uczogW0FycmF5XVxuICAgICAgICAgKiB0aGUgbmFtZXMgb2YgdGhlIHNldCBvZiBidXR0b25zIHRvIGRpc3BsYXkgb24gdGhlIHRvb2xiYXIuXG4gICAgICAgICAqL1xuICAgICAgICBidXR0b25zOiBbJ2JvbGQnLCAnaXRhbGljJywgJ3VuZGVybGluZScsICdhbmNob3InLCAnaDInLCAnaDMnLCAncXVvdGUnXSxcblxuICAgICAgICAvKiBkaWZmTGVmdDogW051bWJlcl1cbiAgICAgICAgICogdmFsdWUgaW4gcGl4ZWxzIHRvIGJlIGFkZGVkIHRvIHRoZSBYIGF4aXMgcG9zaXRpb25pbmcgb2YgdGhlIHRvb2xiYXIuXG4gICAgICAgICAqL1xuICAgICAgICBkaWZmTGVmdDogMCxcblxuICAgICAgICAvKiBkaWZmVG9wOiBbTnVtYmVyXVxuICAgICAgICAgKiB2YWx1ZSBpbiBwaXhlbHMgdG8gYmUgYWRkZWQgdG8gdGhlIFkgYXhpcyBwb3NpdGlvbmluZyBvZiB0aGUgdG9vbGJhci5cbiAgICAgICAgICovXG4gICAgICAgIGRpZmZUb3A6IC0xMCxcblxuICAgICAgICAvKiBmaXJzdEJ1dHRvbkNsYXNzOiBbc3RyaW5nXVxuICAgICAgICAgKiBDU1MgY2xhc3MgYWRkZWQgdG8gdGhlIGZpcnN0IGJ1dHRvbiBpbiB0aGUgdG9vbGJhci5cbiAgICAgICAgICovXG4gICAgICAgIGZpcnN0QnV0dG9uQ2xhc3M6ICdtZWRpdW0tZWRpdG9yLWJ1dHRvbi1maXJzdCcsXG5cbiAgICAgICAgLyogbGFzdEJ1dHRvbkNsYXNzOiBbc3RyaW5nXVxuICAgICAgICAgKiBDU1MgY2xhc3MgYWRkZWQgdG8gdGhlIGxhc3QgYnV0dG9uIGluIHRoZSB0b29sYmFyLlxuICAgICAgICAgKi9cbiAgICAgICAgbGFzdEJ1dHRvbkNsYXNzOiAnbWVkaXVtLWVkaXRvci1idXR0b24tbGFzdCcsXG5cbiAgICAgICAgLyogc3RhbmRhcmRpemVTZWxlY3Rpb25TdGFydDogW2Jvb2xlYW5dXG4gICAgICAgICAqIGVuYWJsZXMvZGlzYWJsZXMgc3RhbmRhcmRpemluZyBob3cgdGhlIGJlZ2lubmluZyBvZiBhIHJhbmdlIGlzIGRlY2lkZWRcbiAgICAgICAgICogYmV0d2VlbiBicm93c2VycyB3aGVuZXZlciB0aGUgc2VsZWN0ZWQgdGV4dCBpcyBhbmFseXplZCBmb3IgdXBkYXRpbmcgdG9vbGJhciBidXR0b25zIHN0YXR1cy5cbiAgICAgICAgICovXG4gICAgICAgIHN0YW5kYXJkaXplU2VsZWN0aW9uU3RhcnQ6IGZhbHNlLFxuXG4gICAgICAgIC8qIHN0YXRpYzogW2Jvb2xlYW5dXG4gICAgICAgICAqIGVuYWJsZS9kaXNhYmxlIHRoZSB0b29sYmFyIGFsd2F5cyBkaXNwbGF5aW5nIGluIHRoZSBzYW1lIGxvY2F0aW9uXG4gICAgICAgICAqIHJlbGF0aXZlIHRvIHRoZSBtZWRpdW0tZWRpdG9yIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWM6IGZhbHNlLFxuXG4gICAgICAgIC8qIHN0aWNreTogW2Jvb2xlYW5dXG4gICAgICAgICAqIFdoZW4gdGhlIF9fc3RhdGljX18gb3B0aW9uIGlzIHRydWUsIHRoaXMgZW5hYmxlcy9kaXNhYmxlcyB0aGUgdG9vbGJhclxuICAgICAgICAgKiBcInN0aWNraW5nXCIgdG8gdGhlIHZpZXdwb3J0IGFuZCBzdGF5aW5nIHZpc2libGUgb24gdGhlIHNjcmVlbiB3aGlsZVxuICAgICAgICAgKiB0aGUgcGFnZSBzY3JvbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RpY2t5OiBmYWxzZSxcblxuICAgICAgICAvKiBzdGlja3lUb3BPZmZzZXQ6IFtOdW1iZXJdXG4gICAgICAgICAqIFZhbHVlIGluIHBpeGVsIG9mIHRoZSB0b3Agb2Zmc2V0IGFib3ZlIHRoZSB0b29sYmFyXG4gICAgICAgICAqL1xuICAgICAgICBzdGlja3lUb3BPZmZzZXQ6IDAsXG5cbiAgICAgICAgLyogdXBkYXRlT25FbXB0eVNlbGVjdGlvbjogW2Jvb2xlYW5dXG4gICAgICAgICAqIFdoZW4gdGhlIF9fc3RhdGljX18gb3B0aW9uIGlzIHRydWUsIHRoaXMgZW5hYmxlcy9kaXNhYmxlcyB1cGRhdGluZ1xuICAgICAgICAgKiB0aGUgc3RhdGUgb2YgdGhlIHRvb2xiYXIgYnV0dG9ucyBldmVuIHdoZW4gdGhlIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWRcbiAgICAgICAgICogKHRoZXJlIGlzIG5vIHNlbGVjdGlvbiwganVzdCBhIGN1cnNvcikuXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVPbkVtcHR5U2VsZWN0aW9uOiBmYWxzZSxcblxuICAgICAgICAvKiByZWxhdGl2ZUNvbnRhaW5lcjogW25vZGVdXG4gICAgICAgICAqIGFwcGVuZGluZyB0aGUgdG9vbGJhciB0byBhIGdpdmVuIG5vZGUgaW5zdGVhZCBvZiBib2R5XG4gICAgICAgICAqL1xuICAgICAgICByZWxhdGl2ZUNvbnRhaW5lcjogbnVsbCxcblxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IuRXh0ZW5zaW9uLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdFRocm90dGxlZE1ldGhvZHMoKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFZGl0b3JPcHRpb24oJ2VsZW1lbnRzQ29udGFpbmVyJykuYXBwZW5kQ2hpbGQodGhpcy5nZXRUb29sYmFyRWxlbWVudCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmdldFRvb2xiYXJFbGVtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEhlbHBlciBtZXRob2QgdG8gZXhlY3V0ZSBtZXRob2QgZm9yIGV2ZXJ5IGV4dGVuc2lvbiwgYnV0IGlnbm9yaW5nIHRoZSB0b29sYmFyIGV4dGVuc2lvblxuICAgICAgICBmb3JFYWNoRXh0ZW5zaW9uOiBmdW5jdGlvbiAoaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2UuZXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlcmF0b3IuYXBwbHkoY29udGV4dCB8fCB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVG9vbGJhciBjcmVhdGlvbi9kZWxldGlvblxuXG4gICAgICAgIGNyZWF0ZVRvb2xiYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b29sYmFyID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgdG9vbGJhci5pZCA9ICdtZWRpdW0tZWRpdG9yLXRvb2xiYXItJyArIHRoaXMuZ2V0RWRpdG9ySWQoKTtcbiAgICAgICAgICAgIHRvb2xiYXIuY2xhc3NOYW1lID0gJ21lZGl1bS1lZGl0b3ItdG9vbGJhcic7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRpYykge1xuICAgICAgICAgICAgICAgIHRvb2xiYXIuY2xhc3NOYW1lICs9ICcgc3RhdGljLXRvb2xiYXInO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlbGF0aXZlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhci5jbGFzc05hbWUgKz0gJyBtZWRpdW0tZWRpdG9yLXJlbGF0aXZlLXRvb2xiYXInO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b29sYmFyLmNsYXNzTmFtZSArPSAnIG1lZGl1bS1lZGl0b3Itc3RhbGtlci10b29sYmFyJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZVRvb2xiYXJCdXR0b25zKCkpO1xuXG4gICAgICAgICAgICAvLyBBZGQgYW55IGZvcm1zIHRoYXQgZXh0ZW5zaW9ucyBtYXkgaGF2ZVxuICAgICAgICAgICAgdGhpcy5mb3JFYWNoRXh0ZW5zaW9uKGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmhhc0Zvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZChleHRlbnNpb24uZ2V0Rm9ybSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0b29sYmFyO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVRvb2xiYXJCdXR0b25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdWwgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyksXG4gICAgICAgICAgICAgICAgbGksXG4gICAgICAgICAgICAgICAgYnRuLFxuICAgICAgICAgICAgICAgIGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgIGJ1dHRvbk5hbWUsXG4gICAgICAgICAgICAgICAgYnV0dG9uT3B0cztcblxuICAgICAgICAgICAgdWwuaWQgPSAnbWVkaXVtLWVkaXRvci10b29sYmFyLWFjdGlvbnMnICsgdGhpcy5nZXRFZGl0b3JJZCgpO1xuICAgICAgICAgICAgdWwuY2xhc3NOYW1lID0gJ21lZGl1bS1lZGl0b3ItdG9vbGJhci1hY3Rpb25zJztcbiAgICAgICAgICAgIHVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMuZm9yRWFjaChmdW5jdGlvbiAoYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbk5hbWUgPSBidXR0b247XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbk9wdHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbk5hbWUgPSBidXR0b24ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uT3B0cyA9IGJ1dHRvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYnV0dG9uIGFscmVhZHkgZXhpc3RzIGFzIGFuIGV4dGVuc2lvbiwgaXQnbGwgYmUgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAvLyBvdGh3ZXJpc2UgaXQnbGwgY3JlYXRlIHRoZSBkZWZhdWx0IGJ1aWx0LWluIGJ1dHRvblxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IHRoaXMuYmFzZS5hZGRCdWlsdEluRXh0ZW5zaW9uKGJ1dHRvbk5hbWUsIGJ1dHRvbk9wdHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbiAmJiB0eXBlb2YgZXh0ZW5zaW9uLmdldEJ1dHRvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBidG4gPSBleHRlbnNpb24uZ2V0QnV0dG9uKHRoaXMuYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgIGxpID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNFbGVtZW50KGJ0bikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpLmFwcGVuZENoaWxkKGJ0bik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaS5pbm5lckhUTUwgPSBidG47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBidXR0b25zID0gdWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uJyk7XG4gICAgICAgICAgICBpZiAoYnV0dG9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uc1swXS5jbGFzc0xpc3QuYWRkKHRoaXMuZmlyc3RCdXR0b25DbGFzcyk7XG4gICAgICAgICAgICAgICAgYnV0dG9uc1tidXR0b25zLmxlbmd0aCAtIDFdLmNsYXNzTGlzdC5hZGQodGhpcy5sYXN0QnV0dG9uQ2xhc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdWw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9vbGJhcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvb2xiYXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnRvb2xiYXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy50b29sYmFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRvb2xiYXIgYWNjZXNzb3JzXG5cbiAgICAgICAgZ2V0SW50ZXJhY3Rpb25FbGVtZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUb29sYmFyRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRvb2xiYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xiYXIgPSB0aGlzLmNyZWF0ZVRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9vbGJhcjtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRUb29sYmFyQWN0aW9uc0VsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRvb2xiYXJFbGVtZW50KCkucXVlcnlTZWxlY3RvcignLm1lZGl1bS1lZGl0b3ItdG9vbGJhci1hY3Rpb25zJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gVG9vbGJhciBldmVudCBoYW5kbGVyc1xuXG4gICAgICAgIGluaXRUaHJvdHRsZWRNZXRob2RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyB0aHJvdHRsZWRQb3NpdGlvblRvb2xiYXIgaXMgdGhyb3R0bGVkIGJlY2F1c2U6XG4gICAgICAgICAgICAvLyAtIEl0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGJyb3dzZXIgaXMgcmVzaXppbmcsIHdoaWNoIGNhbiBmaXJlIG1hbnkgdGltZXMgdmVyeSBxdWlja2x5XG4gICAgICAgICAgICAvLyAtIEZvciBzb21lIGV2ZW50IChsaWtlIHJlc2l6ZSkgYSBzbGlnaHQgbGFnIGluIFVJIHJlc3BvbnNpdmVuZXNzIGlzIE9LIGFuZCBwcm92aWRlcyBwZXJmb3JtYW5jZSBiZW5lZml0c1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWRQb3NpdGlvblRvb2xiYXIgPSBNZWRpdW1FZGl0b3IudXRpbC50aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFzZS5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uVG9vbGJhcklmU2hvd24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGF0dGFjaEV2ZW50SGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE1lZGl1bUVkaXRvciBjdXN0b20gZXZlbnRzIGZvciB3aGVuIHVzZXIgYmVpbmdzIGFuZCBlbmRzIGludGVyYWN0aW9uIHdpdGggYSBjb250ZW50ZWRpdGFibGUgYW5kIGl0cyBlbGVtZW50c1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2JsdXInLCB0aGlzLmhhbmRsZUJsdXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZm9jdXMnLCB0aGlzLmhhbmRsZUZvY3VzLmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGluZyB0aGUgc3RhdGUgb2YgdGhlIHRvb2xiYXIgYXMgdGhpbmdzIGNoYW5nZVxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlQ2xpY2snLCB0aGlzLmhhbmRsZUVkaXRhYmxlQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXl1cCcsIHRoaXMuaGFuZGxlRWRpdGFibGVLZXl1cC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgLy8gSGFuZGxlIG1vdXNldXAgb24gZG9jdW1lbnQgZm9yIHVwZGF0aW5nIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIHRoaXMub24odGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICdtb3VzZXVwJywgdGhpcy5oYW5kbGVEb2N1bWVudE1vdXNldXAuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhIHNjcm9sbCBldmVudCBmb3Igc3RpY2t5IHRvb2xiYXJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRpYyAmJiB0aGlzLnN0aWNreSkge1xuICAgICAgICAgICAgICAgIC8vIE9uIHNjcm9sbCAoY2FwdHVyZSksIHJlLXBvc2l0aW9uIHRoZSB0b29sYmFyXG4gICAgICAgICAgICAgICAgdGhpcy5vbih0aGlzLndpbmRvdywgJ3Njcm9sbCcsIHRoaXMuaGFuZGxlV2luZG93U2Nyb2xsLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbiByZXNpemUsIHJlLXBvc2l0aW9uIHRoZSB0b29sYmFyXG4gICAgICAgICAgICB0aGlzLm9uKHRoaXMud2luZG93LCAncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlV2luZG93U2Nyb2xsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uVG9vbGJhcklmU2hvd24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVXaW5kb3dSZXNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkUG9zaXRpb25Ub29sYmFyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGFuZGxlRG9jdW1lbnRNb3VzZXVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIERvIG5vdCB0cmlnZ2VyIGNoZWNrU3RhdGUgd2hlbiBtb3VzZXVwIGZpcmVzIG92ZXIgdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIGlmIChldmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuaXNEZXNjZW5kYW50KHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKSwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZUVkaXRhYmxlQ2xpY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIERlbGF5IHRoZSBjYWxsIHRvIGNoZWNrU3RhdGUgdG8gaGFuZGxlIGJ1ZyB3aGVyZSBzZWxlY3Rpb24gaXMgZW1wdHlcbiAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IGFmdGVyIGNsaWNraW5nIGluc2lkZSBhIHByZS1leGlzdGluZyBzZWxlY3Rpb25cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0ZSgpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVFZGl0YWJsZUtleXVwOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU3RhdGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVCbHVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBLaWxsIGFueSBwcmV2aW91c2x5IGRlbGF5ZWQgY2FsbHMgdG8gaGlkZSB0aGUgdG9vbGJhclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBCbHVyIG1heSBmaXJlIGV2ZW4gaWYgd2UgaGF2ZSBhIHNlbGVjdGlvbiwgc28gd2Ugd2FudCB0byBwcmV2ZW50IGFueSBkZWxheWVkIHNob3dUb29sYmFyXG4gICAgICAgICAgICAvLyBjYWxscyBmcm9tIGhhcHBlbmluZyBpbiB0aGlzIHNwZWNpZmljIGNhc2VcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlbGF5U2hvd1RpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBEZWxheSB0aGUgY2FsbCB0byBoaWRlVG9vbGJhciB0byBoYW5kbGUgYnVnIHdpdGggbXVsdGlwbGUgZWRpdG9ycyBvbiB0aGUgcGFnZSBhdCBvbmNlXG4gICAgICAgICAgICB0aGlzLmhpZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlVG9vbGJhcigpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAxKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVGb2N1czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1N0YXRlKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gSGlkaW5nL3Nob3dpbmcgdG9vbGJhclxuXG4gICAgICAgIGlzRGlzcGxheWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb29sYmFyRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucygnbWVkaXVtLWVkaXRvci10b29sYmFyLWFjdGl2ZScpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3dUb29sYmFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZW91dCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tZWRpdG9yLXRvb2xiYXItYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93VG9vbGJhcicsIHt9LCB0aGlzLmJhc2UuZ2V0Rm9jdXNlZEVsZW1lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZVRvb2xiYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRvb2xiYXJFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci10b29sYmFyLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignaGlkZVRvb2xiYXInLCB7fSwgdGhpcy5iYXNlLmdldEZvY3VzZWRFbGVtZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGlzVG9vbGJhckRlZmF1bHRBY3Rpb25zRGlzcGxheWVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb29sYmFyQWN0aW9uc0VsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID09PSAnYmxvY2snO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGVUb29sYmFyRGVmYXVsdEFjdGlvbnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG9vbGJhckRlZmF1bHRBY3Rpb25zRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRvb2xiYXJBY3Rpb25zRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd1Rvb2xiYXJEZWZhdWx0QWN0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlRXh0ZW5zaW9uRm9ybXMoKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9vbGJhckRlZmF1bHRBY3Rpb25zRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFRvb2xiYXJBY3Rpb25zRWxlbWVudCgpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2luZyBzZXRUaW1lb3V0ICsgb3B0aW9ucy5kZWxheSBiZWNhdXNlOlxuICAgICAgICAgICAgLy8gV2Ugd2lsbCBhY3R1YWxseSBiZSBkaXNwbGF5aW5nIHRoZSB0b29sYmFyLCB3aGljaCBzaG91bGQgYmUgY29udHJvbGxlZCBieSBvcHRpb25zLmRlbGF5XG4gICAgICAgICAgICB0aGlzLmRlbGF5U2hvd1RpbWVvdXQgPSB0aGlzLmJhc2UuZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2xiYXIoKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaGlkZUV4dGVuc2lvbkZvcm1zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBIaWRlIGFsbCBleHRlbnNpb24gZm9ybXNcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaEV4dGVuc2lvbihmdW5jdGlvbiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5oYXNGb3JtICYmIGV4dGVuc2lvbi5pc0Rpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi5oaWRlRm9ybSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFJlc3BvbmRpbmcgdG8gY2hhbmdlcyBpbiB1c2VyIHNlbGVjdGlvblxuXG4gICAgICAgIC8vIENoZWNrcyBmb3IgZXhpc3RhbmNlIG9mIG11bHRpcGxlIGJsb2NrIGVsZW1lbnRzIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICBtdWx0aXBsZUJsb2NrRWxlbWVudHNTZWxlY3RlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlZ2V4RW1wdHlIVE1MVGFncyA9IC88W15cXC8+XVtePl0qPjxcXC9bXj5dKz4vZ2ltLCAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzMxMjk3MzgvcmVtb3ZlLWVtcHR5LXRhZ3MtdXNpbmctcmVnZXhcbiAgICAgICAgICAgICAgICByZWdleEJsb2NrRWxlbWVudHMgPSBuZXcgUmVnRXhwKCc8KCcgKyBNZWRpdW1FZGl0b3IudXRpbC5ibG9ja0NvbnRhaW5lckVsZW1lbnROYW1lcy5qb2luKCd8JykgKyAnKVtePl0qPicsICdnJyksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSFRNTCA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uSHRtbCh0aGlzLmRvY3VtZW50KS5yZXBsYWNlKHJlZ2V4RW1wdHlIVE1MVGFncywgJycpLCAvLyBGaWx0ZXIgb3V0IGVtcHR5IGJsb2NrcyBmcm9tIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGhhc011bHRpUGFyYWdyYXBocyA9IHNlbGVjdGlvbkhUTUwubWF0Y2gocmVnZXhCbG9ja0VsZW1lbnRzKTsgLy8gRmluZCBob3cgbWFueSBibG9jayBlbGVtZW50cyBhcmUgd2l0aGluIHRoZSBodG1sXG5cbiAgICAgICAgICAgIHJldHVybiAhIWhhc011bHRpUGFyYWdyYXBocyAmJiBoYXNNdWx0aVBhcmFncmFwaHMubGVuZ3RoID4gMTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb2RpZnlTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLndpbmRvdy5nZXRTZWxlY3Rpb24oKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiBJbiBmaXJlZm94LCB0aGVyZSBhcmUgY2FzZXMgKGllIGRvdWJsZWNsaWNrIG9mIGEgd29yZCkgd2hlcmUgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0XG4gICAgICAgICAgICAqIHdpbGwgYmUgYXQgdGhlIHZlcnkgZW5kIG9mIGFuIGVsZW1lbnQuICBJbiBvdGhlciBicm93c2VycywgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0XG4gICAgICAgICAgICAqIHdvdWxkIGluc3RlYWQgYmUgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIGFuIGVsZW1lbnQgdGhhdCBhY3R1YWxseSBoYXMgY29udGVudC5cbiAgICAgICAgICAgICogZXhhbXBsZTpcbiAgICAgICAgICAgICogICA8c3Bhbj5mb288L3NwYW4+PHNwYW4+YmFyPC9zcGFuPlxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiBJZiB0aGUgdGV4dCAnYmFyJyBpcyBzZWxlY3RlZCwgbW9zdCBicm93c2VycyB3aWxsIGhhdmUgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgICAgICogb2YgdGhlICdiYXInIHNwYW4uICBIb3dldmVyLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgZmlyZWZveCB3aWxsIGhhdmUgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0XG4gICAgICAgICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlICdmb28nIHNwYW4uICBUaGUgY29udGVudGVkaXRhYmxlIGJlaGF2aW9yIHdpbGwgYmUgb2ssIGJ1dCBpZiB0aGVyZSBhcmUgYW55XG4gICAgICAgICAgICAqIHByb3BlcnRpZXMgb24gdGhlICdiYXInIHNwYW4sIHRoZXkgd29uJ3QgYmUgcmVmbGVjdGVkIGFjY3VyYXRlbHkgaW4gdGhlIHRvb2xiYXJcbiAgICAgICAgICAgICogKGllICdCb2xkJyBidXR0b24gd291bGRuJ3QgYmUgYWN0aXZlKVxuICAgICAgICAgICAgKlxuICAgICAgICAgICAgKiBTbywgZm9yIGNhc2VzIHdoZXJlIHRoZSBzZWxlY3Rpb25SYW5nZSBzdGFydCBpcyBhdCB0aGUgZW5kIG9mIGFuIGVsZW1lbnQvbm9kZSwgZmluZCB0aGUgbmV4dFxuICAgICAgICAgICAgKiBhZGphY2VudCB0ZXh0IG5vZGUgdGhhdCBhY3R1YWxseSBoYXMgY29udGVudCBpbiBpdCwgYW5kIG1vdmUgdGhlIHNlbGVjdGlvblJhbmdlIHN0YXJ0IHRoZXJlLlxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YW5kYXJkaXplU2VsZWN0aW9uU3RhcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIChzZWxlY3Rpb25SYW5nZS5zdGFydE9mZnNldCA9PT0gc2VsZWN0aW9uUmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVZhbHVlLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRqYWNlbnROb2RlID0gTWVkaXVtRWRpdG9yLnV0aWwuZmluZEFkamFjZW50VGV4dE5vZGVXaXRoQ29udGVudChNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkVsZW1lbnQodGhpcy53aW5kb3cpLCBzZWxlY3Rpb25SYW5nZS5zdGFydENvbnRhaW5lciwgdGhpcy5kb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGFkamFjZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFkamFjZW50Tm9kZS5ub2RlVmFsdWUuc3Vic3RyKG9mZnNldCwgMSkudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uc2VsZWN0KHRoaXMuZG9jdW1lbnQsIGFkamFjZW50Tm9kZSwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UuZW5kQ29udGFpbmVyLCBzZWxlY3Rpb25SYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBjaGVja1N0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlLnByZXZlbnRTZWxlY3Rpb25VcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBlZGl0YWJsZSBoYXMgZm9jdXMgT1Igc2VsZWN0aW9uIGlzIGluc2lkZSBjb250ZW50ZWRpdGFibGUgPSBmYWxzZVxuICAgICAgICAgICAgLy8gaGlkZSB0b29sYmFyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYmFzZS5nZXRGb2N1c2VkRWxlbWVudCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uc2VsZWN0aW9uSW5Db250ZW50RWRpdGFibGVGYWxzZSh0aGlzLndpbmRvdykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHNlbGVjdGlvbiBlbGVtZW50LCBzZWxlY3Rpb24gZWxlbWVudCBkb2Vzbid0IGJlbG9uZyB0byB0aGlzIGVkaXRvclxuICAgICAgICAgICAgLy8gb3IgdG9vbGJhciBpcyBkaXNhYmxlZCBmb3IgdGhpcyBzZWxlY3Rpb24gZWxlbWVudFxuICAgICAgICAgICAgLy8gaGlkZSB0b29sYmFyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRWxlbWVudCA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uRWxlbWVudCh0aGlzLndpbmRvdyk7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbkVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRFZGl0b3JFbGVtZW50cygpLmluZGV4T2Yoc2VsZWN0aW9uRWxlbWVudCkgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbkVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc2FibGUtdG9vbGJhcicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZVRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHdlIGtub3cgdGhlcmUncyBhIGZvY3VzZWQgZWRpdGFibGUgd2l0aCBhIHNlbGVjdGlvblxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdXBkYXRlT25FbXB0eVNlbGVjdGlvbiBvcHRpb24gaXMgdHJ1ZSwgc2hvdyB0aGUgdG9vbGJhclxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlT25FbXB0eVNlbGVjdGlvbiAmJiB0aGlzLnN0YXRpYykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dBbmRVcGRhdGVUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSAndmFsaWQnIHNlbGVjdGlvbiAtPiBoaWRlIHRvb2xiYXJcbiAgICAgICAgICAgIGlmICghTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5zZWxlY3Rpb25Db250YWluc0NvbnRlbnQodGhpcy5kb2N1bWVudCkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5hbGxvd011bHRpUGFyYWdyYXBoU2VsZWN0aW9uID09PSBmYWxzZSAmJiB0aGlzLm11bHRpcGxlQmxvY2tFbGVtZW50c1NlbGVjdGVkKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZVRvb2xiYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zaG93QW5kVXBkYXRlVG9vbGJhcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFVwZGF0aW5nIHRoZSB0b29sYmFyXG5cbiAgICAgICAgc2hvd0FuZFVwZGF0ZVRvb2xiYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubW9kaWZ5U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnNldFRvb2xiYXJCdXR0b25TdGF0ZXMoKTtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncG9zaXRpb25Ub29sYmFyJywge30sIHRoaXMuYmFzZS5nZXRGb2N1c2VkRWxlbWVudCgpKTtcbiAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2xiYXJEZWZhdWx0QWN0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5zZXRUb29sYmFyUG9zaXRpb24oKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRUb29sYmFyQnV0dG9uU3RhdGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmZvckVhY2hFeHRlbnNpb24oZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmlzQWN0aXZlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBleHRlbnNpb24uc2V0SW5hY3RpdmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLnNldEluYWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tBY3RpdmVCdXR0b25zKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hlY2tBY3RpdmVCdXR0b25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWFudWFsU3RhdGVDaGVja3MgPSBbXSxcbiAgICAgICAgICAgICAgICBxdWVyeVN0YXRlID0gbnVsbCxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25SYW5nZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5kb2N1bWVudCksXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICB1cGRhdGVFeHRlbnNpb25TdGF0ZSA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24uY2hlY2tTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLmNoZWNrU3RhdGUocGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4dGVuc2lvbi5pc0FjdGl2ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBleHRlbnNpb24uaXNBbHJlYWR5QXBwbGllZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBleHRlbnNpb24uc2V0QWN0aXZlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4dGVuc2lvbi5pc0FjdGl2ZSgpICYmIGV4dGVuc2lvbi5pc0FscmVhZHlBcHBsaWVkKHBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLnNldEFjdGl2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBleHRlbnNpb25zXG4gICAgICAgICAgICB0aGlzLmZvckVhY2hFeHRlbnNpb24oZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIC8vIEZvciB0aG9zZSBleHRlbnNpb25zIHdoZXJlIHdlIGNhbiB1c2UgZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUoKSwgZG8gc29cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVuc2lvbi5xdWVyeUNvbW1hbmRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeVN0YXRlID0gZXh0ZW5zaW9uLnF1ZXJ5Q29tbWFuZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHF1ZXJ5Q29tbWFuZFN0YXRlIHJldHVybnMgYSB2YWxpZCB2YWx1ZSwgd2UgY2FuIHRydXN0IHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBkb24ndCBuZWVkIHRvIGRvIG91ciBtYW51YWwgY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWVyeVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlTdGF0ZSAmJiB0eXBlb2YgZXh0ZW5zaW9uLnNldEFjdGl2ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi5zZXRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCB1c2UgcXVlcnlDb21tYW5kU3RhdGUgZm9yIHRoaXMgZXh0ZW5zaW9uLCBzbyBhZGQgdG8gbWFudWFsU3RhdGVDaGVja3NcbiAgICAgICAgICAgICAgICBtYW51YWxTdGF0ZUNoZWNrcy5wdXNoKGV4dGVuc2lvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWRQYXJlbnRFbGVtZW50KHNlbGVjdGlvblJhbmdlKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gcGFyZW50IGlzbid0IG91dHNpZGUgb2YgdGhlIGNvbnRlbnRlZGl0YWJsZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldEVkaXRvckVsZW1lbnRzKCkuc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWVkaXVtRWRpdG9yLnV0aWwuaXNEZXNjZW5kYW50KGVsZW1lbnQsIHBhcmVudE5vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGltYiB1cCB0aGUgRE9NIGFuZCBkbyBtYW51YWwgY2hlY2tzIGZvciB3aGV0aGVyIGEgY2VydGFpbiBleHRlbnNpb24gaXMgY3VycmVudGx5IGVuYWJsZWQgZm9yIHRoaXMgbm9kZVxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBtYW51YWxTdGF0ZUNoZWNrcy5mb3JFYWNoKHVwZGF0ZUV4dGVuc2lvblN0YXRlKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBhYm9ydCB0aGUgc2VhcmNoIHVwd2FyZHMgaWYgd2UgbGVhdmUgdGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKE1lZGl1bUVkaXRvci51dGlsLmlzTWVkaXVtRWRpdG9yRWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBQb3NpdGlvbmluZyB0b29sYmFyXG5cbiAgICAgICAgcG9zaXRpb25Ub29sYmFySWZTaG93bjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VG9vbGJhclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0VG9vbGJhclBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5iYXNlLmdldEZvY3VzZWRFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy53aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzbid0IGEgdmFsaWQgc2VsZWN0aW9uLCBiYWlsXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0aWMgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1Rvb2xiYXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgYW55IGFic29sdXRlIHBvc2l0aW9uaW5nIGlmIHJlbGF0aXZlQ29udGFpbmVyIGlzIHNldFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZWxhdGl2ZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb25TdGF0aWNUb29sYmFyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uVG9vbGJhcihzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdwb3NpdGlvbmVkVG9vbGJhcicsIHt9LCB0aGlzLmJhc2UuZ2V0Rm9jdXNlZEVsZW1lbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpb25TdGF0aWNUb29sYmFyOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgdG9vbGJhciBhdCBsZWZ0IDAsIHNvIHdlIGNhbiBnZXQgdGhlIHJlYWwgd2lkdGggb2YgdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKS5zdHlsZS5sZWZ0ID0gJzAnO1xuXG4gICAgICAgICAgICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgZm9yIElFIDlcbiAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSAodGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSB8fCB0aGlzLmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIHdpbmRvd1dpZHRoID0gdGhpcy53aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudCA9IHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lclRvcCA9IGNvbnRhaW5lclJlY3QudG9wICsgc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckNlbnRlciA9IChjb250YWluZXJSZWN0LmxlZnQgKyAoY29udGFpbmVyUmVjdC53aWR0aCAvIDIpKSxcbiAgICAgICAgICAgICAgICB0b29sYmFySGVpZ2h0ID0gdG9vbGJhckVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHRvb2xiYXJXaWR0aCA9IHRvb2xiYXJFbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICAgIGhhbGZPZmZzZXRXaWR0aCA9IHRvb2xiYXJXaWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0TGVmdDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RpY2t5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBiZXlvbmQgdGhlIGhlaWdodCBvZiB0aGUgZWRpdG9yLCBwb3NpdGlvbiBpdCBhdCB0aGUgYm90dG9tIG9mIHRoZSBlZGl0b3JcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsVG9wID4gKGNvbnRhaW5lclRvcCArIGNvbnRhaW5lci5vZmZzZXRIZWlnaHQgLSB0b29sYmFySGVpZ2h0IC0gdGhpcy5zdGlja3lUb3BPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IChjb250YWluZXJUb3AgKyBjb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gdG9vbGJhckhlaWdodCkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tZWRpdG9yLXN0aWNreS10b29sYmFyJyk7XG4gICAgICAgICAgICAgICAgLy8gU3RpY2sgdGhlIHRvb2xiYXIgdG8gdGhlIHRvcCBvZiB0aGUgd2luZG93XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxUb3AgPiAoY29udGFpbmVyVG9wIC0gdG9vbGJhckhlaWdodCAtIHRoaXMuc3RpY2t5VG9wT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tZWRpdG9yLXN0aWNreS10b29sYmFyJyk7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IHRoaXMuc3RpY2t5VG9wT2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAvLyBOb3JtYWwgc3RhdGljIHRvb2xiYXIgcG9zaXRpb25cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tZWRpdG9yLXN0aWNreS10b29sYmFyJyk7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IGNvbnRhaW5lclRvcCAtIHRvb2xiYXJIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuc3R5bGUudG9wID0gY29udGFpbmVyVG9wIC0gdG9vbGJhckhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5hbGlnbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRMZWZ0ID0gY29udGFpbmVyUmVjdC5sZWZ0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IGNvbnRhaW5lclJlY3QucmlnaHQgLSB0b29sYmFyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TGVmdCA9IGNvbnRhaW5lckNlbnRlciAtIGhhbGZPZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRMZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodGFyZ2V0TGVmdCArIHRvb2xiYXJXaWR0aCkgPiB3aW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRhcmdldExlZnQgPSAod2luZG93V2lkdGggLSBNYXRoLmNlaWwodG9vbGJhcldpZHRoKSAtIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0b29sYmFyRWxlbWVudC5zdHlsZS5sZWZ0ID0gdGFyZ2V0TGVmdCArICdweCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9zaXRpb25Ub29sYmFyOiBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyBwb3NpdGlvbiB0aGUgdG9vbGJhciBhdCBsZWZ0IDAsIHNvIHdlIGNhbiBnZXQgdGhlIHJlYWwgd2lkdGggb2YgdGhlIHRvb2xiYXJcbiAgICAgICAgICAgIHRoaXMuZ2V0VG9vbGJhckVsZW1lbnQoKS5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICAgICAgdGhpcy5nZXRUb29sYmFyRWxlbWVudCgpLnN0eWxlLnJpZ2h0ID0gJ2luaXRpYWwnO1xuXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKSxcbiAgICAgICAgICAgICAgICBib3VuZGFyeSA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgc2VsZWN0aW9ucyB3aXRoIGp1c3QgaW1hZ2VzXG4gICAgICAgICAgICBpZiAoIWJvdW5kYXJ5IHx8ICgoYm91bmRhcnkuaGVpZ2h0ID09PSAwICYmIGJvdW5kYXJ5LndpZHRoID09PSAwKSAmJiByYW5nZS5zdGFydENvbnRhaW5lciA9PT0gcmFuZ2UuZW5kQ29udGFpbmVyKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBuZXN0ZWQgaW1hZ2UsIHVzZSB0aGF0IGZvciB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIHJhbmdlLnN0YXJ0Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kYXJ5ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIucXVlcnlTZWxlY3RvcignaW1nJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmRhcnkgPSByYW5nZS5zdGFydENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB3aW5kb3dXaWR0aCA9IHRoaXMud2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgbWlkZGxlQm91bmRhcnkgPSAoYm91bmRhcnkubGVmdCArIGJvdW5kYXJ5LnJpZ2h0KSAvIDIsXG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQgPSB0aGlzLmdldFRvb2xiYXJFbGVtZW50KCksXG4gICAgICAgICAgICAgICAgdG9vbGJhckhlaWdodCA9IHRvb2xiYXJFbGVtZW50Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgICB0b29sYmFyV2lkdGggPSB0b29sYmFyRWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgICAgICBoYWxmT2Zmc2V0V2lkdGggPSB0b29sYmFyV2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIGJ1dHRvbkhlaWdodCA9IDUwLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMZWZ0ID0gdGhpcy5kaWZmTGVmdCAtIGhhbGZPZmZzZXRXaWR0aDtcblxuICAgICAgICAgICAgaWYgKGJvdW5kYXJ5LnRvcCA8IGJ1dHRvbkhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21lZGl1bS10b29sYmFyLWFycm93LW92ZXInKTtcbiAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdtZWRpdW0tdG9vbGJhci1hcnJvdy11bmRlcicpO1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IGJ1dHRvbkhlaWdodCArIGJvdW5kYXJ5LmJvdHRvbSAtIHRoaXMuZGlmZlRvcCArIHRoaXMud2luZG93LnBhZ2VZT2Zmc2V0IC0gdG9vbGJhckhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21lZGl1bS10b29sYmFyLWFycm93LXVuZGVyJyk7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLXRvb2xiYXItYXJyb3ctb3ZlcicpO1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLnRvcCA9IGJvdW5kYXJ5LnRvcCArIHRoaXMuZGlmZlRvcCArIHRoaXMud2luZG93LnBhZ2VZT2Zmc2V0IC0gdG9vbGJhckhlaWdodCArICdweCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaWRkbGVCb3VuZGFyeSA8IGhhbGZPZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLmxlZnQgPSBkZWZhdWx0TGVmdCArIGhhbGZPZmZzZXRXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuc3R5bGUucmlnaHQgPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh3aW5kb3dXaWR0aCAtIG1pZGRsZUJvdW5kYXJ5KSA8IGhhbGZPZmZzZXRXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRvb2xiYXJFbGVtZW50LnN0eWxlLmxlZnQgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuc3R5bGUucmlnaHQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b29sYmFyRWxlbWVudC5zdHlsZS5sZWZ0ID0gZGVmYXVsdExlZnQgKyBtaWRkbGVCb3VuZGFyeSArICdweCc7XG4gICAgICAgICAgICAgICAgdG9vbGJhckVsZW1lbnQuc3R5bGUucmlnaHQgPSAnaW5pdGlhbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLnRvb2xiYXIgPSBUb29sYmFyO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgSW1hZ2VEcmFnZ2luZyA9IE1lZGl1bUVkaXRvci5FeHRlbnNpb24uZXh0ZW5kKHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLkV4dGVuc2lvbi5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVEcmFnJywgdGhpcy5oYW5kbGVEcmFnLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlRHJvcCcsIHRoaXMuaGFuZGxlRHJvcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBoYW5kbGVEcmFnOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAnbWVkaXVtLWVkaXRvci1kcmFnb3Zlcic7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnY29weSc7XG5cbiAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAnZHJhZ292ZXInKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2RyYWdsZWF2ZScpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhhbmRsZURyb3A6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICdtZWRpdW0tZWRpdG9yLWRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgICBmaWxlcztcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgLy8gSUU5IGRvZXMgbm90IHN1cHBvcnQgdGhlIEZpbGUgQVBJLCBzbyBwcmV2ZW50IGZpbGUgZnJvbSBvcGVuaW5nIGluIGEgbmV3IHdpbmRvd1xuICAgICAgICAgICAgLy8gYnV0IGFsc28gZG9uJ3QgdHJ5IHRvIGFjdHVhbGx5IGdldCB0aGUgZmlsZVxuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlci5maWxlcykge1xuICAgICAgICAgICAgICAgIGZpbGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzLCAwKTtcbiAgICAgICAgICAgICAgICBmaWxlcy5zb21lKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlLnR5cGUubWF0Y2goJ2ltYWdlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlUmVhZGVyLCBpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9ICdtZWRpdW0taW1nLScgKyAoK25ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuaW5zZXJ0SFRNTENvbW1hbmQodGhpcy5kb2N1bWVudCwgJzxpbWcgY2xhc3M9XCJtZWRpdW0tZWRpdG9yLWltYWdlLWxvYWRpbmdcIiBpZD1cIicgKyBpZCArICdcIiAvPicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1nID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGltZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmltYWdlRHJhZ2dpbmcgPSBJbWFnZURyYWdnaW5nO1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvLyBFdmVudCBoYW5kbGVycyB0aGF0IHNob3VsZG4ndCBiZSBleHBvc2VkIGV4dGVybmFsbHlcblxuICAgIGZ1bmN0aW9uIGhhbmRsZURpc2FibGVFeHRyYVNwYWNlcyhldmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgICAgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50LFxuICAgICAgICAgICAgY2FyZXRQb3NpdGlvbnMgPSBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldENhcmV0T2Zmc2V0cyhub2RlKTtcblxuICAgICAgICBpZiAoKHRleHRDb250ZW50W2NhcmV0UG9zaXRpb25zLmxlZnQgLSAxXSA9PT0gdW5kZWZpbmVkKSB8fCAodGV4dENvbnRlbnRbY2FyZXRQb3NpdGlvbnMubGVmdCAtIDFdLnRyaW0oKSA9PT0gJycpIHx8ICh0ZXh0Q29udGVudFtjYXJldFBvc2l0aW9ucy5sZWZ0XSAhPT0gdW5kZWZpbmVkICYmIHRleHRDb250ZW50W2NhcmV0UG9zaXRpb25zLmxlZnRdLnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRGlzYWJsZWRFbnRlcktleWRvd24oZXZlbnQsIGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlUmV0dXJuIHx8IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc2FibGUtcmV0dXJuJykpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVEb3VibGVSZXR1cm4gfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZS1kb3VibGUtcmV0dXJuJykpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25TdGFydCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCk7XG5cbiAgICAgICAgICAgIC8vIGlmIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gaXMgZW1wdHkgT1IgcHJldmlvdXMgc2libGluZyB0ZXh0IGlzIGVtcHR5IE9SIGl0IGlzIG5vdCBhIGxpc3RcbiAgICAgICAgICAgIGlmICgobm9kZSAmJiBub2RlLnRleHRDb250ZW50LnRyaW0oKSA9PT0gJycgJiYgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnbGknKSB8fFxuICAgICAgICAgICAgICAgIChub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09ICdicicgJiZcbiAgICAgICAgICAgICAgICAgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnRleHRDb250ZW50LnRyaW0oKSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRhYktleWRvd24oZXZlbnQpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGFiIG9ubHkgZm9yIHByZSBub2Rlc1xuICAgICAgICB2YXIgbm9kZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgICAgdGFnID0gbm9kZSAmJiBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgaWYgKHRhZyA9PT0gJ3ByZScpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5pbnNlcnRIVE1MQ29tbWFuZCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCwgJyAgICAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhYiB0byBpbmRlbnQgbGlzdCBzdHJ1Y3R1cmVzIVxuICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNMaXN0SXRlbShub2RlKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgLy8gSWYgU2hpZnQgaXMgZG93biwgb3V0ZGVudCwgb3RoZXJ3aXNlIGluZGVudFxuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuZXhlY0NvbW1hbmQoJ291dGRlbnQnLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbmRlbnQnLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVCbG9ja0RlbGV0ZUtleWRvd25zKGV2ZW50KSB7XG4gICAgICAgIHZhciBwLCBub2RlID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25TdGFydCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgICB0YWdOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgaXNFbXB0eSA9IC9eKFxccyt8PGJyXFwvPz4pPyQvaSxcbiAgICAgICAgICAgIGlzSGVhZGVyID0gL2hcXGQvaTtcblxuICAgICAgICBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIFtNZWRpdW1FZGl0b3IudXRpbC5rZXlDb2RlLkJBQ0tTUEFDRSwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5FTlRFUl0pICYmXG4gICAgICAgICAgICAgICAgLy8gaGFzIGEgcHJlY2VlZGluZyBzaWJsaW5nXG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgLy8gaW4gYSBoZWFkZXJcbiAgICAgICAgICAgICAgICBpc0hlYWRlci50ZXN0KHRhZ05hbWUpICYmXG4gICAgICAgICAgICAgICAgLy8gYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBibG9ja1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0Q2FyZXRPZmZzZXRzKG5vZGUpLmxlZnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5CQUNLU1BBQ0UpICYmIGlzRW1wdHkudGVzdChub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoZSBiZWdpbmluZyBvZiBhIGhlYWRlciBpbnRvIGFuIGVtcHR5IHByZXZpb3VzIGVsZW1lbnQgd2lsbFxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZSB0aGUgdGFnTmFtZSBvZiB0aGUgY3VycmVudCBub2RlIHRvIHByZXZlbnQgb25lXG4gICAgICAgICAgICAgICAgLy8gaW5zdGVhZCBkZWxldGUgcHJldmlvdXMgbm9kZSBhbmQgY2FuY2VsIHRoZSBldmVudC5cbiAgICAgICAgICAgICAgICBub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZURvdWJsZVJldHVybiAmJiBNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5FTlRFUikpIHtcbiAgICAgICAgICAgICAgICAvLyBoaXR0aW5nIHJldHVybiBpbiB0aGUgYmVnaW5pbmcgb2YgYSBoZWFkZXIgd2lsbCBjcmVhdGUgZW1wdHkgaGVhZGVyIGVsZW1lbnRzIGJlZm9yZSB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgICAgICAgICAvLyBpbnN0ZWFkLCBtYWtlIFwiPHA+PGJyPjwvcD5cIiBlbGVtZW50LCB3aGljaCBhcmUgd2hhdCBoYXBwZW5zIGlmIHlvdSBoaXQgcmV0dXJuIGluIGFuIGVtcHR5IHBhcmFncmFwaFxuICAgICAgICAgICAgICAgIHAgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgICAgICAgICAgcC5pbm5lckhUTUwgPSAnPGJyPic7XG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHAsIG5vZGUpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuREVMRVRFKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucHJldmlvdXNFbGVtZW50U2libGluZyAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgaW4gYSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgIWlzSGVhZGVyLnRlc3QodGFnTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYW4gZW1wdHkgdGFnXG4gICAgICAgICAgICAgICAgICAgIGlzRW1wdHkudGVzdChub2RlLmlubmVySFRNTCkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgbmV4dCB0YWcgKmlzKiBhIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBpc0hlYWRlci50ZXN0KG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAvLyBoaXR0aW5nIGRlbGV0ZSBpbiBhbiBlbXB0eSBlbGVtZW50IHByZWNlZGluZyBhIGhlYWRlciwgZXg6XG4gICAgICAgICAgICAvLyAgPHA+W0NVUlNPUl08L3A+PGgxPkhlYWRlcjwvaDE+XG4gICAgICAgICAgICAvLyBXaWxsIGNhdXNlIHRoZSBoMSB0byBiZWNvbWUgYSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAvLyBJbnN0ZWFkLCBkZWxldGUgdGhlIHBhcmFncmFwaCBub2RlIGFuZCBtb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGJlZ2luaW5nIG9mIHRoZSBoMVxuXG4gICAgICAgICAgICAvLyByZW1vdmUgbm9kZSBhbmQgbW92ZSBjdXJzb3IgdG8gc3RhcnQgb2YgaGVhZGVyXG4gICAgICAgICAgICBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLm1vdmVDdXJzb3IodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsIG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nKTtcblxuICAgICAgICAgICAgbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoTWVkaXVtRWRpdG9yLnV0aWwuaXNLZXkoZXZlbnQsIE1lZGl1bUVkaXRvci51dGlsLmtleUNvZGUuQkFDS1NQQUNFKSAmJlxuICAgICAgICAgICAgICAgIHRhZ05hbWUgPT09ICdsaScgJiZcbiAgICAgICAgICAgICAgICAvLyBoaXR0aW5nIGJhY2tzcGFjZSBpbnNpZGUgYW4gZW1wdHkgbGlcbiAgICAgICAgICAgICAgICBpc0VtcHR5LnRlc3Qobm9kZS5pbm5lckhUTUwpICYmXG4gICAgICAgICAgICAgICAgLy8gaXMgZmlyc3QgZWxlbWVudCAobm8gcHJlY2VlZGluZyBzaWJsaW5ncylcbiAgICAgICAgICAgICAgICAhbm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgLy8gcGFyZW50IGFsc28gZG9lcyBub3QgaGF2ZSBhIHNpYmxpbmdcbiAgICAgICAgICAgICAgICAhbm9kZS5wYXJlbnRFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIG9ubHkgbGkgaW4gYSBsaXN0XG4gICAgICAgICAgICAgICAgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgJiZcbiAgICAgICAgICAgICAgICBub2RlLm5leHRFbGVtZW50U2libGluZy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbGknKSB7XG4gICAgICAgICAgICAvLyBiYWNrc3BhY2luZyBpbiBhbiBlbXB0eSBmaXJzdCBsaXN0IGVsZW1lbnQgaW4gdGhlIGZpcnN0IGxpc3QgKHdpdGggbW9yZSBlbGVtZW50cykgZXg6XG4gICAgICAgICAgICAvLyAgPHVsPjxsaT5bQ1VSU09SXTwvbGk+PGxpPkxpc3QgSXRlbSAyPC9saT48L3VsPlxuICAgICAgICAgICAgLy8gd2lsbCByZW1vdmUgdGhlIGZpcnN0IDxsaT4gYnV0IGFkZCBzb21lIGV4dHJhIGVsZW1lbnQgYmVmb3JlICh2YXJpZXMgYmFzZWQgb24gYnJvd3NlcilcbiAgICAgICAgICAgIC8vIEluc3RlYWQsIHRoaXMgd2lsbDpcbiAgICAgICAgICAgIC8vIDEpIHJlbW92ZSB0aGUgbGlzdCBlbGVtZW50XG4gICAgICAgICAgICAvLyAyKSBjcmVhdGUgYSBwYXJhZ3JhcGggYmVmb3JlIHRoZSBsaXN0XG4gICAgICAgICAgICAvLyAzKSBtb3ZlIHRoZSBjdXJzb3IgaW50byB0aGUgcGFyYWdyYXBoXG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHBhcmFncmFwaCBiZWZvcmUgdGhlIGxpc3RcbiAgICAgICAgICAgIHAgPSB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgICAgICBwLmlubmVySFRNTCA9ICc8YnI+JztcbiAgICAgICAgICAgIG5vZGUucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShwLCBub2RlLnBhcmVudEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgaW50byB0aGUgbmV3IHBhcmFncmFwaFxuICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5tb3ZlQ3Vyc29yKHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LCBwKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0IGVsZW1lbnRcbiAgICAgICAgICAgIG5vZGUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChub2RlKTtcblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5CQUNLU1BBQ0UpICYmXG4gICAgICAgICAgICAgICAgKE1lZGl1bUVkaXRvci51dGlsLmdldENsb3Nlc3RUYWcobm9kZSwgJ2Jsb2NrcXVvdGUnKSAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRDYXJldE9mZnNldHMobm9kZSkubGVmdCA9PT0gMCkge1xuXG4gICAgICAgICAgICAvLyB3aGVuIGN1cnNvciBpcyBhdCB0aGUgYmVnaW5pbmcgb2YgdGhlIGVsZW1lbnQgYW5kIHRoZSBlbGVtZW50IGlzIDxibG9ja3F1b3RlPlxuICAgICAgICAgICAgLy8gdGhlbiBwcmVzc2luZyBiYWNrc3BhY2Uga2V5IHNob3VsZCBjaGFuZ2UgdGhlIDxibG9ja3F1b3RlPiB0byBhIDxwPiB0YWdcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5leGVjRm9ybWF0QmxvY2sodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsICdwJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVLZXl1cChldmVudCkge1xuICAgICAgICB2YXIgbm9kZSA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgICAgdGFnTmFtZTtcblxuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95YWJ3ZS9tZWRpdW0tZWRpdG9yL2lzc3Vlcy85OTRcbiAgICAgICAgLy8gRmlyZWZveCB0aHJvd24gYW4gZXJyb3Igd2hlbiBjYWxsaW5nIGBmb3JtYXRCbG9ja2Agb24gYW4gZW1wdHkgZWRpdGFibGUgYmxvY2tDb250YWluZXIgdGhhdCdzIG5vdCBhIDxkaXY+XG4gICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc01lZGl1bUVkaXRvckVsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgJiYgIU1lZGl1bUVkaXRvci51dGlsLmlzQmxvY2tDb250YWluZXIobm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKCdmb3JtYXRCbG9jaycsIGZhbHNlLCAncCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3lhYndlL21lZGl1bS1lZGl0b3IvaXNzdWVzLzgzNFxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20veWFid2UvbWVkaXVtLWVkaXRvci9wdWxsLzM4MlxuICAgICAgICAvLyBEb24ndCBjYWxsIGZvcm1hdCBibG9jayBpZiB0aGlzIGlzIGEgYmxvY2sgZWxlbWVudCAoaWUgaDEsIGZpZ0NhcHRpb24sIGV0Yy4pXG4gICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0tleShldmVudCwgTWVkaXVtRWRpdG9yLnV0aWwua2V5Q29kZS5FTlRFUikgJiZcbiAgICAgICAgICAgICFNZWRpdW1FZGl0b3IudXRpbC5pc0xpc3RJdGVtKG5vZGUpICYmXG4gICAgICAgICAgICAhTWVkaXVtRWRpdG9yLnV0aWwuaXNCbG9ja0NvbnRhaW5lcihub2RlKSkge1xuXG4gICAgICAgICAgICB0YWdOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgLy8gRm9yIGFuY2hvciB0YWdzLCB1bmxpbmtcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnYScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZCgndW5saW5rJywgZmFsc2UsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgIWV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5leGVjQ29tbWFuZCgnZm9ybWF0QmxvY2snLCBmYWxzZSwgJ3AnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVkaXRhYmxlSW5wdXQoZXZlbnQsIGVkaXRhYmxlKSB7XG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IGVkaXRhYmxlLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcigndGV4dGFyZWFbbWVkaXVtLWVkaXRvci10ZXh0YXJlYS1pZD1cIicgKyBlZGl0YWJsZS5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItdGV4dGFyZWEtaWQnKSArICdcIl0nKTtcbiAgICAgICAgaWYgKHRleHRhcmVhKSB7XG4gICAgICAgICAgICB0ZXh0YXJlYS52YWx1ZSA9IGVkaXRhYmxlLmlubmVySFRNTC50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kcyB3aGljaCBzaG91bGRuJ3QgYmUgZXhwb3NlZCBleHRlcm5hbGx5XG5cbiAgICBmdW5jdGlvbiBhZGRUb0VkaXRvcnMod2luKSB7XG4gICAgICAgIGlmICghd2luLl9tZWRpdW1FZGl0b3JzKSB7XG4gICAgICAgICAgICAvLyBUbyBhdm9pZCBicmVha2luZyB1c2VycyB3aG8gYXJlIGFzc3VtaW5nIHRoYXQgdGhlIHVuaXF1ZSBpZCBvblxuICAgICAgICAgICAgLy8gbWVkaXVtLWVkaXRvciBlbGVtZW50cyB3aWxsIHN0YXJ0IGF0IDEsIGluc2VydGluZyBhICdudWxsJyBpbiB0aGVcbiAgICAgICAgICAgIC8vIGFycmF5IHNvIHRoZSB1bmlxdWUtaWQgY2FuIGFsd2F5cyBtYXAgdG8gdGhlIGluZGV4IG9mIHRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgIHdpbi5fbWVkaXVtRWRpdG9ycyA9IFtudWxsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgYWxyZWFkeSBoYXMgYSB1bmlxdWUgaWQsIHJlLXVzZSBpdFxuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB3aW4uX21lZGl1bUVkaXRvcnMubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luLl9tZWRpdW1FZGl0b3JzW3RoaXMuaWRdID0gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVGcm9tRWRpdG9ycyh3aW4pIHtcbiAgICAgICAgaWYgKCF3aW4uX21lZGl1bUVkaXRvcnMgfHwgIXdpbi5fbWVkaXVtRWRpdG9yc1t0aGlzLmlkXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogU2V0dGluZyB0aGUgaW5zdGFuY2UgdG8gbnVsbCBpbiB0aGUgYXJyYXkgaW5zdGVhZCBvZiBkZWxldGluZyBpdCBhbGxvd3M6XG4gICAgICAgICAqIDEpIEVhY2ggaW5zdGFuY2UgdG8gcHJlc2VydmUgaXRzIG93biB1bmlxdWUtaWQsIGV2ZW4gYWZ0ZXIgYmVpbmcgZGVzdHJveWVkXG4gICAgICAgICAqICAgIGFuZCBpbml0aWFsaXplZCBhZ2FpblxuICAgICAgICAgKiAyKSBUaGUgdW5pcXVlLWlkIHRvIGFsd2F5cyBjb3JyZXNwb25kIHRvIGFuIGluZGV4IGluIHRoZSBhcnJheSBvZiBtZWRpdW0tZWRpdG9yXG4gICAgICAgICAqICAgIGluc3RhbmNlcy4gVGh1cywgd2Ugd2lsbCBiZSBhYmxlIHRvIGxvb2sgYXQgYSBjb250ZW50ZWRpdGFibGUsIGFuZCBkZXRlcm1pbmVcbiAgICAgICAgICogICAgd2hpY2ggaW5zdGFuY2UgaXQgYmVsb25ncyB0bywgYnkgaW5kZXhpbmcgaW50byB0aGUgZ2xvYmFsIGFycmF5LlxuICAgICAgICAgKi9cbiAgICAgICAgd2luLl9tZWRpdW1FZGl0b3JzW3RoaXMuaWRdID0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50c0FycmF5KHNlbGVjdG9yLCBkb2MsIGZpbHRlckVkaXRvckVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgc3RyaW5nLCB1c2UgYXMgcXVlcnkgc2VsZWN0b3JcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGVsZW1lbnQsIHB1dCBpbnRvIGFycmF5XG4gICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0VsZW1lbnQoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IFtzZWxlY3Rvcl07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVyRWRpdG9yRWxlbWVudHMpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBlbGVtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkIGJ5IHRoZSBlZGl0b3JcbiAgICAgICAgICAgIC8vIHNlbGVjb3RyIG1pZ2h0IG5vdCBiZSBhbiBhcnJheSAoaWUgTm9kZUxpc3QpIHNvIHVzZSBmb3IgbG9vcFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3Rvci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHNlbGVjdG9yW2ldO1xuICAgICAgICAgICAgICAgIGlmIChNZWRpdW1FZGl0b3IudXRpbC5pc0VsZW1lbnQoZWwpICYmXG4gICAgICAgICAgICAgICAgICAgICFlbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbWVkaXVtLWVkaXRvci1lbGVtZW50JykgJiZcbiAgICAgICAgICAgICAgICAgICAgIWVsLmdldEF0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci10ZXh0YXJlYS1pZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgTm9kZUxpc3QgKG9yIG90aGVyIGFycmF5IGxpa2Ugb2JqZWN0KSBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICBlbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShzZWxlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cFRleHRhcmVhRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciB0ZXh0YXJlYSA9IGVsZW1lbnQucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYVttZWRpdW0tZWRpdG9yLXRleHRhcmVhLWlkPVwiJyArIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtZWRpdW0tZWRpdG9yLXRleHRhcmVhLWlkJykgKyAnXCJdJyk7XG4gICAgICAgIGlmICh0ZXh0YXJlYSkge1xuICAgICAgICAgICAgLy8gVW4taGlkZSB0aGUgdGV4dGFyZWFcbiAgICAgICAgICAgIHRleHRhcmVhLmNsYXNzTGlzdC5yZW1vdmUoJ21lZGl1bS1lZGl0b3ItaGlkZGVuJyk7XG4gICAgICAgICAgICB0ZXh0YXJlYS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItdGV4dGFyZWEtaWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRFeHRlbnNpb25EZWZhdWx0cyhleHRlbnNpb24sIGRlZmF1bHRzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGRlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb25bcHJvcF0gPSBkZWZhdWx0c1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEV4dGVuc2lvbihleHRlbnNpb24sIG5hbWUsIGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBleHRlbnNpb25EZWZhdWx0cyA9IHtcbiAgICAgICAgICAgICd3aW5kb3cnOiBpbnN0YW5jZS5vcHRpb25zLmNvbnRlbnRXaW5kb3csXG4gICAgICAgICAgICAnZG9jdW1lbnQnOiBpbnN0YW5jZS5vcHRpb25zLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAnYmFzZSc6IGluc3RhbmNlXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWRkIGRlZmF1bHQgb3B0aW9ucyBpbnRvIHRoZSBleHRlbnNpb25cbiAgICAgICAgZXh0ZW5zaW9uID0gc2V0RXh0ZW5zaW9uRGVmYXVsdHMoZXh0ZW5zaW9uLCBleHRlbnNpb25EZWZhdWx0cyk7XG5cbiAgICAgICAgLy8gQ2FsbCBpbml0IG9uIHRoZSBleHRlbnNpb25cbiAgICAgICAgaWYgKHR5cGVvZiBleHRlbnNpb24uaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLmluaXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBleHRlbnNpb24gbmFtZSAoaWYgbm90IGFscmVhZHkgc2V0KVxuICAgICAgICBpZiAoIWV4dGVuc2lvbi5uYW1lKSB7XG4gICAgICAgICAgICBleHRlbnNpb24ubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Rvb2xiYXJFbmFibGVkKCkge1xuICAgICAgICAvLyBJZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGRvbid0IGhhdmUgdGhlIHRvb2xiYXIgZGlzYWJsZWRcbiAgICAgICAgLy8gV2UgbmVlZCBhIHRvb2xiYXJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuZXZlcnkoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISFlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNhYmxlLXRvb2xiYXInKTtcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnRvb2xiYXIgIT09IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQW5jaG9yUHJldmlld0VuYWJsZWQoKSB7XG4gICAgICAgIC8vIElmIHRvb2xiYXIgaXMgZGlzYWJsZWQsIGRvbid0IGFkZFxuICAgICAgICBpZiAoIWlzVG9vbGJhckVuYWJsZWQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hbmNob3JQcmV2aWV3ICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BsYWNlaG9sZGVyRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlciAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBdXRvTGlua0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYXV0b0xpbmsgIT09IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW1hZ2VEcmFnZ2luZ0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW1hZ2VEcmFnZ2luZyAhPT0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNLZXlib2FyZENvbW1hbmRzRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5rZXlib2FyZENvbW1hbmRzICE9PSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRVc2VGaWxlRHJhZ2dpbmdFeHRlbnNpb24oKSB7XG4gICAgICAgIC8vIFNpbmNlIHRoZSBmaWxlLWRyYWdnaW5nIGV4dGVuc2lvbiByZXBsYWNlcyB0aGUgaW1hZ2UtZHJhZ2dpbmcgZXh0ZW5zaW9uLFxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSB1c2VyIHBhc3NlZCBhbiBvdmVycmlkZWQgaW1hZ2UtZHJhZ2dpbmcgZXh0ZW5zaW9uLlxuICAgICAgICAvLyBJZiB0aGV5IGhhdmUsIHRvIGF2b2lkIGJyZWFraW5nIHVzZXJzLCB3ZSB3b24ndCB1c2UgZmlsZS1kcmFnZ2luZyBleHRlbnNpb24uXG4gICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25zLmV4dGVuc2lvbnNbJ2ltYWdlRHJhZ2dpbmcnXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb250ZW50RWRpdGFibGUodGV4dGFyZWEpIHtcbiAgICAgICAgdmFyIGRpdiA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgbm93ID0gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHVuaXF1ZUlkID0gJ21lZGl1bS1lZGl0b3ItJyArIG5vdyxcbiAgICAgICAgICAgIGF0dHMgPSB0ZXh0YXJlYS5hdHRyaWJ1dGVzO1xuXG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgY2FuIG1vdmUgcHJldHR5IGZhc3QsIHNpbmNlIHdlJ3JlIHVzaW5nIGEgdGltZXN0YW1wXG4gICAgICAgIC8vIHRvIG1ha2UgYSB1bmlxdWUtaWQsIGVuc3VyZSB0aGF0IHRoZSBpZCBpcyBhY3R1YWxseSB1bmlxdWUgb24gdGhlIHBhZ2VcbiAgICAgICAgd2hpbGUgKHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHVuaXF1ZUlkKSkge1xuICAgICAgICAgICAgbm93Kys7XG4gICAgICAgICAgICB1bmlxdWVJZCA9ICdtZWRpdW0tZWRpdG9yLScgKyBub3c7XG4gICAgICAgIH1cblxuICAgICAgICBkaXYuY2xhc3NOYW1lID0gdGV4dGFyZWEuY2xhc3NOYW1lO1xuICAgICAgICBkaXYuaWQgPSB1bmlxdWVJZDtcbiAgICAgICAgZGl2LmlubmVySFRNTCA9IHRleHRhcmVhLnZhbHVlO1xuXG4gICAgICAgIHRleHRhcmVhLnNldEF0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci10ZXh0YXJlYS1pZCcsIHVuaXF1ZUlkKTtcblxuICAgICAgICAvLyByZS1jcmVhdGUgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgdGV4dGVhcmVhIHRvIHRoZSBuZXcgY3JlYXRlZCBkaXZcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhdHRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgLy8gZG8gbm90IHJlLWNyZWF0ZSBleGlzdGluZyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBpZiAoIWRpdi5oYXNBdHRyaWJ1dGUoYXR0c1tpXS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKGF0dHNbaV0ubm9kZU5hbWUsIGF0dHNbaV0ubm9kZVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRleHRhcmVhIGhhcyBhIGZvcm0sIGxpc3RlbiBmb3IgcmVzZXQgb24gdGhlIGZvcm0gdG8gY2xlYXJcbiAgICAgICAgLy8gdGhlIGNvbnRlbnQgb2YgdGhlIGNyZWF0ZWQgZGl2XG4gICAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICAgICAgICB0aGlzLm9uKHRleHRhcmVhLmZvcm0sICdyZXNldCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Q29udGVudCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1bmlxdWVJZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0YXJlYS5jbGFzc0xpc3QuYWRkKCdtZWRpdW0tZWRpdG9yLWhpZGRlbicpO1xuICAgICAgICB0ZXh0YXJlYS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgIGRpdixcbiAgICAgICAgICAgIHRleHRhcmVhXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0RWxlbWVudChlbGVtZW50LCBlZGl0b3JJZCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW1lZGl1bS1lZGl0b3ItZWxlbWVudCcpKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGNyZWF0ZUNvbnRlbnRFZGl0YWJsZS5jYWxsKHRoaXMsIGVsZW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIG9ubHkgYXR0YWNoIHRvIGVkaXRhYmxlSW5wdXQgb25jZSBmb3IgPHRleHRhcmVhPiBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZUhhbmRsZUVkaXRhYmxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZUhhbmRsZUVkaXRhYmxlSW5wdXQgPSBoYW5kbGVFZGl0YWJsZUlucHV0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCdlZGl0YWJsZUlucHV0JywgdGhpcy5pbnN0YW5jZUhhbmRsZUVkaXRhYmxlSW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUVkaXRpbmcgJiYgIWVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWRpc2FibGUtZWRpdGluZycpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRFZGl0YWJsZScsIHRydWUpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgdGhpcy5vcHRpb25zLnNwZWxsY2hlY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2Ugb25seSBhdHRhY2ggdG8gZWRpdGFibGVLZXlkb3duRW50ZXIgb25jZSBmb3IgZGlzYWJsZS1yZXR1cm4gb3B0aW9uc1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlSGFuZGxlRWRpdGFibGVLZXlkb3duRW50ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZS1yZXR1cm4nKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNhYmxlLWRvdWJsZS1yZXR1cm4nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlSGFuZGxlRWRpdGFibGVLZXlkb3duRW50ZXIgPSBoYW5kbGVEaXNhYmxlZEVudGVyS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duRW50ZXInLCB0aGlzLmluc3RhbmNlSGFuZGxlRWRpdGFibGVLZXlkb3duRW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgd2UncmUgbm90IGRpc2FibGluZyByZXR1cm4sIGFkZCBhIGhhbmRsZXIgdG8gaGVscCBoYW5kbGUgY2xlYW51cFxuICAgICAgICAgICAgLy8gZm9yIGNlcnRhaW4gY2FzZXMgd2hlbiBlbnRlciBpcyBwcmVzc2VkXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlUmV0dXJuICYmICFlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1kaXNhYmxlLXJldHVybicpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihlbGVtZW50LCAna2V5dXAnLCBoYW5kbGVLZXl1cC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVsZW1lbnRJZCA9IE1lZGl1bUVkaXRvci51dGlsLmd1aWQoKTtcblxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbWVkaXVtLWVkaXRvci1lbGVtZW50JywgdHJ1ZSk7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ21lZGl1bS1lZGl0b3ItZWxlbWVudCcpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGV4dGJveCcpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbXVsdGlsaW5lJywgdHJ1ZSk7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZWRpdW0tZWRpdG9yLWVkaXRvci1pbmRleCcsIGVkaXRvcklkKTtcbiAgICAgICAgICAgIC8vIFRPRE86IE1lcmdlIGRhdGEtbWVkaXVtLWVkaXRvci1lbGVtZW50IGFuZCBtZWRpdW0tZWRpdG9yLWluZGV4IGF0dHJpYnV0ZXMgZm9yIDYuMC4wXG4gICAgICAgICAgICAvLyBtZWRpdW0tZWRpdG9yLWluZGV4IGlzIG5vdCBuYW1lZCBjb3JyZWN0bHkgYW55bW9yZSBhbmQgY2FuIGJlIHJlLXB1cnBvc2VkIHRvIHNpZ25pZnlcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgb3Igbm90XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci1pbmRleCcsIGVsZW1lbnRJZCk7XG4gICAgICAgICAgICBpbml0aWFsQ29udGVudFtlbGVtZW50SWRdID0gZWxlbWVudC5pbm5lckhUTUw7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmF0dGFjaEFsbEV2ZW50c1RvRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dGFjaEhhbmRsZXJzKCkge1xuICAgICAgICAvLyBhdHRhY2ggdG8gdGFic1xuICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duVGFiJywgaGFuZGxlVGFiS2V5ZG93bi5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBCaW5kIGtleXMgd2hpY2ggY2FuIGNyZWF0ZSBvciBkZXN0cm95IGEgYmxvY2sgZWxlbWVudDogYmFja3NwYWNlLCBkZWxldGUsIHJldHVyblxuICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duRGVsZXRlJywgaGFuZGxlQmxvY2tEZWxldGVLZXlkb3ducy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlS2V5ZG93bkVudGVyJywgaGFuZGxlQmxvY2tEZWxldGVLZXlkb3ducy5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBCaW5kIGRvdWJsZSBzcGFjZSBldmVudFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVFeHRyYVNwYWNlcykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoJ2VkaXRhYmxlS2V5ZG93blNwYWNlJywgaGFuZGxlRGlzYWJsZUV4dHJhU3BhY2VzLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIG9ubHkgYXR0YWNoIHRvIGVkaXRhYmxlS2V5ZG93bkVudGVyIG9uY2UgZm9yIGRpc2FibGUtcmV0dXJuIG9wdGlvbnNcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlSGFuZGxlRWRpdGFibGVLZXlkb3duRW50ZXIpIHtcbiAgICAgICAgICAgIC8vIGRpc2FibGluZyByZXR1cm4gb3IgZG91YmxlIHJldHVyblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlUmV0dXJuIHx8IHRoaXMub3B0aW9ucy5kaXNhYmxlRG91YmxlUmV0dXJuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZUhhbmRsZUVkaXRhYmxlS2V5ZG93bkVudGVyID0gaGFuZGxlRGlzYWJsZWRFbnRlcktleWRvd24uYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZSgnZWRpdGFibGVLZXlkb3duRW50ZXInLCB0aGlzLmluc3RhbmNlSGFuZGxlRWRpdGFibGVLZXlkb3duRW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdEV4dGVuc2lvbnMoKSB7XG5cbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gW107XG5cbiAgICAgICAgLy8gUGFzc2VkIGluIGV4dGVuc2lvbnNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLmV4dGVuc2lvbnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzYXZlIHRoZSB0b29sYmFyIGV4dGVuc2lvbiBmb3IgbGFzdFxuICAgICAgICAgICAgaWYgKG5hbWUgIT09ICd0b29sYmFyJyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5wdXNoKGluaXRFeHRlbnNpb24odGhpcy5vcHRpb25zLmV4dGVuc2lvbnNbbmFtZV0sIG5hbWUsIHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgLy8gNCBDYXNlcyBmb3IgaW1hZ2VEcmFnZ2luZyArIGZpbGVEcmFnZ2luZyBleHRlbnNvbnM6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIDEuIEltYWdlRHJhZ2dpbmcgT04gKyBObyBDdXN0b20gSW1hZ2UgRHJhZ2dpbmcgRXh0ZW5zaW9uOlxuICAgICAgICAvLyAgICAqIFVzZSBmaWxlRHJhZ2dpbmcgZXh0ZW5zaW9uIChkZWZhdWx0IG9wdGlvbnMpXG4gICAgICAgIC8vIDIuIEltYWdlRHJhZ2dpbmcgT0ZGICsgTm8gQ3VzdG9tIEltYWdlIERyYWdnaW5nIEV4dGVuc2lvbjpcbiAgICAgICAgLy8gICAgKiBVc2UgZmlsZURyYWdnaW5nIGV4dGVuc2lvbiB3LyBpbWFnZXMgdHVybmVkIG9mZlxuICAgICAgICAvLyAzLiBJbWFnZURyYWdnaW5nIE9OICsgQ3VzdG9tIEltYWdlIERyYWdnaW5nIEV4dGVuc2lvbjpcbiAgICAgICAgLy8gICAgKiBEb24ndCB1c2UgZmlsZURyYWdnaW5nIChjb3VsZCBpbnRlcmZlcmUgd2l0aCBjdXN0b20gaW1hZ2UgZHJhZ2dpbmcgZXh0ZW5zaW9uKVxuICAgICAgICAvLyA0LiBJbWFnZURyYWdnaW5nIE9GRiArIEN1c3RvbSBJbWFnZSBEcmFnZ2luZzpcbiAgICAgICAgLy8gICAgKiBEb24ndCB1c2UgZmlsZURyYWdnaW5nIChjb3VsZCBpbnRlcmZlcmUgd2l0aCBjdXN0b20gaW1hZ2UgZHJhZ2dpbmcgZXh0ZW5zaW9uKVxuICAgICAgICBpZiAoc2hvdWxkVXNlRmlsZURyYWdnaW5nRXh0ZW5zaW9uLmNhbGwodGhpcykpIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zLmZpbGVEcmFnZ2luZztcbiAgICAgICAgICAgIGlmICghb3B0cykge1xuICAgICAgICAgICAgICAgIG9wdHMgPSB7fTtcblxuICAgICAgICAgICAgICAgIC8vIEltYWdlIGlzIGluIHRoZSAnYWxsb3dlZFR5cGVzJyBsaXN0IGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgLy8gSWYgaW1hZ2VEcmFnZ2luZyBpcyBvZmYgb3ZlcnJpZGUgdGhlICdhbGxvd2VkVHlwZXMnIGxpc3Qgd2l0aCBhbiBlbXB0eSBvbmVcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW1hZ2VEcmFnZ2luZ0VuYWJsZWQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmFsbG93ZWRUeXBlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQnVpbHRJbkV4dGVuc2lvbignZmlsZURyYWdnaW5nJywgb3B0cyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCdWlsdC1pbiBleHRlbnNpb25zXG4gICAgICAgIHZhciBidWlsdElucyA9IHtcbiAgICAgICAgICAgIHBhc3RlOiB0cnVlLFxuICAgICAgICAgICAgJ2FuY2hvci1wcmV2aWV3JzogaXNBbmNob3JQcmV2aWV3RW5hYmxlZC5jYWxsKHRoaXMpLFxuICAgICAgICAgICAgYXV0b0xpbms6IGlzQXV0b0xpbmtFbmFibGVkLmNhbGwodGhpcyksXG4gICAgICAgICAgICBrZXlib2FyZENvbW1hbmRzOiBpc0tleWJvYXJkQ29tbWFuZHNFbmFibGVkLmNhbGwodGhpcyksXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogaXNQbGFjZWhvbGRlckVuYWJsZWQuY2FsbCh0aGlzKVxuICAgICAgICB9O1xuICAgICAgICBPYmplY3Qua2V5cyhidWlsdElucykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKGJ1aWx0SW5zW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCdWlsdEluRXh0ZW5zaW9uKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAvLyBVc2VycyBjYW4gcGFzcyBpbiBhIGN1c3RvbSB0b29sYmFyIGV4dGVuc2lvblxuICAgICAgICAvLyBzbyBjaGVjayBmb3IgdGhhdCBmaXJzdCBhbmQgaWYgaXQncyBub3QgcHJlc2VudFxuICAgICAgICAvLyBqdXN0IGNyZWF0ZSB0aGUgZGVmYXVsdCB0b29sYmFyXG4gICAgICAgIHZhciB0b29sYmFyRXh0ZW5zaW9uID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnNbJ3Rvb2xiYXInXTtcbiAgICAgICAgaWYgKCF0b29sYmFyRXh0ZW5zaW9uICYmIGlzVG9vbGJhckVuYWJsZWQuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGFiaWxpdHlcbiAgICAgICAgICAgIHZhciB0b29sYmFyT3B0aW9ucyA9IE1lZGl1bUVkaXRvci51dGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLnRvb2xiYXIsIHtcbiAgICAgICAgICAgICAgICBhbGxvd011bHRpUGFyYWdyYXBoU2VsZWN0aW9uOiB0aGlzLm9wdGlvbnMuYWxsb3dNdWx0aVBhcmFncmFwaFNlbGVjdGlvbiAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRvb2xiYXJFeHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMudG9vbGJhcih0b29sYmFyT3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdG9vbGJhciBpcyBub3QgZGlzYWJsZWQsIHNvIHdlIGFjdHVhbGx5IGhhdmUgYW4gZXh0ZW5zaW9uXG4gICAgICAgIC8vIGluaXRpYWxpemUgaXQgYW5kIGFkZCBpdCB0byB0aGUgZXh0ZW5zaW9ucyBhcnJheVxuICAgICAgICBpZiAodG9vbGJhckV4dGVuc2lvbikge1xuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLnB1c2goaW5pdEV4dGVuc2lvbih0b29sYmFyRXh0ZW5zaW9uLCAndG9vbGJhcicsIHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhkZWZhdWx0cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGVwcmVjYXRlZFByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICBbJ2FsbG93TXVsdGlQYXJhZ3JhcGhTZWxlY3Rpb24nLCAndG9vbGJhci5hbGxvd011bHRpUGFyYWdyYXBoU2VsZWN0aW9uJ11cbiAgICAgICAgXTtcbiAgICAgICAgLy8gd2FybiBhYm91dCB1c2luZyBkZXByZWNhdGVkIHByb3BlcnRpZXNcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZWRQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYWlyWzBdKSAmJiBvcHRpb25zW3BhaXJbMF1dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuZGVwcmVjYXRlZChwYWlyWzBdLCBwYWlyWzFdLCAndjYuMC4wJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTWVkaXVtRWRpdG9yLnV0aWwuZGVmYXVsdHMoe30sIG9wdGlvbnMsIGRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGVjQWN0aW9uSW50ZXJuYWwoYWN0aW9uLCBvcHRzKSB7XG4gICAgICAgIC8qanNsaW50IHJlZ2V4cDogdHJ1ZSovXG4gICAgICAgIHZhciBhcHBlbmRBY3Rpb24gPSAvXmFwcGVuZC0oLispJC9naSxcbiAgICAgICAgICAgIGp1c3RpZnlBY3Rpb24gPSAvanVzdGlmeShbQS1aYS16XSopJC9nLCAvKiBEZXRlY3RpbmcgaWYgaXMganVzdGlmeUNlbnRlcnxSaWdodHxMZWZ0ICovXG4gICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgIGNtZFZhbHVlQXJndW1lbnQ7XG4gICAgICAgIC8qanNsaW50IHJlZ2V4cDogZmFsc2UqL1xuXG4gICAgICAgIC8vIEFjdGlvbnMgc3RhcnRpbmcgd2l0aCAnYXBwZW5kLScgc2hvdWxkIGF0dGVtcHQgdG8gZm9ybWF0IGEgYmxvY2sgb2YgdGV4dCAoJ2Zvcm1hdEJsb2NrJykgdXNpbmcgYSBzcGVjaWZpY1xuICAgICAgICAvLyB0eXBlIG9mIGJsb2NrIGVsZW1lbnQgKGllIGFwcGVuZC1ibG9ja3F1b3RlLCBhcHBlbmQtaDEsIGFwcGVuZC1wcmUsIGV0Yy4pXG4gICAgICAgIG1hdGNoID0gYXBwZW5kQWN0aW9uLmV4ZWMoYWN0aW9uKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gTWVkaXVtRWRpdG9yLnV0aWwuZXhlY0Zvcm1hdEJsb2NrKHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LCBtYXRjaFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aW9uID09PSAnZm9udFNpemUnKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBEZXByZWNhdGUgc3VwcG9ydCBmb3Igb3B0cy5zaXplIGluIDYuMC4wXG4gICAgICAgICAgICBpZiAob3B0cy5zaXplKSB7XG4gICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuZGVwcmVjYXRlZCgnLnNpemUgb3B0aW9uIGZvciBmb250U2l6ZSBjb21tYW5kJywgJy52YWx1ZScsICc2LjAuMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY21kVmFsdWVBcmd1bWVudCA9IG9wdHMudmFsdWUgfHwgb3B0cy5zaXplO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKCdmb250U2l6ZScsIGZhbHNlLCBjbWRWYWx1ZUFyZ3VtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3Rpb24gPT09ICdmb250TmFtZScpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IERlcHJlY2F0ZSBzdXBwb3J0IGZvciBvcHRzLm5hbWUgaW4gNi4wLjBcbiAgICAgICAgICAgIGlmIChvcHRzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5kZXByZWNhdGVkKCcubmFtZSBvcHRpb24gZm9yIGZvbnROYW1lIGNvbW1hbmQnLCAnLnZhbHVlJywgJzYuMC4wJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbWRWYWx1ZUFyZ3VtZW50ID0gb3B0cy52YWx1ZSB8fCBvcHRzLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuZXhlY0NvbW1hbmQoJ2ZvbnROYW1lJywgZmFsc2UsIGNtZFZhbHVlQXJndW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2NyZWF0ZUxpbmsnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMaW5rKG9wdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2ltYWdlJykge1xuICAgICAgICAgICAgdmFyIHNyYyA9IHRoaXMub3B0aW9ucy5jb250ZW50V2luZG93LmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKCdpbnNlcnRJbWFnZScsIGZhbHNlLCBzcmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogSXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS95YWJ3ZS9tZWRpdW0tZWRpdG9yL2lzc3Vlcy81OTVcbiAgICAgICAgICogSWYgdGhlIGFjdGlvbiBpcyB0byBqdXN0aWZ5IHRoZSB0ZXh0ICovXG4gICAgICAgIGlmIChqdXN0aWZ5QWN0aW9uLmV4ZWMoYWN0aW9uKSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKGFjdGlvbiwgZmFsc2UsIG51bGwpLFxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGVkUGFyZW50RWxlbWVudChNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvblJhbmdlKHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50KSk7XG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGNsZWFudXBKdXN0aWZ5RGl2RnJhZ21lbnRzLmNhbGwodGhpcywgTWVkaXVtRWRpdG9yLnV0aWwuZ2V0VG9wQmxvY2tDb250YWluZXIocGFyZW50Tm9kZSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgY21kVmFsdWVBcmd1bWVudCA9IG9wdHMgJiYgb3B0cy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKGFjdGlvbiwgZmFsc2UsIGNtZFZhbHVlQXJndW1lbnQpO1xuICAgIH1cblxuICAgIC8qIElmIHdlJ3ZlIGp1c3QganVzdGlmaWVkIHRleHQgd2l0aGluIGEgY29udGFpbmVyIGJsb2NrXG4gICAgICogQ2hyb21lIG1heSBoYXZlIHJlbW92ZWQgPGJyPiBlbGVtZW50cyBhbmQgaW5zdGVhZCB3cmFwcGVkIGxpbmVzIGluIDxkaXY+IGVsZW1lbnRzXG4gICAgICogd2l0aCBhIHRleHQtYWxpZ24gcHJvcGVydHkuICBJZiBzbywgd2Ugd2FudCB0byBmaXggdGhpc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFudXBKdXN0aWZ5RGl2RnJhZ21lbnRzKGJsb2NrQ29udGFpbmVyKSB7XG4gICAgICAgIGlmICghYmxvY2tDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0QWxpZ24sXG4gICAgICAgICAgICBjaGlsZERpdnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChibG9ja0NvbnRhaW5lci5jaGlsZE5vZGVzKS5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNEaXYgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkaXYnO1xuICAgICAgICAgICAgICAgIGlmIChpc0RpdiAmJiAhdGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9IGVsZW1lbnQuc3R5bGUudGV4dEFsaWduO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNEaXY7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAvKiBJZiB3ZSBmb3VuZCBjaGlsZCA8ZGl2PiBlbGVtZW50cyB3aXRoIHRleHQtYWxpZ24gc3R5bGUgYXR0cmlidXRlc1xuICAgICAgICAgKiB3ZSBzaG91bGQgZml4IHRoaXMgYnk6XG4gICAgICAgICAqXG4gICAgICAgICAqIDEpIFVud3JhcHBpbmcgZWFjaCA8ZGl2PiB3aGljaCBoYXMgYSB0ZXh0LWFsaWduIHN0eWxlXG4gICAgICAgICAqIDIpIEluc2VydCBhIDxicj4gZWxlbWVudCBhZnRlciBlYWNoIHNldCBvZiAndW53cmFwcGVkJyBkaXYgY2hpbGRyZW5cbiAgICAgICAgICogMykgU2V0IHRoZSB0ZXh0LWFsaWduIHN0eWxlIG9mIHRoZSBwYXJlbnQgYmxvY2sgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGNoaWxkRGl2cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlJ3JlIG11Y2tpbmcgd2l0aCB0aGUgSFRNTCwgcHJlc2VydmUgc2VsZWN0aW9uXG4gICAgICAgICAgICB0aGlzLnNhdmVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGNoaWxkRGl2cy5mb3JFYWNoKGZ1bmN0aW9uIChkaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2LnN0eWxlLnRleHRBbGlnbiA9PT0gdGV4dEFsaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0Q2hpbGQgPSBkaXYubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGEgZGl2LCBleHRyYWN0IHRoZSBjaGlsZCBlbGVtZW50cyBhbmQgYWRkIGEgPGJyPlxuICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwudW53cmFwKGRpdiwgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJyID0gdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnQlInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGlsZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiciwgbGFzdENoaWxkLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgYmxvY2tDb250YWluZXIuc3R5bGUudGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgICAgICAgLy8gV2UncmUgZG9uZSwgc28gcmVzdG9yZSBzZWxlY3Rpb25cbiAgICAgICAgICAgIHRoaXMucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxDb250ZW50ID0ge307XG5cbiAgICBNZWRpdW1FZGl0b3IucHJvdG90eXBlID0ge1xuICAgICAgICAvLyBOT1QgRE9DVU1FTlRFRCAtIGV4cG9zZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50cywgb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zLmNhbGwodGhpcywgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm9yaWdFbGVtZW50cyA9IGVsZW1lbnRzO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbGVtZW50c0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lbGVtZW50c0NvbnRhaW5lciA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldHVwKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0dXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZGRUb0VkaXRvcnMuY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBNZWRpdW1FZGl0b3IuRXZlbnRzKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRzKHRoaXMub3JpZ0VsZW1lbnRzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gQ2FsbCBpbml0aWFsaXphdGlvbiBoZWxwZXJzXG4gICAgICAgICAgICBpbml0RXh0ZW5zaW9ucy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgYXR0YWNoSGFuZGxlcnMuY2FsbCh0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudHMuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBlbGVtZW50cyBjb250ZW50LCBmaXggZm9yIGlzc3VlIHdoZXJlIGFmdGVyIGVkaXRvciBkZXN0cm95ZWQgdGhlIHJlZCB1bmRlcmxpbmVzIG9uIHNwZWxsaW5nIGVycm9ycyBhcmUgbGVmdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3BlbGxjaGVjaykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IGVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNsZWFudXAgZXh0cmEgYWRkZWQgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdjb250ZW50RWRpdGFibGUnKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3BlbGxjaGVjaycpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1lZGl1bS1lZGl0b3ItZWxlbWVudCcpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnbWVkaXVtLWVkaXRvci1lbGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tdWx0aWxpbmUnKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci1pbmRleCcpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW1lZGl1bS1lZGl0b3ItZWRpdG9yLWluZGV4Jyk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IGVsZW1lbnRzIGNyZWF0ZWQgZm9yIHRleHRhcmVhc1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci10ZXh0YXJlYS1pZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXBUZXh0YXJlYUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlSGFuZGxlRWRpdGFibGVLZXlkb3duRW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZUhhbmRsZUVkaXRhYmxlSW5wdXQgPSBudWxsO1xuXG4gICAgICAgICAgICByZW1vdmVGcm9tRWRpdG9ycy5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucy5jb250ZW50V2luZG93KTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbjogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5hdHRhY2hET01FdmVudCh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9mZjogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyLCB1c2VDYXB0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5kZXRhY2hET01FdmVudCh0YXJnZXQsIGV2ZW50LCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMuYXR0YWNoQ3VzdG9tRXZlbnQoZXZlbnQsIGxpc3RlbmVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdW5zdWJzY3JpYmU6IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmRldGFjaEN1c3RvbUV2ZW50KGV2ZW50LCBsaXN0ZW5lcik7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChuYW1lLCBkYXRhLCBlZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMudHJpZ2dlckN1c3RvbUV2ZW50KG5hbWUsIGRhdGEsIGVkaXRhYmxlKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsYXk6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmRlbGF5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnRpZCxcbiAgICAgICAgICAgICAgICBjb250ZW50ID0ge30sXG4gICAgICAgICAgICAgICAgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRpZCA9ICh0aGlzLmVsZW1lbnRzW2ldLmlkICE9PSAnJykgPyB0aGlzLmVsZW1lbnRzW2ldLmlkIDogJ2VsZW1lbnQtJyArIGk7XG4gICAgICAgICAgICAgICAgY29udGVudFtlbGVtZW50aWRdID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5lbGVtZW50c1tpXS5pbm5lckhUTUwudHJpbSgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEV4dGVuc2lvbkJ5TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnNpb247XG4gICAgICAgICAgICBpZiAodGhpcy5leHRlbnNpb25zICYmIHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMuc29tZShmdW5jdGlvbiAoZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHQubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTk9UIERPQ1VNRU5URUQgLSBleHBvc2VkIGFzIGEgaGVscGVyIGZvciBvdGhlciBleHRlbnNpb25zIHRvIHVzZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkQnVpbHRJbkV4dGVuc2lvbjogZnVuY3Rpb24gKG5hbWUsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBleHRlbnNpb24gPSB0aGlzLmdldEV4dGVuc2lvbkJ5TmFtZShuYW1lKSxcbiAgICAgICAgICAgICAgICBtZXJnZWQ7XG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkID0gTWVkaXVtRWRpdG9yLnV0aWwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuYW5jaG9yLCBvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gbmV3IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmFuY2hvcihtZXJnZWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdhbmNob3ItcHJldmlldyc6XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5hbmNob3JQcmV2aWV3KHRoaXMub3B0aW9ucy5hbmNob3JQcmV2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXV0b0xpbmsnOlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuYXV0b0xpbmsoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsZURyYWdnaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gbmV3IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLmZpbGVEcmFnZ2luZyhvcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZm9udG5hbWUnOlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9udE5hbWUodGhpcy5vcHRpb25zLmZvbnROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZm9udHNpemUnOlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuZm9udFNpemUob3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2tleWJvYXJkQ29tbWFuZHMnOlxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMua2V5Ym9hcmRDb21tYW5kcyh0aGlzLm9wdGlvbnMua2V5Ym9hcmRDb21tYW5kcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gbmV3IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLnBhc3RlKHRoaXMub3B0aW9ucy5wYXN0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BsYWNlaG9sZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uID0gbmV3IE1lZGl1bUVkaXRvci5leHRlbnNpb25zLnBsYWNlaG9sZGVyKHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBvZiB0aGUgYnVpbHQtaW4gYnV0dG9ucyBmb3IgTWVkaXVtRWRpdG9yIGFyZSBleHRlbnNpb25zXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGNoZWNrIHRvIHNlZSBpZiB0aGUgZXh0ZW5zaW9uIHdlJ3JlIGNyZWF0aW5nIGlzIGEgYnVpbHQtaW4gYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGlmIChNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24uaXNCdWlsdEluQnV0dG9uKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZCA9IE1lZGl1bUVkaXRvci51dGlsLmRlZmF1bHRzKHt9LCBvcHRzLCBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24ucHJvdG90eXBlLmRlZmF1bHRzW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgTWVkaXVtRWRpdG9yLmV4dGVuc2lvbnMuYnV0dG9uKG1lcmdlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBNZWRpdW1FZGl0b3IuZXh0ZW5zaW9ucy5idXR0b24obmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5wdXNoKGluaXRFeHRlbnNpb24oZXh0ZW5zaW9uLCBuYW1lLCB0aGlzKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RvcFNlbGVjdGlvblVwZGF0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudFNlbGVjdGlvblVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0U2VsZWN0aW9uVXBkYXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50U2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNoZWNrU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9vbGJhciA9IHRoaXMuZ2V0RXh0ZW5zaW9uQnlOYW1lKCd0b29sYmFyJyk7XG4gICAgICAgICAgICBpZiAodG9vbGJhcikge1xuICAgICAgICAgICAgICAgIHRvb2xiYXIuY2hlY2tTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gV3JhcHBlciBhcm91bmQgZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gYWN0aW9uIGhhcyBhbHJlYWR5XG4gICAgICAgIC8vIGJlZW4gYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgICAgcXVlcnlDb21tYW5kU3RhdGU6IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBmdWxsQWN0aW9uID0gL15mdWxsLSguKykkL2dpLFxuICAgICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5U3RhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBBY3Rpb25zIHN0YXJ0aW5nIHdpdGggJ2Z1bGwtJyBuZWVkIHRvIGJlIG1vZGlmaWVkIHNpbmNlIHRoaXMgaXMgYSBtZWRpdW0tZWRpdG9yIGNvbmNlcHRcbiAgICAgICAgICAgIG1hdGNoID0gZnVsbEFjdGlvbi5leGVjKGFjdGlvbik7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBxdWVyeVN0YXRlID0gdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUoYWN0aW9uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5U3RhdGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcXVlcnlTdGF0ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBleGVjQWN0aW9uOiBmdW5jdGlvbiAoYWN0aW9uLCBvcHRzKSB7XG4gICAgICAgICAgICAvKmpzbGludCByZWdleHA6IHRydWUqL1xuICAgICAgICAgICAgdmFyIGZ1bGxBY3Rpb24gPSAvXmZ1bGwtKC4rKSQvZ2ksXG4gICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgcmVzdWx0O1xuICAgICAgICAgICAgLypqc2xpbnQgcmVnZXhwOiBmYWxzZSovXG5cbiAgICAgICAgICAgIC8vIEFjdGlvbnMgc3RhcnRpbmcgd2l0aCAnZnVsbC0nIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRvIHRoZSBlbnRpcmUgY29udGVudHMgb2YgdGhlIGVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIChpZSBmdWxsLWJvbGQsIGZ1bGwtYXBwZW5kLXByZSwgZXRjLilcbiAgICAgICAgICAgIG1hdGNoID0gZnVsbEFjdGlvbi5leGVjKGFjdGlvbik7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gdG8gYmUgcmVzdG9yZWQgYWZ0ZXIgYXBwbHlpbmcgdGhlIGFjdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBhbGwgb2YgdGhlIGNvbnRlbnRzIGJlZm9yZSBjYWxsaW5nIHRoZSBhY3Rpb25cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEFsbENvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZXhlY0FjdGlvbkludGVybmFsLmNhbGwodGhpcywgbWF0Y2hbMV0sIG9wdHMpO1xuICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBleGVjQWN0aW9uSW50ZXJuYWwuY2FsbCh0aGlzLCBhY3Rpb24sIG9wdHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkbyBzb21lIERPTSBjbGVhbi11cCBmb3Iga25vd24gYnJvd3NlciBpc3N1ZXMgYWZ0ZXIgdGhlIGFjdGlvblxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2luc2VydHVub3JkZXJlZGxpc3QnIHx8IGFjdGlvbiA9PT0gJ2luc2VydG9yZGVyZWRsaXN0Jykge1xuICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmNsZWFuTGlzdERPTSh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCwgdGhpcy5nZXRTZWxlY3RlZFBhcmVudEVsZW1lbnQoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2VsZWN0ZWRQYXJlbnRFbGVtZW50OiBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdy5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWRQYXJlbnRFbGVtZW50KHJhbmdlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZWxlY3RBbGxDb250ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJOb2RlID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25FbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50V2luZG93KTtcblxuICAgICAgICAgICAgaWYgKGN1cnJOb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbG93ZXN0IGRlc2NlbmRhbnQgbm9kZSB0aGF0IHN0aWxsIHNlbGVjdHMgYWxsIG9mIHRoZSBjb250ZW50c1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyTm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3Vyck5vZGUgPSBjdXJyTm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQoY3Vyck5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNlbGVjdEVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdE5vZGUoZWxlbWVudCwgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgc2VsRWxlbWVudCA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uRWxlbWVudCh0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICBpZiAoc2VsRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmZvY3VzRWxlbWVudChzZWxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRGb2N1c2VkRWxlbWVudDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGZvY3VzZWQ7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBlbGVtZW50IHRoYXQgaGFzIGZvY3VzXG4gICAgICAgICAgICAgICAgaWYgKCFmb2N1c2VkICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW1lZGl1bS1mb2N1c2VkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNlZCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYmFpbCBpZiB3ZSBmb3VuZCB0aGUgZWxlbWVudCB0aGF0IGhhZCBmb2N1c1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWZvY3VzZWQ7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvY3VzZWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gRXhwb3J0IHRoZSBzdGF0ZSBvZiB0aGUgc2VsZWN0aW9uIGluIHJlc3BlY3QgdG8gb25lIG9mIHRoaXNcbiAgICAgICAgLy8gaW5zdGFuY2Ugb2YgTWVkaXVtRWRpdG9yJ3MgZWxlbWVudHNcbiAgICAgICAgZXhwb3J0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRWxlbWVudCA9IE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uRWxlbWVudCh0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdyksXG4gICAgICAgICAgICAgICAgZWRpdGFibGVFbGVtZW50SW5kZXggPSB0aGlzLmVsZW1lbnRzLmluZGV4T2Yoc2VsZWN0aW9uRWxlbWVudCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhdGUgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoZWRpdGFibGVFbGVtZW50SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXRlID0gTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5leHBvcnRTZWxlY3Rpb24oc2VsZWN0aW9uRWxlbWVudCwgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhdGUgIT09IG51bGwgJiYgZWRpdGFibGVFbGVtZW50SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25TdGF0ZS5lZGl0YWJsZUVsZW1lbnRJbmRleCA9IGVkaXRhYmxlRWxlbWVudEluZGV4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZVNlbGVjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0ZSA9IHRoaXMuZXhwb3J0U2VsZWN0aW9uKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gUmVzdG9yZSBhIHNlbGVjdGlvbiBiYXNlZCBvbiBhIHNlbGVjdGlvblN0YXRlIHJldHVybmVkIGJ5IGEgY2FsbFxuICAgICAgICAvLyB0byBNZWRpdW1FZGl0b3IuZXhwb3J0U2VsZWN0aW9uXG4gICAgICAgIGltcG9ydFNlbGVjdGlvbjogZnVuY3Rpb24gKHNlbGVjdGlvblN0YXRlLCBmYXZvckxhdGVyU2VsZWN0aW9uQW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZWRpdGFibGVFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tzZWxlY3Rpb25TdGF0ZS5lZGl0YWJsZUVsZW1lbnRJbmRleCB8fCAwXTtcbiAgICAgICAgICAgIE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uaW1wb3J0U2VsZWN0aW9uKHNlbGVjdGlvblN0YXRlLCBlZGl0YWJsZUVsZW1lbnQsIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LCBmYXZvckxhdGVyU2VsZWN0aW9uQW5jaG9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmltcG9ydFNlbGVjdGlvbih0aGlzLnNlbGVjdGlvblN0YXRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMaW5rOiBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRFZGl0b3IgPSBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLmdldFNlbGVjdGlvbkVsZW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnRXaW5kb3cpLFxuICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50ID0ge30sXG4gICAgICAgICAgICAgICAgdGFyZ2V0VXJsO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNlbGVjdGlvbiBpcyB3aXRoaW4gYW4gZWxlbWVudCB0aGlzIGVkaXRvciBpcyB0cmFja2luZ1xuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuaW5kZXhPZihjdXJyZW50RWRpdG9yKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZGlzYWJsZUN1c3RvbUV2ZW50KCdlZGl0YWJsZUlucHV0Jyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRGVwcmVjYXRlIHN1cHBvcnQgZm9yIG9wdHMudXJsIGluIDYuMC4wXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmRlcHJlY2F0ZWQoJy51cmwgb3B0aW9uIGZvciBjcmVhdGVMaW5rJywgJy52YWx1ZScsICc2LjAuMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXJnZXRVcmwgPSBvcHRzLnVybCB8fCBvcHRzLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRVcmwgJiYgdGFyZ2V0VXJsLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gdGhpcy5vcHRpb25zLmNvbnRlbnRXaW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclJhbmdlID0gY3VycmVudFNlbGVjdGlvbi5nZXRSYW5nZUF0KDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gY3VyclJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydGVkU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29udGFpbmVyUGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRDb250YWluZXJQYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHROb2RlcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgc2luZ2xlIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoZSBzZWxlY3Rpb24gc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1TSUUgc3RpbGwgc2F5cyB0aGUgc3RhcnRDb250YWluZXIgaXMgdGhlIHBhcmVudCBvZiB0aGUgdGV4dCBub2RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgc2luZ2xlIHRleHQgbm9kZSwgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdhbnQgdG8ganVzdCB1c2UgdGhlIGRlZmF1bHQgYnJvd3NlciAnY3JlYXRlTGluaycsIHNvIHdlIG5lZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGFjY291bnQgZm9yIHRoaXMgY2FzZSBhbmQgYWRqdXN0IHRoZSBjb21tb25BbmNlc3RvckNvbnRhaW5lciBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGUgPT09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyUmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGUgIT09IDMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyUmFuZ2Uuc3RhcnRPZmZzZXQgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyUmFuZ2Uuc3RhcnRDb250YWluZXIuZmlyc3RDaGlsZCA9PT0gY3VyclJhbmdlLmVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gY3VyclJhbmdlLmVuZENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb250YWluZXJQYXJlbnRFbGVtZW50ID0gTWVkaXVtRWRpdG9yLnV0aWwuZ2V0Q2xvc2VzdEJsb2NrQ29udGFpbmVyKGN1cnJSYW5nZS5zdGFydENvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmRDb250YWluZXJQYXJlbnRFbGVtZW50ID0gTWVkaXVtRWRpdG9yLnV0aWwuZ2V0Q2xvc2VzdEJsb2NrQ29udGFpbmVyKGN1cnJSYW5nZS5lbmRDb250YWluZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIG5vdCBjb250YWluZWQgd2l0aGluIGEgc2luZ2xlIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IHRoZSBzZWxlY3Rpb24gaXMgY29udGFpbmVkIHdpdGhpbiB0aGUgc2FtZSBibG9jayBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBjcmVhdGUgYSBzaW5nbGUgbGluaywgYW5kIG5vdCBtdWx0aXBsZSBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggY2FuIGhhcHBlbiB3aXRoIHRoZSBidWlsdCBpbiBicm93c2VyIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tb25BbmNlc3RvckNvbnRhaW5lci5ub2RlVHlwZSAhPT0gMyAmJiBjb21tb25BbmNlc3RvckNvbnRhaW5lci50ZXh0Q29udGVudC5sZW5ndGggIT09IDAgJiYgc3RhcnRDb250YWluZXJQYXJlbnRFbGVtZW50ID09PSBlbmRDb250YWluZXJQYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSAoc3RhcnRDb250YWluZXJQYXJlbnRFbGVtZW50IHx8IGN1cnJlbnRFZGl0b3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHdlIGFyZSBnb2luZyB0byBjcmVhdGUgYSBsaW5rIGZyb20gYW4gZXh0cmFjdGVkIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmUgc3VyZSB0aGF0IGlmIHdlIGFyZSB1cGRhdGluZyBhIGxpbmssIHdlIHdvbid0IGxldCBhbiBlbXB0eSBsaW5rIGJlaGluZCAoc2VlICM3NTQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKFdvcmthcm91bmcgZm9yIENocm9tZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWNBY3Rpb24oJ3VubGluaycpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0ZWRTZWxlY3Rpb24gPSB0aGlzLmV4cG9ydFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHBhcmVudEVsZW1lbnQuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RWRpdG9yID09PSBwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYXZvaWQgdGhlIGVkaXRvciBpdHNlbGYgYmVpbmcgd2lwZWQgb3V0IHdoZW4gaXQncyB0aGUgb25seSBibG9jayBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcyBvdXIgcmVmZXJlbmNlIGluc2lkZSB0aGlzLmVsZW1lbnRzIGdldHMgZGV0YWNoZWQgZnJvbSB0aGUgcGFnZSB3aGVuIGluc2VydEhUTUwgcnVucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UganVzdCB1c2UgW3BhcmVudEVsZW1lbnQsIDBdIGFuZCBbcGFyZW50RWxlbWVudCwgcGFyZW50RWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlIHJhbmdlIGJvdW5kYXJpZXMsIHRoaXMgaGFwcGVucyB3aGVuZXZlciBwYXJlbnRFbGVtZW50ID09PSBjdXJyZW50RWRpdG9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHJhZGVvZmYgdG8gdGhpcyB3b3JrYXJvdW5kIGlzIHRoYXQgYSBvcnBoYW5lZCB0YWcgY2FuIHNvbWV0aW1lcyBiZSBsZWZ0IGJlaGluZCBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBlZGl0b3IncyBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiBHZWNrbzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXMgYW4gZW1wdHkgPHN0cm9uZz48L3N0cm9uZz4gaWYgcGFyZW50RWxlbWVudC5sYXN0Q2hpbGQgaXMgYSA8c3Ryb25nPiB0YWcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIFdlYktpdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gaW52ZW50ZWQgPGJyIC8+IHRhZyBhdCB0aGUgZW5kIGluIHRoZSBzYW1lIHNpdHVhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3Iuc2VsZWN0aW9uLnNlbGVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5maXJzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQubGFzdENoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5sYXN0Q2hpbGQubm9kZVR5cGUgPT09IDMgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudC5sYXN0Q2hpbGQubm9kZVZhbHVlLmxlbmd0aCA6IHBhcmVudEVsZW1lbnQubGFzdENoaWxkLmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW9kaWZpZWRFeHBvcnRlZFNlbGVjdGlvbiA9IHRoaXMuZXhwb3J0U2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZXMgPSBNZWRpdW1FZGl0b3IudXRpbC5maW5kT3JDcmVhdGVNYXRjaGluZ1RleHROb2RlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZXhwb3J0ZWRTZWxlY3Rpb24uc3RhcnQgLSBtb2RpZmllZEV4cG9ydGVkU2VsZWN0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBleHBvcnRlZFNlbGVjdGlvbi5lbmQgLSBtb2RpZmllZEV4cG9ydGVkU2VsZWN0aW9uLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGVFbGVtZW50SW5kZXg6IGV4cG9ydGVkU2VsZWN0aW9uLmVkaXRhYmxlRWxlbWVudEluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRleHROb2RlcyBhcmUgbm90IHByZXNlbnQsIHdoZW4gY2hhbmdpbmcgbGluayBvbiBpbWFnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleDogPGE+PGltZyBzcmM9XCJodHRwOi8vaW1hZ2UudGVzdC5jb21cIj48L2E+LCBjaGFuZ2UgZnJhZ21lbnQgdG8gY3VyclJhbmdlLnN0YXJ0Q29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHNldCB0ZXh0Tm9kZXMgYXJyYXkgdG8gW2ltYWdlRWxlbWVudCwgaW1hZ2VFbGVtZW50XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChjb21tb25BbmNlc3RvckNvbnRhaW5lci5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZXMgPSBbZnJhZ21lbnQuZmlyc3RDaGlsZC5maXJzdENoaWxkLCBmcmFnbWVudC5maXJzdENoaWxkLmxhc3RDaGlsZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlcyB0aGUgbGluayBpbiB0aGUgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZWRpdW1FZGl0b3IudXRpbC5jcmVhdGVMaW5rKHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LCB0ZXh0Tm9kZXMsIHRhcmdldFVybC50cmltKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hyb21lIHRyaW1zIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VzIHdoZW4gaW5zZXJ0aW5nIEhUTUwsIHdoaWNoIG1lc3NlcyB1cCByZXN0b3JpbmcgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2VzQ291bnQgPSAoZnJhZ21lbnQuZmlyc3RDaGlsZC5pbm5lckhUTUwubWF0Y2goL15cXHMrLykgfHwgWycnXSlbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm93IG1vdmUgdGhlIGNyZWF0ZWQgbGluayBiYWNrIGludG8gdGhlIG9yaWdpbmFsIGRvY3VtZW50IGluIGEgd2F5IHRvIHByZXNlcnZlIHVuZG8vcmVkbyBoaXN0b3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuaW5zZXJ0SFRNTENvbW1hbmQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQsIGZyYWdtZW50LmZpcnN0Q2hpbGQuaW5uZXJIVE1MLnJlcGxhY2UoL15cXHMrLywgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFNlbGVjdGlvbi5zdGFydCAtPSBsZWFkaW5nV2hpdGVzcGFjZXNDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRlZFNlbGVjdGlvbi5lbmQgLT0gbGVhZGluZ1doaXRlc3BhY2VzQ291bnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltcG9ydFNlbGVjdGlvbihleHBvcnRlZFNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKCdjcmVhdGVMaW5rJywgZmFsc2UsIHRhcmdldFVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGFyZ2V0QmxhbmsgfHwgb3B0cy50YXJnZXQgPT09ICdfYmxhbmsnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVkaXVtRWRpdG9yLnV0aWwuc2V0VGFyZ2V0QmxhbmsoTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25TdGFydCh0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCksIHRhcmdldFVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLnJlbW92ZVRhcmdldEJsYW5rKE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLCB0YXJnZXRVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5idXR0b25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lZGl1bUVkaXRvci51dGlsLmFkZENsYXNzVG9BbmNob3JzKE1lZGl1bUVkaXRvci5zZWxlY3Rpb24uZ2V0U2VsZWN0aW9uU3RhcnQodGhpcy5vcHRpb25zLm93bmVyRG9jdW1lbnQpLCBvcHRzLmJ1dHRvbkNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGaXJlIGlucHV0IGV2ZW50IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBpZiBhbnlvbmUgd2FzIGxpc3RlbmluZyBkaXJlY3RseSB0byB0aGUgRE9NIGlucHV0IGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXRCbGFuayB8fCBvcHRzLnRhcmdldCA9PT0gJ19ibGFuaycgfHwgb3B0cy5idXR0b25DbGFzcykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21FdmVudCA9IHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUV2ZW50LmluaXRFdmVudCgnaW5wdXQnLCB0cnVlLCB0cnVlLCB0aGlzLm9wdGlvbnMuY29udGVudFdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRpc3BhdGNoRXZlbnQoY3VzdG9tRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbmFibGVDdXN0b21FdmVudCgnZWRpdGFibGVJbnB1dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmlyZSBvdXIgY3VzdG9tIGVkaXRhYmxlSW5wdXQgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnRyaWdnZXJDdXN0b21FdmVudCgnZWRpdGFibGVJbnB1dCcsIGN1c3RvbUV2ZW50LCBjdXJyZW50RWRpdG9yKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjbGVhblBhc3RlOiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICAgICAgdGhpcy5nZXRFeHRlbnNpb25CeU5hbWUoJ3Bhc3RlJykuY2xlYW5QYXN0ZSh0ZXh0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXN0ZUhUTUw6IGZ1bmN0aW9uIChodG1sLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmdldEV4dGVuc2lvbkJ5TmFtZSgncGFzdGUnKS5wYXN0ZUhUTUwoaHRtbCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0Q29udGVudDogZnVuY3Rpb24gKGh0bWwsIGluZGV4KSB7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4IHx8IDA7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29udGVudENoYW5nZWQodGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRDb250ZW50OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggfHwgMDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbaW5kZXhdLmlubmVySFRNTC50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICBjaGVja0NvbnRlbnRDaGFuZ2VkOiBmdW5jdGlvbiAoZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGVkaXRhYmxlID0gZWRpdGFibGUgfHwgTWVkaXVtRWRpdG9yLnNlbGVjdGlvbi5nZXRTZWxlY3Rpb25FbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50V2luZG93KTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnVwZGF0ZUlucHV0KGVkaXRhYmxlLCB7IHRhcmdldDogZWRpdGFibGUsIGN1cnJlbnRUYXJnZXQ6IGVkaXRhYmxlIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc2V0Q29udGVudDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIEZvciBhbGwgZWxlbWVudHMgdGhhdCBleGlzdCBpbiB0aGUgdGhpcy5lbGVtZW50cyBhcnJheSwgd2UgY2FuIGFzc3VtZTpcbiAgICAgICAgICAgIC8vIC0gSXRzIGluaXRpYWwgY29udGVudCBoYXMgYmVlbiBzZXQgaW4gdGhlIGluaXRpYWxDb250ZW50IG9iamVjdFxuICAgICAgICAgICAgLy8gLSBJdCBoYXMgYSBtZWRpdW0tZWRpdG9yLWluZGV4IGF0dHJpYnV0ZSB3aGljaCBpcyB0aGUga2V5IHZhbHVlIGluIHRoZSBpbml0aWFsQ29udGVudCBvYmplY3RcblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldENvbnRlbnQoaW5pdGlhbENvbnRlbnRbZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItaW5kZXgnKV0sIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldENvbnRlbnQoaW5pdGlhbENvbnRlbnRbZWwuZ2V0QXR0cmlidXRlKCdtZWRpdW0tZWRpdG9yLWluZGV4JyldLCBpZHgpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkRWxlbWVudHM6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgLy8gQ29udmVydCBlbGVtZW50cyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBjcmVhdGVFbGVtZW50c0FycmF5KHNlbGVjdG9yLCB0aGlzLm9wdGlvbnMub3duZXJEb2N1bWVudCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIERvIHdlIGhhdmUgZWxlbWVudHMgdG8gYWRkIG5vdz9cbiAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGFsbCBuZXcgZWxlbWVudHMgKHdlIGNoZWNrIHRoYXQgaW4gdGhvc2UgZnVuY3Rpb25zIGRvbid0IHdvcnJ5KVxuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBpbml0RWxlbWVudC5jYWxsKHRoaXMsIGVsZW1lbnQsIHRoaXMuaWQpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIG5ldyBlbGVtZW50cyB0byBvdXIgaW50ZXJuYWwgZWxlbWVudHMgYXJyYXlcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGV2ZW50IHNvIGV4dGVuc2lvbnMgY2FuIGtub3cgd2hlbiBhbiBlbGVtZW50IGhhcyBiZWVuIGFkZGVkXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdhZGRFbGVtZW50JywgeyB0YXJnZXQ6IGVsZW1lbnQsIGN1cnJlbnRUYXJnZXQ6IGVsZW1lbnQgfSwgZWxlbWVudCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmVFbGVtZW50czogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IGVsZW1lbnRzIGludG8gYW4gYXJyYXlcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGNyZWF0ZUVsZW1lbnRzQXJyYXkoc2VsZWN0b3IsIHRoaXMub3B0aW9ucy5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICAgICAgICB0b1JlbW92ZSA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHRleHRhcmVhcywgbWFrZSBzdXJlIHdlJ3JlIGxvb2tpbmcgYXQgdGhlIGVkaXRvciBkaXYgYW5kIG5vdCB0aGUgdGV4dGFyZWEgaXRzZWxmXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItdGV4dGFyZWEtaWQnKSAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCdkaXZbbWVkaXVtLWVkaXRvci10ZXh0YXJlYS1pZD1cIicgKyBlbC5nZXRBdHRyaWJ1dGUoJ21lZGl1bS1lZGl0b3ItdGV4dGFyZWEtaWQnKSArICdcIl0nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGFuIGVsZW1lbnQgd2Ugd2FudCB0byByZW1vdmVcbiAgICAgICAgICAgICAgICBpZiAodG9SZW1vdmUuaW5kZXhPZihlbGVtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuY2xlYW51cEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgnbWVkaXVtLWVkaXRvci10ZXh0YXJlYS1pZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwVGV4dGFyZWFFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgZXZlbnQgc28gZXh0ZW5zaW9ucyBjYW4gY2xlYW4tdXAgZWxlbWVudHMgdGhhdCBhcmUgYmVpbmcgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbW92ZUVsZW1lbnQnLCB7IHRhcmdldDogZWxlbWVudCwgY3VycmVudFRhcmdldDogZWxlbWVudCB9LCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIE1lZGl1bUVkaXRvci5nZXRFZGl0b3JGcm9tRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW1lZGl1bS1lZGl0b3ItZWRpdG9yLWluZGV4JyksXG4gICAgICAgICAgICB3aW4gPSBlbGVtZW50ICYmIGVsZW1lbnQub3duZXJEb2N1bWVudCAmJiAoZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IGVsZW1lbnQub3duZXJEb2N1bWVudC5wYXJlbnRXaW5kb3cpO1xuICAgICAgICBpZiAod2luICYmIHdpbi5fbWVkaXVtRWRpdG9ycyAmJiB3aW4uX21lZGl1bUVkaXRvcnNbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXR1cm4gd2luLl9tZWRpdW1FZGl0b3JzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufSgpKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBzdW1tYXJ5OiBUaGUgZGVmYXVsdCBvcHRpb25zIGhhc2ggdXNlZCBieSB0aGUgRWRpdG9yXG5cbiAgICBNZWRpdW1FZGl0b3IucHJvdG90eXBlLmRlZmF1bHRzID0ge1xuICAgICAgICBhY3RpdmVCdXR0b25DbGFzczogJ21lZGl1bS1lZGl0b3ItYnV0dG9uLWFjdGl2ZScsXG4gICAgICAgIGJ1dHRvbkxhYmVsczogZmFsc2UsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBkaXNhYmxlUmV0dXJuOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZURvdWJsZVJldHVybjogZmFsc2UsXG4gICAgICAgIGRpc2FibGVFeHRyYVNwYWNlczogZmFsc2UsXG4gICAgICAgIGRpc2FibGVFZGl0aW5nOiBmYWxzZSxcbiAgICAgICAgYXV0b0xpbms6IGZhbHNlLFxuICAgICAgICBlbGVtZW50c0NvbnRhaW5lcjogZmFsc2UsXG4gICAgICAgIGNvbnRlbnRXaW5kb3c6IHdpbmRvdyxcbiAgICAgICAgb3duZXJEb2N1bWVudDogZG9jdW1lbnQsXG4gICAgICAgIHRhcmdldEJsYW5rOiBmYWxzZSxcbiAgICAgICAgZXh0ZW5zaW9uczoge30sXG4gICAgICAgIHNwZWxsY2hlY2s6IHRydWVcbiAgICB9O1xufSkoKTtcblxuTWVkaXVtRWRpdG9yLnBhcnNlVmVyc2lvblN0cmluZyA9IGZ1bmN0aW9uIChyZWxlYXNlKSB7XG4gICAgdmFyIHNwbGl0ID0gcmVsZWFzZS5zcGxpdCgnLScpLFxuICAgICAgICB2ZXJzaW9uID0gc3BsaXRbMF0uc3BsaXQoJy4nKSxcbiAgICAgICAgcHJlUmVsZWFzZSA9IChzcGxpdC5sZW5ndGggPiAxKSA/IHNwbGl0WzFdIDogJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFqb3I6IHBhcnNlSW50KHZlcnNpb25bMF0sIDEwKSxcbiAgICAgICAgbWlub3I6IHBhcnNlSW50KHZlcnNpb25bMV0sIDEwKSxcbiAgICAgICAgcmV2aXNpb246IHBhcnNlSW50KHZlcnNpb25bMl0sIDEwKSxcbiAgICAgICAgcHJlUmVsZWFzZTogcHJlUmVsZWFzZSxcbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmVyc2lvblswXSwgdmVyc2lvblsxXSwgdmVyc2lvblsyXV0uam9pbignLicpICsgKHByZVJlbGVhc2UgPyAnLScgKyBwcmVSZWxlYXNlIDogJycpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbk1lZGl1bUVkaXRvci52ZXJzaW9uID0gTWVkaXVtRWRpdG9yLnBhcnNlVmVyc2lvblN0cmluZy5jYWxsKHRoaXMsICh7XG4gICAgLy8gZ3J1bnQtYnVtcCBsb29rcyBmb3IgdGhpczpcbiAgICAndmVyc2lvbic6ICc1LjIxLjAnXG59KS52ZXJzaW9uKTtcblxuICAgIHJldHVybiBNZWRpdW1FZGl0b3I7XG59KCkpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBub2RlX21vZHVsZXMvbWVkaXVtLWVkaXRvci9kaXN0L2pzL21lZGl1bS1lZGl0b3IuanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFZQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQWVBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQVVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports) {

"use strict";
eval("\"use strict\";\r\n/**\r\n * For Loop\r\n */\r\nexports.forEach = function (array, callback, scope) {\r\n    for (var i = 0; i < array.length; i++)\r\n        callback.call(scope, i, array[i]);\r\n};\r\n/**\r\n * Pop array by key name\r\n *\r\n * @param data\r\n * @param key\r\n * @returns any[]\r\n */\r\nexports.popByKey = function (data, key, defaults) {\r\n    if (!data.hasOwnProperty(key))\r\n        return defaults;\r\n    var value = data[key];\r\n    delete data[key];\r\n    return value;\r\n};\r\n/**\r\n * Extend Object\r\n *\r\n * @param defaults\r\n * @param object\r\n * @returns {any}\r\n */\r\nexports.extend = function (defaults, object) {\r\n    for (var i in object) {\r\n        if (object.hasOwnProperty(i)) {\r\n            defaults[i] = object[i];\r\n        }\r\n    }\r\n    return defaults;\r\n};\r\n/**\r\n * Convert String to CamelCase\r\n *\r\n * @param str\r\n * @returns {string}\r\n */\r\nexports.toCamelCase = function (str) {\r\n    return str.replace(/^([A-Z])|[\\s-_](\\w)/g, function (match, p1, p2, offset) {\r\n        if (p2)\r\n            return p2.toUpperCase();\r\n        return p1.toLowerCase();\r\n    });\r\n};\r\nexports.captalize = function (str) {\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n};\r\n/**\r\n * Firefox have an issue to submit form if its not appended to the body\r\n * @param form\r\n */\r\nexports.submitForm = function (form) {\r\n    document.body.appendChild(form);\r\n    form.submit();\r\n};\r\nexports.requireAll = function (requireContext) {\r\n    return requireContext.keys().map(requireContext);\r\n};\r\n//# sourceMappingURL=Helpers.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL3R5cGVzY3JpcHQvSGVscGVycy5qcz8yMDZkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG4vKipcclxuICogRm9yIExvb3BcclxuICovXHJcbmV4cG9ydHMuZm9yRWFjaCA9IGZ1bmN0aW9uIChhcnJheSwgY2FsbGJhY2ssIHNjb3BlKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUsIGksIGFycmF5W2ldKTtcclxufTtcclxuLyoqXHJcbiAqIFBvcCBhcnJheSBieSBrZXkgbmFtZVxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YVxyXG4gKiBAcGFyYW0ga2V5XHJcbiAqIEByZXR1cm5zIGFueVtdXHJcbiAqL1xyXG5leHBvcnRzLnBvcEJ5S2V5ID0gZnVuY3Rpb24gKGRhdGEsIGtleSwgZGVmYXVsdHMpIHtcclxuICAgIGlmICghZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0cztcclxuICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuICAgIGRlbGV0ZSBkYXRhW2tleV07XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcbi8qKlxyXG4gKiBFeHRlbmQgT2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBkZWZhdWx0c1xyXG4gKiBAcGFyYW0gb2JqZWN0XHJcbiAqIEByZXR1cm5zIHthbnl9XHJcbiAqL1xyXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZhdWx0cywgb2JqZWN0KSB7XHJcbiAgICBmb3IgKHZhciBpIGluIG9iamVjdCkge1xyXG4gICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgZGVmYXVsdHNbaV0gPSBvYmplY3RbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZmF1bHRzO1xyXG59O1xyXG4vKipcclxuICogQ29udmVydCBTdHJpbmcgdG8gQ2FtZWxDYXNlXHJcbiAqXHJcbiAqIEBwYXJhbSBzdHJcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmV4cG9ydHMudG9DYW1lbENhc2UgPSBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL14oW0EtWl0pfFtcXHMtX10oXFx3KS9nLCBmdW5jdGlvbiAobWF0Y2gsIHAxLCBwMiwgb2Zmc2V0KSB7XHJcbiAgICAgICAgaWYgKHAyKVxyXG4gICAgICAgICAgICByZXR1cm4gcDIudG9VcHBlckNhc2UoKTtcclxuICAgICAgICByZXR1cm4gcDEudG9Mb3dlckNhc2UoKTtcclxuICAgIH0pO1xyXG59O1xyXG5leHBvcnRzLmNhcHRhbGl6ZSA9IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcbn07XHJcbi8qKlxyXG4gKiBGaXJlZm94IGhhdmUgYW4gaXNzdWUgdG8gc3VibWl0IGZvcm0gaWYgaXRzIG5vdCBhcHBlbmRlZCB0byB0aGUgYm9keVxyXG4gKiBAcGFyYW0gZm9ybVxyXG4gKi9cclxuZXhwb3J0cy5zdWJtaXRGb3JtID0gZnVuY3Rpb24gKGZvcm0pIHtcclxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XHJcbiAgICBmb3JtLnN1Ym1pdCgpO1xyXG59O1xyXG5leHBvcnRzLnJlcXVpcmVBbGwgPSBmdW5jdGlvbiAocmVxdWlyZUNvbnRleHQpIHtcclxuICAgIHJldHVybiByZXF1aXJlQ29udGV4dC5rZXlzKCkubWFwKHJlcXVpcmVDb250ZXh0KTtcclxufTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGVscGVycy5qcy5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy90eXBlc2NyaXB0L0hlbHBlcnMuanMiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 4 */
/***/ function(module, exports) {

"use strict";
eval("\"use strict\";\r\nvar Plugins = (function () {\r\n    function Plugins() {\r\n        this.exposes = {};\r\n    }\r\n    Plugins.prototype.install = function () {\r\n    };\r\n    return Plugins;\r\n}());\r\nexports.Plugins = Plugins;\r\n//# sourceMappingURL=Plugins.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL3R5cGVzY3JpcHQvUGx1Z2lucy9QbHVnaW5zLmpzPzNiMjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBQbHVnaW5zID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBsdWdpbnMoKSB7XHJcbiAgICAgICAgdGhpcy5leHBvc2VzID0ge307XHJcbiAgICB9XHJcbiAgICBQbHVnaW5zLnByb3RvdHlwZS5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQbHVnaW5zO1xyXG59KCkpO1xyXG5leHBvcnRzLlBsdWdpbnMgPSBQbHVnaW5zO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbHVnaW5zLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL3R5cGVzY3JpcHQvUGx1Z2lucy9QbHVnaW5zLmpzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
eval("\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar Plugins_1 = __webpack_require__(4);\r\nvar Helpers_1 = __webpack_require__(3);\r\nwindow['dreamsark'].exposes({\r\n    MediumEditor: __webpack_require__(2)\r\n});\r\nvar MediumEditorTables = __webpack_require__(1);\r\nvar Medium = (function (_super) {\r\n    __extends(Medium, _super);\r\n    function Medium(app, element, options) {\r\n        _super.call(this);\r\n        this.defaults = {\r\n            disableExtraSpaces: true,\r\n            buttonLabels: 'fontawesome',\r\n            toolbar: {\r\n                buttons: [\r\n                    'bold', 'italic', 'underline', 'anchor', 'h2', 'h3', 'quote', 'table'\r\n                ]\r\n            },\r\n            extensions: {\r\n                table: new MediumEditorTables()\r\n            }\r\n        };\r\n        this.instance = new MediumEditor(element, Helpers_1.extend(this.defaults, options));\r\n    }\r\n    return Medium;\r\n}(Plugins_1.Plugins));\r\nexports.Medium = Medium;\r\n/**\r\n * Auto install itself\r\n */\r\nwindow['dreamsark'].install({\r\n    Medium: Medium\r\n});\r\n//# sourceMappingURL=Medium.js.map//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL3R5cGVzY3JpcHQvUGx1Z2lucy9NZWRpdW0uanM/YmE3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufTtcclxudmFyIFBsdWdpbnNfMSA9IHJlcXVpcmUoXCIuL1BsdWdpbnNcIik7XHJcbnZhciBIZWxwZXJzXzEgPSByZXF1aXJlKFwiLi4vSGVscGVyc1wiKTtcclxud2luZG93WydkcmVhbXNhcmsnXS5leHBvc2VzKHtcclxuICAgIE1lZGl1bUVkaXRvcjogcmVxdWlyZShcIm1lZGl1bS1lZGl0b3JcIilcclxufSk7XHJcbnZhciBNZWRpdW1FZGl0b3JUYWJsZXMgPSByZXF1aXJlKFwibWVkaXVtLWVkaXRvci10YWJsZXNcIik7XHJcbnZhciBNZWRpdW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1lZGl1bSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1lZGl1bShhcHAsIGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRzID0ge1xyXG4gICAgICAgICAgICBkaXNhYmxlRXh0cmFTcGFjZXM6IHRydWUsXHJcbiAgICAgICAgICAgIGJ1dHRvbkxhYmVsczogJ2ZvbnRhd2Vzb21lJyxcclxuICAgICAgICAgICAgdG9vbGJhcjoge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uczogW1xyXG4gICAgICAgICAgICAgICAgICAgICdib2xkJywgJ2l0YWxpYycsICd1bmRlcmxpbmUnLCAnYW5jaG9yJywgJ2gyJywgJ2gzJywgJ3F1b3RlJywgJ3RhYmxlJ1xyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBleHRlbnNpb25zOiB7XHJcbiAgICAgICAgICAgICAgICB0YWJsZTogbmV3IE1lZGl1bUVkaXRvclRhYmxlcygpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgTWVkaXVtRWRpdG9yKGVsZW1lbnQsIEhlbHBlcnNfMS5leHRlbmQodGhpcy5kZWZhdWx0cywgb3B0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1lZGl1bTtcclxufShQbHVnaW5zXzEuUGx1Z2lucykpO1xyXG5leHBvcnRzLk1lZGl1bSA9IE1lZGl1bTtcclxuLyoqXHJcbiAqIEF1dG8gaW5zdGFsbCBpdHNlbGZcclxuICovXHJcbndpbmRvd1snZHJlYW1zYXJrJ10uaW5zdGFsbCh7XHJcbiAgICBNZWRpdW06IE1lZGl1bVxyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVkaXVtLmpzLm1hcFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL3R5cGVzY3JpcHQvUGx1Z2lucy9NZWRpdW0uanMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);